[
    {
        "user": "U06UMCK9AJC",
        "type": "message",
        "ts": "1712872253.149239",
        "client_msg_id": "ccbacec9-b236-4135-a51b-23954215c371",
        "text": "Hi, trying to use flumine for the first time. I'm starting off by testing an adjusted version of betfair data scientists: how to automate 2. I can see from the logging that the bets are never being matched, although they are being requested at the correct price and size. Any help would be appreciated.\n```trading = betfairlightweight.APIClient('...','...!',app_key='...')\nclient = clients.BetfairClient(trading, interactive_login=True)\n\n# Login\nclient = clients.SimulatedClient()\nframework = FlumineSimulation(client=client)\n\n# Logging\nlogger = logging.getLogger()\ncustom_format = \"%(asctime) %(levelname) %(message)\"\nlog_handler = logging.StreamHandler()\nformatter = jsonlogger.JsonFormatter(custom_format)\nformatter.converter = time.gmtime\nlog_handler.setFormatter(formatter)\nlogger.addHandler(log_handler)\nlogger.setLevel(<http:\/\/logging.INFO|logging.INFO>)  # Set to logging.CRITICAL to speed up simulation\n\nclass BackFavStrategy(BaseStrategy):\n\n    # Defines what happens when we start our strategy i.e. this method will run once when we first start running our strategy\n    def start(self) -&gt; None:\n        print(\"starting strategy 'BackFavStrategy'\")\n\n    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:\n        # process_market_book only executed if this returns True\n        if market_book.status != \"CLOSED\":\n            return True\n\n    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:\n\n        # Collect data on last price traded and the number of bets we have placed\n        snapshot_last_price_traded = []\n        snapshot_runner_context = []\n        for runner in market_book.runners:\n                snapshot_last_price_traded.append([runner.selection_id,runner.last_price_traded])\n                # Get runner context for each runner\n                runner_context = self.get_runner_context(\n                    market.market_id, runner.selection_id, runner.handicap\n                )\n                snapshot_runner_context.append([runner_context.selection_id, runner_context.executable_orders, runner_context.live_trade_count, runner_context.trade_count])\n\n        # Convert last price traded data to dataframe\n        snapshot_last_price_traded = pd.DataFrame(snapshot_last_price_traded, columns=['selection_id','last_traded_price'])\n        # Find the selection_id of the favourite\n        snapshot_last_price_traded = snapshot_last_price_traded.sort_values(by = ['last_traded_price'])\n        fav_selection_id = snapshot_last_price_traded['selection_id'].iloc[0]\n        <http:\/\/logging.info|logging.info>(snapshot_last_price_traded) # logging\n\n        # Convert data on number of bets we have placed to a dataframe\n        snapshot_runner_context = pd.DataFrame(snapshot_runner_context, columns=['selection_id','executable_orders','live_trade_count','trade_count'])\n        <http:\/\/logging.info|logging.info>(snapshot_runner_context) # logging\n\n        for runner in market_book.runners:\n            if runner.status == \"ACTIVE\" and market.seconds_to_start &lt; 60 and market_book.inplay == False and runner.selection_id == fav_selection_id and snapshot_runner_context.iloc[:,1:].sum().sum() == 0:\n                trade = Trade(\n                    market_id=market_book.market_id,\n                    selection_id=runner.selection_id,\n                    handicap=runner.handicap,\n                    strategy=self,\n                )\n                order = trade.create_order(\n                    side=\"BACK\", order_type=LimitOrder(price=runner.last_price_traded, size=5)\n                )\n                market.place_order(order)\n\n# Fields we want to log in our simulations\nFIELDNAMES = [\n    \"bet_id\",\n    \"strategy_name\",\n    \"market_id\",\n    \"selection_id\",\n    \"trade_id\",\n    \"date_time_placed\",\n    \"price\",\n    \"price_matched\",\n    \"size\",\n    \"size_matched\",\n    \"profit\",\n    \"side\",\n    \"elapsed_seconds_executable\",\n    \"order_status\",\n    \"market_note\",\n    \"trade_notes\",\n    \"order_notes\",\n]\n\n# Log results from simulation into csv file named sim_hta_2.csv\n# If the csv file doesn't exist then it is created, otherwise we append results to the csv file\nclass BacktestLoggingControl(LoggingControl):\n    NAME = \"BACKTEST_LOGGING_CONTROL\"\n\n    def __init__(self, *args, **kwargs):\n        super(BacktestLoggingControl, self).__init__(*args, **kwargs)\n        self._setup()\n\n    def _setup(self):\n        if os.path.exists(\"sim_hta_2.csv\"):\n            <http:\/\/logging.info|logging.info>(\"Results file exists\")\n        else:\n            with open(\"sim_hta_2.csv\", \"w\") as m:\n                csv_writer = csv.DictWriter(m, delimiter=\",\", fieldnames=FIELDNAMES)\n                csv_writer.writeheader()\n\n    def _process_cleared_orders_meta(self, event):\n        orders = event.event\n        with open(\"sim_hta_2.csv\", \"a\") as m:\n            for order in orders:\n                if order.order_type.ORDER_TYPE == OrderTypes.LIMIT:\n                    size = order.order_type.size\n                else:\n                    size = order.order_type.liability\n                if order.order_type.ORDER_TYPE == OrderTypes.MARKET_ON_CLOSE:\n                    price = None\n                else:\n                    price = order.order_type.price\n                try:\n                    order_data = {\n                        \"bet_id\": order.bet_id,\n                        \"strategy_name\": order.trade.strategy,\n                        \"market_id\": order.market_id,\n                        \"selection_id\": order.selection_id,\n                        \"trade_id\": order.trade.id,\n                        \"date_time_placed\": order.responses.date_time_placed,\n                        \"price\": price,\n                        \"price_matched\": order.average_price_matched,\n                        \"size\": size,\n                        \"size_matched\": order.size_matched,\n                        \"profit\": order.simulated.profit,\n                        \"side\": order.side,\n                        \"elapsed_seconds_executable\": order.elapsed_seconds_executable,\n                        \"order_status\": order.status.value,\n                        \"market_note\": order.trade.market_notes,\n                        \"trade_notes\": order.trade.notes_str,\n                        \"order_notes\": order.notes_str,\n                    }\n                    csv_writer = csv.DictWriter(m, delimiter=\",\", fieldnames=FIELDNAMES)\n                    csv_writer.writerow(order_data)\n                except Exception as e:\n                    logger.error(\n                        \"_process_cleared_orders_meta: %s\" % e,\n                        extra={\"order\": order, \"error\": e},\n                    )\n\n        <http:\/\/logger.info|logger.info>(\"Orders updated\", extra={\"order_count\": len(orders)})\n\n    def _process_cleared_markets(self, event):\n        cleared_markets = event.event\n        for cleared_market in cleared_markets.orders:\n            <http:\/\/logger.info|logger.info>(\n                \"Cleared market\",\n                extra={\n                    \"market_id\": cleared_market.market_id,\n                    \"bet_count\": cleared_market.bet_count,\n                    \"profit\": cleared_market.profit,\n                    \"commission\": cleared_market.commission,\n                },\n            )\n\n# Searches for all betfair data files within the folder sample_monthly_data_output\ndata_folder = r\"C:\\Users\\matth\\OneDrive\\Documents\\output_2022_02\"\ndata_files = os.listdir(data_folder,)\ndata_files = [f'{data_folder}\/{path}' for path in data_files]\n\n# Set Flumine to simulation mode\nclient = clients.SimulatedClient()\nframework = FlumineSimulation(client=client)\n\n# Set parameters for our strategy\nstrategy = BackFavStrategy(\n    # market_filter selects what portion of the historic data we simulate our strategy on\n    # markets selects the list of betfair historic data files\n    # market_types specifies the type of markets\n    # listener_kwargs specifies the time period we simulate for each market\n    market_filter={\n        \"markets\": data_files,\n        'market_types':['MATCH_ODDS', 'BOTH_TEAMS_TO_SCORE'],\n        \"listener_kwargs\": {\"inplay\": False, \"seconds_to_start\": 80},\n        },\n    max_order_exposure=1000,\n    max_selection_exposure=1000,\n)\n# Run our strategy on the simulated market\nframework.add_strategy(strategy)\nframework.add_logging_control(\n    BacktestLoggingControl()\n)\nframework.run()```\n",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "ga4f6bd6c964",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/a4f6bd6c9648161778284f1cdd5a215d.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0022-72.png",
            "first_name": "Matthew",
            "real_name": "Matthew Lawrence",
            "display_name": "Matthew Lawrence",
            "team": "T4G9NBD2M",
            "name": "matthewwdlawrence",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+lTBE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi, trying to use flumine for the first time. I'm starting off by testing an adjusted version of betfair data scientists: how to automate 2. I can see from the logging that the bets are never being matched, although they are being requested at the correct price and size. Any help would be appreciated.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "trading = betfairlightweight.APIClient('...','...!',app_key='...')\nclient = clients.BetfairClient(trading, interactive_login=True)\n\n# Login\nclient = clients.SimulatedClient()\nframework = FlumineSimulation(client=client)\n\n# Logging\nlogger = logging.getLogger()\ncustom_format = \"%(asctime) %(levelname) %(message)\"\nlog_handler = logging.StreamHandler()\nformatter = jsonlogger.JsonFormatter(custom_format)\nformatter.converter = time.gmtime\nlog_handler.setFormatter(formatter)\nlogger.addHandler(log_handler)\nlogger.setLevel(logging.INFO)  # Set to logging.CRITICAL to speed up simulation\n\nclass BackFavStrategy(BaseStrategy):\n\n    # Defines what happens when we start our strategy i.e. this method will run once when we first start running our strategy\n    def start(self) -> None:\n        print(\"starting strategy 'BackFavStrategy'\")\n\n    def check_market_book(self, market: Market, market_book: MarketBook) -> bool:\n        # process_market_book only executed if this returns True\n        if market_book.status != \"CLOSED\":\n            return True\n\n    def process_market_book(self, market: Market, market_book: MarketBook) -> None:\n\n        # Collect data on last price traded and the number of bets we have placed\n        snapshot_last_price_traded = []\n        snapshot_runner_context = []\n        for runner in market_book.runners:\n                snapshot_last_price_traded.append([runner.selection_id,runner.last_price_traded])\n                # Get runner context for each runner\n                runner_context = self.get_runner_context(\n                    market.market_id, runner.selection_id, runner.handicap\n                )\n                snapshot_runner_context.append([runner_context.selection_id, runner_context.executable_orders, runner_context.live_trade_count, runner_context.trade_count])\n\n        # Convert last price traded data to dataframe\n        snapshot_last_price_traded = pd.DataFrame(snapshot_last_price_traded, columns=['selection_id','last_traded_price'])\n        # Find the selection_id of the favourite\n        snapshot_last_price_traded = snapshot_last_price_traded.sort_values(by = ['last_traded_price'])\n        fav_selection_id = snapshot_last_price_traded['selection_id'].iloc[0]\n        logging.info(snapshot_last_price_traded) # logging\n\n        # Convert data on number of bets we have placed to a dataframe\n        snapshot_runner_context = pd.DataFrame(snapshot_runner_context, columns=['selection_id','executable_orders','live_trade_count','trade_count'])\n        logging.info(snapshot_runner_context) # logging\n\n        for runner in market_book.runners:\n            if runner.status == \"ACTIVE\" and market.seconds_to_start < 60 and market_book.inplay == False and runner.selection_id == fav_selection_id and snapshot_runner_context.iloc[:,1:].sum().sum() == 0:\n                trade = Trade(\n                    market_id=market_book.market_id,\n                    selection_id=runner.selection_id,\n                    handicap=runner.handicap,\n                    strategy=self,\n                )\n                order = trade.create_order(\n                    side=\"BACK\", order_type=LimitOrder(price=runner.last_price_traded, size=5)\n                )\n                market.place_order(order)\n\n# Fields we want to log in our simulations\nFIELDNAMES = [\n    \"bet_id\",\n    \"strategy_name\",\n    \"market_id\",\n    \"selection_id\",\n    \"trade_id\",\n    \"date_time_placed\",\n    \"price\",\n    \"price_matched\",\n    \"size\",\n    \"size_matched\",\n    \"profit\",\n    \"side\",\n    \"elapsed_seconds_executable\",\n    \"order_status\",\n    \"market_note\",\n    \"trade_notes\",\n    \"order_notes\",\n]\n\n# Log results from simulation into csv file named sim_hta_2.csv\n# If the csv file doesn't exist then it is created, otherwise we append results to the csv file\nclass BacktestLoggingControl(LoggingControl):\n    NAME = \"BACKTEST_LOGGING_CONTROL\"\n\n    def __init__(self, *args, **kwargs):\n        super(BacktestLoggingControl, self).__init__(*args, **kwargs)\n        self._setup()\n\n    def _setup(self):\n        if os.path.exists(\"sim_hta_2.csv\"):\n            logging.info(\"Results file exists\")\n        else:\n            with open(\"sim_hta_2.csv\", \"w\") as m:\n                csv_writer = csv.DictWriter(m, delimiter=\",\", fieldnames=FIELDNAMES)\n                csv_writer.writeheader()\n\n    def _process_cleared_orders_meta(self, event):\n        orders = event.event\n        with open(\"sim_hta_2.csv\", \"a\") as m:\n            for order in orders:\n                if order.order_type.ORDER_TYPE == OrderTypes.LIMIT:\n                    size = order.order_type.size\n                else:\n                    size = order.order_type.liability\n                if order.order_type.ORDER_TYPE == OrderTypes.MARKET_ON_CLOSE:\n                    price = None\n                else:\n                    price = order.order_type.price\n                try:\n                    order_data = {\n                        \"bet_id\": order.bet_id,\n                        \"strategy_name\": order.trade.strategy,\n                        \"market_id\": order.market_id,\n                        \"selection_id\": order.selection_id,\n                        \"trade_id\": order.trade.id,\n                        \"date_time_placed\": order.responses.date_time_placed,\n                        \"price\": price,\n                        \"price_matched\": order.average_price_matched,\n                        \"size\": size,\n                        \"size_matched\": order.size_matched,\n                        \"profit\": order.simulated.profit,\n                        \"side\": order.side,\n                        \"elapsed_seconds_executable\": order.elapsed_seconds_executable,\n                        \"order_status\": order.status.value,\n                        \"market_note\": order.trade.market_notes,\n                        \"trade_notes\": order.trade.notes_str,\n                        \"order_notes\": order.notes_str,\n                    }\n                    csv_writer = csv.DictWriter(m, delimiter=\",\", fieldnames=FIELDNAMES)\n                    csv_writer.writerow(order_data)\n                except Exception as e:\n                    logger.error(\n                        \"_process_cleared_orders_meta: %s\" % e,\n                        extra={\"order\": order, \"error\": e},\n                    )\n\n        logger.info(\"Orders updated\", extra={\"order_count\": len(orders)})\n\n    def _process_cleared_markets(self, event):\n        cleared_markets = event.event\n        for cleared_market in cleared_markets.orders:\n            logger.info(\n                \"Cleared market\",\n                extra={\n                    \"market_id\": cleared_market.market_id,\n                    \"bet_count\": cleared_market.bet_count,\n                    \"profit\": cleared_market.profit,\n                    \"commission\": cleared_market.commission,\n                },\n            )\n\n# Searches for all betfair data files within the folder sample_monthly_data_output\ndata_folder = r\"C:\\Users\\matth\\OneDrive\\Documents\\output_2022_02\"\ndata_files = os.listdir(data_folder,)\ndata_files = [f'{data_folder}\/{path}' for path in data_files]\n\n# Set Flumine to simulation mode\nclient = clients.SimulatedClient()\nframework = FlumineSimulation(client=client)\n\n# Set parameters for our strategy\nstrategy = BackFavStrategy(\n    # market_filter selects what portion of the historic data we simulate our strategy on\n    # markets selects the list of betfair historic data files\n    # market_types specifies the type of markets\n    # listener_kwargs specifies the time period we simulate for each market\n    market_filter={\n        \"markets\": data_files,\n        'market_types':['MATCH_ODDS', 'BOTH_TEAMS_TO_SCORE'],\n        \"listener_kwargs\": {\"inplay\": False, \"seconds_to_start\": 80},\n        },\n    max_order_exposure=1000,\n    max_selection_exposure=1000,\n)\n# Run our strategy on the simulated market\nframework.add_strategy(strategy)\nframework.add_logging_control(\n    BacktestLoggingControl()\n)\nframework.run()"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ]
    },
    {
        "user": "U4H19D1D2",
        "type": "message",
        "ts": "1712899745.699119",
        "client_msg_id": "E15FC9EB-AB95-4779-B8B0-327F7CD7A07A",
        "text": "Basic data?",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "137c5a3ef323",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-03-15\/6819395173841_137c5a3ef323f1944a1a_72.png",
            "first_name": "liam",
            "real_name": "liam",
            "display_name": "liam",
            "team": "T4G9NBD2M",
            "name": "liam",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DA0ER",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Basic data?"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]