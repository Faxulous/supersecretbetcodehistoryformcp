# Strategies - Community Knowledge

*5532 relevant conversations from across all channels*

---

## 2025-01-26 08:28:15 - strategies channel

**Unknown**

Big week this week and it all came out of the meetup on Tuesday



I had an idea for a new strategy while chatting to [@U01PJ5YMFBJ](@U01PJ5YMFBJ) and while it took a few days to go from idea to implementation (both o1 and DeepSeek made a complete hash of it), the backtest looks great - see first attached plot. I've live tested it on a couple of races and am looking to deploy it more widely today. This is now `Strategy3`



Also at the meetup, [@U05SRUKGYCC](@U05SRUKGYCC) made some comments that gave me some perspective on `Strategy2`. It helped cement my feeling that it's not contrarian enough and I need to revert to the original vision of the strategy. I've started work on a third iteration of it with promising signs. I had really hoped I was going to be able to report today that I'd gone live with _both_ `Strategy2` and `Strategy3` this week but sadly not quite there yet



Existing strategies got absolutely crushed this week and that unfortunately coincided with it being my turn to run them. My already considerable shortfall is now even larger. Although they've been running for years, variance like this is still stressful when you're personally making the losses even if it all gets accounted for. However, these emotional factors are easier to handle being part of a group that can provide perspective and shared experience



New strategies flat on the week so far after a bad day yesterday (my naturally pessimistic disposition thinks there's still plenty of time for them to get further in the hole for the week) but the losses seem in line with variance and I'm not at all concerned (yet). I did increase stakes on `Strategy0` on Monday and it's probably past time I increased stakes on `Strategy1` as well



Plan for the coming week is to get `Strategy3` as widely deployed as possible - I'll need to check backtest performance on US/rest of world horses, and see what I can do about testing it on greyhounds as well. I have a feeling the strategy should work well inplay but backtests look awful. I'm actually specifically interested in getting it working for inplay football but that probably needs a fair bit more work than just tuning some parameters



Development-wise the main focus will be trying to finally get `Strategy2` over the line

---

## 2025-01-23 20:24:06 - strategies channel

**Justice**

Does the calculation for the p-value assume your returns are normally distributed? I keep it simple and use a bootstrapping to analyse the statistical significance of my strategy

---

## 2025-01-22 18:18:54 - random channel

**Justice**

[@UUE6E1LA1](@UUE6E1LA1) Yes true. It's more the fact my model had a much shorter price (&lt;5) which was clearly ridiculous. I admit that sometimes, just because of the nature of the price, it seems like you're wasting money

---

## 2025-01-22 18:11:25 - random channel

**Justice**

My model had the price much shorter than 1000 because the data showed it being much closer to the finish than it actually was. I actually hardly ever get dropouts or missing packets- I sub to multiple feeds and de-dupe. But I get the problems with inaccuracies all the time. I have some basic checks that act as a short circuit but only for obvious things... like runners not moving for a certain amount of time or going backwards

---

## 2025-01-22 17:00:18 - random channel

**Gooat**

This is interesting, it's an out of sample test in a way. 



I feel like current models are overtrained/perform on the popular testing suites, even after test updates. 



Do you run them through an actual backtest or just eyeball?

---

## 2025-01-22 15:35:20 - random channel

**Mo**

```I have added these parameters and there's been a large boost to the log-likelihood. Yet the backtest looks largely unchanged. With a significantly better model, how can this be? What should I do next to improve the model?```

---

## 2025-01-22 15:34:42 - random channel

**Justice**

My model backed 1,000 in that race due to a data error so I got excited for a minute... But no luck, it was the 3rd :joy:

---

## 2025-01-22 15:00:33 - random channel

**Paul**

One of my favourite exercises for these llms in this context is to ask it to give me a flumine strategy for market making while managing overall liability and skew, and then I spend a few minutes looking at the result and spotting all the leaks and estimating how fast it would lose money. GPT-4 produced a solution that would lose a sizeable bank within an hour on UK racing. This one, actually might be flat. Not much needed to get it a little above flat. Impressive. 

---

## 2025-01-22 09:43:52 - general channel

**D C**

Yeah I've found that for inplay too [@U05N9773A23](@U05N9773A23) when combining price and GPS into a model - the price just dominates. I think using market price makes more sense for pre-off as pre-off prices are only reflective of current market sentiment, whereas inplay prices are more reflective of the true probability (excluding things like high volatility periods and information latency etc.)

---

## 2025-01-22 09:36:32 - general channel

**Justice**

Interesting thread and discussion. None of my models have any idea about the market price. Adding this information to my model causes it to become highly correlated to the market and dilutes the other signals/features I'm using. I find this has a large adverse affect on my turnover and therefore profit. Perhaps I need a more sophisticated approach rather than just using it as another feature

---

## 2025-01-22 08:16:49 - random channel

**river_shah**

Love this model: [https://chat.deepseek.com/](https://chat.deepseek.com/). We are going to have o3 levels of intelligence all open source (o3 is likely just o1 with far more inference time compute)

---

## 2025-01-21 19:06:09 - general channel

**liam**

Yes, reducing reliance on the model, not sure why but it's not spoken much on here or elsewhere but I know a few pros/syndicates use the market price as a valuable source of info/feature, even if its at the final stage inbetween model/execution

---

## 2025-01-21 19:02:34 - general channel

**D C**

So is this what he means by "X% market (100-X)% model blends" ?? Some kind of weighting of a model price with the current market price?

---

## 2025-01-21 18:58:49 - general channel

**liam**

Doesn't have to be price action, a fundamental model can/would use the market price for features / filtering etc.

---

## 2025-01-21 18:38:09 - general channel

**D C**

So because you don't know the impact your money has had, and because your model is price action driven. you have less certainty that your subsequent model prices are "legit" ?

---

## 2025-01-21 18:22:44 - general channel

**liam**

Its something I struggle with, for example inplay you can find value and get stuck in, few seconds later and the price has moved from 5-&gt;15, in my case it is very likely I have been the cause of that movement (ideally it wasn't)



So we now have a new price but it is no longer 'exogenous' because it has very likely been impacted by your own model. You can trick yourself/model into believing it has +ev causing a circular loop to death.

---

## 2025-01-21 18:04:48 - general channel

**D C**

I saw that earlier today but I could not fathom what he was talking about in regards to  "regressing to the market" and "65% market 35% model blends".

---

## 2025-01-20 09:05:25 - random channel

**Justice**

A lot of the points are post race points that I would like to plug into a pre-race model. But only 2 years of back history and the possibility of look-ahead bias makes it of little use to me. My models are all very data hungry

---

## 2025-01-19 12:59:23 - strategies channel

**Unknown**

It's been a frustrating week trying to get `Strategy2` to the point where I'd be comfortable redeploying it



On Monday I started by increasing the exposure limit on `Strategy1` for in play horses to bring it in line with what I've used for backtesting. I haven't spent much time using backtests to gauge how much I can scale everything up but that's perhaps something to start thinking about



I wasn't planning on doing this but I decided on Monday to also compare `Strategy0`'s live bets to the backtest and discovered some big problems with my execution which meant I'd missed out on - very roughly - about 15,000 bets over the past three months. This was largely down to handling the start of races and using the `marketStartTime`. I've completely overhauled the logic and it appears to have fixed things. I made a separate tweak that should also help reduce the number of missing bets but, checking that now, it's been somewhat less successful



Right, back to `Strategy2`. I've definitely made significant improvements to the model over the past week but none of the changes have translated into a meaningful shift in backtest performance. Intuitively, where the model is strongest it must just be agreeing with the market. However, I did have a small breakthrough last night with the filters I'm applying to try to avoid adverse selection and I think the strategy is just about at the stage where I'm happy to start live testing it again today. I don't think the backtest performance is quite good enough but the thing that convinced me it's worth live testing is that I can run it against many more markets than I have scraped prices for - i.e. all of the `OTHER_PLACE` markets. As in my last update, I can use BSP to quickly assess whether it's actually finding value on those markets. The breakthrough I'm referring to should apply to pretty much any taker strategy so I'm excited to apply it to other strategies



So the plan for the rest of the day is to manually run the strategy against today's UK racing and I also still owe my syndicates another couple of hours work for the week. Looking to next week, I should fit `Strategy2`'s model to Australian racing and backtest it again to see how that's looking. I do have one other big model improvement on my to-do list that I'll action and a couple of suggestions from o1 that I think are worth exploring but I haven't thought about what's next beyond that. I'll review my list of strategy ideas and have another chat with o1



A couple of general findings from this week:



1. It really helps to step away from the computer. All of my big breakthroughs in thinking came from taking a shower or cooking dinner or walking the dog

2. o1 continues to be indispensable. It's at least as good as if I had a junior quant working for me

Update on performance:



1. Got rotated back into syndicate strategies yesterday. We've been undertaking a large reconciliation exercise, the end result of which is that I'm quite a bit behind of my share so I imagine I'll be in rotation for a bit now

2. New strategies had a bad couple of days midweek and have been absolutely crushing it since then

New strategies net profit up to 2.3% of existing strategies net profit!

---

## 2025-01-19 12:32:48 - random channel

**D C**

In my last job I was reading "Fixed Odds Sports Betting" by Buchdahl when I had to get involved with applying and removing margins - it definitely had a section on that stuff somewhere. Probably any basic book on sports betting will do although some of them use more American terms (and odds format which I hate) which can be confusing.

---

## 2025-01-19 12:22:32 - random channel

**D C**

In crude terms, if you were modelling, you'd get outcome probabilities, calculate "fair" price, then make them more shit (to the punter) by applying margin to those prices (making them shorter). How you spread the margin across the runners though is down to the bookie - and they may (or may not) adjust prices based on weight of punter money. Genuinely sounds like you could do with reading a basic book on betting [@U01PJ5YMFBJ](@U01PJ5YMFBJ) to get a firmer grip of this stuff. It may not be necessary but you'll get a more detailed explanation of things.

---

## 2025-01-18 20:30:27 - random channel

**AndyL**

1. So "margin" I thought is the difference from a selection "my book price" and "bookmaker price" ? not sure how that affects "my book price" ?

2. Staking methods/size is to do with whether you trade an opportunity "flat" stake, "kelly..", "liability",...?

3. "inventory" not sure what that means in this context? sounds like "managing a set of active trades" ?

---

## 2025-01-18 12:46:00 - random channel

**Paul**

Bull does an interesting piece in this on staking systems I might write up for the blog. It’s before Kelly, obviously, and it’s kind of funny but he’s working his way there a little…

---

## 2025-01-17 09:46:08 - general channel

**Justice**

[@UUE6E1LA1](@UUE6E1LA1) imo trading manually with the data defeats the point. This is where I went wrong when I first got the data back in 2019/20. It was a big missed opportunity for me but I was too narrow minded to see past the inaccuracies and didn't have the data skills that I have now. I also then got access to a drone feed when very few others were getting them. This was very easy money so I shelved the TPD data. The drone edge dropped off a cliff after about 6 months as others started to catch on. I would've made considerably more money had I persisted with the data.



[@U03FS7KM2NL](@U03FS7KM2NL) Honestly I don't know how to time it accurately since it relies on the clocks on the gps device being synced with my client. I doubt it's more than 50ms quicker than the Betfair feed

---

## 2025-01-17 09:23:14 - general channel

**Justice**

[@UUE6E1LA1](@UUE6E1LA1) I'm just muddying the signal :joy::joy: Though I do maintain that the inaccuracy is hugely frustrating. Whenever my model is wrong and I get picked off, I'd say 95% of the time it's due to an inaccuracy in the data. I'm curious as to whether the data from the other courses will be using the same technology and whether it will be any more accurate. I can imagine there is a very small latency advantage but I don't know if this is significant. I also found I can subscribe to duplicate feeds for redundancy so dropouts are very minimal

---

## 2025-01-17 09:06:43 - general channel

**Justice**

[@UUE6E1LA1](@UUE6E1LA1)  As soon as I'm not making sufficient money I will try to renegotiate the rate or cancel. I need to shift my focus away from horse racing and find an edge in another sport, most likely cricket as I have strong domain knowledge- this is one of my goals this year. 



I've not noticed anything in particular but I'm very paranoid about alpha decay... Especially if my strategy is on a drawdown. I currently have no means to identify when this is occurring other than the fact I'd be losing money :joy: Should really work on this.



If I was already getting the data from those other RMG tracks I would be really pissed off, especially if I was paying big money. I wasn't, so this is a win for me as I can turn over more money. Though I'm not comfortable applying my models to new courses without back history

---

## 2025-01-15 22:35:45 - strategies channel

**Charlie (Fugazi)**

I had a model built that might help. Had every greyhound ever in its database until I gave up on it around a year ago



[https://drive.google.com/file/d/1HXVIQMgnD8CUwTzTCsRcgAPJPV7181ck/view?usp=sharing|https://drive.google.com/file/d/1HXVIQMgnD8CUwTzTCsRcgAPJPV7181ck/view?usp=sharing](https://drive.google.com/file/d/1HXVIQMgnD8CUwTzTCsRcgAPJPV7181ck/view?usp=sharing|https://drive.google.com/file/d/1HXVIQMgnD8CUwTzTCsRcgAPJPV7181ck/view?usp=sharing)



Bet angel thread with a bit more info



[https://forum.betangel.com/viewtopic.php?p=368464&amp;hilit=Greyhound+model#p368464|https://forum.betangel.com/viewtopic.php?p=368464&amp;hilit=Greyhound+model#p368464](https://forum.betangel.com/viewtopic.php?p=368464&amp;hilit=Greyhound+model#p368464|https://forum.betangel.com/viewtopic.php?p=368464&amp;hilit=Greyhound+model#p368464)

---

## 2025-01-15 15:44:55 - strategies channel

**Matt**

> When those talk about time series, do you think they are referring to some unobservable latent measure of team performance, or time series of prices on a runner?

it is more of conceptually around *metric  or feature volatility*, *not Market Volatility*. (and i look it from a more pure model building POV)

Time series, especially in NBA (or sports with a lot of matches in a season), around performance of players and teams seems to be a neglected statistic. Things like a RAPM are great for a player metric in NBA, but adding a feature of volatility, hurst, etc to that players epm also lets the model know how chaotic that players performance is or if its mean reverting (depending on what you are using for time analysis).



If you sort NBA players by their RAPM strength (lets say DEC 1) and then do it again FEB 1, people that are more consistant will be at the top both times, and people that were (or arrived) at the top have higher variance. this as an added feature will let a model understand this.



in the end, i think it can be a signal of latent states (maybe seeing some player, lineup or team that all stabilized, or went volatile. But the intention is to let the model you are building know that "this person is playing erratic for this metriuc, this person is playing consistant for this metric, this team is...)

[@UPMUFSGCR](@UPMUFSGCR)

---

## 2025-01-14 16:13:10 - strategies channel

**D C**

[@UBS7QANF3](@UBS7QANF3) For this particular "backtest" where I have looked at profit taking BSP if it is greater than model price, I see a clear drop off of profit if BSP is more than double "my" price. Basically if looks too good to be true, it ends up being shite. But if I know this in advance and it remains constant it might not be a problem.

---

## 2025-01-14 16:02:44 - strategies channel

**D C**

Ah right thanks - the normal meaning!! Actually my probabilities are already normalised in this model.

---

## 2025-01-14 16:01:44 - strategies channel

**John Foley**

haha very fair!

in a 3 runner race if your model has predicted win probabilities 0.6, 0.7, 0.4

normalized probabilities would be 0.35, 0.41, 0.24. each is divided by the sum 0.6 + 0.7 + 0.4

---

## 2025-01-14 15:43:33 - strategies channel

**Justice**

For what it's worth, the first 2 things I look at are calibration (as done above but with a 95% CI) and then, I plot the distribution of probabilities from my model and BSP and compare. This quickly highlights if there's a problem discriminating short/long prices. I'd then isolate those cases and analyse what pieces of information my model is missing using domain knowledge (of which I have none for dogs). I'd then attempt to encode this information into the features for my model

---

## 2025-01-14 15:32:15 - strategies channel

**Unknown**

Apologies in advance to anyone I've already asked about this...

I've been working on a model for GB dogs. No price data or market signals involved at all - it is all fundamental modelling using data freely available to anyone. I'm usually of the opinion that models from such data are going to be worthless but I decided to give it a go anyway.

I've come up with a model that I believe has squeezed as much as it can from the data available. Model summary as follows:

1. Model built to generate win probabilities for dogs ONLY for A grade races

2. Model built using data from 2018 to 2023 (inclusive) using classical statistical modelling only

I've taken the model parameters and using 2024 data have generated some rough numbers to see how well calibrated it is. I've also run a quick and dirty backtest by approximating profit backing to BSP whenever BSP is greated than my model's 0EV price (I realise this step may well be pointless). For what it is worth, this test shows tiny profit after commission.



Looking at the numbers (attached) it looks like the model is reasonably well calibrated - I do have some concerns that it lacks the power to predict high probabilies for runners as the vast majority of fitted prbabilities are 0.4 or under. This might be OK though as these are graded races where each dog is supposed to be roughly the same current standard.



My questions are as follows:



1. Is the model shite and can/should it be abandoned now based on attached numbers

2. Assuming no to 1. what is a "good" next step to take (e.g. full backtest using highest price traded, full backtest using price X seconds from scheduled start etc.)

3. Again assuming no to 1. is it "good enough" to be worth pursuing with the view to augmenting the dataset with some more obscure/less easily available data

A lot of questions here but pre-off fundamental models are new to me. Inplay, backtesting or running strategies without backtest is easier to grasp - you know your model value has a finite lifetime and you need to pull any unmatched money before it gets too stale. Pre-off, your probability is fixed - but the market changes so how do you evaluate the execution (literature tells you value is not around for a long time with bookies, but betfair pre-off dog and horse markets suggest othewise - do you ride a trend in your favour until it reverses or fill your boots while you can) ??



I was going to keep asking people things via DM, but I figured that this is generic enough of a modelling problem to possibly be worth asking about publicly and resulting discourse might be helpful to others (even if only as an example of something that is ultimately useless and should be abandoned)

---

## 2025-01-12 13:29:11 - strategies channel

**Mo**

Very different I’d say. The syndicate strategies are highly scalable and less focused on the strength of the predictions and more on the engineering of the overall system. Currently the personal strategies are focused on smaller scale market inefficiencies where the modelling is much more important

---

## 2025-01-11 08:09:38 - strategies channel

**Mo**

1. How are you working out "expected"?

2. There are 350 prices on the Betfair price ladder. You should expect some of the outcomes to be below and some to be above expectation, especially given limited sample sizes

3. To reiterate, I am sure that strategies can be profitable _without_ beating BSP. All I am saying is that I have observed for this particular strategy that it's an important indicator of bet value

---

## 2025-01-10 18:40:28 - random channel

**PeterLe**

Ah I see



GPT explained that for me:

Yes—*if* Flumine is calling your `process_sports_data` method and passing in a valid `market` object, it means Flumine has already recognized that sports-data (“raceSubscription”) update *belongs* to one of the markets it’s tracking. In other words, Flumine does the internal ID matching (the RaceStream `'mid'` vs. the strategy’s `'market_id'`).

When It “Just Works”

In many cases (particularly UK racing), Betfair’s `'mid'` from the RaceStream *matches* the `'market_id'` in the MarketStream. Flumine will say:

• “I see a sports-data update for `'mid' = 1.23456...'`.”

• “I have a known Market object for `'market_id' = 1.23456...'`.”

• “So I’ll call `process_sports_data(market, sports_data)` with that Market object.”

That’s why in `process_sports_data`, you can trust `market.market_id` is the same ID Betfair used in `'mid'`. So you can store the GPS data under `self.gps_data[market_id]` safely.

When You See “Market Not Present for Sports Data”

This arises if Betfair sends `'rcm'` messages with a `'mid'` that *does not* match any Market object Flumine is currently tracking. In that scenario, Flumine logs something like *“Market not present”* or doesn’t call your `process_sports_data` for that `'mid'`. That mismatch usually happens if:

1. You’re subscribed to additional markets/venues (like US or Irish racing) that come through the same RaceStream feed but you aren’t actually “watching” them in your `market_filter`.

2. You see the RaceStream `'mid'` is slightly different (e.g. `'1.23456...'` in RaceStream vs `'1.23457...'` in MarketStream). Rare, but it can happen.

Bottom Line

• *Yes*, if `process_sports_data` is being invoked with a valid Market, you essentially have “correctly mapped” RaceStream data to that Market.

• If you ever see a mismatch (`"Market not present..."`) in the logs, that means Betfair sent RaceStream data for an `'mid'` Flumine does not recognize as an active Market object. That’s the scenario where you’d either *ignore* that data (since you’re not betting on it) or implement a “mapping” workaround if you suspect Betfair’s `'mid'` and `'market_id'` differ.

In most standard UK racing setups, you *won’t* need a custom mapping. Flumine’s built-in logic does the ID match automatically, and you’ll receive `process_sports_data(market, ...)` calls whenever the RaceStream `'mid'` matches your `'market_id'`.



...and on the dummy strategy:



Exactly—Flumine can subscribe to multiple data streams (Market and Race) simultaneously, and it handles the matching between those streams under the hood. The “dummy strategy” approach is one way to ensure you’re actively subscribing to all the right race data (the so-called raceSubscription stream). Meanwhile, your main strategy can use the same feed (or a separate feed) to place bets.

Why a “Dummy Strategy” Sometimes Helps

• *Two different filters*: You can run one strategy (the “dummy”) with a market filter that explicitly subscribes to certain markets or events, possibly with a custom sports data filter. This dummy strategy may not place bets but ensures Flumine is pulling in the RaceStream data for those markets.

• *Another strategy* (the “main” strategy) can also see that same data (or a subset) and perform the actual betting logic.

In practice, though, *a single strategy* that sets both:

```python





market_filter=streaming_market_filter(...),

sports_data_filter=["raceSubscription"],```

often suffices. Flumine will then:

1. Identify your target markets (via `market_filter`).

2. Subscribes to the race data (via `sports_data_filter=["raceSubscription"]`).

3. Calls `process_sports_data(market, sports_data)` with the correct *`market` object* whenever Betfair’s RaceStream updates arrive.

4. Calls `process_market_book(market, market_book)` whenever MarketStream updates arrive for that same market.

If Betfair provides matching IDs for both Market and Race streams (which is usually the case for UK/GB markets), you get the “best of both worlds” without needing an additional “dummy” subscription.

That said, if you see mismatches or logs complaining “Market not present for sports data,” using a “dummy strategy” (or broad filter) can force Flumine to track _all_ possible markets, thereby capturing RaceStream updates even for those you don’t necessarily plan to bet on. Then your real strategy can “cherry-pick” from that data.

In Short

• *Yes*, Flumine does the heavy lifting once you tell it which markets (`market_filter`) and which data feed(s) (`sports_data_filter`) you want.

• You _can_ use a dummy strategy to ensure you subscribe to as many RaceStreams as you want, but it’s not strictly necessary if your single strategy is set up with the correct filters and streams.

• Typically, you only need a second “dummy” strategy if the streams you want to subscribe to are intentionally more encompassing than what your main betting strategy handles. If all you need are your main markets plus the RaceStream for them, a single strategy does the job

Thanks Liam, I understand now

---

## 2025-01-10 18:32:16 - random channel

**liam**

You will need a dummy strategy that has a market filter subscription with the markets you want 

---

## 2025-01-10 16:59:57 - strategies channel

**birchy**

Tired, yes. Retired...not yet. :grinning: 

To clarify, 70% of the bets I got _matched_ beat BSP, but that was obviously only when the BSP was wrong. And of course BSP rarely sums to exactly 1.0, hence the question regarding normalisation. So yeah, I suspected that simply 'beating BSP' wasn't your strategy. :wink:

---

## 2025-01-10 12:43:36 - strategies channel

**Leo**

Are these all price action based strategies/models ? 

---

## 2025-01-10 12:27:43 - strategies channel

**Alex A**

So, does the syndicate work by basically each day whichever of you has the least running profit runs your strategy in their personal account and the others chill?

---

## 2025-01-10 11:24:01 - strategies channel

**Unknown**

I haven't really settled on a definitive schedule for publishing these but I figured I'd probably be too busy this weekend so I'm getting this week's update in early



It's been a hard and frustrating week grinding away on `Strategy2`



First up, as mentioned in my [https://betcode-org.slack.com/archives/CTPL3R3FU/p1736081164005719|last post](https://betcode-org.slack.com/archives/CTPL3R3FU/p1736081164005719|last post), I increased stakes on `Strategy0` and `Strategy1` on Monday (2025-01-06). My plan is for these to increase in line with the notional bankroll I have set aside for this collection of personal strategies, and for this bankroll to grow organically. If I find a strategy that I'm extremely bullish on and think it could benefit from an injection of capital then I will obviously do so but that's not (yet?) the case for `Strategy0` or `Strategy1`.



So, `Strategy2`. I've been alternating between thinking I've cracked it and thinking all I have is a horribly overfit hot mess. I started off very quickly making progress in overhauling the model and staking which:



1. Permitted trading on all runners, not just the favourite

2. Widened the number of markets that could potentially be traded

3. Takes current position into account, hopefully resulting in smoother returns

The progress was such that on Wednesday (2025-01-08), I switched off "V1" and deployed "V2". I observed the bets for V2 in a few races and noticed it wasn't doing a great job of beating BSP. Small sample size obviously but I decided to switch it off and dig into the backtests a bit more



First up I confirmed in the backtest that bets which beat BSP do great and bets which don't beat BSP are bad. So it's not like my model is so good that it can identify times BSP is wrong (at least in aggregate)



This strategy and, to a lesser extent, `Strategy1`, has a variety of filters applied to the trading signals. Things like requiring a minimum expected ROI (EROI) to bet, but also not exceeding a maximum EROI. Also some traded volume and other market "quality" indicators like overround/spread in an attempt to restrict to situations where confidence in the model predictions is likely to be highest



Initially I had optimised these filters using backtest realised returns but based on my increased understanding of the importance of beating BSP for this strategy, I went back and included expected value calculations in the optimisation process. This suggested that I'd overfit many of these filters and so I went back and re-optimised them using expected value with the result that several of the filters were discarded in their entirety. The backtest performance although arguably now more likely to reflect future returns looked significantly less impressive by the end of this process



For both backtesting and the live trading that's been done with the strategy, such that it is, I've been focusing on UK horse racing. However, I'm very keen to get it working in other jurisdictions and also on greyhounds. For obvious reasons:



1. The more markets it can trade, the quicker live feedback can be had

2. More markets traded = smoother returns

3. If it can widely scaled then the per bet performance doesn't need to be amazing

I do have some problems with lack of data, however:



1. I haven't been scraping greyhound markets for very long

2. I only realised this week I haven't been scraping horse racing `OTHER_PLACE` markets (now corrected)

3. No doubt there are other market types I'm still not scraping that I am ultimately interested in (e.g. Each Way, AvB, Without favourite, all exactas/quinellas/forecasts/reverse forecasts/perfectas/superfectas/trifectas/etc. and all aliases thereof)

This lack of market data to backtest against is one reason why I'm so keen to nail down the model building process and to rely less heavily on the market based filters. If I can be confident that I'm building a market beating model in cases where I do have the market data, then I am more inclined to cautiously deploy the model to other markets and rely on live results for feedback



I mentioned in my last update that as part of this strategy I wanted to look at extending both Shin's method and Kelly staking to handle markets with multiple winners. I've had some generic insights into these that I think people may find useful:



1. The R package [https://cran.r-project.org/web/packages/implied/index.html|implied](https://cran.r-project.org/web/packages/implied/index.html|implied) already implements Shin's method for multiple winners. However, it simply finds a value of `z` numerically using the existing formula. I don't believe this is correct as the starting assumptions under which Shin derived his model are not applicable for multiple winners. Nevertheless, this approach may be practically useful if not conceptually sound

2. A recently developed alternative to Shin is [https://github.com/gotoConversion/goto_conversion|GOTO (Gambling Odds To Outcome) Conversion](https://github.com/gotoConversion/goto_conversion|GOTO (Gambling Odds To Outcome) Conversion). This method apparently has serious chops, having been used in several gold medal winning solutions on Kaggle. It appears to be able to handle cases with multiple winners trivially. However, I observed some issues using the method in practice. Firstly, the code does not seem to be very well written, requiring me to fork the repo and make some changes. Secondly, the method produced negative probabilities for the BSP on a completely unremarkable horse racing WIN market. Also worth noting that most if not all of the motivating analysis supporting the method focuses on markets with few winners like football and therefore there's much weaker evidence that it would outperform Shin in horse racing. The repo is not configured for me to create a GitHub issue to discuss these concerns with the author so I have reached out to him on LinkedIn but have yet to receive a response

3. ChatGPT, o1 specifically, has been extremely useful for strategic discussions about developing `Strategy2`. In my opinion, a product like it is becoming increasingly essential if you work by yourself

4. I'm no longer planning on extending Kelly staking to handle market with multiple winners but while looking at it I noticed that the way I've always done fractional Kelly staking is wrong. This has implications for my existing strategies and it's gratifying that looking at new markets in new ways can lead to widely applicable fresh insights in this way

Update on performance with reference to the attached plots:



1. I got rotated back into the syndicate strategies for a day, made a load of money and got rotated out

2. New strategies took a few days to dig themselves out of the hole but they've done it

3. Looks like `Strategy1` in play is really carrying water

New strategies net profit up to 0.77% (from 0.4%) of net profit of existing strategies so everything is moving in the right direction!



Plan for the coming week is to continue to grind away on `Strategy2`, mainly focusing on the model, and hopefully getting it to the point where it can be redeployed to UK racing. Next step after that will be getting it deployed to Australian racing then US racing then perhaps rest of world if it seems worthwhile, followed by greyhounds. I haven't thought about what's next after `Strategy2` but last count I have ideas for 11 other strategies on my list. Other syndicate members will be back to work on Monday so I'll be back to working on existing strategies next week as well

---

## 2025-01-10 09:28:03 - general channel

**A**

Thanks jonjonjon - I totally lost any understanding I had about the workings of my code, and with that I lost motivation (especially as the models weren’t spitting out anything of any use!). So going back to basics and gathering the momentum again.



Looking forward to finally finding something with an edge. I have some pretty cool reporting and alerting set up in a prod environment, but all it’s done so far is notify me of my own financial demise :rolling_on_the_floor_laughing:

---

## 2025-01-10 08:57:18 - general channel

**A**

My plans are to pick this up again after a little break following the birth of my second child, hopefully by the end of this year I’ll have my first profitable strategy running in production.



I’m probably going to stick my ML based approaches on ice, and move back to trying to gain a deeper understanding of the markets through fundamentals and regression.

---

## 2025-01-09 10:08:07 - strategies channel

**Paul**

Put another way:

1. Why is Saturday volume or major festival volume different? Different set of punters, different betting styles, different habits, different takes, and so on. :white_check_mark: 

2. I think that and other factors around quality, directly influence volatility, liquidity, usage of BSP (and usage determines its accuracy), and other metrics. Let's call that, for lack of actual analysis in hand right now, an open question. :question: I want to try and do some of that analysis and share it.

3. I think for pre-event models, including those that are using fundamentals, that _might_ affect strategy outcomes in some cases. Again open question :question: - not sure we can answer this, but perhaps there can be a way to look at a strategy based on those factors once #2 is better understood to help understand it for each of our own models. Let's call that more an open brain fart we all need to figure out for ourselves :dash: 

---

## 2025-01-09 10:02:11 - strategies channel

**Paul**

OK, now we're getting into interesting hot takes. Yes, I think fundamentals vary based on external factors (several advent of alpha ideas circle around that, a little laboriously, but hey 25 ideas is hard...), and yes a fundamental model should take that into account. What I'm saying is that your _counterparties_ change. How sharp/soft the market is, changes. Most of the money is originally sourced from recreational punters who have habits and biases and tendencies about how they bet and that markets therefore reflect that.

---

## 2025-01-09 09:37:37 - strategies channel

**D C**

To be fair, my main disagreement with things you said is isolated to this statement:



_"Do you think BSP is uniformaly fair across all days of the week and afternoon vs evening racing? Last time I looked (a long time ago), I was not convinced it was. Before I go into that rabbit hole, I think I need to break out Jupyter this weekend and show my working, perhaps."_



Not sure anyone is saying that markets don't vary from day to day - weekend volumes usually higher on Saturdays than weekdays for racing - but that would not be the case for a Royal Ascot Tuesday or a Chelthenham Thursday. But I can see no reason why a fundamental model based purely on historical team/player/participant data used to predict outcome probabilties would behave any differently on any given day of the week than another. I could see that perhaps external factors might make it appear that way on occasion - EPL game on a Monday night involving a "fresh" team and a team with heavy euro/cup schedule might throw up an "upset" - but I'd expect a decent fundamental model to incorporate player fatigue / overloaded schedule in some way.  Was the "upset" caused by the fatigue? Or because it was played on a Monday? Or just natural variation?

---

## 2025-01-09 09:20:32 - strategies channel

**Jonjonjon**

I totally agree with that. However, when I tested adding time/date features to my model they didn't improve it:disappointed: . So while we can easily observe that volumes vary by hour and day of week, I haven't been able to use it for anything useful.:disappointed:

---

## 2025-01-09 08:59:21 - strategies channel

**Paul**

I'm not saying the moon affects racing, or some celestial calendar is at play where the gods decide that variance will differ because today's day starts with an S. I'm saying that racing on a Saturday is a different sport to racing on a Tuesday, in the same way that EPL is different to 2nd division French football, and that the markets reflect that change because the entire industry operates that market differently through necessity. If you're trading pre-event, not factoring that in could mean you have a decent model that works over _there_ but does not work _here._

---

## 2025-01-09 08:57:14 - strategies channel

**Paul**

When handling pre-event, I am convinced that some models are decent in some market conditions, and not in others, and those market conditions correlate to quality of event, which correlates to day of week and time of day in horse racing.

---

## 2025-01-08 19:17:33 - strategies channel

**liam**

Agreed, you can focus on time of day / moon cycle etc once you have a decent model 

---

## 2025-01-08 19:16:01 - strategies channel

**Dave**

Unlikely it affects many here though. If your model sucks then time of day won't help you.

---

## 2025-01-08 09:41:17 - strategies channel

**D C**

At this point everything is belief and opinion. I do not believe that BSP is accurate all of the time. I do believe it is accurate on the larger scale and is "good enough" for certain things (such as _*estimating*_ the EV of a pre-off strategy). I know that Newtonian mechanics is not "correct" - but it's good enough for most things we do in life.



I also believe that there is enough smart money in the market to ensure that BSP (or closing prices in general) will likely never be "miles off" long term but it can/will be in certain conditions. If said conditions were easily identifiable, I believe that that same smart money would likely be on it in a flash and would be exploiting it until it no longer existed. The "pothole in the road would have been filled"  - we might be able to detect it's existence historlcally but for now it has "gone". And if we have detected that it once existed, have we truly identified something beneficial (especially if we start with the belief that BSP is not accurate all of the time anyway)?



Totally believe that AW and turf are different - as are flat and jumps and my own models reflect this. Totally believe that market behaviour and participants can be different at different times of day/days of week/class or racing/division/league/formats or any other characteristic of any sport. But I also believe in CLV in the broad sense and that if there were some simple exploitable loophole in BSP, then smart players would close it quickly by exploiting it.



This stuff makes for an interesting chat - and likely would make for an interesting Phd or Masters thesis. I look forward to seeing your numbers/analysis as it is an interesting topic and has provided some interesting discourse but (as you may have noted) I have taken great pains to apply the word "believe" to the above - which are nothing more than my opinions.

I am afraid that I don't have the time to come up with evidence to support these beliefs/opinions. I might have the inclination to do so if I could see that it would be of use in increasing profits. That's likely a shortcoming on my part. But I'll happily tip my hat to anyone who is able to (or already does) exploit this for financial gain!!!

---

## 2025-01-08 09:05:26 - strategies channel

**Paul**

I think we might be getting into arguments about arguments here.



1. Do you believe that the quality of events and the intentions of competitors in every event is equal? If yes, crack on, nobody here will convince you of anything, no matter how much data we provide

2. If you believe quality and intent varies, do you believe that in pre-event betting, these differences might manifest themselves in terms of betting counter parties, their intentions and actions? If you think bettors are all robots who do the same thing over and over again, fine, move on, nothing to see here.

3. If you do believe it might change behaviour, the question then become how do you qualify and quantify those changes. My hypothesis is we should see differences in behaviour (liquidity, volatility, BSP calibration, and so on), that align variation in quality. In horse racing I believe quality significantly varies from mid-week betting (outside of major festivals), to weekend betting. I believe AW and Turf racing are in essence different sports with different fundamentals, different trainers, jockeys, horses, breeding lines, _everything_, that I should expect to see differences in pre-event betting behaviour, and by looking at the data and filtering for day of week, day vs evening, turf vs AW, handicap vs stakes, at different grades, and so on, I will see variations that might be strategy impacting unless I account for them

---

## 2025-01-08 08:37:10 - strategies channel

**D C**

Yeah I don't think anyone would suggest that SP is accurate for every runner all of the time, especially in horse racing which is not entirely "clean" anyway. But we can never know if any single SP is accurate or not - it's not like detecting a biased coin or a weighted die or a dodgy roulette wheel - we have no reference model to compare with. I suppose people with strong fundamental models for racing might be able to sniff out a dodgy runner based on strong market move and large deviation from "expected" implied probability.

But even if we could show that BSP is "wrong" in certain situations how would it benefit? If you have a 6 runner race, the favourite price could be spot on (say 2.0) and yet the BSP of all other runners in that race could be off. Similarly, 2 prices could be way off and yet all others could be spot on. At best all we could ever really show is that BSP (or SPs with margin removed - whatever estimator) is inaccurate in certain situations. But we kind of know that anyway don't we??

---

## 2025-01-07 20:58:39 - general channel

**Unknown**

That's reassuring, although I already know it's a profitable strategy. Not life changing amounts, but being consistently &gt; 0 is inspiring. Although I've become very complacent. :thinking_face:

---

## 2025-01-07 19:46:26 - strategies channel

**Mo**

[@UUE6E1LA1](@UUE6E1LA1) just sounds like a simple mixed effects model/analysis of variance situation where day of week is a factor

---

## 2025-01-07 19:23:49 - strategies channel

**liam**

I am going to go out on a limb here and disagree, you would be trying to find a signal in a very noisy dataset and even if you do find one it will be weak, very weak.



The sharper the crowd / the sharper the market, yes, however that doesn't mean your models should be any different. The only variable that does get impacted by this is execution as adverse selection becomes a real problem.

---

## 2025-01-07 18:27:00 - strategies channel

**D C**

Not sure I would know how to show BSP was more or less accurate over a time range or a day of the week. Either you have faith in it as a metric or not though surely? Same with those who consider Pinnacle closing lines (Buchdahl) as the "benchmark". It's either usable or not surely? If we get down the route of "BSP is inaccurate on Monday afternoons for dog racing" what kind of can of worms does that open for assessing EV?



I should probably say that I only really use profit as my measure of EV and don't really concern myself with estimating it (other than as deviation of current prices from my models) so I am probably not the best person to be discussing it.

---

## 2025-01-07 14:20:41 - general channel

**birchy**

It feels wrong to me as well. This is a strategy that has been running for 4 years and I know it's low ROI but it just plods along so I've left it alone.

---

## 2025-01-07 13:25:44 - issues channel

**Guilherme Scherner**

[@U07AK2APF2B](@U07AK2APF2B) Yes I changed it, login is successful but when I try to call `betting.list_current_orders()` I get INVALID_APP_KEY

```trading = betfairlightweight.APIClient(

                email,

                password,

                app_key,

                cert_files=("certificate.crt", "certificate.pem"),

            )

            trading.api_uri = "[https://api.betfair.bet.br/exchange/](https://api.betfair.bet.br/exchange/)"

            trading.identity_uri = "[https://identitysso.betfair.bet.br/api/](https://identitysso.betfair.bet.br/api/)"

            trading.identity_cert_uri = "[https://identitysso-cert.betfair.bet.br/api/](https://identitysso-cert.betfair.bet.br/api/)"

            trading.login()```

---

## 2025-01-07 11:22:30 - strategies channel

**Jonjonjon**

Interesting.... Have you had much luck incorporating stuff like that into your price action models?



I tried adding stuff like hour of day, day of week, recent performance Vs other runners,  but didn't really get anything worthwhile from it.

---

## 2025-01-07 06:57:55 - strategies channel

**AndyL**

It’s mind boggling to me that you have a strategy that works both pre and in-play :thinking_face: !

---

## 2025-01-07 00:39:17 - general channel

**Alex A**

I’ve asked on here before and some people have said they can happen on the initial snapshot, but I still haven’t seen it, and processing the snapshot faster is very unlikely to noticeably improve my betting performance.

---

## 2025-01-06 22:28:25 - strategies channel

**Mo**

[@U0128E7BEHW](@U0128E7BEHW) - assume you mean (mean daily pnl / std daily pnl) * sqrt(365)?



• Strategy0: 1.63. However, it looks to me that the strategy only _started_ working in 2021. Sharpe ratio since 2021 is 2.47

• Strategy1 Pre-event: 2.97

• Strategy1 In-play: 3.89

• Strategy2: 3.05

My guess for undisclosed reasons is Strategy0 has the lowest capacity followed by Strategy2 followed by Strategy1

---

## 2025-01-06 21:32:35 - strategies channel

**liam**

Some great articles on this blog (relatively new)



[https://www.sharpsresearch.com/blog/ai-is-easy/|AI is Easy, Spend Your Time on Your Dataset, not Your Model](https://www.sharpsresearch.com/blog/ai-is-easy/|AI is Easy, Spend Your Time on Your Dataset, not Your Model)



[https://www.sharpsresearch.com/blog/time/|Time, A Note on Market Inefficiency and the Future of Sports Betting](https://www.sharpsresearch.com/blog/time/|Time, A Note on Market Inefficiency and the Future of Sports Betting) 

---

## 2025-01-06 19:24:04 - strategies channel

**Dave**

Suspect you'll find your strategies 0/1 to have higher capacity but lower ROI than your strategy 2

---

## 2025-01-06 19:14:01 - strategies channel

**birchy**

Brilliant. I'm mostly operating strategy 0 &amp; 1 style based on market state but have had moderate success with xgboost/lgbm regressions. Like you, I have a couple of WIP's which are scooping pennies but I'm finding them troublesome to scale up.

---

## 2025-01-06 19:10:21 - strategies channel

**Mo**

Strategies 0 and 1 have no fair probability, they will just bet if certain conditions are met. Strategy2 has a fair probability/model

---

## 2025-01-06 19:08:32 - strategies channel

**birchy**

Hopefully this will spark up some much needed discussion and [@U012XF5CNPN](@U012XF5CNPN) dripping some more alpha. [@UBS7QANF3](@UBS7QANF3)  Just as a general question, do you use models or more of a statistical approach/`if EV &gt; 0: get_stuck_in()`?

---

## 2025-01-06 18:50:47 - strategies channel

**lorenzo**

well I'll keep the questions coming (hopefully other people get something of them to): When you say 'not very much capacity for these' do you/others have any good literature / approaches on modelling this?

---

## 2025-01-06 16:51:35 - strategies channel

**Paul**

I can think of some cliff edges that are worth thinking about when sizing: to deal with minimum stake/payout/liability pieces (which I do plenty of as I'm market making, but might just be me leaking alpha here). I stumbled into a three figure mistake the other week by allowing a MARKET_ON_CLOSE to actually lapse because parts of the order chipped away dropping the liability &lt; £10... and even if I coded up to spot that and move it to PERSIST, it often never matched... and then left me exposed elsewhere... repeat that enough and it doesn't half add up :money_with_wings:



I mention it in this context because let's suppose you are sizing to a payout, but the minimum liability (not payout), to enter BSP auction is £10. If you're near minimums for either (say £10), you've effectively built a strategy around a price inflection point. £20 payout at 2.0 has a £10 liability so if you hedge to auction that will work :white_check_mark: . At 1.99 it doesn't, and will LAPSE :no_entry: So, there you go, an actual cliff edge based on a price.

---

## 2025-01-06 16:01:12 - random channel

**Mo**

Saw this paper "Maximizing Betting Profitability Through Predictive Modeling in European Football: A Feature-Driven Approach" shared on LinkedIn: [https://drive.google.com/file/d/1XOwLye3mxIyVEbFA1KrKbYOpYd0Lcloy/view](https://drive.google.com/file/d/1XOwLye3mxIyVEbFA1KrKbYOpYd0Lcloy/view)

---

## 2025-01-06 11:58:23 - strategies channel

**Mo**

[@U012XF5CNPN](@U012XF5CNPN) - yes, adverse selection is the big problem. No one is forced to take your offers so when you do get matched it's much more likely because you're wrong. In addition to that, making prices on Betfair is a really shit deal:



1. No maker/taker fee structure unlike most (virtually every?) other financial exchanges

2. No Last Look mechanism unlike being a bookmaker/some trading venues

3. No idea who your counterparty is unlike being a bookmaker/some trading venues

I wonder if the big market makers do have one or more of these although I've never heard anything to that effect

---

## 2025-01-06 10:26:42 - issues channel

**D C**

This has been discussed in the past but does anyone use a market AND order subscription within the same streaming connection? I am basically at my max connection limit (10) and looking for ways to cut down. I know people use things like redis so there is a "common" store of updated order information and thus only using a single connection for all order updates, but this is not a great option for me right now. I do some things that most would consider stupid (like having separate bots to record stream data - the same data that production strategy bots also request) but I prefer this approach and won't be changing that.

Basically it seems to me that the quickest and easiest method will be make my market stream connections also subscribe to order change messages but this has always felt a little bit "dirty".

Does anyone actually do this (seem to remember last time the most common approach was single stream each for market and order data)?

---

## 2025-01-06 09:21:20 - random channel

**Paul**

Not relevant to your question, but there may also be glitches in the machine for that course. Weird markets last night at Sam Houston. I was watching them live. There would be huge delays (fine, BAU, US racing often delays as they wait for the betting pools to fill up), and the markets would turn to treacle (nothing matching), and then the market would be voided. And then again on the next and on the next. I assumed adverse weather meant a cancelled meeting but noted the races had actually run. Settled down by about 22:00 UTC.

---

## 2025-01-05 17:26:17 - strategies channel

**D C**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) just a suggestion, but have you thought of trying some fundamental modelling instead of purely market signal type approaches. Something pretty basic just to give you a better idea of model building and regression? Your talk of just throwing shitloads of features into a NN suggests that you are hoping to just stumble across something.

---

## 2025-01-05 15:48:19 - strategies channel

**AndyL**

Nice one Mo, My other post is inrunning horses model, you’re giving me some added motivation now, although I’m not running live!!

---

## 2025-01-05 13:31:51 - strategies channel

**Dave**

Complexity is not necessarily a bad thing (for instance if you use a tree or NN model then likely the decisions they make are far more complex than your handcrafted ifs). However typically the relationship between features and target is observable/make practical sense, so even if your logic is mostly a black box / super complicated, a simple regression of feature Vs target would suggest "yes it makes sense to include this feature/indicator". But if you don't practice good hygiene with train/test splitting / avoiding leakage etc, or simply don't use enough data, then you will have a useless model. And ofc this isn't specific to ML models, despite the terminology. Stuff like "it only works on odds of 8 and above" is _likely_ overfitting.

---

## 2025-01-05 12:46:04 - strategies channel

**Unknown**

As promised, here is the first update on my yearly goal for my new strategies to equal or exceed my take home profit from existing strategies



The first attached plot shows cumulative net profit. Some comments:



1. The existing strategies have very high costs associated with them. Therefore I am using 37.5% of gross profit as net profit

2. In contrast, the new strategies have very low costs associated with them, therefore I am using 59% of gross profit where, hopefully obviously, this is almost entirely the 40% premium char - ahem, expert fee

3. The new strategies have made approximately 0.4% of the net profit of the existing strategies to date. LFG!

4. Since 2nd January I'm ahead of my syndicate share so haven't _personally_ been trading the existing strategies hence the flat line

The second attached plot shows the cumulative net profit only for the new strategies. Some comments:



1. As you can see, they had a bit of a rough time yesterday

2. I was planning on increasing the stakes but this has given me some pause. Note that I'm just being a pussy, the correct thing is still to increase the stakes. It's arguably sensible to wait until Monday anyway to minimise the impact on live trading from restarts

The third attached plot shows the relative profit for the new strategies. Some comments:



1. `Strategy2` got deployed yesterday and only had two bets, one of which accounts for almost all of the loss for that strategy. The price was fine (according to BSP) but the staking was a bit too high for a newly deployed strategy. Lesson learned

2. `Strategy1` is a generic strategy that I'm keen to also deploy to football but it looks like this will require some elbow grease as I'll need to optimise some market (sport) dependent parameters

3. `Strategy0` trades all horse races regardless of country; `Strategy1` and `Strategy2` only do GB racing for now. I'd like to expand them to other countries but that's fairly low down the priority list

My focus for now will be `Strategy2`:



• `Strategy2` bets into markets that have multiple winners; think forecasts/exactas/trifectas/superfectas/quinellas etc.

• I'm doing some foundational work to both my shin ([https://github.com/mberk/shin](https://github.com/mberk/shin)) and kelly ([https://github.com/mberk/kelly](https://github.com/mberk/kelly)) packages to allow for markets with more than 1 winner. Everyone will be able to take advantage of these

• `Strategy2` currently only bets on the favourite. Being able to bet on all runners is the next step

Some general comments:



1. Knowing that I "had to" share this update was excellent motivation, as hoped. Without it, I might have dragged my heels over getting `Strategy2` deployed

2. Hopefully you will agree I've been remarkably open with this update but will also understand why certain details have been held back. You're welcome to ask my anything at all - whether I can give a straight forward answer is another matter. If you know some of the details from things I've previously told you in confidence then obviously please refrain from including these in your questions. If in doubt you can always DM me

3. My overall philosophy with these strategies is this: I'm hoovering up pennies. Hopefully there will be enough pennies that they will add up to something meaningful. There are inefficiencies every-fucking-where. Not necessarily massively profitable inefficiencies but it is free money being left on the table and the more of these I can hit as soon as possible the better my money printing machine will become. Having chunky profitable strategies to begin with helps as this encourages doing more volume

Fire away...

---

## 2025-01-05 11:42:29 - strategies channel

**Mo**

I don't think you're thinking about this in the right way. Your thought process seems to have been:



1. Model isn't accurate

2. Try something else

Rather than thinking about _why_ it isn't accurate. What are the specific circumstances where it most significantly diverges from the market?

---

## 2025-01-05 10:07:20 - strategies channel

**AndyL**

My thoughts on why the model is not always accurate is thinking about it I wouldn’t expect just basing on a combination of traded / queued volume to model well on its own, which then makes me think is it useful at all…. ? Hence why I tried using gradients thinking maybe that was being modeled better 

---

## 2025-01-05 09:44:19 - strategies channel

**AndyL**

I foresee adding extra params/filters to better model

---

## 2025-01-05 09:43:37 - strategies channel

**AndyL**

Thanks Mo, yeah see what you mean about the model, could be tricky that bit

---

## 2025-01-05 09:33:16 - strategies channel

**Mo**

&gt; sometimes the model vs actual price was wildly wrong

Working out why this is the case sounds like the key to your success

---

## 2025-01-04 22:52:16 - strategies channel

**AndyL**

so what else is there to go on for a market based strategy? as a "market" is basically people trading "volume"?? Be that volume happening in terms of it being "matched", "queued", or "cancelled" ?

---

## 2025-01-04 22:49:12 - strategies channel

**thambie1**

What's the underlying reason why you think a price model based on traded volume will work? How can you confirm or falsify that reason? I know[@UGV299K6H](@UGV299K6H) talked about this idea before, if that's all you're going off of and you haven't found any evidence confirming it as a interesting approach you likely won't get far.

---

## 2025-01-04 22:38:05 - strategies channel

**AndyL**

I see where you're coming from, and I definitely do that a lot..... I typically convince myself altering a filter make sense in some way!

I feel my main weakness is a lack of ingenuity in coming up with a good idea. The one i'm currently working is creating a price model based on the traded volume back/lay on a selection over recent timeframe, constructing a "book" based on that volume. Now using that model directly seemed useless, as sometimes the model vs actual price was wildly wrong, so I thought maybe I could use it's "gradient" as an indicator, eg. actual price goes up over 10seconds, model price stable/down, then "back" bet... and from there I created filters to make that work over my 3 month sample, eg.seems to work well for price &gt; 8.0 ! ..... and then go to a 1 year backtest and find it's crap!!

---

## 2025-01-04 22:28:28 - strategies channel

**thambie1**

Adding a ton of filters, usually indicates a lack of understanding. You keep adding filter after filter to try and get it profitable, but what's the narrative? Why do those filters make sense? If a filter you thought would help doesn't, why not? What belief did you have about the strategy/dataset that turned out to be untrue?

---

## 2025-01-04 22:00:35 - strategies channel

**AndyL**

Several things come up in strategy discussions that on thought seem to contradict a bit, 1) keeping it simple and 2) making it profitable. As from my experience in trying to successfully implement an idea I end up applying "filters" and many "if's" which inherently makes it complex and usually succumbs to being "fitted". I usually end up with the later because my "simple" idea doesn't quite work...! So I then invariably try and make it more complex (i.e. not simple!) :thinking_face:

---

## 2025-01-03 14:42:14 - general channel

**Tim**

Happy New year everyone! -- Extremely new to the group but have found it immensely useful so far.



I have a background working for market making firms in options + crypto space, interested in seeing how well this can translate into market making on a betting exchange. 



Hoping that with sound market making logic, I can create a profitable strategy that won't need a strong edge in terms of valuation.

---

## 2025-01-02 21:58:13 - strategies channel

**AndyL**

no not quite, the 1s and 25% were arbitrary for posing the question above

the reality of my strategy, is yes i've got an aribtrary seconds, but not the 25% i've analysed various signals to indicate abnormal value position

but yeah, applied to all race types...!?!

---

## 2025-01-02 12:09:45 - general channel

**Ankit Aggarwal**

Happy New Year! My goal is to deploy my first strategy!!

---

## 2025-01-01 21:17:27 - issues channel

**Brøndby IF**

[@U07AK2APF2B](@U07AK2APF2B) and [@U4H19D1D2](@U4H19D1D2)



```    trading.api_uri = "[https://api.betfair.bet.br/exchange/](https://api.betfair.bet.br/exchange/)"

    trading.identity_uri = "[https://identitysso.betfair.bet.br/api/](https://identitysso.betfair.bet.br/api/)"

    trading.identity_cert_uri = "[https://identitysso-cert.betfair.bet.br/api/](https://identitysso-cert.betfair.bet.br/api/)"```

Adding these three lines when logging in, everything seems to have worked perfectly again. I'll do some testing and I will bring the final feedback. Thank you very much for your help!

---

## 2025-01-01 21:02:50 - issues channel

**Brøndby IF**

[@U4H19D1D2](@U4H19D1D2) I tried doing like this:



```def login() -> APIClient:

    trading = betfairlightweight.APIClient(

        ..., ..., app_key=..., 

        cert_files=('./betfair_brl_certs/myAppBrl.crt','./betfair_brl_certs/myAppBrl.pem'), 

        session=requests.Session()

    )

    trading.api_uri = "[https://api.betfair.bet.br/exchange/](https://api.betfair.bet.br/exchange/)"

    trading.login()

    return trading```

And returned the error:



`betfairlightweight.exceptions.LoginError: API login: AUTHORIZED_ONLY_FOR_DOMAIN`

---

## 2025-01-01 19:18:17 - general channel

**Josh**

To deploy my first strategy!

---

## 2025-01-01 19:13:33 - general channel

**Mo**

Happy new year. As I’ve already mentioned to some of you, towards the end of last year I started working on some of my own strategies for the first time. Those of you who are familiar with my background and current circumstances will know that prior to this point, all of my betting activity has been part of syndicates that I’ve been a founding member of



My completely ludicrous goal for this year is for my take home pay from my own strategies to meet or exceed my take home pay from my existing syndicate strategies. I’m going to be documenting this process by providing a weekly update on the Slack comparing (axis free thank you very much) equity curves for the two, in addition to a running commentary on strategy developments and upcoming plans 

---

## 2025-01-01 15:08:13 - issues channel

**Lee**

&gt; Hi,

&gt; 

&gt; Today, I received a message from Neil Thomas (API Product Specialist | Betfair) regarding the discontinuation of the Betfair Exchange API for Brazilian customers due to regulatory changes. I am a developer in Brazil and have built my own interface to place bets using the Betfair Exchange API.

&gt; 

&gt; The message states:

&gt; 

&gt; "Olá. Devido a mudanças regulatórias, a partir de 1 de Janeiro de 2025, não forneceremos mais acesso à API pessoal para clientes brasileiros até novo aviso. Isso significa que, a partir de 1 de Janeiro de 2025, suas chaves de aplicação existentes serão desativadas e você não poderá mais acessar a API da Betfair Exchange usando suas chaves de aplicação. Se essa situação mudar, avisaremos você diretamente."

&gt; 

&gt; This raises significant concerns for me as a developer. I would appreciate your advice on the following:

&gt; Will Betfair consider offering a commercial license for developers or professional bettors to continue using their own betting interfaces?

&gt; Is this a definitive decision, or are there ongoing discussions that might provide further updates in the near future?

&gt; 

&gt; Any guidance you can provide would be greatly appreciated as I assess how to adapt my work moving forward.

&gt; 

&gt; Thank you for your time and support.

---

## 2024-12-30 13:44:02 - random channel

**Paul**

Of course we know this isn't laundering. It's such an exceptionally rare activity though (money normally goes only one way with betting operators), it's always going to be a little hard to convince a regular customer service agent that while it walks like a money laundering duck and talks like a money laundering duck, it's actually legit...

---

## 2024-12-29 09:42:14 - issues channel

**WilliamR**

Hi I've started getting the following error complaining about an invalid session seems intermittent and program still runs and places bets.... should I be worried?:



 File "D:\Users\willi\anaconda3\Lib\site-packages\flumine\worker.py", line 126, in poll_market_catalogue

    market_catalogues = client.betting_client.betting.list_market_catalogue(

                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "D:\Users\willi\anaconda3\Lib\site-packages\betfairlightweight\endpoints\betting.py", line 233, in list_market_catalogue

    (response, response_json, elapsed_time) = self.request(method, params, session)

                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "D:\Users\willi\anaconda3\Lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 54, in request

    self._error_handler(response_json, method, params)

  File "D:\Users\willi\anaconda3\Lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 80, in _error_handler

    raise self._error(response, method, params)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketCatalogue

Params: {'filter': {'marketIds': ['1.237584679', '1.237584668', '1.237584666', '1.237584713', '1.237582001', '1.237584706', '1.237584674', '1.237582040', '1.237584707', '1.237584715', '1.237584714', '1.237582041', '1.237584699', '1.237611936', '1.237611941', '1.237611968', '1.237611961', '1.237611945', '1.237611955']}, 'marketProjection': ['COMPETITION', 'EVENT', 'EVENT_TYPE', 'RUNNER_DESCRIPTION', 'RUNNER_METADATA', 'MARKET_START_TIME', 'MARKET_DESCRIPTION'], 'maxResults': 25}

Exception: None

Error: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie2-ang06a-prd-11260945-00381f34ac', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie2-ang06a-prd-11260945-00381f34ac', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}

2024-12-29 09:41:16,405:INFO:162:Client update account details

2024-12-29 09:41:18,027:INFO:263:Updated marketCatalogue for 1.237613210

---

## 2024-12-28 10:11:53 - random channel

**AndyL**

Thanks [@UUE6E1LA1](@UUE6E1LA1) yeah see what you mean 

Football im leaving as is at the moment as I don’t think I have enough data yet, ive just got one live football strategy i am leaving running for the moment 

---

## 2024-12-27 09:14:31 - strategies channel

**AndyL**

Finding a profitable "real" signal is hard, I spent most of this year trying to find one! hence why I pickup the pennies with the above strategy...

---

## 2024-12-27 06:59:56 - strategies channel

**liam**

When you create a strategy like this how focussed are you on the initial bet in terms of signal?

---

## 2024-12-26 21:55:50 - strategies channel

**Unknown**

The Green vs NoGreen game, the same strategy, but one with the hedge bet removed, which one would you "ride" ?!

---

## 2024-12-25 12:56:37 - strategies channel

**Leo**

Interesting thread, my fundemental pre race jumps racing model is showing a remarkably similar pattern, although last month or so have been much better. I just put it down to time of year/ natural variance with that type of model. Maybe need to do some more digging myself. Anyway time to get off slack on Christmas Day  

---

## 2024-12-24 20:10:19 - strategies channel

**AndyL**

[@U0128E7BEHW](@U0128E7BEHW) Your strategy exhibiting the same turn in June, is interesting. Looks like your's is more resilient (larger edge) than mine. Mine was very basic.

---

## 2024-12-24 19:11:09 - strategies channel

**Dave**

I am just trying to provide some evidence that, contrary to everyone telling [@U01PJ5YMFBJ](@U01PJ5YMFBJ) that he has no edge, that he may in fact have an edge but a) it doesn't stand the test of time because it just isn't modelled well enough and his features may just need to be more time-invariant, or b) simply he was relying on external behaviour which is no longer present. I noticed a step change in behaviour around June too, so I suspect a change in external factors :slightly_smiling_face:

---

## 2024-12-24 18:46:39 - strategies channel

**Dave**

Edges can erode. It also depends on whether you've modelled your edge correctly - your approach may just be one that's not robust to time, and therefore needs some recalibration every so often (whereas if you understand it better, your model may be more time invariant)

---

## 2024-12-24 16:45:43 - strategies channel

**Rob**

If it helps, I've done pre-race for about 8-months since starting using flumine. I use ML models and have found that they last for about 2 months before degrading.



I will soon find out if this is seasonality, or just that the world keeps changing!

---

## 2024-12-24 15:15:31 - strategies channel

**AndyL**

My live returns for this strategy over the year match the backtest roughly 

---

## 2024-12-24 14:43:46 - strategies channel

**ShaunW**

What's the EV chart look like for that in-running strategy, how much of that flatline is just the randomness of the won/lost outcome ?

---

## 2024-12-24 11:59:58 - strategies channel

**D C**

I thought you said this was a real strategy [@U01PJ5YMFBJ](@U01PJ5YMFBJ)?

---

## 2024-12-24 10:00:46 - strategies channel

**AndyL**

I think in reality it is just random as both strategies are TOTALLY different!

1: pre race , simple market making 

2: in running, complex pricing model

---

## 2024-12-24 00:14:56 - strategies channel

**Unknown**

Bizarrely, a totally different GB racing strategy, this on "in-running", exhibiting the same change June '24 :thinking_face:

---

## 2024-12-22 15:54:56 - strategies channel

**ShaunW**

BSP might be considered as a long term EV benchmark but unless you're betting them all then you're being selective, is that highly selective subset of horses also 0ev at bsp?



Closing/hedging at bsp might not always be optimal but at least it locks in a number rather than having the headache of working out if the EV of your bets is actually value or did they just beat the sp of the horses the strategy inadvertently selected.  Theoretically you could be backing horses at 2.5 that sp at 2.3, but those horses should have been 2.6 even though the set ALL horses at 2.3 are 2.3.  I think :thinking_face:

---

## 2024-12-21 22:19:48 - strategies channel

**Dave**

The EV Vs BSP chart isn't very useful, you know that generally bsp is close to 0 bsp so ofc you're gonna see loss if you don't beat bsp. Though it sounds like you're alluding to the fact that you're beating bsp less and less over the last few months. Sounds like either competition has stepped up/entered or your model become stale.

---

## 2024-12-21 19:35:26 - strategies channel

**AndyL**

Mine is betting sub-10.0 odds

It’s based on a pricing model built from traded volume flow 

---

## 2024-12-21 19:31:33 - strategies channel

**Jonjonjon**

&gt; take the above EVvBSP chart, how would you go about weening out the -EV bets ?

If your strategy is anything like mine, you might be bleeding cash on bets above odds of 100.

---

## 2024-12-21 19:18:14 - strategies channel

**Jonjonjon**

The thing is, if you don't hedge, your EV is just an estimate of the true EV. I've seen models that beat or underperform the EV to a significant degree (where BSP is used as the proxy for it).

---

## 2024-12-21 19:12:42 - strategies channel

**AndyL**

that's a no-green strategy

---

## 2024-12-21 19:11:04 - strategies channel

**AndyL**

i'm tempted to "rollback" to an older version of the strategy, i've done that in the past to good effect

---

## 2024-12-21 18:55:55 - strategies channel

**Jonjonjon**

Sorry to hear that [@U01PJ5YMFBJ](@U01PJ5YMFBJ). My GB model has had a bad week, but is still up overall for the year

---

## 2024-12-21 18:15:31 - strategies channel

**AndyL**

is anyone else finding GB racing (pre-race) too competitive now? What small edges I had in the past seem to have dissappeared, i've just stopped my last strategy

---

## 2024-12-21 18:13:47 - strategies channel

**Paul**

Another angle: let’s suppose you have a fundamental model that spits out probabilities you think are better than the market in certain situations. Calibration plots let you quickly eyeball if you’re right or not. If nothing else, the alpha is not letting your own BS doom you into a trap of a massive leak.

---

## 2024-12-20 23:47:01 - random channel

**Paul**

I work _a lot_ with GenAI models. It's been my life for 18 months now. I can't talk about a lot of what we do, but it's cutting edge (we were doing RAG and GraphRAG within weeks of respective papers being published), and I get to work with applied and research scientists with PhDs in this space, trying to push the envelope, many of whom are getting papers selected for major confs and journals.



My 2p: I doubt this has applicability to this domain right now. It's getting there, directionally this is promising, but the fact you're going to need 2 orders of magnitude more money to go from 75.7% to 87.5%, and that higher number is still basically useless for a lot of things you can do for a lot less money with humans means I'd hold back on the excitement for now.

---

## 2024-12-20 15:52:33 - issues channel

**liam**

That strategy even shows a profit on that market :joy: 

---

## 2024-12-20 15:13:14 - issues channel

**tone**

*** I don't like cricket ***

Hi all, I get a warning: "No markets or events found for strategy cricket" trying to simulate a cricket market in Flumine.

The market is Melbourne Stars vs Brisbane Heat from a few days ago which I recorded using MarketRecorder.

Any help would be greatly appreciated.

class ExampleStrategy(BaseStrategy):

   def check_sports_data(self, market, sports_data) -&gt; None:

       print(market, sports_data)

       return True



   def process_market_book(self, market, market_book):

       print(market_book)



 client = clients.SimulatedClient()

 framework = FlumineSimulation(client=client)



 folder = "D:/test/"

 sports_folder = folder+"sportsdata"

 market = folder+"1.237252156"

 framework.add_market_middleware(

   SimulatedSportsDataMiddleware("cricketSubscription", sports_folder)

 )



 strategy = ExampleStrategy(

   name="cricket",

   market_filter=streaming_market_filter(

       market_ids=[market],

   ),

 )



 framework.add_strategy(strategy)

 framework.run()

---

## 2024-12-20 13:35:24 - random channel

**Paul**

Fortune's Formula is the story of how Kelly criterion came to be, taking in a narrative via Shannon and Thorpe. It's a great read. I re-read it every few years as it's just well written. His other books have some great stuff in too, but not _quite_ as strong, IMO

---

## 2024-12-20 13:25:55 - random channel

**Dave**

Yes I have Fortunes Formula on my wishlist - I delayed getting it as I read it's mostly just about the application of Kelly in various scenarios/anecdotes?

---

## 2024-12-20 10:29:06 - random channel

**D C**

I think the premise is basically kelly staking applied to multiple bets - rather like your own implementation. That was the reasoning behind my purchase anyway but hopefully there will be more in there too.

---

## 2024-12-20 09:44:18 - random channel

**Dave**

There was a lot of commotion around his election probabilities, and a lot of noise from the dude such as "I ran 80,000 simulations and Kamala won in 50.1% of them, the odds are really as close as you can get!". He got trolled a lot on twitter over that. Why - well if your model says "it's gonna be a coin flip" then maybe your model is just not good (except he kinda failed to see that).

---

## 2024-12-19 14:42:48 - general channel

**Jonjonjon**

Yes next six months could be very good or very bad. I hope my models don't blow up.

---

## 2024-12-16 19:54:16 - strategies channel

**Gooat**

I've got old markets where I have prices and my orders but can't recreate the strategy part.

---

## 2024-12-15 19:56:56 - general channel

**PeterLe**

Upgrade went through very smoothly..compared previous backtest results (on one strategy) and then again on new version, identical thanks chaps

---

## 2024-12-14 17:52:01 - random channel

**Unknown**

Obviously market/event specific but in betting markets your concern should be optimising stake for liquidity / market impact. 



To answer your question any sort of drawdown that is outside of ‘normal’ should immediately make you question the impact you are having on the market. I am not sure what you are doing but it is very rare that you can simply 10x your bankroll (if that is what you are implying / concerned about) 



With my strategies it’s a case of thinking outside the box in order to increase turnover / profit, ie. can you scale horizontally 

---

## 2024-12-14 17:25:18 - random channel

**thambie1**

A big reason to not accept large drawdowns, is that it makes it hard to differentiate variance from a strategy that for one reason or another is no longer working (bugs, changing market conditions, etc). These days my max drawdown is ~6% of annual profits

---

## 2024-12-14 17:08:57 - random channel

**Unknown**

[@UPMUFSGCR](@UPMUFSGCR) I get your point, feeling exactly the same at the moment, this is a new football strategy 3 month "backtest", went live 3 days ago and then starts going off a cliff!!

---

## 2024-12-14 15:42:05 - random channel

**Jonjonjon**

I'm one of the green brigade. So not sure if Kelly applies. Please don't flame me. :fire:

---

## 2024-12-14 15:15:38 - random channel

**Paul**

This feels like the wrong way to think about it. Kelly tells you what your stake should be relative to your bank factoring in edge and odds. Overbet, you die. Underbet, you plod, but don’t die.

---

## 2024-12-12 13:54:48 - general channel

**Mo**

Any plans to improve flumine typing, for example



```    def process_orders(self, market: Market, orders: list) -> None:

        # process list of Order objects for strategy and Market

        return```

subscripting the list type for orders

---

## 2024-12-06 16:11:33 - general channel

**WilliamR**

Hi [#C4HL6EZTQ|general](#C4HL6EZTQ|general) is there a way to simply place each way bets based on WIN market prices or do I have to create a whole new BaseStrategy class so I get the EACH_WAY market book?

---

## 2024-12-04 08:13:11 - general channel

**Mo**

Right so if I wanted to separate scraped cleared orders by strategy I can use the first token in the `customerOrderRef`

---

## 2024-12-04 08:06:48 - general channel

**liam**

hmm this comes up a lot, its routed in the fact I run a lot of instances/strategies on the same markets and I wanted an easy way to separate orders/positions etc. per instance rather than per strategy



As [@U0155J92A7Q](@U0155J92A7Q) mentions, best practice is to always log the strategy data with the betId's and any context etc. so you should never need to use the betfair customerStrategyRef.



To answer Mo's question, flumine also uses [https://github.com/betcode-org/flumine/blob/a9cd71befc6062b52ce65ca695b50a56a2e81344/flumine/order/order.py#L269|customerOrderRef](https://github.com/betcode-org/flumine/blob/a9cd71befc6062b52ce65ca695b50a56a2e81344/flumine/order/order.py#L269|customerOrderRef) however it has a hash of the strategy name



```    @property

    def customer_order_ref(self) -&gt; str:

        return "%s%s%s" % (self.trade.strategy.name_hash, self.sep, self.id)```

---

## 2024-12-04 07:49:49 - general channel

**James**

What is behind the decision to not allow us to use our own strategy refs [@U4H19D1D2](@U4H19D1D2)? 

---

## 2024-12-04 06:56:09 - general channel

**Jorge**

If running more than 1 strategy in the same flumine instance, it is not possible to separate every strategy using the customer_strategy_ref. So I use [https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py#L56C26-L56C39|order.trade.strategy in the cleared_orders.txt](https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py#L56C26-L56C39|order.trade.strategy in the cleared_orders.txt)

---

## 2024-12-04 06:49:55 - general channel

**Jorge**

If I am only running 1 strategy in the same flumine instance then I use:

```from flumine import config

config.customer_strategy_ref = "alpha_1"```

---

## 2024-12-03 14:12:30 - general channel

**Mo**

I know this has been asked in the past but how can I use the strategy_ref without breaking flumine functionality? Should I be using the customer_order_ref instead?

---

## 2024-12-02 16:46:02 - strategies channel

**Paul**

This is a naive understanding based on some interviews their traders have done, it is likely wrong. But in essence, they have a similar problem to trading on the exchange they just _know for certain_ that the money is sharp. Exchange traders have to guess. I think it's safe to assume it probably is, because the alternative is to think you're smarter than every major syndicate on Earth.

---

## 2024-12-02 10:47:23 - general channel

**Alex A**

It probably would be possible for the right employee to do that, as AWS say

```We do not access, use, or share customer data without your agreement, except as required to prevent fraud and abuse, or to comply with law, as described in our Customer Agreement.```

You could try encrypting all your software and data on the VPS, but at some point you will have to run your program, and someone who controls that VM or the underlying machine would be able to access that. Personally I make no effort to protect anything I have running on any VPS from the provider, and am not worried in the least about it. I’d guess you’re more likely to have your personal desktop stolen or drive cloned by someone who knows you have a betting strategy, which is also not something I go to any effort to stop.

---

## 2024-12-02 10:34:50 - general channel

**JFP**

VPS noob question. Setting up a VPS for the first time to run my betting strats and have a question regarding security. There is plenty of info available on how to harden for external threats but how do you protect your data from the VPS provider? Does anyone here take extra steps to hide their setup when running on a VPS vs on their desktop?

---

## 2024-11-30 14:43:27 - strategies channel

**Michael**

I'm glad that people appreciated the suggestions above, but I would add that the context was a conversation with a player who was yet to experience substantial success and seemed to just be flitting about pointlessly, a more experienced player might see things a little differently and I expect would have a pretty good intuitive idea of what's likely to work. If someone like [@UBS7QANF3](@UBS7QANF3) thinks an idea is a goer then I'll bet it is and it'll just be a question of finding the right strategy for developing it. In that regard I think [@UPMUFSGCR](@UPMUFSGCR)'s suggestion of just stepping away for a bit to shift one's perspective is a good one.



For my own part if I have a new idea I'll start by seeing if there's anything in it at all with some very simple test, like does it generate a series of back bets that would produce a profit if they all matched immediately at BATB - whatever's relevant. If I can't find any reason for hope within a couple of hours I'll semi-forget about it and just do a quick write up of what my thinking was and how I tested it so that I can read over it at some future point and maybe think differently about it.



If I do find that an idea has at least some potential then I'll work on realising if for as long as it maintains my interest, but I rarely spend all that long because I favour getting something up and betting and then digging into the results over a lot of back testing or anything like that. That's a matter of approach though, others will doubtless have their own ways of doing things.



Finally; If I have an idea that I think has legs I basically never give up on it,  if I can't get it working then I just write a break-even version of it, start it going with minimal stakes and forget about it for months on end, even years if I've really forgotten. Eventually I come back to it with fresh eyes and tonnes of data and try again.

---

## 2024-11-30 10:48:07 - strategies channel

**Mo**

Second related question: what is your workflow for going from idea to live trading strategy? Mine is usually:



1. Get told about an idea ([@U012XF5CNPN](@U012XF5CNPN) leaking alpha) or reading about one (in a book that [@UPMUFSGCR](@UPMUFSGCR) has dismissed out of hand)

2. Validate idea by doing some basic analysis on summary data eg BSP data

3. Confirm idea looks good in a backtest, mainly looking at the equity curve (is it up and to the right, how do the drawdowns and other variance characteristics look)

4. Validate backtest by live trading small stakes and comparing live trading results to backtests on the same events

5. Scale up stakes in line with live trading performance



---

## 2024-11-30 10:20:51 - strategies channel

**Mo**

Related question: how many hours of work is it normally for you to go from idea to profitable live trading strategy?

---

## 2024-11-30 10:08:50 - strategies channel

**Unknown**

When developing a new strategy, how do you decide when to bin it and move on to another idea versus keep grinding away at it?

---

## 2024-11-28 16:52:49 - betfair-news channel

**Joe**

[@U02GSMUSG56](@U02GSMUSG56) will there be an indicator on the market definition as to which delay model (legacy or this new one) is going to be used? I think we will need this.

---

## 2024-11-27 15:58:23 - issues channel

**liam**

yeah or



```if market.blotter.strategy_selection_orders(self, selection_id, 0, order_status=LIVE_STATUS):

    # cook```

---

## 2024-11-27 15:48:32 - issues channel

**Mo**

Something like



```if any(

    order.status in LIVE_STATUS or order.size_matched &gt; 0

    for order in market.blotter.strategy_selection_orders(

        self, selection_id, 0

    )

):

    # Do cool shit```

?

---

## 2024-11-27 15:36:09 - issues channel

**liam**

`market.blotter.strategy_selection_orders` is probably the cleanest but using the `runner_context` will be slightly quicker



[https://github.com/betcode-org/flumine/blob/a9cd71befc6062b52ce65ca695b50a56a2e81344/flumine/markets/blotter.py#L73](https://github.com/betcode-org/flumine/blob/a9cd71befc6062b52ce65ca695b50a56a2e81344/flumine/markets/blotter.py#L73)

---

## 2024-11-27 09:48:52 - issues channel

**Tom**

2024-11-27 20:43:25,730 [DEBUG] __main__: Found order: Order 369539252565: Execution complete. Status: OrderStatus.EXECUTION_COMPLETE

2024-11-27 20:43:25,731 [DEBUG] __main__: Found order: Order 369539257045: Execution complete. Status: OrderStatus.EXECUTION_COMPLETE

2024-11-27 20:43:25,731 [DEBUG] __main__: Found order: Order 369541038302: Execution complete. Status: OrderStatus.EXECUTION_COMPLETE

2024-11-27 20:43:25,731 [ERROR] __main__: Print Marketbook delayed None

2024-11-27 20:43:25,731 [ERROR] __main__: Cross matching is False

2024-11-27 20:43:25,731 [ERROR] __main__: Version is 6300260619

2024-11-27 20:43:25,731 [ERROR] __main__: Market staleness check returned None.

2024-11-27 20:43:25,731 [WARNING] flumine.baseflumine: High latency between current time and MarketBook publish time

2024-11-27 20:43:25,731 [INFO] flumine.baseflumine: Adding: 1.236494334 to markets

2024-11-27 20:43:25,732 [DEBUG] urllib3.connectionpool: Starting new HTTPS connection (1): [http://api.betfair.com:443|api.betfair.com:443](http://api.betfair.com:443|api.betfair.com:443)

2024-11-27 20:43:25,803 [DEBUG] urllib3.connectionpool: [https://api.betfair.com:443](https://api.betfair.com:443) "POST /exchange/betting/json-rpc/v1 HTTP/11" 200 2392

2024-11-27 20:43:25,806 [INFO] root: OrdersMiddleware: Processing order 369500134776

2024-11-27 20:43:25,807 [INFO] root: OrdersMiddleware: New order trade created

2024-11-27 20:43:25,808 [INFO] flumine.order.order: Order status update: Execution complete

2024-11-27 20:43:25,808 [INFO] flumine.order.trade: Trade status update: Complete

2024-11-27 20:43:25,808 [INFO] root: OrdersMiddleware: Processing order 369502827322

2024-11-27 20:43:25,808 [INFO] root: OrdersMiddleware: New order trade created



Ok I wasn't logging very effectively. This is coming up inbetween running markets for the first time. The problem occurs after running a while as well though.



What kind of logs will be useful to see? Startup logs look normal

---

## 2024-11-25 11:15:00 - strategies channel

**Joe**

[@UBS7QANF3](@UBS7QANF3) To answer 1-5 I have an IO front end with a little dsl that can extract data from the compressed json stream files, fast enough like [2min per year of global racing, but this is largely because there is minimal impedance mismatch between IO and compute and memory in my implementation, it is using very fast local storage and lots of cores for parallel decompression, this is the same point that <@US2RWCWKY](2min per year of global racing, but this is largely because there is minimal impedance mismatch between IO and compute and memory in my implementation, it is using very fast local storage and lots of cores for parallel decompression, this is the same point that <@US2RWCWKY) was making.



To back test / train / ML that same IO front end is used but to fill memory structures whose contents are 'implied' by the strategy being trained and shape/order optimised for the hardware (e.g. gpu structures will be totally different shape to cpu). In other words it only keeps the answers to the questions it is likely to need during training and puts them in the memory location that will guarantee the lowest latency during training given the expected order those questions will be asked in. This is the data equivalent to dead code removal during compilation followed by compile time optimisation. The training process then only iterates over these memory structures at high frequency. To do this and ensure that the 'logic' being trained will behave identically when run in production on live streams requires everything be written against interfaces that are implemented multiple times. This is similar to what [@U012XF5CNPN](@U012XF5CNPN) alluded to in point 3. It could also be thought of as a very application specific cache.



This would be quite a departure from how Flumine works where there is no real change between live and back testing other than inserting the simulated matcher.

---

## 2024-11-25 10:07:43 - strategies channel

**liam**

&gt; The dirty secret of market impact? It's messier than anyone admits. This article challenges conventional models by looking at how information actually flows through markets. Here's the real problem: impact hits differently when you're getting in versus getting out of positions - a fundamental asymmetry that most models miss entirely. Add in the fact that every major player's algos are scrapping for the same liquidity, and traditional execution models fall apart.

[https://x.com/imotw2/status/1860802661832155549](https://x.com/imotw2/status/1860802661832155549)

---

## 2024-11-24 19:35:02 - general channel

**Jonjonjon**

[@UUE6E1LA1](@UUE6E1LA1) I wouldn't be surprised it most people who paid it haven't made it back. It requires a lot of good fortune to find a working strategy.

---

## 2024-11-23 12:42:38 - general channel

**Elie Couttet**

Hi, I'm new here! :wave:

A few months ago, I was playing around with the Betfair API (the free delayed one for now) and was managing to send some POST requests and getting a response from javascript code in a Gsheet.

I've been fighting with the same code since yesterday and keep getting the same 403 response... I have tried to dumb it down as much as I could with still no success. Can one of you put me in the right direction?



Here is the simplified version of my code. I have checked that the appKey and sessionId work on the Betting Api Demo Tool. I'd be grateful for any support!



const url = "[https://api.betfair.com/exchange/betting/json-rpc/v1](https://api.betfair.com/exchange/betting/json-rpc/v1)";



  var header = { 'X-Application' : appkey, 'X-Authentication' : ssid ,'content-type' : 'application/json'}

  var jsonrpc_req={"jsonrpc": "2.0", "method": "SportsAPING/v1.0/listEventTypes", "params": {"filter":{ }}, "id": 1}



  const options = {

    method: 'POST',

    muteHttpExceptions: false,

    headers: header,

    data: jsonrpc_req

  };





    // Send POST request to the API

    var response = UrlFetchApp.fetch(url, options);

---

## 2024-11-18 11:56:24 - random channel

**D C**

That's a shame if so. I was actually intending on coming to the last meet as I was unable to make the Xmas event but I anticipated that election modelling would dominate proceedings and I have less interest (and nothing to contribute) in that area than I do in medieval basket weaving and so I decided to leave it. Had I realised that the shelf life was going to be so limited on these things I would have shown up.

---

## 2024-11-18 06:15:00 - general channel

**Nita Suos**

I am using betfairlightweight streaming for events using market_id and event_id, Can someone tell me how to retrieve the LTP and Volumes for each runner through the stream?  They are always None with the below code.  thanks

```def stream_data():

    global trading



    # Create queue and listener

    output_queue = queue.Queue()

    listener = betfairlightweight.StreamListener(output_queue=output_queue)

    stream = trading.streaming.create_stream(listener=listener)

    current_event_ids = []

    current_market_ids = []

    market_id_to_name = {} 

    runner_name_cache = {}  



    while True:

        event_ids = gd.Betfair.focusEventId

        market_ids = gd.Betfair.focusMarketId



        # Skip processing if IDs are invalid or None

        if not event_ids or not market_ids:

            continue



        if not isinstance(event_ids, list):

            event_ids = [event_ids]

        if not isinstance(market_ids, list):

            market_ids = [market_ids]

        if set(event_ids) != set(current_event_ids) or set(market_ids) != set(current_market_ids):

            current_event_ids = event_ids

            current_market_ids = market_ids

            stream.stop()

            market_catalogue = trading.betting.list_market_catalogue(

                filter=filters.market_filter(

                    event_ids=[gd.Betfair.focusEventId],

                    market_ids=[gd.Betfair.focusMarketId]

                ),

                market_projection=[

                    "MARKET_START_TIME",

                    "RUNNER_DESCRIPTION",

                ],

                max_results=20, lightweight=True,

            )

            print("PP")

            print(market_catalogue)

            for market in market_catalogue:

                market_id = market["marketId"]

                runner_name_cache[market_id] = {

                    runner["selectionId"]: runner["runnerName"]

                    for runner in market["runners"]

                }

            market_id_to_name = {

                market["marketId"]: market["marketName"]

                for market in market_catalogue

            }

            market_filter = streaming_market_filter(

                event_ids=current_event_ids,

                market_ids=current_market_ids,

            )

            market_data_filter = streaming_market_data_filter(

                fields=["EX_BEST_OFFERS", "EX_MARKET_DEF"],

                ladder_levels=10

            )

            stream.subscribe_to_markets(

                market_filter=market_filter,

                market_data_filter=market_data_filter,

                conflate_ms=1000,

            )

            threading.Thread(target=stream.start, daemon=True).start()





        while not output_queue.empty():



            market_books = output_queue.get()

            for market_book in market_books:



                print(vars(market_book))

                print("-" * 50)  

                market_data = {

                    "marketId1": market_book.market_id,

                    "marketName": market_id_to_name.get(market_book.market_id, "Unknown Market"),  # Add marketName

                    "isMarketDataDelayed": market_book.is_market_data_delayed,

                    "status": market_book.status,

                    "betDelay": market_book.bet_delay,

                    "bspReconciled": market_book.bsp_reconciled,

                    "complete": market_book.complete,

                    "inplay": market_book.inplay,

                    "numberOfWinners": market_book.number_of_winners,

                    "numberOfRunners": market_book.number_of_runners,

                    "numberOfActiveRunners": market_book.number_of_active_runners,

                    "lastMatchTime": market_book.last_match_time,

                    "totalMatched": market_book.total_matched,

                    "totalAvailable": market_book.total_available,

                    "crossMatching": market_book.cross_matching,

                    "runnersVoidable": market_book.runners_voidable,

                    "version": market_book.version,

                    "runners": []

                }



                for runner in market_book.runners:

                    print(vars(runner))

                    print("-" * 50)

                runner_data = {

                        "selectionId": runner.selection_id,

                        "runnerName": runner_name_cache.get(market_book.market_id, {}).get(runner.selection_id,

                                                                                           "Unknown Runner"),



                        "lastPriceTraded": runner.last_price_traded,

                        "totalMatched": runner.total_matched,

                        "ex": {

                            "availableToBack": runner.ex.available_to_back,

                            "availableToLay": runner.ex.available_to_lay

                        },

                        "tradedVolume": runner.ex.traded_volume

                    }

                    market_data["runners"].append(runner_data)

                gd.Betfair.EventMarketCatalogue1 = [market_data]```



---

## 2024-11-17 23:28:40 - general channel

**Nita Suos**

Can I please clarify this: so if I add a strategy or strategies to the framework and run the framework, at this point it is not possible to add any more strategies, workers etc and for those strategies added they can't be removed unless I shutdown and restart the application, use flags, or is there a solution to this that others use. Thanks.

---

## 2024-11-17 10:52:26 - general channel

**Mo**

You would need to add them all at the start before calling `run`. If you want to dynamically enable or disable them then you could always control this via boolean flags in the strategy that are checked in, for example, `check_market_book`

---

## 2024-11-17 10:42:43 - general channel

**Mo**

If literally all you want to do is print the upcoming horse races then use `betfairlightweight`. If that's just a first step to developing a full blown strategy then ultimately that strategy will need to be implemented in `flumine` rather than `betfairlightweight`

---

## 2024-11-17 10:40:25 - general channel

**Nita Suos**

Hi, can someone please explain this with flumine?  With the examples, I see the strategies are added, then the framework is run.  Can the framework be run in it's own thread, and then strategies added to it, and if so, could someone please offer a sample code?  Right now I initialize like so:

```trading = betfairlightweight.APIClient(my_username, my_password, app_key=my_app_key, certs=certs_path)

client = clients.BetfairClient(trading, interactive_login=True)

framework = Flumine(client=client)

framework_thread = threading.Thread(target=run_framework)

framework_thread.start()```

The framework is now running in it's own thread, and I would like to run a strategy to print the X next upcoming horse races.  Can this be done or is it better to use betfairlightweight?

---

## 2024-11-07 16:14:36 - strategies channel

**thambie1**

There's no name. I believe [@UBS7QANF3](@UBS7QANF3)'s library does this: [https://github.com/mberk/kelly](https://github.com/mberk/kelly)

---

## 2024-11-07 16:00:44 - strategies channel

**thambie1**

There are many variations of kelly, you can modify it such that it accounts for existing positions when calculating the size of a new order.

---

## 2024-11-07 15:55:46 - strategies channel

**Ankit Aggarwal**

If I am not wrong Kelly is for order sizing and not position management. Also for kelly how do you calculate probability of win from backtested results of each order?

---

## 2024-11-07 15:49:58 - strategies channel

**thambie1**

Kelly criterion is often used

---

## 2024-11-07 15:43:45 - strategies channel

**ShaunW**

No consensus, depends if you're having one bet a week or one per second, your average price, strategy track record, personal attitude to risk, how deep your pockets are, and if you need a profit at the end of the day or end of the year.  Too many variables, strategy types and personality types to be prescriptive.

---

## 2024-11-07 14:32:23 - random channel

**Dave**

Fwiw, if you consider something to have odds of a coin toss, it may also mean that your model/forecast is no better than a coin toss (i.e. you got no alpha, as opposed to strong alpha that is confident it is indeed a coin toss)

---

## 2024-11-07 11:14:32 - random channel

**George**

I am personally active in politics and political campaigns in the UK. The "shy Tory" - or in this case "shy Trump" effect is very well known in these circles. It has played out in most (perhaps not all, but definitely most) UK election polls in the last 40 years.



I don't know why polling companies haven't learnt their lesson, but they haven't. People lie, and they lie in a fairly systematic way (the effect size varies over time but the direction generally does not).



I have no doubt that there were +EV bets to be made on this election, but they could only have been made by someone who has very carefully studied the "shy" effect with data, and I suspect very few of us here have. Theo did, and his data gave him confidence that his bets were +EV, so he placed them - probably he got the Kelly staking wrong but the EV was there.



The idea that Harris was +EV at 2.x based on "the available information" is highly likely to be wrong (though I admit I cannot be 100% of this, having not studied the data in detail) because the available information included a long and predictable history of exactly this sort of polling error.

---

## 2024-11-07 11:11:34 - random channel

**Bert Raven**

538, the silver bulletin, etc represent the public information as much as the racing post probably represent the public information for a horse race. if the bsp was massively different to the RP forecast on lots of volume I think most of us would on balance conclude that there might be a crazy owner who's really stupid, orr someones got a better model than the RP or better information.

---

## 2024-11-07 09:46:00 - random channel

**Derek C**

Going long oil after a Trump win is an interesting strategy. I would have gone the opposite way, based on likely increases in US production and Trump’s previous involvement with the Abraham accords. Time will tell.

---

## 2024-11-06 22:19:05 - random channel

**Alex A**

He did have some election night model thing going last night which was admittedly shit, but I assume everyone is talking about his pre-election forecasting.

---

## 2024-11-06 22:15:38 - random channel

**Alex A**

To the people saying Nate Silver is clearly wrong, this outcome (Trump winning all seven swing states) was literally the most likely outcome of his model for the past month. His final forecast had either candidate with a 50% chance of winning, which isn’t the same as expecting them to both get exactly 50% of the vote.

---

## 2024-11-06 16:00:10 - random channel

**Paul**

I'd argue that the EV comes from the fact there were hundreds of polls that had been analysed, weighted and shifted based on multiple orgs approaches - including, most famously, 538's analysis  - that showed a coin toss was a reasonable summation of all the public source information to hand. It wasn't a single poll and a single market and everyone just going "the poll is wrong", it was tens of millions of dollars worth of data analysis that produced an indication and a model. It's a single market event, but not a single data point.

---

## 2024-11-06 13:55:22 - random channel

**Paul**

[@U80AMMRKP](@U80AMMRKP) 1.9ish - polling put him slightly ahead. We did not have data to support shy Trump voter, sampling error, whatever else is uncovered as influencing in weeks and months to come. You can only make the call with the info you have. It’s the problem with this sort of betting, you deal with incomplete information, you are managing variance in an unknown distribution, this isn’t dice, roulette or even poker where you can do the maths with absolute or high degrees of confidence. It’s judgement you can add to with more information. I’d ask where is the additional info that made sense to price in that polymarket did price in? I’m not sure it exists. I’m not certain, but in my judgement, with the information available last week, Harris backers had EV, Trump backers didn’t… 

---

## 2024-11-06 13:49:55 - random channel

**Gooat**

So pre votes what would now say was fair value?



Sorry Paul our messages dropped at the same time. 



Just trying to work out my mental model for low frequency events, do I adjust my pre held beliefs/pricing or hodl.

---

## 2024-11-05 06:22:40 - issues channel

**anomaly**

Hi all, quick question regarding betfairlightweight and getting market clarifications for the historical stream. For the live api when i query the APIClient object i have to specify the market_projection, like as follows



```        trading_client.login()

        market_catalogues= trading_client.betting.list_market_catalogue(

            ...

            market_projection=[

                'MARKET_START_TIME',

                'RUNNER_DESCRIPTION',  

                'MARKET_DESCRIPTION', 

            ],

            ...

            )```

and everything works as expected and i can access the clarifications.



Is it possible to also get the market catalogues for the historical streaming (like in examples/examplestreaminghistorical.py). I am only able to retrieve the marketbook right now and it's not clear how I would go about accessing the market catalogues (specifically, clarifications)



cheers!

---

## 2024-11-02 10:50:37 - general channel

**Daniel**

The other was to add the relevant enums from the Betting API into a Pythonic representation, i.e.



[https://github.com/nunnsy/betfair/pull/2/files](https://github.com/nunnsy/betfair/pull/2/files)



[https://betfair-developer-docs.atlassian.net/wiki/spaces/1smk3cen4v3lu3yomq5qye0ni/pages/2687455/Betting+Enums](https://betfair-developer-docs.atlassian.net/wiki/spaces/1smk3cen4v3lu3yomq5qye0ni/pages/2687455/Betting+Enums)

---

## 2024-11-01 03:32:12 - general channel

**Phydeaux**

I have a "home lab" for other reasons, with NAS and a decent amount of compute so I've not deployed to the cloud. I am rural so have a good amount of solar and batteries, so even the electricity is free. The capex was relatively chunky, but built for other reasons, so the marginal cost to use it for betting / analysis was basically zero apart from my time.



Network latency isn't a concern for my strategy, but if it was I'd do a little testing to find which GCP/AWS/other zone is "closest".

---

## 2024-10-31 15:54:00 - general channel

**Jhonny**

Hi everyone, I keep getting NOT_AUTHORIZED error when trying to use the esa api. I haven't used it in about 2 months; my live key just got accepted and it's my first time trying it out:



```:event {:op connection, :connectionId 206-311024154911-133459}

:event {:op status, :statusCode FAILURE, :errorCode NOT_AUTHORIZED, :errorMessage Connection is not authenticated: MarketSubscriptionMessage{marketFilter=MarketFilter{marketIds=[1.235241223], bspMarket=null, bettingTypes=null, eventTypeIds=null, eventIds=null, turnInPlayEnabled=null, marketTypes=null, venues=null, countryCodes=null, raceTypes=null}, marketDataFilter=com.betfair.platform.exchange.stream.api.domain.market.MarketDataFilter@70734c3a, initialClk='null', clk='null', conflateMs=null, heartbeatMs=null}, :connectionClosed true, :connectionId 206-311024154911-133459}

:stream-closed```

Last I tested with the delayed key, it worked. However, both live and delay keys are currently not working. Would appreciate anyone's help, thanks

---

## 2024-10-31 12:08:06 - issues channel

**frank**

Hi, I'm trying to login to betfair api. but this code, gives me an ssl error. :  `# Import libraries`

`import betfairlightweight`

`from betfairlightweight import filters`

`import pandas as pd`

`import numpy as np`

`import os`

`import datetime`

`import json`



`# Change this certs path to wherever you're storing your certificates`

`certs_path = r'C:\certs'`



`with open('credentials.json') as f:`

    `cred = json.load(f)`

    `my_username = cred['username']`

    `my_password = cred['password']`

    `my_locale= cred['locale']`

    `my_app_key = cred['app_key']`



`trading = betfairlightweight.APIClient(username=my_username,`

                                       `password=my_password,`

                                       `locale=my_locale,`

                                       `app_key=my_app_key,`

                                       `certs=certs_path)`



`trading.login()`   errorse is the following: `Exception: HTTPSConnectionPool(host='[http://identitysso-cert.betfair.com|identitysso-cert.betfair.com](http://identitysso-cert.betfair.com|identitysso-cert.betfair.com)', port=443): Max retries exceeded with url: /api/certlogin (Caused by SSLError(SSLError(524297, '[SSL] PEM lib (_ssl.c:3905)')))`  any help would be very appreciated. Thanks

---

## 2024-10-31 10:28:25 - general channel

**James**

Following on from Paul’s recommendation, I work with AWS in my day job extensively but don’t have the same limitations he does. Lightsail and Fargate serverless containers, and s3 for storage. Along with using a neon Postgres or digital ocean Postgres (for no cold start) is what I use for my market catalogues and betting records. Most of your record keeping can happen in background threads and can afford to be a little slower. 



Lightsail and neon are a bit more batteries included and a good place to start, and less knobs go turn. Fargate and a dedicated DB can let you squeeze some more out as you get deeper into it. 



This setup means my costs are low. I run my sims on my own hardware, even if slow it doesn’t cost me anything except electricity :relaxed: 

---

## 2024-10-30 19:57:23 - random channel

**Paul**

By saying Fredi can’t be Kelly optimal I’m assuming he has &lt;1% edge at those prices (I can’t accept he has a whole lot more without us diving into absurdity). So it’s either -EV, it’s +EV and he’s insanely rich (Musk/Bezos/Zuck levels), or there is something else going on like a market that won’t settle “right”

---

## 2024-10-30 19:49:16 - random channel

**Paul**

If it’s a coin toss (which I accept might be a big “if”), Kelly says 9% of bank is max bet (because Kamala is priced with a 9% edge over evens true odds). It seems unlikely the polls are so wide of reality that Fredi is Kelly optimal at that position size unless his bank runs to 9-10 figures. Occam’s razor to my mind says either: it’s nowhere near a coin flip and polls are a mess; the market won’t settle based on actual result (see comments from [@U05L8PZD2FM](@U05L8PZD2FM)), and Fredi is pricing in a coup of some sort here; or, there is a whale in a hot -EV mess skewing prices. I’m not sure which is true but I think public polling is likely closer to reality than being 10% out towards Harris - the error bars can’t be that wide.

---

## 2024-10-30 11:18:40 - strategies channel

**Terry**

```RunOrders = market.blotter.strategy_selection_orders(self, SEL, matched_only=True)

                            

if len(RunOrders) > 0:



    logger.info(f"{runner_name} has {len(RunOrders)} matched order")

    continue  # Skip placing an order if there is already an active investment or trade



else:

    ##Place Bet```

---

## 2024-10-30 09:28:05 - strategies channel

**liam**

`greys_2 = MyModelLay(`

---

## 2024-10-30 09:25:03 - strategies channel

**Terry**

```GREYS_2 = MyModel_LAY(

    market_filter=marketfilter,

    max_order_exposure=50,

    max_trade_count=1,

    max_live_trade_count=1, 

    max_selection_exposure=50,

    conflate_ms=1500,

    name="greys_LAY",

    

)```

---

## 2024-10-30 09:11:58 - strategies channel

**liam**

What are your strategy settings? (and logs will tell you)



```strategy = LowestLayer(

    market_filter={"markets": markets},

    context={"stake": 2},

    max_live_trade_count=2

)```

---

## 2024-10-29 17:59:11 - random channel

**Jonjonjon**

The strategy won't be great. But tipsters don't sell good tips.

---

## 2024-10-29 17:45:57 - random channel

**Ralegh**

I can’t imagine a strategy that’s hard to scale but that you could tip for? If it’s hard to scale then there’s limited liquidity ie other people couldn’t put the bet on (alternatively it’s super low sharpe but i assume from £2 bets that the variance isn’t that high)

---

## 2024-10-29 11:14:27 - random channel

**Jonjonjon**

Suppose I have a strategy that makes around £100 per month, placing £2 bets on UK horse racing on the morning of each race. The strategy is hard to scale. Maybe I can just sell it instead, by publishing the signals at the same time as I execute? I'm not claiming it'll be good value for the punter, but it won't really be worse than anything else out there.

---

## 2024-10-29 11:09:44 - random channel

**Justice**

Why would you want to do that unless your strategy isn't making money?

---

## 2024-10-29 11:07:03 - random channel

**Jonjonjon**

Has anyone with a successful pre-off racing strategy attempted to sell it as a tipster service?

---

## 2024-10-27 12:39:04 - general channel

**Jhonny**

Hi everyone,

How long does it take to get approval for the live API key?

I bought historical data for this month, hoping to use it in conjunction with the api (since it's not allowed to simply listen to markets without betting); However, I haven't gotten any update about my live api key; Not even an acknowledgement of my request. The month is as good as gone

---

## 2024-10-25 08:39:16 - strategies channel

**liam**

From the AUS team



&gt; NEW CONTENT   

&gt; Just in time for the weekend, Parts 1 &amp; 2 of our new series "How To Build A Soccer Bot" are now live on the Automation Hub! 

&gt; Part 1: [https://betfair-datascientists.github.io/modelling/howToBuildASoccerBotPartI/](https://betfair-datascientists.github.io/modelling/howToBuildASoccerBotPartI/) 

&gt; Part 2: [https://betfair-datascientists.github.io/modelling/howToBuildASoccerBotPartII/](https://betfair-datascientists.github.io/modelling/howToBuildASoccerBotPartII/)

---

## 2024-10-19 15:22:05 - general channel

**Mo**

1. Look at the [https://github.com/betcode-org/betfair/tree/master/|source code](https://github.com/betcode-org/betfair/tree/master/|source code), especially [https://github.com/betcode-org/betfair/tree/master/examples|the examples](https://github.com/betcode-org/betfair/tree/master/examples|the examples) and [https://github.com/betcode-org/betfair/blob/master/betfairlightweight/resources/bettingresources.py|the resources](https://github.com/betcode-org/betfair/blob/master/betfairlightweight/resources/bettingresources.py|the resources) 

2. Familiarise yourself with the [https://betfair-developer-docs.atlassian.net/wiki/spaces/1smk3cen4v3lu3yomq5qye0ni/pages/2687473/Reference+Guide|Betfair API documentation](https://betfair-developer-docs.atlassian.net/wiki/spaces/1smk3cen4v3lu3yomq5qye0ni/pages/2687473/Reference+Guide|Betfair API documentation)

3. Install and use a decent IDE like [https://www.jetbrains.com/pycharm/|PyCharm](https://www.jetbrains.com/pycharm/|PyCharm) that will allow you to debug which will let you step through code line by line and examine the Python objects involved

---

## 2024-10-19 14:28:57 - general channel

**John**

What is the correct way to call the listMarketCatalogue method with a known market_id   My code is:

```# Create the request parameters

listMarketCatalogue_req = {

    "filter": {

        "market_ids": [event_id],

        "marketProjection": ["MARKET_START_TIME", "RUNNER_METADATA", "RUNNER_DESCRIPTION", "EVENT_TYPE", "EVENT"]

    },

    "id": 1

}



# Call the listMarketCatalogue method

response = client.betting.list_market_catalogue(listMarketCatalogue_req)```

where client is betfairlightweight.APIClient(username, password, app_key)

---

## 2024-10-18 21:40:59 - random channel

**D C**

At the risk of adding to the pedantry, is it not the case that probabilities are variable over time, but that we are only able to approximate it within some degree of accuracy depending on what information we are privvy to at the time? And as there are lots of differing amounts of information that certain subsets have access to, the approximations are (very likely) very different to each other. It's an extreme case but a jockey who decides to throw a race and not tell anyone else effectively ensures that the probability that the horse wins is zero. We are all churning data to identify the outcome probabilities but the jockey's info is superior to everone else's. Of course as a human, he/she may subsequently change their mind about throwing the race up to a point at which it becomes too late. But there is just some information we can't ever have access to and so our models are always inaccurate (isn't there some quote along the lines of all models are incorrect but some models are useful). But the probability remains precise.

I've always thought of it along quantum mechanical lines where each eigenstate probability can vary over time up until the measurement is made (result has it's outcome) at which point state vector collapses onto the eigenstate represented by the observed value (projection postulate I think it was called?)

As people who build models, all we can do is approximate based on repeated measurement data from similar historic events? The probabilities are always precise - it's just we can't ever know for sure how far away our approximations are and we have to rely on longer term averages to show that prices/ implied probabilities match up with observed data frequencies.



I've had some beer and I feel I may regret this post in the morning.

---

## 2024-10-17 09:21:58 - issues channel

**NT**

Rookie question, is there a limit to how many times you can call trading.keep_alive()?



I am trying to keep my session alive to both: 1) read price data, and 2) make trades.



My strategy for doing this has been to: 1) call the keep alive endpoint and 2) use trading.keep_alive().



I'm pretty new to the betfairlightweights library, so sorry if I've missed something obvious on where to find this information!

---

## 2024-10-16 11:13:48 - random channel

**Unknown**

Topics for this meetup included:

• the philosophical nature of Justified True Beliefs and Gettier in the context of open discussion of "alpha"

• almost _passionate_ disagreement on the quality of Nate Silver's knowledge, beliefs, and ability as a writer

• [@U05REBJ21EC](@U05REBJ21EC) honourably deciding to test the legality of trading on crypto prediction markets in the US from the UK for the rest of us - we'll send you a file in a cake if you end up in a Supermax Lorenzo, go for it, haters gonna hate!

• is the real alpha just starting your own exchange?

• dumb ideas that seem to make money, even though they're so obvious they _have_ to be just dimes in front of a steamroller, no?

• how much to invest in smart ideas that don't seem to make money because it _must_ just be the parameter search hasn't hit yet (aka, the source of all imposter syndrome in this domain)

• whether going to Rules for dinner is worth it (probably, yes - speak to [@UBS7QANF3](@UBS7QANF3) if you wish to join)

• would horse racing be the second largest spectator sport in the UK if it weren't for Cheltenham festival?

• undocumented forbidden stake amounts at certain price points created by rounding errors

• and, inevitably, "taxes are bad mmm'kay?", as a means to get a rise out of your local Northern Labour-voting cryptosocialist (:wave:)

Next one will be in a few weeks. Probably. I dunno. You figure it out.

---

## 2024-10-14 11:50:13 - random channel

**D C**

Surely the Benter edge stems from that hard earned data though (at least the raw edge from pricing). You could scrape racing post and apply the same statistical technique to build a model but I'd imagine it would perform poorly. I've enough confidence in that opinion to have so far not bothered doing it but who knows, maybe I've been sitting on a gold mine all this time. I know the HK racing setup is very different to racing in other countries, but I'm just talking in general - freely available generic data versus specifically formulated data requiring hundreds of man hours to get hold of is always going to lose out.

---

## 2024-10-14 10:33:11 - strategies channel

**liam**

Weird as it lets me search it but then the link doesn't work



&gt; 

&gt; 

&gt; *liam*  [3:24 PM]

&gt; Does anyone know how much Decimal charge for the Cricket feed?

&gt; 49 replies

&gt; 

&gt; 

&gt; 

&gt; 

&gt; 

&gt; *Robert*  [3:55 PM]

&gt; I'm on the hunt for a decent feed too!

&gt; 

&gt; 

&gt; 

&gt; *D C*  [4:02 PM]

&gt; Is it just a score feed? Is Betfair's not up to scratch?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [4:05 PM]

&gt; No comment

&gt; 

&gt; 

&gt; 

&gt; *D C*  [4:06 PM]

&gt; Understood

&gt; 

&gt; 

&gt; 

&gt; *liam*  [9:10 AM]

&gt; I have sent an email, will share the price if they do however I fear it might be out of my budget

&gt; 

&gt; 

&gt; 

&gt; *Mo*  [9:56 AM]

&gt; I can give you a personal introduction if you don’t get anywhere

&gt; 

&gt; 

&gt; 

&gt; *Robert*  [11:22 AM]

&gt; I think the main issue, not just for cricket, is Betfair's inability to use the widely accepted team or players names.

&gt; 

&gt; 

&gt; 

&gt; *Robert*  [3:15 PM]

&gt; And the inability to match names strikes again :expressionless:

&gt; 

&gt; 

&gt; 

&gt; *liam*  [3:36 PM]

&gt; It's a complete fucking joke tbh, almost 3 years this has been in 'production'

&gt; 

&gt; 

&gt; 

&gt; *Robert*  [3:48 PM]

&gt; you would have thought, it being the same team causing the issue as yesterday, they might have pre-empted it .....

&gt; 

&gt; 

&gt; 

&gt; *Lee*  [3:49 PM]

&gt; what issues are you seeing [@U4H19D1D2](@U4H19D1D2)?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [3:51 PM]

&gt; The usual ongoing mapping issues and there is some sort of bug with the Lancashire game which is pushing out about a million updates per second on certain connections, seems like they just don't care

&gt; 

&gt; 

&gt; 

&gt; *Mo*  [6:11 PM]

&gt; Wow, looks like this is bringing down my entire scraping infrastructure

&gt; 

&gt; 

&gt; 

&gt; *liam*  [6:19 PM]

&gt; Try restarting, doesn’t seem to be on every connection

&gt; 

&gt; 

&gt; 

&gt; *Mo*  [6:21 PM]

&gt; Better but the damage has already been done

&gt; 

&gt; 

&gt; 

&gt; *Lee*  [6:22 PM]

&gt; nice to know the cricket feed could take down all my recording

&gt; 

&gt; 

&gt; 

&gt; *Mo*  [6:23 PM]

&gt; Well your mileage may vary depending on how much disk space your box has and whether you have appropriate alerts set up

&gt; 

&gt; 

&gt; 

&gt; *D C*  [6:24 PM]

&gt; Is this a recent problem or  long term? Just wondering if it's related to my recent server reboot as I am recording the cricket score feed on said server.

&gt; 

&gt; 

&gt; 

&gt; *liam*  [7:53 PM]

&gt; Recent, started today at 11:45ish, apparently now fixed

&gt; 

&gt; 

&gt; 

&gt; *liam*  [8:21 AM]

&gt; Looks like either it was never fixed or it started happening again today at about 1am

&gt; 

&gt; [8:22 AM]

&gt; 

&gt; This file is hidden because it was uploaded more than 90 days ago. [https://betcode-org.slack.com/plans?feature=unlimited_messages|Upgrade to a paid subscription](https://betcode-org.slack.com/plans?feature=unlimited_messages|Upgrade to a paid subscription) to view.

&gt; 

&gt; 

&gt; 

&gt; 

&gt; *Robert*  [12:10 PM]

&gt; My machine must have been smoking, I wonder what's going on... (edited)

&gt; 

&gt; 

&gt; 

&gt; *liam*  [12:29 PM]

&gt; eventide issues apparently

&gt; 

&gt; [http://docs.eventide-project.org/](http://docs.eventide-project.org/)

&gt; 

&gt; 

&gt; *[http://docs.eventide-project.org|docs.eventide-project.org](http://docs.eventide-project.org|docs.eventide-project.org)*

&gt; *[http://docs.eventide-project.org/|Eventide](http://docs.eventide-project.org/|Eventide)*

&gt; Pub/Sub, Event Sourcing, Evented Microservices

&gt; 

&gt; 

&gt; 

&gt; *Gooat*  [6:48 PM]

&gt; Any ball park price numbers come back?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [7:03 PM]

&gt; Nope

&gt; 

&gt; 

&gt; 

&gt; *liam*  [11:29 AM]

&gt; For those interested

&gt; 

&gt;&gt; You are more than welcome to come direct but we do have a minimum fee for direct customers that may be prohibitive to you of £2k per month and £150 per game.

&gt; 

&gt; 

&gt; 

&gt; *D C*  [11:46 AM]

&gt; 2K a month AND £150 a game. No idea if that's cheap or expensive to be fair

&gt; 

&gt; 

&gt; 

&gt; *Mo*  [11:48 AM]

&gt; Expensive compared to other sports but there’s easily enough liquidity in a match to extract that much EV

&gt; 

&gt; 

&gt; 

&gt; *liam*  [12:18 PM]

&gt; I read that as £150 a game, minimum 2k a month.

&gt; 

&gt; Update on the betfair feed is that I have continued hounding Neil to the point they have made some changes to the 'team' lots of politics/stupid code freezes but things have improved

&gt; 

&gt; 

&gt; 

&gt; *Lee*  [12:20 PM]

&gt; I noticed last month there was a big jump in quantity of matches with the feed. Up around 100 matches.

&gt; 

&gt; [12:20 PM]

&gt; Is that seasonal or from the improvements?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [12:21 PM]

&gt; Both but we are now down to missing about 15% of the matches due to mapping, there where times last year where it was around 50%

&gt; 

&gt; 

&gt; 

&gt; *Lee*  [12:22 PM]

&gt; Big improvement

&gt; 

&gt; 

&gt; 

&gt; *Lee*  [2:03 PM]

&gt; How do you work out which markets are missing the feed?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [2:09 PM]

&gt; nightly script to reconcile between market/feed data

&gt; 

&gt; 

&gt; 

&gt; *Lee*  [2:12 PM]

&gt; are we expecting every cricket match to have the feed?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [2:13 PM]

&gt; pretty much, expect sub ~3% to not have a feed depending on what betfair put up

&gt; 

&gt; 

&gt; 

&gt; *Gooat*  [5:38 PM]

&gt; Has anyone levelled up to big stakes from the feed?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [5:58 PM]

&gt; I am up to a few k exposure per market

&gt; 

&gt; 

&gt; 

&gt; *Gooat*  [6:02 PM]

&gt; Nice. Model or mix of price and flow? I struggled to avoid averse selection when testing it.

&gt; 

&gt; 

&gt; 

&gt; *liam*  [6:08 PM]

&gt; model

&gt; 

&gt; 

&gt; 

&gt; *Gooat*  [9:28 PM]

&gt; How did that game go?

&gt; 

&gt; 

&gt; 

&gt; *Sen*  [2:32 PM]

&gt; On this note - [@U4H19D1D2](@U4H19D1D2) how do you know Decimal is the best data provider in the cricket space? Something you've been able to test? (edited)

&gt; 

&gt; 

&gt; 

&gt; *liam*  [2:36 PM]

&gt; I don't, its just the one betfair provide

&gt; 

&gt; 

&gt; 

&gt; *Mo*  [2:37 PM]

&gt; I can say that the people behind it have been involved in cricket data for at least a decade

&gt; 

&gt; 

&gt; 

&gt; *Sen*  [3:15 PM]

&gt; Another option is sportmonks - they look pretty decent too

&gt; 

&gt; 

&gt; 

&gt; *liam*  [3:15 PM]

&gt; Yeah, considerably cheaper

&gt; 

&gt; 

&gt; 

&gt; *D C*  [4:31 PM]

&gt; Has the Betfair cricket feed not improved ?

&gt; 

&gt; 

&gt; 

&gt; *liam*  [7:23 PM]

&gt; Yes it has but it’s been hard work (for myself and Neil)



---

## 2024-10-14 06:42:18 - general channel

**lorenzo**

you might be looking for [https://github.com/betcode-org/betfair/blob/d21e277755de34d13ed10715c5eb6eee532158d7/betfairlightweight/resources/bettingresources.py#L384|RunnerBookEx](https://github.com/betcode-org/betfair/blob/d21e277755de34d13ed10715c5eb6eee532158d7/betfairlightweight/resources/bettingresources.py#L384|RunnerBookEx) instead of the SP ? As far as I understand the SP has only the MarketOrders (related to the Starting Price)

---

## 2024-10-13 15:29:26 - random channel

**Paul**

You don't need to build a model for every league in every sport - they do. Their attention is divided. Because their prices are either directly tradable or start to inform exchange markets, opportunities open up.

---

## 2024-10-13 15:29:11 - random channel

**Paul**

My take on it is not too far from the premise covered in [https://www.amazon.co.uk/Interception-Secrets-Modern-Sports-Betting-ebook/dp/B0CKS8GGX4/ref=sr_1_1?crid=3V8X13PPVX0S0&amp;dib=eyJ2IjoiMSJ9.rWpJIs_Gy1zJr2pM-4nqkGmV5GNE5Npr2krst8t4oyYAHRh-tyx88S1-pQeHsebQtU0ipaAqHftXXYPA8gbze8N1x9be32dRjgkSOyE4GomvmUktHTDq53aoo8a50-KQEYInDot_fdZPqjURXCxncspw4LDgXl9aHzOlHO7CBoIenKv5oc7A6_ZY81a8evFw3sb_VK80J-_5FauBF1NOuu6qcNPl45H_owT5TQGBBUY.uCKWCrPwifipksVyutW8QYay2w83z4Y7G-ltzZYKHxY&amp;dib_tag=se&amp;keywords=interception&amp;nsdOptOutParam=true&amp;qid=1728829608&amp;sprefix=interception%2Caps%2C102&amp;sr=8-1|Interception](https://www.amazon.co.uk/Interception-Secrets-Modern-Sports-Betting-ebook/dp/B0CKS8GGX4/ref=sr_1_1?crid=3V8X13PPVX0S0&amp;dib=eyJ2IjoiMSJ9.rWpJIs_Gy1zJr2pM-4nqkGmV5GNE5Npr2krst8t4oyYAHRh-tyx88S1-pQeHsebQtU0ipaAqHftXXYPA8gbze8N1x9be32dRjgkSOyE4GomvmUktHTDq53aoo8a50-KQEYInDot_fdZPqjURXCxncspw4LDgXl9aHzOlHO7CBoIenKv5oc7A6_ZY81a8evFw3sb_VK80J-_5FauBF1NOuu6qcNPl45H_owT5TQGBBUY.uCKWCrPwifipksVyutW8QYay2w83z4Y7G-ltzZYKHxY&amp;dib_tag=se&amp;keywords=interception&amp;nsdOptOutParam=true&amp;qid=1728829608&amp;sprefix=interception%2Caps%2C102&amp;sr=8-1|Interception) - most of these companies are going thin and broad because that's what their customer want/need. That means that it is likely possible to build better models than most of these firms can attempt.

---

## 2024-10-13 14:23:01 - random channel

**Paul**

I think if the government want to reduce problem gambling and do so in a way that protects jobs, they need to move to more heavily regulate online RNG to the point of almost making it impractical to operate. It's where most degens suffer, and at least you can point to tens of thousands of jobs supported directly with sports betting or in-person gaming...

---

## 2024-10-12 13:22:11 - random channel

**D C**

I do wish bookies would make up their minds about whether they want to operate as RNG outfits or proper sportsbooks. The only positive in this article is that there seems to be some distinction between the two types of gambling and a recognition that RNG betting is more harmful in terms of potential addiction. Problem is that this current collection of halfwits seem intent on grabbing money from wherever they can but there really is no point speculating until this budget statement is announced.

---

## 2024-10-12 10:40:36 - random channel

**Paul**

And if it does get into the media that the markets are indicating a Trump win, at least some of us will know that is not wisdom of the crowd. One thing worth learning from this is that arbs sometimes occur not because of new info being widely disseminated yet (the foundation of Kelly’s thought train on information theory), but because motives are misaligned. Market making books want to be greened up and need to move the line, some people believe their own BS, etc

---

## 2024-10-11 14:37:10 - general channel

**Jorge**

I got a model that bets in the half-time (I want to avoid betting when the ball is running) and want to be able to bet as soon as possible

---

## 2024-10-07 11:23:17 - strategies channel

**Paul**

[@UPMUFSGCR](@UPMUFSGCR) - depends. Software capability maturity model is a real thing. Not everyone is - or is able to - hit best practices in every box, due to other conflicting requirements. Anyone over the age of 30 probably didn't have it enforced on them when getting into the industry, so never felt the benefits, so drag their feet. TDD only _really_ came of age in the 2010s, as tools across Ruby (choice of startups on both sides of the Atlantic 2006-2015), Java, C# (enterprise, both) got good, and then mimicked in other languages like Python, C++, Go, Rust and so on afterwards. If you worked in investment banks, you probably know full well there are tons of things inside investment banks that are either ancient (COBOL, S/360s, AS/400s, et al), or shonky (VBA in Excel spreadsheets for portfolio management), or both (I was told about a Lotus Notes thing absolutely key to one bank KTLO operation a couple of years ago). Greenfield projects that are tech heavy (which banks have been throwing money at since Jane Street and co started to eat their lunch), will nearly always be TDD these days, but even then 90% of the devs I work with drag their feet and you're doing well to see 60%+ test coverage on most code bases.

---

## 2024-10-05 10:47:00 - strategies channel

**Jonjonjon**

I scanned a load of files yesterday and noticed lots of "available to back" orders with a liability of 1p or less. Is that a viable strategy? I thought Betfair had cut down on it.

---

## 2024-10-03 21:30:12 - issues channel

**Matthew Lawrence**

I'm using this to test my login and it's not working:

```with open(r"C:\Users\matth\OneDrive\Documents\docker_scripts\Certs\credentials.json") as f:

    cred = json.load(f)

    my_username = cred["username"]

    my_password = cred["password"]

    my_app_key = cred["app_key"]



# Create an instance of the Custom Betfair API client

trading = betfairlightweight.APIClient(my_username, my_password, app_key=my_app_key,certs=r"C:\Users\matth\OneDrive\Documents\docker_scripts\Certs"

)



response = trading.login()

print("Login successful.")



# Get account information

balance = trading.account.get_account_funds(wallet="UK")

BANK = balance.available_to_bet_balance

print(f"Available to Bet Balance: {BANK}")```



---

## 2024-10-03 21:19:57 - strategies channel

**JL**

oh it's wrong? I did it similar to: [https://www.quantstart.com/articles/Sharpe-Ratio-for-Algorithmic-Trading-Performance-Measurement/](https://www.quantstart.com/articles/Sharpe-Ratio-for-Algorithmic-Trading-Performance-Measurement/)

---

## 2024-10-03 15:19:46 - general channel

**liam**

how confident are you there isn't another strategy causing an issue?

---

## 2024-10-03 15:18:06 - general channel

**Newbie99**

For my understanding, if its commented out though, why would it not just use start from the BaseStrategy?

---

## 2024-10-03 15:16:45 - general channel

**Newbie99**

```'''     def start(self):

        # subscribe to streams

        print("starting strategy ", self.name) '''```

---

## 2024-10-03 15:14:32 - general channel

**liam**

its the bit you aren't showing me, what does your strategy `start` look like?

---

## 2024-10-03 15:14:00 - general channel

**Newbie99**

Sorry [@U4H19D1D2](@U4H19D1D2), I'm not really understanding the error, the affected line is:



```framework.run()```

What should the syntax be, maybe I'm misunderstanding the error, but I thought this section relates to the Flumine package rather than my code, so I'm a bit confused:



```  File "/home/ec2-user/.pyenv/versions/3.9.0/lib/python3.9/site-packages/flumine/strategy/strategy.py", line 279, in start

    s.start(flumine)

TypeError: start() takes 1 positional argument but 2 were given ```

---

## 2024-10-03 13:40:18 - general channel

**liam**

Yeah that was changed last month, it had a depreciation warning for about 6 months



[https://github.com/betcode-org/flumine/blob/cd5b228a412dc6e55d55051ca2be98ce5a0152b5/flumine/strategy/strategy.py#L95](https://github.com/betcode-org/flumine/blob/cd5b228a412dc6e55d55051ca2be98ce5a0152b5/flumine/strategy/strategy.py#L95)

---

## 2024-10-03 13:33:01 - general channel

**Newbie99**

I get this post upgrade:



```  File "/home/ec2-user/trading/env/projects/startup.py", line 208, in startup

    framework.run()

  File "/home/ec2-user/.pyenv/versions/3.9.0/lib/python3.9/site-packages/flumine/flumine.py", line 27, in run

    with self:

  File "/home/ec2-user/.pyenv/versions/3.9.0/lib/python3.9/site-packages/flumine/baseflumine.py", line 450, in __enter__

    self.strategies.start(self)

  File "/home/ec2-user/.pyenv/versions/3.9.0/lib/python3.9/site-packages/flumine/strategy/strategy.py", line 279, in start

    s.start(flumine)

TypeError: start() takes 1 positional argument but 2 were given```



---

## 2024-10-03 09:51:39 - random channel

**Jonjonjon**

I think Autogluon can do that with the time series models, though I didn't like it when I tried. Didn't  [@U012XF5CNPN](@U012XF5CNPN) recommend it a while back?

---

## 2024-10-02 16:32:30 - random channel

**Mo**

Sounds like multivariate time series analysis and you can use the vector equivalents of AR (VAR), ARMA (VARMA) and ARIMA (VARIMA) models

---

## 2024-10-02 12:21:45 - random channel

**Leo**

Depends how you model time series. I just chuck it all In a lightgbm model and you can use lagged features of both river levels and rainfall 

---

## 2024-10-02 12:04:47 - random channel

**Paul**

I suspect a lot of people might have looked at this: are there decent fully baked models/approaches for being able to correlate time series predictions? As an example, let's suppose I have previous data for the height of a tidal river, and I wanted to understand how rainfall affects that level, I'd have a time series data set for rainfall in that area, and a time series data set from a river gauge, and I want to predict future river levels given predicted future rain, is there an out of the box method for that? I've been doing some digging around and found models for predicting a single time series, but not correlation, and some papers that talk about Pearson coefficient, but don't fancy coding them up if somebody can just say "Oh, use this library for that".

---

## 2024-09-30 19:12:35 - random channel

**Paul**

&gt; One conclusion of this experiment and article is that there is little value in a crystal ball without sensible trade-sizing.

Over-betting has been mathematically been shown to guarantee ruin, even if you have +EV. If there is nothing else Kelly can give you, it’s this. Over-bet = guaranteed ruin. Doesn’t matter what the edge is, if there is variance, over-betting *will* ruin you.

---

## 2024-09-26 16:22:28 - random channel

**Newbie99**

One other thing that concerns me about all the GPT models is that if you challenge a response it almost always concedes, even if it was correct and my challenge was incorrect.

---

## 2024-09-23 12:46:14 - random channel

**Joe**

It will show as percentage of a single core by default, moreover depending on what threading model you are using if you are running multiple threads in say java they will be grouped under one entry by default, so it will display the sum of the child process cpu usage as a percentage of a single cpu even though it will be spread over many cpus concurrently.

---

## 2024-09-17 07:42:02 - general channel

**Shahid Tariq**

I am using betfairlightweight library for streaming, here is my subscription code:

```await stream.subscribe_to_markets(

            market_filter=streaming_market_filter(

                event_type_ids=[1, 2, 4, 7, 4339], betting_types=["ODDS"]

            ),

            market_data_filter=streaming_market_data_filter(

                fields=["EX_MARKET_DEF", "EX_BEST_OFFERS_DISP", "EX_TRADED_VOL"],

                ladder_levels=3,

            ),

            conflate_ms=BetfairStreamConstants.CONFLATE_MS,

            initial_clk=listener.initial_clk,

            clk=listener.clk,

        )```

---

## 2024-09-17 07:00:17 - issues channel

**Thomas Conti**

When I do this without restricting market IDs, I get the error. What should I use to restrict the number of markets without picking market_ids?

Appreciate your help.



2024-09-17 15:14:34,927:ERROR:[MarketStream: 2006]: SUBSCRIPTION_LIMIT_EXCEEDED: trying to subscribe to 206 markets whereas max allowed number was: 200



```strategy = LayStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["4339", '7'],  # Greyhound and Horse Racing

        country_codes=["AU", "NZ"],  # Australia and New Zealand

        market_types=["WIN"],  # Win markets

    )

)```



---

## 2024-09-17 02:45:39 - issues channel

**Thomas Conti**

Hi everyone,

The issue arises when I try to dynamically add `market_ids` to the market stream. When I try to add new markets, the stream doesn't automatically refresh to include these new `market_ids`. Consequently, my strategy stops processing once the initially subscribed markets close. I need help with ensuring that the stream updates correctly with new markets during runtime.



 Any advice on how to add market_ids dynamically would be appreciated.

---

## 2024-09-16 10:35:13 - random channel

**liam**

Agreed, I have found the more you try and do with the data the worse it gets, keep it as raw as possible, there are going to be errors but considering you are against users who are betting almost blind it doesn't really matter

---

## 2024-09-16 08:46:50 - random channel

**D C**

I think if you're dealing with fundamentals [@U01PJ5YMFBJ](@U01PJ5YMFBJ) then it makes sense to factor in the environment. I'm no tennis modeller, but I'd imagine that clay court stats for a player are less impactful than grass courts when modelling wimbledon prices.

---

## 2024-09-16 08:38:38 - random channel

**Justice**

I don't have access to those files otherwise I would. [@UGV299K6H](@UGV299K6H) Perhaps it's a coincidence then, I just get frustrated with how often my model is making poor decisions due to errors in the data. Though I suppose if it was that good they wouldn't have made it available :joy:

---

## 2024-09-16 08:35:20 - random channel

**Justice**

[@UUE6E1LA1](@UUE6E1LA1) I also find that Chester is shit on the data for my strategy. Along with Lingfield. I have long since been suspicious of the way TPD calculate the distance to the finish based on the running line. I notice strange anomalies in races where horses run wide etc.

---

## 2024-09-15 22:27:10 - random channel

**AndyL**

I'm going to ask a really dumb question probably(!) but I keep seeing [@UQL0QDEKA](@UQL0QDEKA) posting these 1000 winners, and everyone seems to join in... So I am guessing there's some value in betting in certain cicumstances on 1000.0 (obviously!) I guess if the horse is still on all 4's it might be value???

---

## 2024-09-15 21:20:34 - random channel

**D C**

Some yeah but it depends on how much data there is available. The AW tracks for instance because there are just so many more meetings and therefore more data to build a model with so I can run a per-track model for each. Do you?

---

## 2024-09-15 15:57:55 - random channel

**ShaunW**

In that example [@UPMUFSGCR](@UPMUFSGCR) the risk was always £90 for that very reason. Tech is famously falable and it's naive to assume the worse case scenario won't occur, especially if you're betting 247.



But I'd hope not thinking about that risk adequately would be a one time error, and as such it might not be a reason to stop. Unless you do it twice.

---

## 2024-09-15 09:44:10 - general channel

**foxwood**

That looks ok - must have left some strategy stuff in - the example works out of the box - look at that [https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py](https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py)

---

## 2024-09-15 09:32:26 - general channel

**Johnnb**

I recently separated my market recorder and strategy code and this has caused the market recorder to start generating enormous logs full of warnings like these :



```{"asctime": "2024-09-14 18:04:50,227", "levelname": "WARNING", "message": "Order 361076840419 not present in blotter", "bet_id": "361076840419", "market_id": "1.232946144", "customer_strategy_ref": "ip-172-26-2-232", "customer_order_ref": "fbcd952b00c57-139456298400765211", "client_username": "xxxxxxx"}

{"asctime": "2024-09-14 18:04:50,227", "levelname": "WARNING", "message": "Strategy not available to create order 139456298400765211", "bet_id": "361076840419", "market_id": "1.232946144", "customer_strategy_ref": "ip-172-26-2-232", "customer_order_ref": "fbcd952b00c57-139456298400765211", "strategy_name_hash": "fbcd952b00c57"}```

Can I safely suppress these with a logging filter or do they indicate that I'm doing something wrong? All the recorder's connections are specified as DataStream which I thought meant that they wouldn't receive any order info?



```racing_recorder = S3MarketRecorder(

    name="RACING_RECORDER",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB","IE","FR"],

        market_types=["WIN"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": local_dir,

        "force_update": False,

        "remove_file": True,

        "remove_gz_file": True,

        "recorder_id": recorder_id,

        "bucket":"xxxxxx",

    },

)```

---

## 2024-09-15 01:04:49 - strategies channel

**Gooat**

I always wonder about many small models/ratings v many features and dealing with it in OMS.

---

## 2024-09-14 13:14:17 - general channel

**Rob**

I'd second mlflow, as much for experiment tracking as for holding models.



As much code as possible is shared between strategies, and I structure the code so the same strategy class is used for live/backtesting.



I use notebooks for analysis only.

---

## 2024-09-14 08:52:36 - general channel

**Justice**

[@UUE6E1LA1](@UUE6E1LA1) To sum up my current workflow: data analysis, visualization, model development, backtesting all done in Python (backtesting done directly in a polars dataframe, not with flumine). All this is just strewn around in various notebooks with no real thought. Export trained model via ONNX to C# codebase for production use

---

## 2024-09-14 06:47:52 - issues channel

**Unknown**

As a step in this direction, I have created the following PR: [https://github.com/betcode-org/flumine/pull/765|https://github.com/betcode-org/flumine/pull/765](https://github.com/betcode-org/flumine/pull/765|https://github.com/betcode-org/flumine/pull/765)



This adds a new listener kwarg `max_inplay_seconds` which caps the number of seconds after turning in play that updates will be processed. An example use case would be running a football strategy as part of CI only on the first 10 minutes of the match to minimise testing time

---

## 2024-09-13 20:08:05 - general channel

**Justice**

[@U012XF5CNPN](@U012XF5CNPN) Is that just your backtesting/strategy logic? Or do you literally have the entire process in a single file including data processing, cleaning, feature creation, model training etc.

---

## 2024-09-13 19:56:02 - general channel

**Paul**

I’m crazy in that I will use parameters in file names. So for example if I have a cricket model that trades 3 ticks off the last traded it could live in cricket_inplay_3t.py and so I can quickly create multiple variants with a file cp to a new name. That’s a very simplistic version of what I’m actually doing but broadly right.

---

## 2024-09-13 15:55:14 - general channel

**Justice**

How are people structuring their codebases for model development and backtesting? I'm trying to formalize my approach a bit as I have several strategies I'm reasonably happy with but they're all just strewn around in notebooks and it's becoming hard to keep track of the experiments I'm running. Python is not my primary language and I've only ever used it for ML/data, so I'm always a bit lost when it comes to this

---

## 2024-09-13 14:20:46 - random channel

**Paul**

I was listening to Nate Silver’s latest book, and as predicted he’s drifting like a boat :slightly_smiling_face:, but the other night I got to the point where he was talking about slots advantage players, and it actually does sound like there is +EV strategy lurking in there, just not widely known. Some of the podcasts I listen to (Risk of Ruin for example), sometimes cover video slots APs who seem to make a decent living with much less risk than Blackjack card counting, and with less variance than poker (even cash games), so I do wonder if I’m just being a prig about it. Silver made the point that many players don’t even want to win (sirens going off, staff coming over to shake your hand, becoming the centre of attention, etc.), which is indicative of a problem to me. But it does seem winnable as a form of gambling with the right approach (casino machines with particular payout mechanics, knowledge of the games themselves, etc.). Not my thing (haven’t the patience to spend 10 hours trawling around checking machines for a possible +EV setup), but I do wonder if it’s the approach to the game that’s the problem, not the game sometimes…

---

## 2024-09-12 18:54:43 - strategies channel

**Michael**

Yeah so in that case you can forget all about Kelly. Keep your stakes flat and small. I know it's frustrating but small stakes really is the way to go.

---

## 2024-09-12 18:48:45 - strategies channel

**Justice**

[@U4H19D1D2](@U4H19D1D2) Yeh I just have level stake fixed liability at the moment. I used to use flumine. I have my own trading framework written in C# for production code. And I do backtesting using a custom Rust plugin for polars dataframes

---

## 2024-09-12 16:29:02 - strategies channel

**D C**

But you can also be the one making the cake, and leaving it on the table? As with all these types of question, it really depends on the sport and strategy doesn't it? I often find that there is a bias towards the horses and taking prices due to the number of people on this slack that do well off it. It's a very different game trying to grab a few quid at nice prices across a few seconds of opportunity in a 5 furlong race to getting matched in cricket where there can be tens of thousands up for grabs and 5 days to manage your money over.

---

## 2024-09-12 15:54:58 - general channel

**Ankit Aggarwal**

Hello everyone, I have recently joined the exchange and while researching the sample code and other references I happen to come across Flumine and this community. My sincere appreciation to the creator and contributors of flumine its made life a lot easier compared to the API docs and sample code of the exchange. I am an engineer with coding experience at a software company and trading is my passion/escape. Could anyone help me with the keys for live API access? Any suggestions on how to go about it.

---

## 2024-09-12 14:03:25 - strategies channel

**Justice**

Curious to know how folks are handling bet sizing in running. My instinct was to use fractional kelly but due to the in-play delay, I have no idea what price I'll be matched

---

## 2024-09-12 14:01:46 - general channel

**river_shah**

I have been living under a rock. Thanks for the kind words [@U4H19D1D2](@U4H19D1D2)



sports betting teaches at an accelerated pace. best proving grounds for advanced modelling techniques.



I was speaking with a friend who tests gene editing on zebra fish. You get answers back in a couple of weeks. It would take years on primates



You get feedback from sports markets in days / weeks. In financials you can hold terribly wrong views for years and hold onto crap ideas without something smacking you back in line (the central bank funded asset bubbles don't help either).

---

## 2024-09-11 19:38:40 - issues channel

**foxwood**

Trying to place a lot of bets all together using a transaction. Involves iterating through own runner data stored in market context and calling various functions which also refer to the market context. All that results in a run time error

```    with market.transaction as t: TypeError: 'method' object does not support the context manager protocol```

Is there any easy way of working around this without removing all context usage from the loop (tried removing context for top level of loop and worked ok but fails due to context use in deeper function calls which would be complex to refactor) - presume strategy context would have the same issues ?

---

## 2024-09-05 20:57:44 - general channel

**Jonjonjon**

&gt; If you want an easy life and you're able to make it work betting still a good option

A problem is that most people won't be able to make it work.



The chances of getting very consistent but small returns is probably higher than in many other areas though. I don't think anyone but the top 0.1% is likely get get 7 figures a year from this.



Crypto probably has a higher chance of the big bucks, but it's a lot harder to get started than sports betting.

---

## 2024-09-05 19:45:55 - general channel

**Rob**

Thanks.



My current homemade codebase conflates to 1000ms, but on moving to flumine, I also want to record the data for other uses later, and had assumed that if I use conflate its reflected in the recorded data too?



But I'll certainly start that way - thanks for the tip on paper trading.

---

## 2024-09-05 19:39:20 - general channel

**Rob**

Obviously what I want to avoid!



I can't see any way that flumine is using >1 core, so if that's the case, and my code is too slow, I  guess I can offload the data processing/model scoring to a locally hosted API which can use all the cores, and have the flumine `process_market_book` code call that.



Anyone else do that, or anything similar?

---

## 2024-09-05 19:04:15 - general channel

**Rob**

I'm just about ready to use flumine for live betting for the first time (rather than simulation).



Based on what I've read here, I know I'm doing more heavy computation that others. I'm happy with the speed of simulation but that's using 10 cores, and I'm not clear if flumine can use >1 core when running live? If a `process_market_book` call is still running when the next update arrives, what happens?



I'll try it tomorrow night so I guess I can also find out that way :slightly_smiling_face:

---

## 2024-09-05 18:44:55 - strategies channel

**D C**

Can't you just fit a saturated model and remove things? Think they used to call that backward selection but it might not be trendy anymore.

---

## 2024-09-05 14:34:13 - strategies channel

**Ralegh**

I mainly use linear models so Pearson makes sense

---

## 2024-09-05 08:15:43 - general channel

**Michael**

_"there is very little money to be made in Betfair api trading these day........you would be better off stacking shelves at Tesco"_



Speak for yourself. As a general statement this is nonsense.

---

## 2024-09-04 23:44:14 - general channel

**James Scott**

I’ll tell you straight, there is very little money to be made in Betfair api trading these day. If you look at amount of work you would have to put in, and the amount of money you would make, you would be better off stacking shelves at Tesco.

---

## 2024-09-04 21:11:25 - general channel

**Sam G**

Great question. I'm tired of running operations.. It drains me out. Depending on electricians and housekeepers to clean and fix properties ( else I lose money) , ensuring that inventory clerk comes in time. Running an operational business that depends on lots of other human beings is stressful



You might say: why don't you go do algo trading in financial markets. ... It's just not possible for an individual. You need big money at least £10million . Colocation near exchange etc



Hence sports trading. Hope that makes sense. Combines my love for trading and programming

---

## 2024-09-04 19:33:20 - general channel

**Sam G**

Hi [!here](!here) i have been a relatively quiet watcher on this slack workspace - and want to dive in more and learn about the ins and outs of sports betting coding. I have been a python programmer for over 12 years, and some C++ and Java before that ( was in high frequency trading in finance sector). I have a property tech startup that I am winding down (due to business profitablity slowing down) and I want to go back to my love of quant + programming in sports betting, an area that I have slowly picked up some interest in. I also learnt Rust for last 1.5 years, used it on my own startup (which really didnt need Rust but used it to learn) and want to see if I can use Rust knowledge in bet-code



I also helped start a crypto trading firm (so have some relatively newer experience in programming for excahnge trading - around 2018-2020 - was working part time with them)



I learnt a bit of the betfair api - but not much,and want to dive in.



*questions:*

1. What are the best resources to learn production level (or near production level) sports betting. Are there good videos or paid training material that explains a lot of things in one place? 

2. Is someone looking for a partner to do it with - perhaps someone who knows more about the sports betting side of things, and some programming experience - and I can help them with my knowledge in programming ?

Will be good to help others and learn in the process



Thanks again

---

## 2024-09-04 16:47:07 - random channel

**Michael**

[@U01DCR5PXDY](@U01DCR5PXDY) I have mixed feelings about it. I think people should be free to gamble and most people who gamble do so without it causing a problem, framed that way my conscience is clear. On the other hand; BF has exploited some of its vulnerable customers in ways that I think are wholly wrong and I can't deny that I am part of the mechanism of that exploitation.  Then again - virtually everything I do causes harm at some level, even if it's just the general harm of consumption. Overall I'm more occupied by the guilt of my environmental footprint than by that of my involvement in betting.

---

## 2024-09-04 13:43:10 - random channel

**thambie1**

That begs an interesting question [@UGV299K6H](@UGV299K6H). Do you think what we do, automated betting, causes harm? You seem to imply it at the end there

---

## 2024-09-04 13:38:53 - random channel

**D C**

Oh I agree and I don't absolve the industry of the harm it causes completely. But ultimately we do things we know we shouldn't or that will have a negative impact and ultimately that lies with the individual. Having said all that, if I were to place blame anywhere I would place it with credit card companies. Obviously it is very specific to my case, but the way these companies make it so so easy to just borrow more is disgraceful. Not sure if it still happens now, but every time I would near my credit limit, the companies would increase it by a couple of grand - without notice and not at my request. It is a complex setup because if I were not already heavily gambling to reduce my debt, I would never have made use of that extra credit and so the situation just got worse and worse until I reached the point of saying enough was enough. Strangely, it was taking out a Wonga payday loan that provided the biggest wake up call and I got myself straight after that point (after several years).

The strangest thing for me though is that the only issue I would have was with RNG games - never with sports betting and it really irks me that the UKGC refuse to distinguish between these types of betting. That said, many are able to play them for entertainment and suffer no problems at all so it really is a complicated issue.

---

## 2024-09-03 16:58:50 - random channel

**D C**

OK [@US2RWCWKY](@US2RWCWKY) I think your last point is the one that makes sense to me. Finding situations where you suspect the BSP bet is +EV - despite not knowing what the price is. I think this is where my mental block is. It just feels strange to be betting without knowing what price you will get. But if you've established situations where you know/suspect that regardless of what you end up with, it will be +EV then I see the appeal. Now I can just wrap my brain up in knots trying to think about how you would go about that problem.

---

## 2024-09-03 16:52:25 - random channel

**D C**

[@UNQGKT0CR](@UNQGKT0CR) but if you had a fundamental model, surely you'd be better off just monitoring the market and trying to get matched +EV during the market evolution? Whichever way I look at it I just can't see what type of customers see SP betting as attractive (aside from the previously mentioned  0EV hedge to reduce variance in P&amp;L)

---

## 2024-09-02 15:14:54 - general channel

**tone**

This is the code: strategyMR = MarketRecorder(

            name="Market Recorder TPD",

            market_filter=betfairlightweight.filters.streaming_market_filter(

                market_ids=tpd_market_ids,

            ),

            stream_class=RaceDataStream,

            context={

                "local_dir": utils.configs.marketDataPathToday,

                "force_update": True,

                "remove_file": False,

                "remove_gz_file": False,

                "load_market_catalogue": True,

                "recorder_id": "",

            },

        )

        framework.add_strategy(strategyMR)

---

## 2024-09-02 14:52:28 - general channel

**tone**

OK, I'm back. Bloodied but unbowed! So, after using the correct example, I feel I might finally be getting somewhere.

However I'm now struggling with this error:

    framework.run()

  File "d:\sports_trading\source_code\projects\trading\lib\site-packages\flumine\simulation\simulation.py", line 97, in run

    self._process_market_books(

  File "d:\sports_trading\source_code\projects\trading\lib\site-packages\flumine\simulation\simulation.py", line 124, in _process_market_books

    market = self._add_market(market_id, market_book)

  File "d:\sports_trading\source_code\projects\trading\lib\site-packages\flumine\baseflumine.py", line 216, in _add_market

    middleware.add_market(market)

  File "d:\sports_trading\source_code\projects\trading\lib\site-packages\flumine\markets\middleware.py", line 338, in add_market

    self._next = next(self._gen)

  File "d:\sports_trading\source_code\projects\trading\lib\site-packages\flumine\streams\historicalstream.py", line 239, in _read_loop

    if listener_on_data(update):

  File "d:\sports_trading\source_code\projects\trading\lib\site-packages\flumine\streams\historicalstream.py", line 225, in on_data

    return self.stream._process(data[self.stream._lookup], publish_time)

KeyError: 'rc'



The raw_data parameter in HistoricListener.on_data(..) is set to: '{"op":"mcm","clk":"-8312644392346355926","pt":1725022823949,"mc":[{"id":"[tel:335344121330|33534412.1330](tel:335344121330|33534412.1330)","mid":"1.232378340","rpc":{"ft":1725022823900,"g":"","st":0,"rt":0,"spd":0,"prg":1609.3,"ord":[],"J":[]}}]}\n'

This seems, to me at least, like plausible TPD data except of course that there is no "rc" key!

Do I need to do some sort of transformation of key values?

---

## 2024-09-02 11:34:02 - general channel

**tone**

Here's the DEBUG level logs: {"asctime": "2024-09-02 10:31:36,488", "levelname": "DEBUG", "message": "Starting new HTTPS connection (1): [http://identitysso-cert.betfair.com:443%22}|identitysso-cert.betfair.com:443"}](http://identitysso-cert.betfair.com:443%22}|identitysso-cert.betfair.com:443"})

{"asctime": "2024-09-02 10:31:36,707", "levelname": "DEBUG", "message": "[https://identitysso-cert.betfair.com:443](https://identitysso-cert.betfair.com:443) \"POST /api/certlogin HTTP/11\" 200 87"}

{"asctime": "2024-09-02 10:31:36,710", "levelname": "INFO", "message": "Client added", "username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": null, "transaction_count_total": null, "trading_controls": [], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2024-09-02 10:31:36,710", "levelname": "INFO", "message": "Adding market middleware &lt;flumine.markets.middleware.SimulatedMiddleware object at 0x00000191605B7460&gt;"}

{"asctime": "2024-09-02 10:31:36,711", "levelname": "INFO", "message": "Adding client control MAX_TRANSACTION_COUNT"}

{"asctime": "2024-09-02 10:31:36,711", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2024-09-02 10:31:36,711", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2024-09-02 10:31:36,711", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2024-09-02 10:31:36,712", "levelname": "INFO", "message": "Adding strategy ExampleStrategy"}

{"asctime": "2024-09-02 10:31:36,712", "levelname": "DEBUG", "message": "{'uri': 'D:/test/1.232378340', 'mode': 'r', 'buffering': -1, 'encoding': None, 'errors': None, 'newline': None, 'closefd':

True, 'opener': None, 'compression': 'infer_from_extension', 'transport_params': None}"}

{"asctime": "2024-09-02 10:31:36,717", "levelname": "INFO", "message": "Creating new HistoricalStream (1000) for strategy ExampleStrategy", "strategy": "ExampleStrategy", "stream_id": 1000, "market_filter": "D:/test/1.232378340", "event_id": "33534412", "event_processing": false}

{"asctime": "2024-09-02 10:31:36,717", "levelname": "INFO", "message": "Starting flumine", "clients": {"Betfair": {}, "Simulated": {"15986142": {"username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 0, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 1200)&gt;"]}

{"asctime": "2024-09-02 10:31:36,718", "levelname": "INFO", "message": "Client login", "username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2024-09-02 10:31:36,719", "levelname": "INFO", "message": "Client update account details", "username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2024-09-02 10:31:36,719", "levelname": "INFO", "message": "Starting historical market 'D:/test/1.232378340'", "market": "D:/test/1.232378340"}

{"asctime": "2024-09-02 10:31:36,719", "levelname": "INFO", "message": "[Register: 1000]: marketSubscription"}

{"asctime": "2024-09-02 10:31:36,720", "levelname": "INFO", "message": "[MarketStream: 1000]: \"MarketStream\" created"}

{"asctime": "2024-09-02 10:31:36,720", "levelname": "DEBUG", "message": "{'uri': 'D:/test/1.232378340', 'mode': 'r', 'buffering': -1, 'encoding': None, 'errors': None, 'newline': None, 'closefd':

True, 'opener': None, 'compression': 'infer_from_extension', 'transport_params': None}"}

{"asctime": "2024-09-02 10:31:36,730", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.232378340 added, 1 markets in cache"}

{"asctime": "2024-09-02 10:31:36,732", "levelname": "INFO", "message": "Adding: 1.232378340 to markets"}

{"asctime": "2024-09-02 10:31:39,061", "levelname": "INFO", "message": "Market 1.232378340 closed", "market_id": "1.232378340", "event_id": "33534412", "event_type_id": "7", "event_name": null, "market_type": "WIN", "market_start_datetime": "2024-08-30 13:30:00", "country_code": "GB", "venue": "Ffos Las", "race_type": "Flat", "orders_cleared": [], "market_cleared": [], "closed": true}

{"asctime": "2024-09-02 10:31:39,062", "levelname": "INFO", "message": "Market cleared", "market_id": "1.232378340", "order_count": 0, "clients": {"Betfair": {}, "Simulated": {"15986142": {"username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 1200)&gt;"]}

{"asctime": "2024-09-02 10:31:39,063", "levelname": "INFO", "message": "Market level cleared", "market_id": "1.232378340", "profit": 0, "bet_count": 0}

{"asctime": "2024-09-02 10:31:39,063", "levelname": "INFO", "message": "Market closed", "market_id": "1.232378340", "clients": {"Betfair": {}, "Simulated": {"15986142": {"username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 1200)&gt;"]}

{"asctime": "2024-09-02 10:31:39,064", "levelname": "INFO", "message": "Removing market 1.232378340", "clients": {"Betfair": {}, "Simulated": {"15986142": {"username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 1200)&gt;"]}

{"asctime": "2024-09-02 10:31:39,065", "levelname": "INFO", "message": "Completed historical market 'D:/test/1.232378340'"}

{"asctime": "2024-09-02 10:31:39,065", "levelname": "INFO", "message": "Shutting down Execution (SimulatedExecution)"}

{"asctime": "2024-09-02 10:31:39,065", "levelname": "INFO", "message": "Shutting down Execution (BetfairExecution)"}

{"asctime": "2024-09-02 10:31:39,066", "levelname": "INFO", "message": "Client logout", "username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total":

0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2024-09-02 10:31:39,066", "levelname": "INFO", "message": "Exiting flumine", "clients": {"Betfair": {}, "Simulated": {"15986142": {"username": "15986142", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x00000191605B7490&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 1200)&gt;"]}

{"asctime": "2024-09-02 10:31:39,067", "levelname": "INFO", "message": "Simulation complete"}

---

## 2024-09-02 11:14:32 - random channel

**D C**

So this would require some decent modelling/estimation of what SP will actually be at calculation?

---

## 2024-09-02 10:54:38 - general channel

**tone**

I have managed to save the TPD stream to a file but now I wish to replay it in simulation mode. I have set sports_data_filter=["raceSubscription"] but cannot determine how to get the strategy to associate the saved betfair market with the saved TPD stream - or does this somehow happen automatically?

---

## 2024-08-30 19:21:51 - issues channel

**Rob**

Probably something dumb that I've done, but moved working flumine strategy simulation code from my linux laptop to a windows desktop and I'm now getting the following error:



```  File "C:\Users\xxx\anaconda3\envs\bfai\lib\site-packages\flumine\simulation\simulation.py", line 34, in run

    with self:

  File "C:\Users\xxx\anaconda3\envs\bfai\lib\site-packages\flumine\baseflumine.py", line 450, in __enter__

    self.strategies.start(self)

  File "C:\Users\xxx\anaconda3\envs\bfai\lib\site-packages\flumine\strategy\strategy.py", line 279, in start

    s.start(flumine)

TypeError: EarlyBackLay.start() takes 1 positional argument but 2 were given```

where `EarlyBackLay` is strategy I've created. The exact same code (e.g. reverted back to the github branch on both) is still working fine on linux, all I've done is update the path for the stored market data  to be the location  on the windows machine.



Anyone got any ideas?

---

## 2024-08-29 19:03:36 - random channel

**Jonjonjon**

It's the first reason that you suggested

 I'm segmenting up front for both long and short term models. I'll try what you suggest and see what happens...

---

## 2024-08-29 14:07:23 - strategies channel

**liam**

Agreed, however pending is a state in flumine so wanted to remove any confusion.



This is the quickest / most efficient way, using a [https://github.com/betcode-org/flumine/blob/d03def30a778e9460e336b53b0689edb953f7c55/flumine/execution/transaction.py#L12|transaction](https://github.com/betcode-org/flumine/blob/d03def30a778e9460e336b53b0689edb953f7c55/flumine/execution/transaction.py#L12|transaction) means it will be sent in a single http request



```orders = market.blotter.strategy_orders(

    self, order_status=OrderStatus.EXECUTABLE

)

with market.transaction() as t:

    for order in orders:

        t.cancel_order(order)```



---

## 2024-08-29 13:02:50 - strategies channel

**Aryan Kapoor**

is there a quick way to cancel all pending orders in flumine? im currently looping through all strategy orders and then using market.cancel_order but was wondering if there was a simpler way

---

## 2024-08-29 07:33:13 - general channel

**Ralegh**

Forex is a no go, crypto is a maybe if you have actual trading/quant experience, but there’s always a chance you build out a model and get kicked off because of regulation changes. You have to think what specific edge you might have, tower dominate cross exchange arbs and general HFT crypto, there’s probably money to be made on hours to days horizon but would need experience doing that or something similar. If you somehow have access to an exchange that firms can’t get access too (for whatever reason) then that could be an edge. Otherwise it’s tough.

---

## 2024-08-28 22:44:08 - random channel

**Rob**

a few guesses...



• if you're building lots of models because you're segmenting upfront (e.g. a separate model for close to the off vs the day before) I'd try skipping this and building a model across all segments (e.g. include time before the off as a feature), as ML models can do a good job of replicating this segmentation

• if you're building lots of models because you're trying lots of hyperparameters, there are bayesian methods that should find the optimal set faster

---

## 2024-08-28 22:25:53 - random channel

**Rob**

The 9950 benchmarks somewhere towards double the 3950x, so I'd expect you're right about the speed up you'd get. After that you're pretty much in threadripper territory, if you don't want to cloud.



Obviously don't know what you're doing, but I tend to just do as much as I can in a reasonable amount of time. Most ML stuff has diminishing returns (e.g. you can build a model that's 98% as good in 1/100th of the time), but sometimes you need the extra performance.

---

## 2024-08-28 20:53:34 - random channel

**birchy**

We're in very different leagues. I still run simulation and model training on a $20 Lightsail instance. And only yesterday, I coded up a burst capacity monitor using boto3 to put my process to sleep when I've hammered the server and need to wait for some more credits to build up. :grinning:

---

## 2024-08-28 14:16:53 - general channel

**D C**

Speaking from personal experience, slots really ARE addictive. I've never had a problem with sports betting. But high street bookies only really make money from FOBTs now - 4 per store limit so they open up multiple branches in the same town. Absolute filth and I agree they should be put in the bin.

---

## 2024-08-28 14:12:25 - general channel

**D C**

Biggest problem is that they refuse to distinguish between RNG shit like online slots and sports betting.

---

## 2024-08-28 13:59:26 - strategies channel

**liam**

and store strategy stuff in



```strategy.context["yada"] = 123```

---

## 2024-08-28 13:58:22 - strategies channel

**Aryan Kapoor**

also with your point about it being set at a strategy level

---

## 2024-08-28 13:53:30 - strategies channel

**liam**

this is set at the strategy level but I imagine it should be per market?

---

## 2024-08-28 13:36:34 - strategies channel

**liam**

In your strategy you are writing the headers for the 'theos.csv' file in `start`  so this is being wiped every time a new process starts, is this expected or the bug?

---

## 2024-08-28 12:22:26 - general channel

**ShaunW**

I think that in-running seasonality [@U03FS7KM2NL](@U03FS7KM2NL) is due to the longer distances.   



For what it's worth Imo the reasons for the decline are manyfold, innovators (like TPD) have been more interested in wooing us than generating new customers, lack of interest in the affected sports, greater competition for the leisure £, a decade+ of wage/inflation disparity, lack of imagination in the way betting is presented, probably others too.



The question is, will the decline bottom out before it becomes unsustainable.

---

## 2024-08-25 09:43:42 - random channel

**Ralegh**

My workflow is store everything in S3, then just write a few python/bash scripts to install all requirements and download the data i need, if the output is fitted model then you can just upload back to S3, boto3 is fine for that

---

## 2024-08-24 15:16:34 - random channel

**thambie1**

Fitting your models once for production doesn't sound that expensive. Doing it over and over again while iterating on your models may be. Find a way to iterate on your models without training all of them fully. Can you train and analyze just 10% of your models?

---

## 2024-08-24 14:54:24 - random channel

**Jonjonjon**

What's the recommended way to work out the best optimisation route for calibrating tabular models such as xgboost, catboost, random forest etc ..?



My models are taking around 100seconds to fit on my cpu. I fit hundreds of models.



I use a 16 core Ryzen 3950x cpu



I have found that it's best to do this using 16 processes, allowing each model fit to use 2 CPUs.

To improve performance, I guess I have the options to

• upgrade CPU to 9950x

• get a GPU

• try a cloud machine

I'm not keen on just buying a machine with a 9950x to see how much better it will be due to the cost, and my suspicions that it might only give me 50-100% improvement.

From reading on GPUs I might only get 2-5x improvement, but those articles were with different cpus and older GPUs.

I'm not an expert on the cloud, and am worried about potential costs and complexity.

What is a good workflow to identify to best way forward for me?

---

## 2024-08-20 15:51:30 - strategies channel

**Johnny Boston**

``` "status": "FAILURE", "errorCode": "BET_ACTION_ERROR", "marketId": "1.231956835", "instructionReports": [{"status": "FAILURE", "errorCode": "INVALID_MIN_FILL_SIZE", "instruction": {"selectionId": 71661945, "handicap": 0.0, "limitOrder": {"size": 0.55, "price": 8.4, "minFillSize": 1.35, "timeInForce": "FILL_OR_KILL"}, "customerOrderRef": "43da61bd07abd-139434572457729620", "orderType": "LIMIT", "side": "LAY"}}]}, "order_package": {"id": "37bb203a-0748-4c5d-9931-442a5c2880fd", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f64af923b90&gt;", "market_id": "1.231956835", "orders": ["139434572457729620"], "order_count": 1, "package_type": "Place", "customer_strategy_ref": "[http://ip-10-2-8-71.eu|ip-10-2-8-71.eu](http://ip-10-2-8-71.eu|ip-10-2-8-71.eu)", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": true}}```

---

## 2024-08-20 08:56:11 - strategies channel

**liam**

the start function is when the strategy starts at runtime, `process_new_market` is when a market gets added to the stream, is that what you want?

---

## 2024-08-20 08:19:29 - strategies channel

**liam**

Sorry I don't understand, you can see all the strategy functions [https://github.com/betcode-org/flumine/blob/0241aca36f751bf1e35c5f8d7242735d2f1a5687/flumine/strategy/strategy.py#L91|here](https://github.com/betcode-org/flumine/blob/0241aca36f751bf1e35c5f8d7242735d2f1a5687/flumine/strategy/strategy.py#L91|here)

---

## 2024-08-20 07:57:30 - issues channel

**Jorge**

Okay thanks. There is a [https://github.com/betcode-org/betfair/blob/master/examples/exampleinplayservice.py#L18|trading.login()](https://github.com/betcode-org/betfair/blob/master/examples/exampleinplayservice.py#L18|trading.login()) in the example so that's why I was not sure

---

## 2024-08-19 11:11:31 - strategies channel

**birchy**

I was thinking more at strategy level in Flumine, but that's definitely an option. :+1:

---

## 2024-08-17 13:15:25 - strategies channel

**Jonjonjon**

Any insights?



Today I'm doing 10-200 bets per horse race. I'm wondering that if I'm iceberging lots of small orders,  am I giving away info?



However, my model does not work if I start trading larger quantities.

---

## 2024-08-12 09:37:25 - general channel

**Sen**

Mostly because the 5 day lag doesn't have a meaningful effect on 95% of features for my fundamental model. Then I just get the data from betfair 5 days later for modelling purposes. But given my fears about my data quality... I'm now very much thinking about recording and storing

---

## 2024-08-11 23:49:15 - general channel

**Paul**

Things that spring to mind others didn’t mention 



1. If you’re making rather than taking, and your prices are more than 1-2 pips away from each other (back/lay spread on US racing can be very broad), someone new could be doing the same strategy “inside” your prices. Can you go back and check what volume was matched at a price other than your own?

2. Your hosting setup has changed. Data centres get new links, retire old ones, your VPS could now have a noisy neighbour sucking bandwidth, and so on, and so on. Doesn’t take much to add 10ms latency onto a box. Even worse if you’re running from home (residential broadband especially over OpenReach makes no guarantees about anything, ever)

3. You were betting against another bot, you’ve taken their money, they’re gone.

4. Variance. Law of large numbers says you’ll have bad runs now and again and sounds like this has been running for a long time. I know you asked how to check it’s not chance alone, but one easy check is to wait another few days where the odds become smaller and smaller

---

## 2024-08-11 17:02:36 - general channel

**Sen**

Interesting- so I'm only running pre-off strategies. But I'm also interestingly finding that modelled vs. Actual is varying quite a bit. So trying to solve this- and this very much might be one of the reasons

---

## 2024-08-11 16:01:55 - general channel

**Joe**

Sorry I don't know the details other than it is generated from the stream so materialised, rolled up and sampled as you suggest [@U4H19D1D2](@U4H19D1D2) , probably of no use to anyone that is price action based, probably usable if you want to test your fundamental pre-off models against the market.

---

## 2024-08-11 12:30:25 - general channel

**liam**

[@U05L8PZD2FM](@U05L8PZD2FM) might be able to explain how the data is actually created but with BASIC/ADV you are getting data that has been grouped ('rolled up') and then streaming has been replicated, thus it is completely different to what you see when betting live or simulating with real data. Obviously it depends on the frequency you are betting as to whether this has an impact or not but if you are concerned about betting movements over a 1s interval you need real data.

---

## 2024-08-11 12:09:52 - general channel

**D C**

Yeah did that [@UBS7QANF3](@UBS7QANF3) . I added a new strategy that does not overlap with the "problem" strategy 3 days prior to the match rate drop. Turns out that the NEW one was doing nicely over those 3 days and then ALSO suffers from the match rate drop. Now looks like a competitor is the most likely cause.

---

## 2024-08-10 18:23:37 - general channel

**Dave**

Backtests are good - if your backtest for May + June look similar and look good, while your real performance for May matches backtest but June doesn't then likely you've broken something (i.e. you got a bug). If your backtest for June shows similar degradation then it suggests your alpha has degraded (either because some participants have scaled down, someone competitive has entereed etc). It might be a matter of recalibrating some params, or it might be a matter of resting the strategy and backtesting again in a few weeks to see if the breakage was transient or not.

---

## 2024-08-10 15:45:53 - general channel

**D C**

I'm not sure that it is possible to determine really. I mean how do you assign a probability to someone else developing a similar strategy. The US spread is wide - this is a 100% offer price strat so someone could easily be offering better than I am. In all honesty [@UGV299K6H](@UGV299K6H) I would not know where to start in regards to putting a number on it.

---

## 2024-08-10 15:29:42 - general channel

**ShaunW**

Not.    But that explains why it's been boom time for my mixed doubles ping pong strategy. :grin:  Wimbledon and big footy can divert some money but Olympic markets aren't big enough to cause a ripple. 



There's usually a silver lining, an enforced revisit isn't necessarily bad thing.

---

## 2024-08-10 13:49:32 - general channel

**K H**

If you don't already, I'd recommend tracking as much as possible around the matching process - total volume matched, volume matched on your selections, liquidity per second around the time you place your bets, the amount of money waiting at the prices you bet on etc.



If you haven't run the strategy for more than a year, one of the causes may be seasonality - although imo the exact immediate cause can only be known by tracking enough data to tell you what's happening around your matching process

---

## 2024-08-09 23:23:15 - general channel

**D C**

In general, if you have been running a strategy for some time that experiences fairly steady match rates, then suddenly notice a quite severe drop off in that match rate (despite no changes to the strategy) what are the most likely causes, and what can you do to try to confirm the reason?

I can pretty much only think of 3 reasons:

1. Drop off in volumes in general

2. Running a new strategy in parallel that interferes with the existing strategy

3. Someone else competing for prices

I've been running this strategy that is profitable (nothing special but worth doing) that is offering prices (both sides) inplay on US markets for minimum stakes and I've basically seen match rates halved from start of June (as compared with January to May). Profit is down and placing a lot more bets overall as a consequence of so many now being unmatched.

Any advice on where to start looking for a reason? Or best to just forget it?

---

## 2024-08-08 10:35:14 - strategies channel

**Mo**

I have two different setups, both relatively old school. For the first there is an EC2 instance running 24/7 that processes new data on an hourly basis using a cron job. That “new data” is a combination of data scraped from APIs into an RDS Postgres database and log files uploaded to S3 from trading servers



For the second it’s a one off daily pipeline, also running on an EC2 box as a cron job. AWS EventBridge used to bring the box up and down so it’s only running for the duration of the pipeline. Database this time is Aurora Serverless for, in principle, cheaper database costs. In practice, regularly get fucked in the arse by IOPS

---

## 2024-08-07 18:08:13 - general channel

**liam**

model

---

## 2024-08-07 18:02:07 - general channel

**Gooat**

Nice. Model or mix of price and flow? I struggled to avoid averse selection when testing it.

---

## 2024-08-07 07:10:03 - random channel

**Tom**

IMO Taleb rationalised his luck in the '87 crash, not just with the money he received being the result of some high minded trading strategy, but into a feature of intellectual superiority.

---

## 2024-08-06 22:20:49 - strategies channel

**Michael**

[@UPMUFSGCR](@UPMUFSGCR) I post prices all over the place depending on the strategy, I'm not certain what you mean by "spamming" but personally I don't back longer than BATL or lay shorter the BATB because I always want to be front of the queue, but I know other people do and they make it work. Broadly I just take a stab at fair value and add X margin to it, but that might not be relevant to what you're doing.

---

## 2024-08-06 22:14:36 - strategies channel

**Jonjonjon**

[@U01DPK9PGMC](@U01DPK9PGMC)  what sort of strategy do you use for offering more/less generous prices, when a tick has different value depending on the price level?



My market maker just quotes at the best available price. Would you recommend spamming quotes up to 'n' levels of depth?

---

## 2024-08-06 22:06:08 - strategies channel

**Michael**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) I'd also encourage you to do simple AvB tests with your existing strategy to optimise your stakes and prices. When you're trying to get the most out of something it's tempting to see how high you can push the stakes but that's often counter-productive, maybe experiment with reducing them and see what happens over 1000 markets. Try offering more generous and less generous prices. The nice thing about that sort of thing is that it takes minimal work, just a couple of minutes then forget about it for a month or two. So much easier than sweating over a jupyter notebook.

---

## 2024-08-06 21:58:03 - strategies channel

**birchy**

While we're mentioning S3... I'm at a point where I've got millions of markets saved via flumine market recorder and am wondering how others are filtering the files? e.g. say I want all GB horse races that turn inplay, what's the nicest way to find them? I've currently got a somewhat convoluted boto3 setup that paginates the market catalogues and then returns a list of market IDs that match my filters. I then download the files to local storage. I've played around with creating a local index file but it gets very big very quickly. I'm also pondering streaming direct from S3 -&gt; flumine rather than downloading them all as, similarly to [@U4H19D1D2](@U4H19D1D2), I'm processing through flumine to format data for model training.

---

## 2024-08-06 20:16:02 - strategies channel

**thambie1**

I have one medium size machine, where I do all production work. Strategy development lives elsewhere. If haven't/don't want to host your flumine instances with other production jobs on the same machine.. I can see why you'd go serverless

---

## 2024-08-06 19:47:47 - strategies channel

**liam**

I need to build a process that processes historical data and creates predictions on a daily basis (every am) Does anyone have a decent design / system for this? I am currently thinking:



-&gt; machine or lambda to process the historical data to then store in a db 



-&gt; another to create the predictions using the db



-&gt; store predictions in s3 



-&gt; flumine strategy that handles the execution

---

## 2024-08-06 13:37:58 - general channel

**Jonjonjon**

That type of strategy paid for the deposit on my flat many years ago. Please don't criticise it.

---

## 2024-08-06 13:27:04 - strategies channel

**birchy**

Yeah, anything you can derive from the market data we receive. There's a million ways to calculate signals from combinations of available & matched prices and volumes. I'd also add that I spent far too long trying to find strategies using just simulation and there's no substitute for live betting, which, ironically, was my mindset several years ago before I discovered flumine. For example, most of my strategies are taking prices and the only way to prove that is by running live.

---

## 2024-08-06 13:15:57 - strategies channel

**birchy**

With horse racing the pre play liquidity has dropped off a lot but there's a significant amount matched inplay, sometimes more than was matched at the off time. I've been hacking around with modelling recently and have had some success with a basic LR model that has about 30 features that are all market data based, but there are 3 or 4 features/signals that are particularly stronger than the others. Engineering features is a trivial exercise but finding good ones is much harder. I took the approach of using lots of features and then dropping the shit ones until I had something production ready. I'm not really a fan of the 'black box' approach but it seems to understand the market nuances better than I do. The bottom line is that it's bringing in some £'s, so I'm slowly convincing myself that it's a much easier route to take.

---

## 2024-08-06 13:10:26 - general channel

**איתמר קינן**

Hey guys

I'm currently working on a model for getting some football odds (over under/corners/money line)

I tried some scraping jobs on bet365 but it seems too hard/impossible

I'm looking for a sharp local bookies with fastly updated odds that is possible to scrape/has a good api

I don't mind paying some $ if necessary

---

## 2024-08-06 09:52:51 - strategies channel

**AndyL**

[@UGV299K6H](@UGV299K6H) sorry I meant a simple linear feature model, so my example previous was a simple linear model using the 3 core features: volume, queued and matched 

---

## 2024-08-06 07:52:30 - strategies channel

**Michael**

_"trying to find a single linear feature model"_



Yeah - that aint gonna work.

---

## 2024-08-06 07:51:14 - strategies channel

**AndyL**

Thanks chaps, it’s a tricky one horses are definitely competitive and liquidity reducing but I feel I’ve invested a lot of effort already which I feel would be wasted moving to football. As to prerace vs inplay thats a tricky one too, im currently feeling an attraction to the high volatility of inplay at the moment.

My modeling I think is a bit too simple and trying to find a single linear feature model doesn’t possibly fit the opportunities I am trying to find…maybe!

Anyway I think ive been talking too much and not getting down to it….

Cheers all

---

## 2024-08-06 00:39:17 - strategies channel

**K H**

(Mostly directed at the comment on where to direct your modelling efforts)



I don't know if thinking about it as being 'up against' anybody is the right framing. Theoretically, anytime you're in the market you're up against something far more intelligent than a single individual - studies tend to find the 'wisdom of the crowds' far wiser. And any market of decent liquidity on betfair is a decent sized crowd.



But you don't need to be wiser than the crowd (whether it's a crowd of PHDs or a crowd of children). You just need to find points where the crowd are biased (and the crowd is human, so it will be biased), or where it wavers (volatility), or indicators that the crowd is about to start moving in a certain direction.

Which is not to say it's easy - but there are about a thousand different angles you can attack the market from. And the crowd's actions aren't instantaneous, so with enough data there's a high likelihood an angle (many angles) can be found regardless of the crowd.



In general (others probably have more in depth advice), focusing your efforts where there is a lot of liquidity probably makes sense - if you had to look for a single criteria and could only pick along one dimension.

---

## 2024-08-05 23:09:47 - strategies channel

**AndyL**

Im sort of delving with this question between prerace and inplay, as to where my modelling efforts are best placed. Inplay horses im up against all you lot and just a few punters, whereas prerace theres far more punter money flow, but then there is the Syndicate big money controlling things… !??

---

## 2024-08-04 23:16:58 - general channel

**AndyL**

So say I have the matched volume for a selection, also the available queued, maybe infer recent match rate, and I put together a model price for a selection as:

3.0/(vol/totvol + queued/totqueued + matchrate/totmatchrate)

What’s wrong with that as a model? No ML in sight! Just plain raw values….

???

---

## 2024-08-04 17:57:44 - strategies channel

**Rob**

>  Takes my machine around 3 seconds to process a single market

Same here, until I add my processing.



When using `flumine`, how do I know when my processing is too slow, e.g. if `process_market_book` is still running when the next update arrives? I tried randomly waiting for 2s in my simulation, but I don't see anything in the logs.



I'm currently approximating how much "time" I have per market based on the # markets in my strategy and the amount of time they're active for e.g. there are 6 race meetings per day, with 7 races, that I'm active in for an average of 6 hours before the off, then if each market takes 2 minutes to simulate, there should be plenty of time

---

## 2024-08-04 15:37:14 - general channel

**Jonjonjon**

A problem I've seen with ML models and sports betting is that a lot of highly qualified people with PhDs from top institutions can't even work out what makes a good strategy or not.

---

## 2024-08-04 15:34:35 - general channel

**Jonjonjon**

The thing with the models above is that they often won't make much difference. Or if the model makes a difference and you have a good understanding of your features, you can transform them so that even linear regression works.

---

## 2024-08-04 15:32:59 - general channel

**Jonjonjon**

To be more accurate I use a non-machine learning based model. More similar to black scholes than regression stuff.

---

## 2024-08-04 15:19:34 - general channel

**Jonjonjon**

I prefer no model.

---

## 2024-08-04 10:19:34 - general channel

**AndyL**

Do people’s models use input parameters based on the live event or historical as well? Eg. how fast the horse ran in the last 5 races??

---

## 2024-08-04 10:17:32 - general channel

**John Foley**

a gradient boosting model requires very few (if any) assumptions about distributions etc. handles outliers and strange distributions well. handles complicated interactions between features and handles missing data. feature selection is somewhat "built-in." performance is comparable to deep learning algos for simple tabular data

---

## 2024-08-04 10:13:06 - general channel

**Mo**

This is obviously very much a philosophical argument but conceptually by using such a probabilistic model you are bypassing a large amount of learning that a generic machine learning model has to do to understand the dynamics of the sport



Also means your model is not a black box and you can directly relate the model parameters to observable factors

---

## 2024-08-04 10:10:48 - general channel

**Justice**

[@U02GGCCLTKM](@U02GGCCLTKM) I have used Xgboost before, I know it is very popular. What do you like about it? I always struggle with overfitting when using gradient boosting models

---

## 2024-08-04 10:09:43 - general channel

**Justice**

[@UBS7QANF3](@UBS7QANF3) Very interesting. Is there a particular reason why you use such models? Do the idiosyncrasies of specific sports make them well suited?

---

## 2024-08-04 09:34:02 - general channel

**John Foley**

interested to hear what people have done to tackle latency with model inference (ML or otherwise). struggle with this myself, usually end up just making fewer .predict calls than i would like to

---

## 2024-08-04 07:48:31 - general channel

**Mo**

None of these. I use sport specific probabilistic models such as Markov chains for tennis or running time distributions for horse racing

---

## 2024-08-04 07:08:15 - issues channel

**Unknown**

Hi guys; I've noticed lately that my marketbooks are not being updated - I'm not sure what the problem is exactly, but in the log file the price is 11.5 where the actual price is 15.5.  It's the whole book, and it happened the other day as well. On a reboot of the program it's done the same thing again. Log files are showing old prices, with the book just not being updated.  What do I need to check to analyse the problem / what should I be on the lookout for?



I am running a beta version of my script to add untested strategy on the same ec2 instance, so there are multiple scripts pulling the data with the same address or whatever. I don't think there are any memory problems because it's happened again after I've checked that.



The prices on the other script running look fine - different strategy names if it helps.

---

## 2024-08-03 23:38:23 - general channel

**John Foley**

generally go straight to xgboost for any modelling on tabular data

---

## 2024-08-03 22:25:32 - general channel

**D C**

I personally use certain methods of good old fashioned classical inference.

As for why:

1. I don't like using any methods that I DON'T understand from a theoretical standpoint. This rules out most ML at this point in time (even though things like logistic regression seem to be labelled as ML nowadays, to me it's just a GLM).

2. I like to use models where parameters are evaluated and known as part of the model fitting process (I don't like black boxes). This allows some kind of common sense validation and quantification of parameter effects.

3. I use C++ so I need to be able to evaluate models in that context - not by plugging data into some black box evaluation package in python or R. This reason is wrapped up with 2 to a certain extent.

It might make me a bit of a dinosaur, but I'm a firm believer that statistics can be (and is) abused and is most useful when you understand what it's doing. Never been a fan of throwing a shitload of data into a black box and using the output despite having no idea what is going on under the surface.

---

## 2024-08-03 21:58:19 - general channel

**Michael**

So I'm going to admit that I don't do "proper" regression. I just plot my features, look at the plots, rub my face, think about it, make up something plausible and try it.



Every once in a while I get all anxious that I should have done it properly, so I make a big effort and do xgboost or whatever, then I test that against my "eyeball" criteria and either the eyeball wins or the difference is trivial.



My general experience is that there are huge gains to be found when I find a new feature but overly stressing on the model doesn't yield much.

---

## 2024-08-03 20:14:45 - general channel

**Justice**

I'm curious as to what types of models people on here are using and why.



• Linear  (e.g logistic regression)

• Bagging (e.g random forest)

• Boosting (lightgbm, xgboost etc.)

• Deep learning (pytorch, tensorflow etc.)

• No model (!)

---

## 2024-08-03 18:56:29 - strategies channel

**AndyL**

First misstake of "inplay", simulate a strategy based on zero-delay, looks fantastic, try backtesting it and it's crap as after 1-second delay it instantly matches at a crap price, doh!

---

## 2024-08-01 20:50:01 - general channel

**Jonjonjon**

But if their model suggested they'd get value from certain 1,000 lays, then why not?

---

## 2024-08-01 20:48:27 - random channel

**AndyL**

blimey sweating over a new strategy takes on a new meaning when my Mac is running a long analysis and it's 30deg outside !!

---

## 2024-08-01 11:07:56 - issues channel

**liam**

`reset_elapsed_seconds` seconds since trade was reset, ie order has become execution_complete



`placed_elapsed_seconds` seconds since an order was placed (per strat)



These are all strategy level settings per init

---

## 2024-08-01 09:49:14 - issues channel

**Jorge**

Hi, I'm getting these errors in a Flumine Simulation: Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failed: reset_elapsed_seconds (-0.99) &lt; reset_seconds (0.0).

What does [https://github.com/betcode-org/flumine/blob/master/flumine/strategy/runnercontext.py#L60|reset_elapsed_seconds](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/runnercontext.py#L60|reset_elapsed_seconds) mean?

---

## 2024-07-31 22:04:26 - general channel

**Jonjonjon**

The thing with Betfair is that if you are lucky enough to have a winning strategy then return on investment is very high.



I'd like to move to financial trading, but don't have a baseline model to work from and don't even know how/where to get clean/reliable data.



The top dogs here are probably making 100x annualised returns (non compounded) without drawdown. I don't think that's possible in traditional finance, though perhaps it is in crypto but I'm not involved in that so can't say.



As a result, I think many people are stuck with betfair

---

## 2024-07-31 22:02:36 - general channel

**Gooat**

Have you considered modeling some tennis?

---

## 2024-07-31 20:59:06 - general channel

**Paul**

As someone who is far away from this point, I’ll just remind you to see the benefits. There’s a reason it’s seen as those outside as a bit of an aspirational club. Regardless of any offsetting/minimisation strategy, I’d encourage you to see those chunk of cash going out as motivating. They are a way of keeping track of your success.

---

## 2024-07-31 15:27:02 - general channel

**D C**

Today:                                             _"My modelling is crap (not my area)"_



Few days ago in another thead:   _"I have no bias in my prices - the market does though"_

---

## 2024-07-31 15:04:16 - general channel

**Misha**

On that one I'm very confident. It's nearly 15 years in production, constantly upgraded, and has been used by one of the biggest bettors in Australia, and one of the biggest in the world. Turnover through my software has been over $1B. It's what I do for a living (professional software developer), and last 15 years full-time in sports betting. I can compare what I have to all the other systems used by my clients over that time. So I'm pretty sure on that. My modelling is crap (not my area). Software development is what i do on the other hand

---

## 2024-07-30 12:36:34 - general channel

**liam**

I would call it TPD refinement as things have become more competitive. A few years ago it was such an edge that you could be very lazy but now parts of my strategies / models are falling into negative EV particularly in areas where the margins were already thin. 



A lot of my recent work has been to try and quantify where the value actually is so I can better price the market.

---

## 2024-07-30 09:32:30 - general channel

**Jonjonjon**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) so if your model is perfect, should your EV vs BSP plot be a straight line?

---

## 2024-07-30 09:30:55 - general channel

**AndyL**

[@UPMUFSGCR](@UPMUFSGCR) ev vs bsp gives you an idea if your pre race strategy is beating BSP overall, a cum plot is a good way if visualizing it

Basically you need to stash the reconciled BSP after inplay, I actually just do it in the closed_market callback, then in your analysis/pandas simply merge it with your matched bet data in order to plot…

---

## 2024-07-30 08:20:20 - general channel

**Michael**

I actually don't agree that you need SO much data. The number of markets you need depends on how much edge you have, what prices you're betting at and what you're trying to get from the data.



If you have more edge you need fewer markets to prove it, if you're betting at middleish prices you need fewer markets before your results converge and if you're content to know roughly whether a strategy is profitable rather than exactly quantifying your edge then that needs fewer markets.



There's also a question of recency, when you're stacking up a year or more of data you can risk market conditions changing.



For my own part I'm usually content to analyse a few thousand markets, even fewer if I'm working on something quite specific.



When TPD came along I went live with &lt; 100 and a hunch - as I recall [@U4H19D1D2](@U4H19D1D2) did the same? When I first started out I had no data at all, went live with nothing and just analysed the results.

---

## 2024-07-30 00:00:48 - general channel

**Unknown**

So some good points learner by me tonight:

1. You can run Flumine sumulation from compressed data, I can now simulate a whole year at once, nice one [@U4H19D1D2](@U4H19D1D2) 

2. EV_vs_BSP is great to visualize actual startegy performance

3. You need a decent size dataset to evaluate a strategy, ie.1 year! as you can see below this "fitted" strategy can perform seemingly well for a few months in a row, but in the end of the day although +ve, it is highly likely just random!!

 1 year backtest from compressed .gz data:

---

## 2024-07-29 20:04:04 - general channel

**AndyL**

yeah, in fact whatever tweaks I make to my model, January seems up, and March down, which most likely means my model is just "random" !

---

## 2024-07-29 10:47:32 - general channel

**A**

Great thread. I’m currently following a similar path to you Andy - brute forcing things until I find something consistently profitable. I’m playing in the greyhounds market at the moment. Current strategy seems to be breaking even to slightly profitable (based on 2-3 weeks). Need to bite the bullet and implement simulation and backtesting as my feedback loop is so slow in my current workflow (essentially AB testing the same strategy with different thresholds running live)

---

## 2024-07-29 10:35:57 - strategies channel

**Misha**

Nothing I do negates anyone else's strategy. I never even implied that. So nothing I do for myself is ever making an assessment on anyone else

---

## 2024-07-29 10:26:18 - strategies channel

**D C**

Show me an actual profit graph for your model in 5 years and I'll take it all back. Good luck with it. Bye.

---

## 2024-07-29 10:20:53 - strategies channel

**liam**

This is all theoretical though based on backtesting / simulation, IMO not sure you can state facts on liquidity constraints until you have proved a strategy live, anyone can create a graph like that

---

## 2024-07-29 10:20:21 - strategies channel

**Misha**

Back-test. When betting it matches within +/- 0.5%. Have months of data to prove that. Every single time I bet I match the model

---

## 2024-07-29 10:14:54 - strategies channel

**D C**

I'd have to disagree with your assurance that it shows your model is correct. If (as you have stated), your model is only ever selecting ONE player's odds as being favourable, then your notion is that your model is more correct than the market over the entire duration of that match? There are too many very smart and sophisticated operators out there for me to ever believe that that would be the case.

---

## 2024-07-29 10:10:27 - strategies channel

**D C**

Rarely? No wonder you've problems with variance then. Does that not indicate some inherent bias/inaccuracy in your model prices if you are only ever backing one player

---

## 2024-07-29 10:10:21 - strategies channel

**Misha**

I have no restriction on prices. Model is no better or worse on any price range

---

## 2024-07-29 10:05:50 - strategies channel

**D C**

I find variance is only an issue when I find that I am getting more matched at higher prices. I don't back odds on because my models are shit in that price region (something still working on) so I just omit them. I accept the variance and I certainly have bad days and losing weeks but I have an exposure cap per market and a (so far) large enough bank to see that through.

---

## 2024-07-29 10:04:03 - strategies channel

**Misha**

I was asked why I stopped betting completely. The answer was that it was more important to build up the detailed dataset for back-testing than it was to keep betting. The data I have cannot be bought - it has to be collected yourself, which means a good up-to-date score and Betfair streaming prices

---

## 2024-07-29 09:32:28 - general channel

**D C**

I haven't tried it to be honest. I use R for my modelling, C++ for production bots and node.js for stream data acquisition. It is something I need to get on top of but in truth my enthusiasm for programming is at a career low right now. I'll need to kick myself up the backside and give it a try

---

## 2024-07-29 09:26:09 - general channel

**Michael**

Surely you can just take your betting data and do some Pandas Fu?

---

## 2024-07-28 23:36:26 - general channel

**Misha**

This month, after a restart, we are on a "flyer" with low stakes. +15% POT after commission on 130K bets. Average stake about $0.30. Model averages +4% over 4 years, but would not expect to get quite that due to commission (bet execution manages to knock of some of the commission, but not all, at this stage)

---

## 2024-07-27 23:27:55 - general channel

**Misha**

See comment about football model :wink:

---

## 2024-07-27 23:27:38 - general channel

**Michael**

_"My biggest client has been working on the same type of model for decades"_



Is he gradually makin it better bit by bit? That would be smart.

---

## 2024-07-27 23:26:41 - general channel

**Misha**

I think that they had been working on a football model for over 2 years that had not gone live

---

## 2024-07-27 23:25:41 - general channel

**Misha**

My biggest client has been working on the same type of model for decades

---

## 2024-07-27 23:20:05 - general channel

**Misha**

You have to remember that almost by accident I have something that works consistently over years, that doesn't use any new data beyond 2019, and doesn't even take into account the players. If someone told me they had that model, I would have said that they were lying

---

## 2024-07-27 23:17:26 - general channel

**Misha**

We are working on a proper ML model, but progress has been a lot slower than I would like. But that's not my job :wink:

---

## 2024-07-27 23:02:26 - general channel

**Misha**

I gained a huge amount from the first attempt. Massive amounts of detailed point and price data; a model that does work; bet execution tests; learnt about the variance of this model; have a system that was robust enough to place around 5 million bets without ever once going rogue. That's a lot of wins right there

---

## 2024-07-27 22:55:01 - general channel

**Misha**

For this model, it's very painful

---

## 2024-07-27 22:43:15 - general channel

**Misha**

I ran the back-testing before we restarted. Now mindful that the worst period the model has is 150 days without going forward (nearly 3 months), here is the graph for 4 years at the scale we are currently betting:

---

## 2024-07-27 22:16:33 - general channel

**Misha**

The stuff I developed was only supposed to be a test until my partner developed a real ML model. Except it seemed to work. So we ran with it. Scaled up too quickly, but until you actually do it you won't really learn

---

## 2024-07-27 22:02:54 - general channel

**Michael**

I'm curious as to why you stopped betting completely rather than just scaling back your stakes? That would have left you with much better data and probably some cash. Of all the problems you can have over scaling is the easiest to fix.

---

## 2024-07-27 21:08:38 - general channel

**AndyL**

Interesting you say that Michael, I do suspect i'm one of those missfits that finds it very hard, despite pushing and working on this an awful lot, I struggle to find anything new apart from my one basic strategy.

My ideas and coding gets very very complex, and I do suspect that's not right, [http://ie.it|ie.it](http://ie.it|ie.it)'s actually simpler... although that may sound odd! Like my "book" price for 3.0 horses we discussed earlier in the thread, i'm currently working on a combination of 5 aspects that i've constructed, just seems overly complex!!

---

## 2024-07-27 20:25:21 - general channel

**Misha**

Last thing: the original model I have actually does work, but with high variance. After 1.5 years there was not enough data to know. Now I have 4 years of data and it seems to be pretty consistent over 4 years. In terms of sizing we were a bit naive - due to the first 6 months all showing significant profits. Increased sizes made it a wild ride. So back to data collection, a full-time job as software development manager for a betting agency who started up in the US, and now doing the greyhounds stuff full-time, among other things

---

## 2024-07-27 20:13:32 - general channel

**Misha**

Just started testing again with a better version of the same model, and integrating an ML model, but will be more circumspect this time :wink:

---

## 2024-07-27 18:45:47 - general channel

**AndyL**

We know people on here who have mastered it so model pricing must be possible even now

It’s probably so simple but til you find it it seems impossible!

---

## 2024-07-27 16:25:29 - issues channel

**Derek C**

I'm having some new issues lately where Flumine isn't enforcing exposure limits on selections and I am getting exposures that are a multiple of what I would like them to be. I recently made the following changes, could these somehow cause the exposure limits to be breached?

• started setting the config parameter to make orders 'async' 

• adding 'force=True' on cancellations (because I often hit the hourly transaction limit)

Another symptom that may or may not be related is I get a lot of unmatched orders hanging around, even though my 'process_orders' function cancels after n seconds.



My assumption/understanding is that if I stop Flumine and re-start it will recalculate exposures for all outstanding strategy orders, so stop/restart shouldn't be the issue.



Is there something I should be logging that would help track this down?

---

## 2024-07-27 15:08:06 - general channel

**thambie1**

[@UPMUFSGCR](@UPMUFSGCR) In strategy research you have endless roads you can go down. How do you choose one? How far down that road do you go? You've spent over a month, hit a bunch of dead ends, is it time to call it quits? What will you learn upon failure (the most likely outcome) by going down that road? I've tried working with other people, this is what I've found to be the lacking skill.

---

## 2024-07-27 12:05:25 - strategies channel

**D C**

Actually came across a paper that seems to tackle exactly this problem. I had to skim over some of the convex optimisation stuff but might be of interest to others as there are references to placing -EV bets in order to increase the expected wealth gain which is something I've seen recently discussed on here



[https://www.semanticscholar.org/paper/In-game-betting-and-the-Kelly-criterion-Andersen-Hassel/d9be9ec95ca971bd2e45ad2cf9a41f97397b6cbd](https://www.semanticscholar.org/paper/In-game-betting-and-the-Kelly-criterion-Andersen-Hassel/d9be9ec95ca971bd2e45ad2cf9a41f97397b6cbd)

---

## 2024-07-26 16:51:15 - strategies channel

**D C**

Also, how impactful would you guys say this method of stake sizing is to your profits? I've been rather "rough" around the edges really in certain regards, focusing more on model accuracy than anything but now that I'm having to give BF 40% of my profit every week I feel I really need to tighten up and this could be something useful in future endeavours.

---

## 2024-07-26 15:45:35 - strategies channel

**D C**

I'm basing my EV of model price [@U4H19D1D2](@U4H19D1D2) (fundamental, not market signals) but of course that is not going to be accurate all of the time. I see what you are saying though. I actually use in a few strategies a staking based on an old Pinnacle article written by Buchdahl that chooses stake based on the assumption that you've no idea what true EV is. It's basically some kind of logarithmic scaling of ask price. Can't seem to find a link to it now though. Can't remember if it has any theoretical validity in contexts other than those which Buchdahl usually frames his writing.

---

## 2024-07-26 14:07:48 - strategies channel

**liam**

My experience says otherwise, once you start fitting kelly to meet the market capacity you are no longer getting any advantage from it and becomes a hinderance. The bet sizes diverge from the optimal whilst coming at a cost of EV as you move the market, execution is far more crucial than the 'kelly optimal'

---

## 2024-07-26 12:47:33 - strategies channel

**Bert Raven**

you don't know the true probabilities but you should have a reasonable estimate of what your edge is through backtesting and live realized, in which case I simply scale the kelly ratio by realized (or backtested) ev/ model forecasted ev

---

## 2024-07-26 12:21:05 - general channel

**JFP**

Logging level INFO vs CRITICAL



Does logging level affect strategy processing and bet placement, or is logging running in a separate thread?

---

## 2024-07-26 12:10:31 - strategies channel

**Mo**

[@U4H19D1D2](@U4H19D1D2), both problems are overstated I think. Obviously you don't know the true probabilities but trivial to protect yourself against this by using fractional Kelly which everyone does. If your probabilities are really so far off then you probably don't have a profitable strategy in the first place. For the market capacity problem, just fire in the Kelly bet and see what happens. You'll take account of what actually got matched when you calculate your next bets. If that opens you up to too much adverse selection then just use a stake size cap

---

## 2024-07-26 11:57:38 - strategies channel

**liam**

The problem with kelly is that it assumes you know the ev of your bets which I think boils down to problem you are facing? Can you accurately put a figure on your ev?



But then you have the next problem which is market capacity required to fulfil kelly staking which in certain markets (inplay racing) is never going to work

---

## 2024-07-26 10:07:26 - strategies channel

**D C**

Are there any articles on this kind of thing?  I've read papers on how to adjust Kelly when you are betting on more than one selection in multi selection events but I've never seen anything about kelly criterion adjusted for existing exposure?

Are you deriving these things from first principles?

---

## 2024-07-25 18:06:04 - strategies channel

**thambie1**

kelly criterion that takes existing positions into account

---

## 2024-07-25 11:13:22 - general channel

**liam**

A strategy can have many trades and a trade can have many orders, so makes sense to store 'trade' state within `trade.context`

---

## 2024-07-23 10:52:09 - issues channel

**liam**

[https://github.com/betcode-org/flumine/blob/master/flumine/strategy/runnercontext.py](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/runnercontext.py)

---

## 2024-07-23 10:38:29 - issues channel

**liam**

Sounds like you just want to use a trade / multiple orders and limit using `max_live_trade_count` on the strategy

---

## 2024-07-23 10:21:05 - general channel

**Adrian**

[@UQL0QDEKA](@UQL0QDEKA) no I don’t think so. One account, I had had 4 instances of flumine running on two machines at home (gave up on the VPS). One strategy for market recorder, two for live strategies and one for temp/testing. No warnings from the API about connection limits or anything. I don’t my betting patterns were anything weird, one of strategies was placing back and lay bets before the off, the other was placing them after the off.

Why I’m sure it was to do with the political discord is, it was the only place I’ve been posting for the last couple of days, and I was removed instantly from the discord server the second my account was closed. 

---

## 2024-07-22 21:47:10 - general channel

**birchy**

I do mine at strategy level in process_market_book but it would be nicer in middleware. I usually just save the complete market_book and then do stuff like get time series based on the publish_time_epoch, etc. From memory, middleware __call__() gets called on every update. [@U4H19D1D2](@U4H19D1D2)?

---

## 2024-07-22 17:26:59 - issues channel

**A**

Hey. Recently getting `SUBSCRIPTION_LIMIT_EXCEEDED: trying to subscribe to 221 markets whereas max allowed number was: 200` just trying to subscribe to UK hounds. First I’ve seen of this. Wondering if it’s trying to subscribe to tomorrows races too?



Code (was working great until this last hour):



```MyStrategy(

  market_filter=betfairlightweight.filters.streaming_market_filter(

    event_type_ids=["4339"],

    country_codes=["GB"],

    market_types=["WIN"]

  )

)```

Any way to get it to subscribe to the day’s racing?

---

## 2024-07-19 21:43:41 - general channel

**AndyL**

Thanks for a great answer [@UGV299K6H](@UGV299K6H) 

So I have one strategy that does work and makes me about £2k a month, that’s my background earner albeit not huge.. but I actually enjoy the challenge of digging but it can be very frustrating at times! This thread has spawned a new idea/area, and I think I will try your idea of pushing it… so cheers for your direction 

---

## 2024-07-19 20:40:36 - general channel

**Paul**

My gut says follow the Kelly trail

---

## 2024-07-18 14:41:41 - random channel

**Unknown**

Twilight zone American democracy. Kamala feels like a value bet. No model, not systematic. Just a punt

---

## 2024-07-17 13:06:02 - random channel

**Paul**

I’m looking forward to giving the core model building chapters a read later, though. It seems we are on the verge of forming a book club on this one. :slightly_smiling_face:

---

## 2024-07-17 13:01:56 - general channel

**liam**

He is missed, I wonder if he ever recovered from going live for the first time with his 'model'

---

## 2024-07-17 08:26:22 - issues channel

**liam**

```from flumine.worker import BackgroundWorker





def update_df(context: dict, flumine) -&gt; None:

    df = get_df_data()

    # store df in market context?

    for market in flumine.markets:

        market.context["df"] = df

    # store df in strategy context?

    for strategy in flumine.strategies:

        strategy.context["df"] = df





framework.add_worker(

    BackgroundWorker(

        framework,

        update_df,

        interval=60,

        start_delay=4,

    )

)```

---

## 2024-07-16 21:04:43 - random channel

**Paul**

This looks great, but building models in R is only slightly less unhinged than writing them in Excel. Bit easier to port, mind.

---

## 2024-07-15 13:59:06 - issues channel

**birchy**

So presumably, at strategy level you're checking the blotter for pending bets before firing in the next lot? Obviously there's an advantage to NOT waiting for the order stream to pick them up, but I assume you use other mechanisms to prevent the same bets being placed multiple times?

---

## 2024-07-12 12:30:28 - strategies channel

**George**

It's not a question of EV, or edge, or techniques, it's a question of liquidity. If you don't want to get stuck with an outright punt, then you can only back with the size that you're confident that you'll be able to lay later on.



If there's unlimited liquidity and you're going to trade out anyway (whether the price moves in your favour or not) then you can - and would need to - use big stakes.



Having said all that - it's better to just not trade out, and then you can rely on Kelly staking.

---

## 2024-07-11 23:33:23 - strategies channel

**Ralegh**

If you’re backing and laying then in a sense your bet isn’t the outright bet but you’re betting on your change in EV. Eg you back 500 and (not gonna get the right numbers here but) want to lay at 250, your ev is say double your bet or +1U, whereas if price balloons out then it’s -1U, ie you’d want that trade if probability of hedging at &lt;=250 is &gt; 50%, so that’s what you’d put into Kelly

---

## 2024-07-11 21:34:26 - strategies channel

**Jonjonjon**

Actually that's a bad example as I made up the numbers.



For back at 100, lay at 90 (fair value) trade, kelly fraction is 12%

For back at 500, lay at 450 (fair value) , kelly fraction is 0.02%.



In reality I often do up to 10% of my bank on bets of 500

---

## 2024-07-11 21:25:31 - strategies channel

**Jonjonjon**

Suppose I back at 100 and lay at 90, Kelly tells me to bet very little when in reality my model is very reliable so I'd bet quite a lot on it.

---

## 2024-07-11 20:36:12 - strategies channel

**birchy**

Stakes based on edge (Kelly) is surely the right thing to do within market capacity?

---

## 2024-07-11 20:28:25 - strategies channel

**Mo**

Why isn't Kelly suitable?

---

## 2024-07-11 20:11:26 - strategies channel

**birchy**

Don't fret [@UPMUFSGCR](@UPMUFSGCR). I run flumine simulation on a $20 AWS Lightsail instance to generate 'features' CSV's and then train models on Google Colab. My strategies are unsophisticated, so 5K markets takes an hour or so to run and model takes &lt; 10 minutes to train with ~30 features. I've set a limit of 5k markets so I can get results fairly quickly and that's working for me. I take the view that if a strategy needs &gt; 5k markets to make a profit, then it's not viable in the real world.

---

## 2024-07-11 19:49:25 - strategies channel

**Jonjonjon**

For people who trade in and out using forecasting models, what techniques do they use to scale bet sizes as a function of forecast magnitude, price etc...? Kelly isn't suitable as I trade in and out (i.e. I'm one of the losers who hedges)

---

## 2024-07-11 13:04:58 - strategies channel

**AndyL**

unfortunately I don't have the "model" know-how to use one!

---

## 2024-07-11 11:23:48 - strategies channel

**Joe**

Probably worth pointing out that back testing where you run the markets once to get a result doesn't really matter how fast it is, I'm sure 10mps is fine. Training OTOH where your objective function is a block of procedural stateful strategy code, that is non-differentiable   so you can't use back prop, requires many orders higher run frequency as you are limited to quasi evolutionary / genetic type parameter searches, or even worse some sort of nD grid search. I do the evolutionary thing hence the high frequency requirement of my process.



Or to put it simpler back testing is not the same as training RL albeit both need to run data through your logic and sum up the cost.

---

## 2024-07-11 09:34:15 - general channel

**river_shah**

Does `size_matched` get reduced or set to 0 entirely if bet voided as VAR events occur?



```market.blotter.strategy_selection_orders(strategy, selection_id)

b_exposure = 0

.... 

for order in orders:

    if order.side == "BACK":

        b_exposure += order.average_price_matched```

---

## 2024-07-11 00:08:30 - strategies channel

**thambie1**

If I were buying a machine for backtests, I'd build a desktop with the most powerful retail CPU on the market. And then in my case, model training is also memory heavy so I'd want minimum 128GB on that. Everything else wouldn't matter as much

---

## 2024-07-11 00:04:27 - strategies channel

**thambie1**

@James I have done cost experiments for zipped vs unzipped. I found unzipped to be cheaper in my use case. You should have cpu profiling working and be able to do such experiments yourself if you want to make optimizations of this kind. That being said, the financial choice is clear to just buy a better dev machine if that can fix your problem, unless your really not valuing your time to go the cloud route. It really is a time sink, trust me.

---

## 2024-07-10 11:50:54 - general channel

**liam**

IMHO paper trading is for testing your code against live data, no advantage over just simulating using historical data

---

## 2024-07-09 18:46:02 - random channel

**PeterLe**

I was just thinking. One of the best traders (Gambler) i know once told me that he never really uses anything much beyond GCSE maths.

If you were to create two categories for successful gamblers, one using simple based maths and one using sophisticated models, which group would you expect to make the greater combined profit?

---

## 2024-07-09 17:29:17 - random channel

**Paul**

Ok, so let me explain. I regularly read about an area of maths, or comp sci, and I think “wait, there could be a strategy here”. I think a lot of foundational thinking in this space starts with the abstract and needles its way into concrete stuff. Pascal, Shannon, Kelly, Thorp, Bentner, many others: they looked at some maths and saw an interesting thing that then became a way to make money. Shannon noticed the money making oops but did nothing about it. Thorp noticed the maths and ended up building the world’s first wearable computer to apply it. If you only ever see theory as a means to making money, you’ll only ever look at stuff that is “obvious” in terms of its alignment to money making.

---

## 2024-07-09 16:42:46 - random channel

**Simon Chan**

Maybe a weird question:

I recalled that someone here posted a photo of some paragraph from a book a while ago. I don't remember what it said exactly but what I can paraphrase from memory is: it talks about  the author (or someone else)  learning /using advanced technical concepts (mathematics, computer science) in order to help trading, but is not interested 

 in these concepts on their own at all, as these are just useful tools to make money.  There was also discussion on this sentiment and I think most folks here disagreed/ were not warmed to it.



I can't find the post now because it is way past the 90 days history limit by Slack.  It is probably a wild guess, but does anyone know the book, or know who posted it and/or have archived the post?  I'm interested in reading the book further (part of the academic research I'm doing).

---

## 2024-07-08 15:33:58 - strategies channel

**D C**

I realise that this can't be a precise measure of EV, but I was wondering why you suppose that profit is still negative up to (eyeballing it) 0.45 EV ? Is the fact that its around zero on the far left side a consequence of this strategy signal being very strong and you don't actually place many bets that are -EV according to this definition?

---

## 2024-07-08 14:51:07 - strategies channel

**Unknown**

And this is a 'real' strategy on the same dataset

---

## 2024-07-07 11:31:28 - general channel

**Rob**

I previously dumped everything in to a database because that was also where I stored all the data for long term analytics/model builds etc, but at least at first glance, the simulated backtesting that Flumine offers means I expect I can use that, along with the logging that dumps data for each trade

---

## 2024-07-06 10:35:37 - general channel

**birchy**

Yeah, I agree on it's bad practice. I'm tracking previous market books and traditionally I've just done `market.context['xmbs'].append(market_book)` and then process as required. Some of the values are static once calculated, so I'm currently working on a 'MiniBook' class and will likely just set an instance in `market.context`  with a view to adding it to middleware in the future. If my strategy works. :grinning:

---

## 2024-07-05 12:51:51 - strategies channel

**Rob**

It's part of the BF API,  in betfairlightweight [https://github.com/betcode-org/betfair/blob/8ec3c29d68d35e5aed1e606a5833b53210dc3847/betfairlightweight/endpoints/betting.py#L439|here](https://github.com/betcode-org/betfair/blob/8ec3c29d68d35e5aed1e606a5833b53210dc3847/betfairlightweight/endpoints/betting.py#L439|here)

---

## 2024-07-04 17:37:11 - general channel

**birchy**

Having just seen the other thread on this subject, you could setup a simple scraper for yahoo finance and adjust the timestamps in the URL to match the betfair trading times. I'd probably go for hourly timestamps and save them all to a database or lookup table.

---

## 2024-07-04 13:54:53 - general channel

**D C**

But surely simulation/backtest errors/assumptions effects of your own money on the market etc. would dwarf tiny fluctations in currency? No backtest can be flawless. I might understand if you were trading using some crypto shitcoin that can change 50% in an hour, but surely no fiat currency fluctuates in any significant sense over such small timeframes? I mean obviously your time is your own to do with what you will, but I'd have thought there are better ways to spend time?

---

## 2024-07-04 12:51:35 - general channel

**Gabriel Mocan**

[@U9JHLMZB4](@U9JHLMZB4) I agree, but let me tell you the whole story.



I’m collecting live data since Aug/23. My system is pretty much validated as far as Monte Carlo allows me to validate, and I’m already live trading for about 45 days in that strategy.



Still, I would like to add more data to the backtest to make it more robust. So I’ve purchased a couple months prior to Aug/23. The thing is, my data is collected in BRL, and the strategy parameters were also designed in BRL (most important being the market volume). To make the backtest cohesive, I would need to convert the historical data to BRL before uploading it to my database.

---

## 2024-07-04 06:35:23 - issues channel

**liam**

Do you know what your latency is when receiving data ie. Publish time vs your clock / do you get any data conflated? 



Unless you are betting into a highly volatile market such as inplay racing I am not sure this would be latency tbh 

---

## 2024-07-03 15:18:48 - general channel

**Sen**

I've been scaling up since end of 2023. It started with an amazing Dec. Then a really tough Q1/Q2. I want to improve many parts... the model and execution. I think that not getting fully filled in every bet is having a negative impact on my pnl

---

## 2024-07-03 09:58:32 - general channel

**Jonjonjon**

If 2024 has not been good why are you increasing size? My models haven't done well on dogs either so I've been scaling back. My pnl seems to stabilise when I scale back, but I'm trading much smaller size than you.

---

## 2024-07-02 18:40:59 - general channel

**AndyL**

[@U02S5LNK291](@U02S5LNK291) how long have you been running this strategy? As im surprised you have found a long term profitable edge on dogs with that size bet, but kudos if you have 

---

## 2024-07-02 13:34:00 - random channel

**Unknown**

I guess I will ping some further observations and punting log as it makes watching the tournament more interesting. I make no claims to having any alpha in this as my systematic strategies don't touch this.



Portugal actually drifted out despite winning their game. Less than stellar performance and Ronaldo seems very unconvincing. When Portugal was drifting out, someone started backing England some more. Causal? It seems like regardless of weaker or stronger teams getting kicked out of tournament, there is a wall of money backing England.



There were a couple of £1M bets during the Portugal/ Slovenia penalties (To Qualify market). Maybe [@U4H19D1D2](@U4H19D1D2) has started betting on football

---

## 2024-07-02 04:06:35 - issues channel

**Adrian**

[@UUCD6P13J](@UUCD6P13J) no nothing related to that bet at all, which is why I omitted it, just hundreds of max_live_trade count >= 1 strategy violation messages while fumine tries to place a second bet

---

## 2024-07-01 18:02:12 - random channel

**Paul**

You’re lumped out on France a bit. What’s your secret model there, hmm?

---

## 2024-07-01 17:58:45 - random channel

**Paul**

That’s not an awful model… :-)

---

## 2024-07-01 17:55:30 - random channel

**river_shah**

My uber fantastic model tells me (three multiplications that I have pulled out of a hat) that price should be closer to 6.5

---

## 2024-07-01 17:51:15 - random channel

**Paul**

Look at the tournament bracket. Switzerland is the hardest match they’ll have in terms of World rankings until final. If you model it with ELO (which is all rankings really are a proxy for), factor in they are more likely to handle extra time and penalties well based on player form compared to the players they are facing, the price feels about right to me. People buying into media narrative of Southgate mediocrity - the same people calling for his resignation at 90’ + 4 last night - are potentially the mugs on the other sides of your bets. All he needs to do is tweak some positions and they’re going to be getting a *lot* more attempts on goal…

---

## 2024-06-30 15:41:07 - random channel

**lorenzo**

After the draw I do think it’s going to be a bit easier to get far along (and possibly to the end). I also have no model but I’m not sure 5.0 is really value now 

---

## 2024-06-30 15:30:51 - random channel

**river_shah**

I don't have a particular model for this, but surely England priced at 5.0 for the Euros seems way too optimistic 

---

## 2024-06-29 05:57:18 - issues channel

**Adrian**

This log for one of the bets. If I'm reading correctly, it's cancelling the matched, execution complete bet? How is that possible

```{"asctime": "2024-06-29 00:26:34,373", "levelname": "INFO", "message": "execute_place", "taskName": null, "trading_function": "place", "elapsed_time": 0.31791043281555176, "response": {"customerRef": "cfca0e5e66bb42aca58660e4d5d04156", "status": "SUCCESS", "marketId": "1.230213698", "instructionReports": [{"status": "SUCCESS", "instruction": {"selectionId": 63123802, "handicap": 0.0, "limitOrder": {"size": 0.9, "price": 6.0, "persistenceType": "LAPSE"}, "customerOrderRef": "10486de05a131-139389135940498137", "orderType": "LIMIT", "side": "LAY"}, "betId": "352983020564", "placedDate": "2024-06-29T00:26:34.000Z", "averagePriceMatched": 6.0, "sizeMatched": 0.9, "orderStatus": "EXECUTION_COMPLETE"}]}, "order_package": {"id": "cfca0e5e-66bb-42ac-a586-60e4d5d04156", "client": "[flumine.clients.betfairclient.BetfairClient object at 0x7f08e2a6a540](flumine.clients.betfairclient.BetfairClient object at 0x7f08e2a6a540)", "market_id": "1.230213698", "orders": ["139389135940498137"], "order_count": 1, "package_type": "Place", "customer_strategy_ref": "7b7f8aff23d6", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}



{"asctime": "2024-06-29 00:34:28,149", "levelname": "INFO", "message": "Order status update: Cancelling", "taskName": null, "market_id": "1.230213698", "selection_id": 63123802, "handicap": 0, "id": "139389135940498137", "customer_order_ref": "10486de05a131-139389135940498137", "bet_id": "352983020564", "date_time_created": "2024-06-29 00:26:34.049894", "publish_time": "2024-06-29 00:26:34.048000", "market_version": null, "async": false, "trade": {"id": "b7996cca-1057-482b-8cde-05d1cd654818", "strategy": "laying", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["139389135940498137"], "offset_orders": [], "notes": "", "market_notes": "4.6,6,None", "status": "Live", "status_log": "Pending, Live"}, "order_type": {"order_type": "Limit", "price": 6, "size": 0.9, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null, "price_ladder_definition": "CLASSIC"}, "info": {"side": "LAY", "size_matched": 0.9, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 6}, "responses": {"date_time_placed": "2024-06-29 00:26:34.374398", "elapsed_seconds_executable": null}, "runner_status": null, "line_range_result": null, "status": "Cancelling", "status_log": "Pending, Executable, Cancelling", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "6.5993862158248975,1105.950219", "market_notes": "4.6,6,None", "client": ""}```

my orders file shows the bet was matched and resulted in a loss with 474 seconds elapsed executable. even though it was matched instantly

---

## 2024-06-26 11:19:49 - general channel

**PeterLe**

Yes you would use that as well DC ie :

```print("Loading environment variables...")

load_dotenv('details.env')



myacc = os.getenv('USER_SUB1')

if not myacc:

    raise ValueError("Account name not set in environment variables")



mypass = os.getenv('PASS_SUB1')

if not mypass:

    raise ValueError("Password not set in environment variables")



app_key = os.getenv('APP_KEY_SUB1')

if not app_key:

    raise ValueError("App key not set in environment variables")



print("Prompting for 2FA...")

two_fa = input("Please enter your 6-digit Google Authenticator code for Sub1: ")



mypass += two_fa

certs_path = r"C:\certs"



print("Creating API client...")

trading = betfairlightweight.APIClient(myacc, mypass, app_key, certs=certs_path)



print("API Client created, proceeding ...")```



---

## 2024-06-25 02:48:10 - general channel

**Ben Coleman**

Hi Guys,

I am wanting to access the market catalogue within the process_closed_market function within a flumine strategy class to gather a few bits of information about the markets I have bet on including the market base rate and the market name. I tried calling market.market_catalogue however it just returned None. I have managed to call this successfully before in other strategies however it doesn't seem to be working for me now. Is there anything you need to specify to be able to gather the market catalogue information?

Also, unrelated question, is a bet directly into the SP considered a 'live bet' in the context of setting the argument max_live_trade_count when calling your class, I assume not?

Cheers

---

## 2024-06-24 17:58:57 - issues channel

**foxwood**

I do a fiddle in `check_market_book()` where I initially set a default of 999999

```if market.context[self.ctxname]["skipToSeconds"] != 999999 \

        and realSecsToGo > market.context[self.ctxname]["skipToSeconds"] :

    # after start time and asked need to skip

    return False```

and in the strategy when finished set it with

```market.context[self.ctxname]["skipToSeconds"] = -9999```

---

## 2024-06-24 09:50:15 - general channel

**Jared King**

Thanks [@U4H19D1D2](@U4H19D1D2). Hows this look

```    def process_orders(self, market: Market, orders: list) -&gt; None:

        orders = market.blotter.strategy_orders(self)

        for order in orders:

            if order.execution_complete:

                if order.id not in self.order_trigger:                    

                    side = [http://order.info['info']['side']|order.info['info']['side']](http://order.info['info']['side']|order.info['info']['side'])

                    opp = {'LAY': 'BACK', 'BACK': 'LAY'}[side]

                    selection_id = [http://order.info['selection_id']|order.info['selection_id']](http://order.info['selection_id']|order.info['selection_id'])

                    handicap = [http://order.info['handicap']|order.info['handicap']](http://order.info['handicap']|order.info['handicap'])

                    size = [http://order.info['order_type']['size']|order.info['order_type']['size']](http://order.info['order_type']['size']|order.info['order_type']['size'])

                    print(f'Order trigger {opp}, {selection_id}, {size}')

                    trade = Trade(market.market_id,selection_id, handicap, self)

                    new_order = trade.create_order(side=opp, order_type=MarketOnCloseOrder(size)) 

                    self.order_trigger[order.id] = order

                    market.place_order(new_order)

        return```

---

## 2024-06-23 14:05:57 - random channel

**mk19**

[@UUE6E1LA1](@UUE6E1LA1)  'I don't understand = pointless maths' is still a bold claim, and then suggesting computer vision which is a solved domain. 



Anyway, I'm not sure what PhD program is this, but normally you need to have the topic of specialization to start not find it later. A profitable model is not a significant contribution, so I guess there shouldnt be a worry for that

---

## 2024-06-23 13:48:52 - random channel

**D C**

[@U05EXF0UXHB](@U05EXF0UXHB) I think Liam's perspective is perfectly acceptable from someone who is a practitioner rather than someone doing this for academic interest or qualifications. For someone doing a PhD it is probably more important to find something that they are interested in AND that the supervisor genuinely has some knowledge of as it can be a very lonely game. You need to work out if you are doing the Phd in the hopes that you end up with a profitable betting model, or to benefit from the research training and qualification it gives you when you are finished.

For someone who has a similar mindset to my own, I'd be very worried about the former overwhelming the latter otherwise worst case scenario you end up with neither.

---

## 2024-06-23 12:43:04 - issues channel

**Jared King**

Liam will probably spit out his coffee, but i do this:

```from flumine import config

config.customer_strategy_ref = 'strat_name'```

---

## 2024-06-23 08:34:07 - strategies channel

**Justice**

Interesting. Guess I'll have to wait till next year to test my strategy :sweat_smile: It uses TPD data which to my knowledge cannot be purchased unaltered

---

## 2024-06-22 20:25:00 - strategies channel

**Justice**

I am finding that returns for my strategy are highly variable when I back test depending on the subset of markets I hold back to test my model on. How many markets does everyone generally test on? I can spare about 200-250 at the moment for testing

---

## 2024-06-22 19:39:42 - strategies channel

**foxwood**

To set your own values add `max_live_trade_count=nnn` as argument to strategy constructor - other options in the docs at [https://betcode-org.github.io/flumine/strategies/#parameters](https://betcode-org.github.io/flumine/strategies/#parameters)

---

## 2024-06-22 11:44:52 - strategies channel

**Adrian**

`'Error: strategy.validate_order failed: live_trade_count (1) >= max_live_trade_count (1)'`

Is this limit explicitly defined somewhere?

I haven't changed it. Is it just a default safety measure in flumine or something?

---

## 2024-06-21 10:24:51 - random channel

**D C**

I agree with Liam 100%. The fact that you are even asking this question suggests that you have an open book and are not bound to an already written research proposal (???) so I would definitely go down the path of looking at positional/tracking data and some fundamentals based modelling. It is possible that doing this via a phd route might get you some "free" data to work with too. I did something along these lines in my last job for NFL data and to be honest I found it really interesting. Should counter that with the fact that I found nothing "useful" but I was doing this in a corporate setting, whereas you will not have that kind of pressure and have more time and (presumably) better guidance.

---

## 2024-06-21 08:42:02 - random channel

**Leo**

Would probably agree, ties in closely with a problem I've grappled with a fair bit with fundamental models where most "accuarate" model != most profitable model all of the time. Seen hundreds of the first type of paper I.e. here's a model applied to some historic sports data and as mo said maybe interesting academically are almost always useless    

---

## 2024-06-21 08:40:44 - random channel

**Mo**

The other two are interesting only as academic curiosities. Holmes and McHale backtest versus Bet365 which are not real prices so any claims their model is market beating cannot be supported

---

## 2024-06-20 06:50:13 - random channel

**river_shah**

Glad to hear and wasn't being a sour about it. That race was a small net win across models. British racing is pretty laissez-faire. That wander would have been a definite issue in the US

---

## 2024-06-20 00:23:11 - general channel

**Adrian**

Sorry to keep bringing this up, but any ideas why commission wouldn't re recorded in orders.txt from the default backtestloggingcontrol? Do I need to add something extra into my strategy e.g. into the process_closed_markets function?

---

## 2024-06-18 15:34:35 - random channel

**AndyL**

i'm your son, so do you have a winning strategy account running for me please...??

---

## 2024-06-18 09:08:28 - general channel

**Jorge**

Hey, I'm trying to understand how Flumine Simulations work for BSP bets vs Real betting. Is it true that in the simulation we assume the whole stake is filled at the BSP price? But in reality the price would be different because there is a limited amount of stake available at the BSP price?

---

## 2024-06-17 11:21:31 - general channel

**liam**

You mean like the optimised helper functions?



`market.blotter.strategy_selection_orders(_, _)`

---

## 2024-06-16 23:56:22 - random channel

**Rob**

I tend to work in RAM, would consider:



• don't store every row if you don't need to - does every row change every tick? if not, store each unique once with a from/to datetime

•  use the smallest possible data types

• do feature engineering or get feature importance on a smaller sample, and then build your model on a much dataset of columns that amtter  - obviously YMMV, but I don't build models with the full set of traded volumes at every price

• sample - lots of the time, you're not going to get a massively different answer with a subset that does fit in RAM

• buy more RAM (it's relatively cheap compared to the time you're investing - 128Gb of DDR5 isn't crazy)

• get it working locally on a sample, then use a cloud server (e.g. EC2) to fun your full build

---

## 2024-06-16 20:27:39 - random channel

**Ralegh**

Flat file is generally the best, you don’t stream to parquet so you either stream to (eg) CSV or betfairs json format then batch convert to parquet, or batch convert historical data to parquet. [https://signalsandthreads.com/state-machine-replication-and-why-you-should-care/|https://signalsandthreads.com/state-machine-replication-and-why-you-should-care/](https://signalsandthreads.com/state-machine-replication-and-why-you-should-care/|https://signalsandthreads.com/state-machine-replication-and-why-you-should-care/) - good reading, generally advice is to have writing be single threaded (ie don’t need a dbms) which reduces complexity. If JS can handle their shittons of data in a single thread (and most financial exchanges) then almost anyone can. My betting stuff is set up roughly similar, all data gets logged to disk and the trading is full deterministic so I can fully replicate a days data in the right order and see exactly why everything happened. Each day gets zipped as one file and put in S3, about 100MB each

---

## 2024-06-16 19:31:05 - random channel

**Justice**

[@UEA14GBRR](@UEA14GBRR) Yes I could use SQL, with a properly normalized database. But I am going to have to de-normalize and load into memory at some point to train my model/test/visualize etc.



I could lazily iterate which would avoid memory issues as [@U0128E7BEHW](@U0128E7BEHW) suggested but it would be awfully slow and I'm impatient. Perhaps I just need more compute.

---

## 2024-06-16 19:24:31 - random channel

**Justice**

[@U03FS7KM2NL](@U03FS7KM2NL) Research, testing and model training

---

## 2024-06-16 15:42:58 - strategies channel

**Rob**

In terms of the process I coded up, it's effectively:



1. Get all matched orders on the market (and check there are no unmatched orders left)

2. If the back/lay amount for each selection are not even, record the size of the discrepancy (at this point, match price isn't important)

    a. for example, if you've backed runner A for £100 and layed for £90, record a £10 lay bet against this runner

3.  Get your current P&amp;L per runner via `list_market_profit_and_loss` , simulate the effect of adding the bets above to the result at the current prices, and, and get the current prices for the market

4. For runners where you're in profit, record that you want to lay with size `current_profit / current_lp` 

5. For runners where you're losing, record that you want to back with size `( current_loss) / current_bp` 

6. Add the greening bets from steps 4 and 5 to the bets from step 2, and place them at the current back/lay prices and you should have a greened book

The only other complexities are around bet sizes - if you're betting relatively small amounts and include longer odds runners you will be below the minimum bet size. You can place a £1 bet far away from the current prices and then reduce the size, then the price.



At some point you can't do this as you run in to errors from betfair around what's allowed, but at that stage, the amounts of money are small enough not worry about greening

---

## 2024-06-15 23:27:31 - strategies channel

**Adrian**

Thanks Peter appreciate your share! Lots to think about. It sucks that your strategy went south after making that change. Were you able to correct it? I haven't made any changes yet. Still weighing up the pros and cons, also would like to backtest it to compare expected profits. There is possibly one thing beside profit that trumps everything else and that's the tax implications of hedging. In Australia that act alone turns you from a tax-free gambler to a taxable trader.

---

## 2024-06-15 10:41:26 - strategies channel

**liam**

No / Yes, it’s per strategy / market / runner

---

## 2024-06-14 23:04:29 - strategies channel

**Adrian**

[@U012XF5CNPN](@U012XF5CNPN) I want to hedge because I'm no longer wanting to back (or lay) the runner. I got my value already- the price swing and I'm sitting on a nice profit. Almost every race. By post, the value isn't there any more. There is no value in holding onto the position. Only variance. If you're betting into 50 different markets, that's no problem. But if you;re just starting out like me and you only have one strategy, you want to put as much money into that strategy as possible without breaking your bank. You can't do that without hedging

---

## 2024-06-13 18:03:03 - issues channel

**Rodolfo**

hey, I am not a pro coder but I managed to create a script that places bets. Works fine. But I am helping a friend that lives in Sweden, he gets a AUTHORIZED_ONLY_FOR_DOMAIN_SE error. How can I ask betfairlightweight to try the SWEDEN exchange?



trading = betfairlightweight.APIClient(EMAIL, PASSWORD, app_key=API_KEY_DELAYED)

trading.login_interactive()



Thank you.

---

## 2024-06-11 14:39:36 - general channel

**George**

so in live trading, after a runner is removed, the `blotter._live_orders` and `blotter._strategy___orders` etc will all be lists of orders with the new (lower) prices?

---

## 2024-06-10 08:10:04 - general channel

**Ben Coleman**

Hi Guys,

I have been testing a new strategy using historical data simulation on Flumine and I have noticed that quite often some of my simulated bets aren't getting matched. I am only ever trying to trade at the best available price, and I am just wondering what kind of algorithm the Flumine simulation uses to decipher whether you would have been matched or how much you would of been matched. My logic on any given update takes at most 4-5ms.

---

## 2024-06-09 23:55:23 - general channel

**Adrian**

Ok, so thanks for the suggestions. I tried using the backtestloggingcontrol example. A couple of things about the orders.txt output:

• It only recorded one of my bets in the first market when I had two

• It seems like `_process_cleared_markets` isn't running at all as I am not seeing any of those 'extra' fields appear

The logs are recording these things just fine, however, so it's just an issue with how the example is writing to orders.txt

Here is the code I'm running. the logging control is unchanged from the example. Any ideas?

```# Logger setup

logger = logging.getLogger()

custom_format = "%(asctime)s %(levelname) %(message)s"

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

# Adding StreamHandler to output to sys.stderr

log_handler_stream = logging.StreamHandler()

log_handler_stream.setFormatter(formatter)

logger.addHandler(log_handler_stream)

# Adding FileHandler to output to a specified file

log_file_path = '/Users/adrian/Data/logs/betting.log'

log_handler_file = logging.FileHandler(log_file_path)

log_handler_file.setFormatter(formatter)

logger.addHandler(log_handler_file)

logger.setLevel(logging.INFO)

...

control = backtestloggingcontrol.BacktestLoggingControl()

framework.add_logging_control(control)

framework.run()```

Here is the output in the log file (correct and complete):

```{"asctime": "2024-06-09 11:24:35,566", "levelname": "INFO", "message": "Market level cleared", "taskName": null, "market_id": "1.229732924", "profit": -3.01, "bet_count": 2}

{"asctime": "2024-06-09 11:24:35,567", "levelname": "INFO", "message": "Cleared market", "taskName": null, "market_id": "1.229732924", "bet_count": 2, "profit": -3.01, "commission": 0.0}```

And here is the output from the backtestlogging control's orders.txt (incomplete):

```bet_id,strategy_name,market_id,selection_id,trade_id,date_time_placed,price,price_matched,size,size_matched,profit,side,elapsed_seconds_executable,order_status,market_note,trade_notes,order_notes

351219139942,take_bsp,1.229732924,9541871,8902a6e5-5745-4fbf-85ab-f68b02de316d,2024-06-09 11:21:00.429400,3.0,2.761065519504482,2.0,2,-2.0,BACK,54.478439,Execution complete,"2.68,2.74,2.68",,"2.507662997872342,2.0"```

---

## 2024-06-09 12:04:50 - general channel

**Adrian**

I butchered the jupyterloggingcontrol so it would run after framework.run. I don’t know how to make it work on a live strategy

---

## 2024-06-08 19:41:46 - issues channel

**Elliot A**

Hi guys I have a strategy that uses Process New Market to wait for new markets to appear on Betfair and then do some stuff. The code runs 24hrs a day but seems to just stop processing markets after a few hours. Have not changed the default workers so it should be kept alive, any ideas whats happening? 

---

## 2024-06-03 13:05:58 - general channel

**ShaunW**

All the alternatives do is to dilute the already small pool of money; and too much emphasis is placed on attracting 'pro' money rather than punters we can do business with. The day one of these starts advertising to punters at the same level as Ladbrokes or PP is the day I might start to take them seriously.  Without punters it's just us expending time effort and money to fight with each other, to create the illusion of activity in order to justify their exit strategy price.

---

## 2024-06-02 14:09:35 - random channel

**river_shah**

To clarify, this is on track exposure that he's accumulated and then partially hedged off with exchanges?



I'd be hard pressed to acquire this level of risk on exchange alone without significant mkt impact (regardless of modelling confidence)

---

## 2024-06-01 10:55:40 - random channel

**Paul**

About that. It seems - based on interviews and bits and bobs I’ve picked up over the years - that Star Sports model is to lay a book to a common payout, but take a liability on a horse they don’t like at or near the head of the market. They then rely on the 1.5% a runner over round they get to make decent money 2/3 of the time and take a knock 1/3 of the time (in the long run). It’s a very old school way of book making, Vic Chandler senior would recognise it from his days on the rails. Given Ben started as an assistant to a bookie at a dog track and he’s now got multiple shops, a decent website, quite a few staff and he’s sponsoring a fair few things, seems to work for him.

---

## 2024-05-31 21:20:49 - general channel

**George**

Not sure about that... actually, in simulation, the race condition with order status happens when using the normal logging controls, it's nothing to do with what I've added here.



When I comment out the code I've added, I still see "new" orders being written to the log with size_cancelled > 0 and size_remaining == 0.



That wouldn't happen in live trading because of the real-life latency involved.

---

## 2024-05-29 21:20:36 - random channel

**Michael**

0.1% does seem very low. It wouldn't take much of a losing streak to turn that negative. On the other hand it might be a platform to build from, if you think you've got a decent chance of improving it when you've got enough data then you might well run it just for that. You'd certainly want to be sure that you're not canibalising any of your other betting though, that seems like a big risk with such a low margin strategy.

---

## 2024-05-29 12:18:13 - general channel

**George**

When setting up CI on GitLab I am encountering a lot of warnings about Pydantic via Betconnect. They look like this:



```../../usr/local/lib/python3.9/site-packages/betconnect/resources/betting.py:92

  /usr/local/lib/python3.9/site-packages/betconnect/resources/betting.py:92: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at [https://errors.pydantic.dev/2.6/migration/](https://errors.pydantic.dev/2.6/migration/)```

Does anyone know why this is happening? Am I using the wrong version of something?

---

## 2024-05-28 09:07:42 - issues channel

**Jorge**

I do use notes, the issue is not separating the orders internally, I can do that. The issue is when calling the `trading.betting.list_cleared_orders` endpoint, it is only possible to separate orders by the customer_strategy_ref value. When running 2 strategies in the same flumine instance it's not possible to give different values to each strategy unfortunately. I'd like to "mark" the orders in Betfair's side so that later when analyzing results by calling the API in 1 month I can separate the orders and attribute the P&L to each Strategy.

---

## 2024-05-27 13:24:48 - general channel

**AndyL**

[@UCQB6S222](@UCQB6S222) so not sure, but I suspect we're talking cross purpose... I think what you're asking based on the fact you say you don't use "proces_orders()", is does "process_market_book() include newly-placed orders?". Answer, "No", don't think it contains any orders.....

• `process_market_book()` Processes market book updates, called on every update that is received

    ◦ Do all your market book stuff here

• `process_orders()` Process list of Order objects for strategy and Market

    ◦ Do all your order stuff here

---

## 2024-05-27 10:23:09 - general channel

**Lee**

You can look at the simulation middleware to see how it works. It’s also not an easy problem to solve especially when your strategy participated in the market

---

## 2024-05-25 01:55:06 - strategies channel

**Troy Edwards**

I'm hearing you :slightly_smiling_face:  I have been playing around with Lasso/Ridge and reduced my data features down to 10.  I then created different models using different data features with one meaning static as in does not rely on odds or volume for Australian Greyhounds Markets.



Train/tested well.  Then after 5 days of validation 4 of those models broke (for that day anyway) but I will continue to validate over a few weeks as to the see the overall effect.



Maybe you should just continue to validate as sometimes one/two bad days is just part of that variance

---

## 2024-05-25 01:46:16 - strategies channel

**Troy Edwards**

[@U01S1VB9X9P](@U01S1VB9X9P) hi just on min bet, Betfair Australia now allows a min $1 bet which is great for validating models/systems in the real market.



Also I think if you turn over more bets then commission may be lowered.  My view is that turning over more bets for the same return increases your validation of your model/system working

---

## 2024-05-22 20:59:04 - general channel

**Dave**

For myself, I saw degradation in my tick to trade time as soon as I merged enough streams. It makes sense given the GIL + flumine, if an update arrives a micro after another, but both are tradeable, then the reaction to the second is going to be double your tick to trade inevitably. IMO if you go this route, then you should broadcast the data internally and then scale your trading processes as necessary. Of course the situation is different if you have your own stack that does true multithreading.

---

## 2024-05-22 00:00:21 - general channel

**Andrew**

I regularly see posts around this question. My understanding is the market filter has a parameter of time to start. If so, wouldn’t that be the best control? How many people are betting on markets hours before start?

---

## 2024-05-21 14:35:56 - issues channel

**Jorge**

Hi, when running 2 strategies in the same flumine instance, is it possible to give different customer_strategy_ref values to the orders placed by each Strategy? So that later I can analyze the results of each Strategy calling the `trading.betting.list_cleared_orders` endpoint.



In the flumine instance I save my own cleared_orders.txt which separates the orders using a "strategy_name" column as the example [https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|backtestloggingcontrol.py](https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|backtestloggingcontrol.py) . But I like to analyze the results calling Betfair directly in case the script was down.

---

## 2024-05-19 22:45:27 - strategies channel

**foxwood**

So I dug down into this and `add_historical_stream()` in streams.py only returns the stream created by another strategy if the file names are the same (True), the `event_processsing` is the same (True) and the `listener_kwargs` are the same (False).

The two strategies kwargs had different `seconds_to_start` and no other entries. Not sure why that should be counted as a different market feed but does explain what I found. Didn't discover this in any of the "docs" though. Assume the strategies would work in parallel if it did all match but not tested.

---

## 2024-05-19 21:27:08 - strategies channel

**foxwood**

I've combined them into 1 strat for now but would be nice to get this working. Code follows docs I think but don't remember anything special on multi markets ? These are the main bits of code

`dataDir = "path to directory"`

`strats = [launchTest1, launchTest2]`

`markets = [globbed list of fully pathed file names]`

`client = clients.SimulatedClient()`

`framework = FlumineSimulation(client=client)`



`with mock_patch("builtins.open", smart_open.open):`

    `for launch in strats :`

        `launch(framework, markets, client)`

    `middleware.marketcatalogue.MARKET_CATALOGUE_PATH = dataDir`

    `framework.add_market_middleware(MarketCatalogueMiddleware())`

    `try:`

        `framework.run()`

    `except Exception as e:`

        `print( traceback.format_exc() )`



`In separate file for each strategy:`



`def launchTestN(framework, markets, client):`

    `launchtest(framework, markets, client)`



`def launchtest(framework, markets, client):`

    `framework.add_strategy(`

        `stratN(`

            `name=stratN.__name__,`

            `market_filter={"markets": markets,`

                           `"listener_kwargs": {}`

                           `},`

            `max_order_exposure=999,`

	         `etc,`

            `context={"client": client, },`

        `)`

    `)`

---

## 2024-05-19 19:17:42 - strategies channel

**foxwood**

I'm trying to simulate 2 parallel strategies running on the same market and talking to each using market.context. Seems like they are both created and started ok but then strategy1 goes through all files with no sign of strategy2 getting a look in. From the logs I see each strategy is added but each one gets its own version of the HistoricalStreams created from the market_filter["markets"] file list when the strategy is constructed. Is there a way to make this work in simulation - I assume it works ok live judging by comments in other threads.

---

## 2024-05-16 11:56:19 - random channel

**Ralegh**

I think ridge+feature engineering given enough time and ideas may be sota but for stuff like HFT I have heard deep learning, (and also deep RL for execution/optimiser). There’s just so much data and you can fit to it quickly eg blackrock deploying a new execution algo could be factored in if you recalibrated every day but those transient signals might not fit into features that you’ve come up with historically unless you were literally coming up with new ideas every day. 



I think XTX is pretty big on deep learning and their whole thing is taking large positions while making markets so I assume their forecasts are good. That being said regression is like concrete or steel and probably is the final arbiter of what goes in a forecast.



Also ridge + features are a lot handier for transfer learning. If you moved to a new market with little historical data you’d feel pretty confident just copying stuff across. Would be easier to manipulate and remove features (weight = 0) without the required data in the new market than trying to break apart a web of neural network shenanigans. If I’ve learned anything from success stories the easiest way to make money is take a good strategy and apply it to an inefficient/new market.

---

## 2024-05-16 11:33:04 - random channel

**river_shah**

Yes, the thing is in his preamble he goes on precisely how the model is being constructed. So you know why not do that extra step, write some of the features out by hand (rather than lstm hidden representations) and fit ridge with GCV and show us the full multi horizon alpha term structure. I'd bet even this basic approach matches lstm illustrated performance (let alone what can be achieved by grinding harder at the problem use ridge + domain knowledge)

---

## 2024-05-16 11:26:43 - random channel

**Johnny**

Maybe he didn't have access to a SOTA model...

---

## 2024-05-16 11:22:57 - random channel

**river_shah**

The Kolm paper is good but feature engineering + ridge is still SOTA. It's too bad he does not have that as the baseline model

---

## 2024-05-16 10:51:55 - random channel

**Johnny**

[@U03FS7KM2NL](@U03FS7KM2NL) yep - I guess when I say "embedding" I mean a representation to store the state, which you've said can be done with a model of some kind

---

## 2024-05-16 10:41:20 - random channel

**Ralegh**

Orderbook as uniform shape is fairly easy? You just take top K levels over a T look back period, put in some transformer/cnn/lstm model, as Tx2K (or 4K with prices). 

---

## 2024-05-16 10:35:13 - random channel

**Johnny**

For a single point in time I'd agree but if you're looking at a time series then you'd need some way to put the data into a uniform shape to feed the model

---

## 2024-05-16 09:51:39 - random channel

**Johnny**

I think to implement RAG, one would need to find a suitable set of variables to represent either the current state (marketbook or equivalent) or the time series leading up to the current state - then learning a vector embedding for this so the model can search for similar states seen before and therefore potential similar outcomes.  Not sure if there are many pre-trained embedding models for this kind of data... probably something out there in the financial trading world

---

## 2024-05-16 09:29:51 - issues channel

**Jorge**

Seems to be working well using the simulate.py example. I noticed that in my simulation it runs first the strategy_1 in the 100 markets and then runs the strategy_2 in the 100 markets, as opposed to the simulate.py which runs them in the same market at the same time. So in the simulate.py I only see 1 log of "Cleared market" and no duplicates...

---

## 2024-05-16 08:24:00 - issues channel

**Jorge**

Hey guys, I recently started Simulating 2 strategies in the same flumine instance, with the goal of running them live. Until now, I was running both strategies in different scripts. This is my code:



```client = clients.SimulatedClient()

framework = FlumineSimulation(client=client)



control = BacktestLoggingControl(logs_dir=logs_dir)

framework.add_logging_control(control)



with patch("builtins.open", smart_open.open):

    framework.add_strategy(strategy_1)

    framework.add_strategy(strategy_2)

    framework.add_market_middleware(MarketCatalogueMiddleware(strategy_2.market_filter["markets"]))

    framework.run()```

My issue is with the [https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|backtestloggingcontrol.py](https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|backtestloggingcontrol.py) , I noticed that in my orders.txt, the orders from strategy_1 are duplicated. The same happens with the markets.txt (cleared_markets), I get double the amount of cleared_markets and the last half is the correct one which includes both strategies. How could I fix this so the [https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|backtestloggingcontrol.py](https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|backtestloggingcontrol.py) works when running multiple strategies in the same instance?

---

## 2024-05-16 01:47:45 - random channel

**Adrian**

[https://www.youtube.com/watch?v=GAj9G8rkg3s](https://www.youtube.com/watch?v=GAj9G8rkg3s)

The fact that someone like yourself Chris with no python knowledge can now knock up a fully working simulation and backtested model means we're all kinda fucked. This is the worst AI will ever be, in 6 months it will be 50 times better than it already is now. Everyone's edge will disappear cause the AI will be reinforcement learning better than any of us can understand the markets. The only difference between who wins and who loses is who can dedicate the most computational power to each problem. Link related.

---

## 2024-05-15 15:12:34 - random channel

**Chris**

From knowing absolutely nothing  about python except a few basic lines chatgpt 4 has written me an xgboost model predicting probabilities , webscraping racecards with scrapy and implementing it all to use with flumine.

Backtesting (thanks peterle) with only 3 months of data so far.

I found chatgpt4 much better compared to 3.5 which kept sending me around in circles. 

---

## 2024-05-15 08:22:31 - random channel

**Ralegh**

I think especially for tradfi there’s so little publicly available knowledge that these models won’t be able to give good advise on the trading side. Coding side useful of course

---

## 2024-05-15 07:50:47 - random channel

**river_shah**

Holy smokes: [https://chatgpt.com/?model=gpt-4o](https://chatgpt.com/?model=gpt-4o)

---

## 2024-05-14 10:41:31 - random channel

**Johnny**

Yeah I'm doing too many lookups and calcs in the strategy, need to rethink the logic probably

---

## 2024-05-13 10:46:43 - issues channel

**Adrian**

Yep makes sense! Quite handy actually. The market stuff shared across markets has been working flawlessly. Now i know where to put the strategy specific stuff. I was going crazy all day thinking it had something to do with the multiprocessing

---

## 2024-05-13 10:44:03 - issues channel

**liam**

flumine tries to be consistent so strategy stuff in `strategy.context` and market stuff in `market.context` allowing you to share if required

---

## 2024-05-13 10:40:52 - issues channel

**liam**

Yes, use `strategy.context`

---

## 2024-05-13 10:40:33 - issues channel

**Adrian**

Soo, I don't know if this is intended behaviour or not, but it seems like market.context is shared across all strategies? Reason i ask is, when I set a flag on strategy one after placing a bet (market.context['bet_placed'] = True), my other strategies can access that flag (they stop placing bets if market.context['bet_placed']). Is that to be expected?

---

## 2024-05-13 10:32:06 - issues channel

**Johnny**

```"/home/xxx/anaconda3/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 47, in request\n    check_status_code(response)\n  File \"/home/xxx/anaconda3/lib/python3.11/site-packages/betfairlightweight/utils.py\", line 37, in check_status_code\n    raise StatusCodeError(response.status_code)\nbetfairlightweight.exceptions.StatusCodeError: Status code error: 404", "client": "APIClient", "trading_function": "account.get_account_funds", "response": "Status code error: 404"}```

---

## 2024-05-10 20:00:11 - issues channel

**JL**

thank you, I'll do some further testing. The strategy is executing a limit order on the best available back/lay

---

## 2024-05-10 01:09:00 - strategies channel

**Adrian**

Ok so reflecting on your posts, thanks for the input everyone.



> filter out the 'bad' ones when you have enough data

I thought for sure this would be committing the cardinal sin of 'backfitting' - retrospectively selecting only the good bets. Does this have any predictive value?



Actually, this is what's tying me up at the moment. My strategy for discovering how to implement my model involves adjusting the parameters of execution such that the resulting backtest profit is optimised. I feel like this is breaking some kind of statistical rule of thumb?



E.g. scientifically, you propose a hypothesis - 'laying at odds of 2 at t-10 will produce the highest EV'. The backtest shows a marginal profit, then you adjust to t-9, t-8 etc to squeeze the most EV out, moving away from the original hypothesis you chose. Is that acceptable?

---

## 2024-05-09 15:33:14 - issues channel

**NAS**

my bots went down earlier today due to the maintenance and when this happens flumine fails to reconnect, seems there's an issue with the keep_alive worker? checking code seems to suggest it should always attempt a new login if theres an issue with the sessions?



`2024-05-09 13:23:24,033 - flumine.clients.betfairclient - ERROR - BetfairClient `keep_alive` error`

`Traceback (most recent call last):`

  `File ".../flumine/clients/betfairclient.py", line 44, in keep_alive`

    `return self.betting_client.keep_alive()`

           `^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^`

  `File ".../betfairlightweight/endpoints/keepalive.py", line 30, in __call__`

    `(response, response_json, elapsed_time) = self.request(session=session)`

                                              `^^^^^^^^^^^^^^^^^^^^^^^^^^^^^`

  `File ".../betfairlightweight/endpoints/keepalive.py", line 60, in request`

    `self._error_handler(response_json)`

  `File ".../betfairlightweight/endpoints/keepalive.py", line 67, in _error_handler`

    `raise self._error(response)`

`betfairlightweight.exceptions.KeepAliveError: API keepAlive FAIL: NO_SESSION`

`2024-05-09 13:23:24,038 - flumine.worker - ERROR - Error in BackgroundWorker keep_alive: 'NoneType' object has no attribute 'status'`

`Traceback (most recent call last):`

  `File ".../flumine/worker.py", line 66, in run`

    `self.function(`

  `File "..../flumine/worker.py", line 106, in keep_alive`

    `if resp is True or resp.status == "SUCCESS":`

                       `^^^^^^^^^^^`

`AttributeError: 'NoneType' object has no attribute 'status'`

---

## 2024-05-09 10:28:58 - general channel

**liam**

Not sure I understand the logic in not building on a already proven profitable strategy, anything can be automated

---

## 2024-05-09 06:44:02 - general channel

**rmwesley**

I think I'm explaining myself badly, apologies :joy: I'm not interested in porting my current system to flumine. I'd like to start from scratch and build something completely new. I was hoping to short circuit a few years of trial-and-error by starting to back-test systems using a general approach which was battle proven in flumine, e.g. either what I call a statistical approach (e.g. purely using historic race data to optimise a target variable like ROI), or a classic technical analysis approach (e.g. finding head-and-shoulders patterns), or a price action approach (betting / laying into support/resistance levels etc.), or something else?



Thanks if you have had the strength to read this far.

---

## 2024-05-08 22:07:35 - general channel

**birchy**

[@U04M35GKUMP](@U04M35GKUMP) So having briefly read this thread, it seems to me that you have 2 things going on: 1. You want to automate your routine of choosing bets to place, and 2. You want to automate placement of said bets? Flumine will handle the latter, but you'll probably need to supply it with your bet selections. Basically, if your bets are chosen by using market data or external 'live' data feeds, then you can do all of that in Flumine. If your strategy is not time sensitive, i.e. you preprocess some third party sources, then (to me) that's a separate project where you create a list of bets and execute them using Flumine.

---

## 2024-05-08 21:42:13 - general channel

**rmwesley**

I have a [non-flumine] system which is labour intensive and only allows me to evaluate a couple of races per day. If I increase my stakes it gets a bit volatile. Therefore, I wanted to change tack and give flumine a crack. My existing system won't port to flumine, so was trying to figure out something entirely new with a more systematic, codified approach. I'm OK coding in python, building ML models etc. but was wondering if this approach bore fruit for others. Or if it didn't, what type of approach did. Hopefully that makes sense.

---

## 2024-05-08 13:36:51 - strategies channel

**Adrian**

When you start a new strategy and see this:

```1. Back	1.99	5.00	-5.00 Lost

1. Back	2.68	5.00	-5.00 Lost

1. Back	1.98	5.00	-5.00 Lost

1. Back	5.90	5.00	-5.00 Lost

4. Back	2.20	5.00	-5.00 Lost

1. Back	1.97	5.00	-5.00 Lost

6. Back	2.59	5.00	-5.00 Lost```

:dotted_line_face:

---

## 2024-05-07 09:53:11 - issues channel

**liam**

strategy__name or similiar

---

## 2024-05-07 09:38:07 - issues channel

**Adrian**

df_strategies['strategy_name']

df['trade__strategy']

---

## 2024-05-07 09:35:34 - issues channel

**liam**

Did that get renamed to `strategy_name`?

---

## 2024-05-07 09:32:59 - issues channel

**Adrian**

Ok yep, got it to the next step. It runs the first cell but encounters KeyError: 'name' in the second cell :

`df = pd.merge(df, df_strategies, left_on="trade__strategy", right_on="name", how="left")`

There's no 'name' column in any of the dataframes

---

## 2024-05-07 07:47:04 - issues channel

**Adrian**

Is this supposed to do something other than load up the Jupyter launcher screen?

[https://github.com/betcode-org/flumine/blob/master/examples/controls/jupyterloggingcontrol.py](https://github.com/betcode-org/flumine/blob/master/examples/controls/jupyterloggingcontrol.py)

I put it in my backtest like this:

```control = jupyterloggingcontrol.JupyterLoggingControl()

...

framework.add_strategy(strategy)

framework.add_logging_control(control)



framework.run()

control.launch()```

The backtest runs fine but when control.launch() opens up JL it just sits at the launcher screen doing nothing. There is no /tmp/orders.json output anywhere either

---

## 2024-05-06 13:36:55 - general channel

**Adrian**

Single market:

&gt;        1044 function calls (1041 primitive calls) in 0.001 seconds

&gt; 

&gt;    Ordered by: standard name

&gt; 

&gt;    ncalls  tottime  percall  cumtime  percall filename:lineno(function)

&gt;         8    0.000    0.000    0.000    0.000 &lt;frozen genericpath&gt;:121(_splitext)

&gt;         8    0.000    0.000    0.000    0.000 &lt;frozen posixpath&gt;:117(splitext)

&gt;         8    0.000    0.000    0.000    0.000 &lt;frozen posixpath&gt;:140(basename)

&gt;         8    0.000    0.000    0.000    0.000 &lt;frozen posixpath&gt;:41(_get_sep)

&gt;        24    0.000    0.000    0.000    0.000 &lt;frozen posixpath&gt;:52(normcase)

&gt;         1    0.000    0.000    0.001    0.001 &lt;string&gt;:1(&lt;module&gt;)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1087(flush)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1098(emit)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:123(getLevelName)

&gt;         2    0.000    0.000    0.000    0.000 __init__.py:1319(disable)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1479(info)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1561(findCaller)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1595(makeRecord)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1610(_log)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1636(handle)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:164(&lt;lambda&gt;)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1690(callHandlers)

&gt;         2    0.000    0.000    0.000    0.000 __init__.py:1720(getEffectiveLevel)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:1734(isEnabledFor)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:183(dumps)

&gt;        24    0.000    0.000    0.000    0.000 __init__.py:194(_is_internal_frame)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:2223(handle)

&gt;         2    0.000    0.000    0.000    0.000 __init__.py:228(_acquireLock)

&gt;         2    0.000    0.000    0.000    0.000 __init__.py:237(_releaseLock)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:292(__init__)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:368(getMessage)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:606(formatTime)

&gt;        16    0.000    0.000    0.000    0.000 __init__.py:815(filter)

&gt;        16    0.000    0.000    0.000    0.000 __init__.py:922(acquire)

&gt;        16    0.000    0.000    0.000    0.000 __init__.py:929(release)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:942(format)

&gt;         8    0.000    0.000    0.000    0.000 __init__.py:965(handle)

&gt;         1    0.000    0.000    0.000    0.000 accountresources.py:17(__init__)

&gt;         5    0.000    0.000    0.000    0.000 baseclient.py:101(transaction_count_total)

&gt;         5    0.000    0.000    0.000    0.000 baseclient.py:120(info)

&gt;         5    0.000    0.000    0.000    0.000 baseclient.py:87(username)

&gt;         5    0.000    0.000    0.000    0.000 baseclient.py:94(current_transaction_count_total)

&gt;         2    0.000    0.000    0.000    0.000 baseexecution.py:156(shutdown)

&gt;         2    0.000    0.000    0.000    0.000 baseflumine.py:124(log_control)

&gt;         1    0.000    0.000    0.000    0.000 baseflumine.py:128(_add_default_workers)

&gt;         1    0.000    0.000    0.000    0.000 baseflumine.py:401(_process_end_flumine)

&gt;         2    0.000    0.000    0.000    0.000 baseflumine.py:404(info)

&gt;         2    0.000    0.000    0.000    0.000 baseflumine.py:412(&lt;listcomp&gt;)

&gt;         1    0.000    0.000    0.000    0.000 baseflumine.py:417(__enter__)

&gt;         1    0.000    0.000    0.000    0.000 baseflumine.py:445(__exit__)

&gt;         1    0.000    0.000    0.000    0.000 baseresource.py:11(__init__)

&gt;         5    0.000    0.000    0.000    0.000 clientcontrols.py:108(current_transaction_count_total)

&gt;         5    0.000    0.000    0.000    0.000 clientcontrols.py:112(transaction_count_total)

&gt;         1    0.000    0.000    0.000    0.000 clients.py:56(login)

&gt;         1    0.000    0.000    0.000    0.000 clients.py:66(logout)

&gt;         1    0.000    0.000    0.000    0.000 clients.py:71(update_account_details)

&gt;         1    0.000    0.000    0.000    0.000 clients.py:76(simulated)

&gt;         2    0.000    0.000    0.000    0.000 clients.py:84(info)

&gt;         2    0.000    0.000    0.000    0.000 clients.py:86(&lt;dictcomp&gt;)

&gt;         6    0.000    0.000    0.000    0.000 clients.py:87(&lt;dictcomp&gt;)

&gt;         1    0.000    0.000    0.000    0.000 clients.py:94(__len__)

&gt;         8    0.000    0.000    0.000    0.000 encoder.py:105(__init__)

&gt;         7    0.000    0.000    0.000    0.000 encoder.py:161(default)

&gt;         8    0.000    0.000    0.000    0.000 encoder.py:183(encode)

&gt;         8    0.000    0.000    0.000    0.000 encoder.py:205(iterencode)

&gt;        11    0.000    0.000    0.000    0.000 enum.py:1255(value)

&gt;        11    0.000    0.000    0.000    0.000 enum.py:193(__get__)

&gt;         2    0.000    0.000    0.000    0.000 events.py:39(__init__)

&gt;         7    0.000    0.000    0.000    0.000 inspect.py:456(istraceback)

&gt;         8    0.000    0.000    0.000    0.000 jsonlogger.py:176(add_fields)

&gt;         8    0.000    0.000    0.000    0.000 jsonlogger.py:193(_perform_rename_log_fields)

&gt;         8    0.000    0.000    0.000    0.000 jsonlogger.py:198(process_log_record)

&gt;         8    0.000    0.000    0.000    0.000 jsonlogger.py:205(jsonify_log_record)

&gt;         8    0.000    0.000    0.000    0.000 jsonlogger.py:213(serialize_log_record)

&gt;         8    0.000    0.000    0.000    0.000 jsonlogger.py:217(format)

&gt;         8    0.000    0.000    0.000    0.000 jsonlogger.py:28(merge_record_extra)

&gt;         7    0.000    0.000    0.000    0.000 jsonlogger.py:59(default)

&gt;         4    0.000    0.000    0.000    0.000 markets.py:54(markets)

&gt;         2    0.000    0.000    0.000    0.000 markets.py:58(open_market_ids)

&gt;         2    0.000    0.000    0.000    0.000 markets.py:60(&lt;listcomp&gt;)

&gt;         2    0.000    0.000    0.000    0.000 markets.py:69(__iter__)

&gt;         2    0.000    0.000    0.000    0.000 markets.py:72(__len__)

&gt;         8    0.000    0.000    0.000    0.000 process.py:189(name)

&gt;         8    0.000    0.000    0.000    0.000 process.py:37(current_process)

&gt;         1    0.000    0.000    0.000    0.000 simulatedclient.py:18(login)

&gt;         1    0.000    0.000    0.000    0.000 simulatedclient.py:24(logout)

&gt;         1    0.000    0.000    0.000    0.000 simulatedclient.py:27(update_account_details)

&gt;         1    0.000    0.000    0.001    0.001 simulation.py:29(run)

&gt;         1    0.000    0.000    0.000    0.000 strategy.py:142(finish)

&gt;         1    0.000    0.000    0.000    0.000 strategy.py:286(start)

&gt;         1    0.000    0.000    0.000    0.000 strategy.py:298(finish)

&gt;         2    0.000    0.000    0.000    0.000 strategy.py:306(__iter__)

&gt;         1    0.000    0.000    0.000    0.000 strategy.py:96(start)

&gt;         1    0.000    0.000    0.000    0.000 streams.py:254(start)

&gt;         1    0.000    0.000    0.000    0.000 streams.py:263(stop)

&gt;         4    0.000    0.000    0.000    0.000 streams.py:271(__iter__)

&gt;         2    0.000    0.000    0.000    0.000 thread.py:216(shutdown)

&gt;         2    0.000    0.000    0.000    0.000 threading.py:1125(_wait_for_tstate_lock)

&gt;         8    0.000    0.000    0.000    0.000 threading.py:1152(name)

&gt;         2    0.000    0.000    0.000    0.000 threading.py:1192(is_alive)

&gt;         8    0.000    0.000    0.000    0.000 threading.py:1453(current_thread)

&gt;         2    0.000    0.000    0.000    0.000 threading.py:1501(enumerate)

&gt;         4    0.000    0.000    0.000    0.000 threading.py:575(is_set)

&gt;         2    0.000    0.000    0.000    0.000 threading.py:931(__repr__)

&gt;         1    0.000    0.000    0.000    0.000 utils.py:31(__enter__)

&gt;         1    0.000    0.000    0.000    0.000 utils.py:37(__exit__)

&gt;        16    0.000    0.000    0.000    0.000 {built-in method _thread.get_ident}

&gt;         1    0.000    0.000    0.001    0.001 {built-in method builtins.exec}

&gt;        53    0.000    0.000    0.000    0.000 {built-in method builtins.hasattr}

&gt;        61    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}

&gt;         8    0.000    0.000    0.000    0.000 {built-in method builtins.iter}

&gt;       8/5    0.000    0.000    0.000    0.000 {built-in method builtins.len}

&gt;        40    0.000    0.000    0.000    0.000 {built-in method posix.fspath}

&gt;         8    0.000    0.000    0.000    0.000 {built-in method posix.getpid}

&gt;         8    0.000    0.000    0.000    0.000 {built-in method sys._getframe}

&gt;         8    0.000    0.000    0.000    0.000 {built-in method time.gmtime}

&gt;         8    0.000    0.000    0.000    0.000 {built-in method time.strftime}

&gt;         8    0.000    0.000    0.000    0.000 {built-in method time.time}

&gt;         4    0.000    0.000    0.000    0.000 {built-in method utcnow}

&gt;         2    0.000    0.000    0.000    0.000 {method '__exit__' of '_thread.RLock' objects}

&gt;         2    0.000    0.000    0.000    0.000 {method '__exit__' of '_thread.lock' objects}

&gt;        18    0.000    0.000    0.000    0.000 {method 'acquire' of '_thread.RLock' objects}

&gt;         2    0.000    0.000    0.000    0.000 {method 'acquire' of '_thread.lock' objects}

&gt;         1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

&gt;         8    0.000    0.000    0.000    0.000 {method 'flush' of '_io.TextIOWrapper' objects}

&gt;        94    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects}

&gt;        25    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}

&gt;         8    0.000    0.000    0.000    0.000 {method 'join' of 'str' objects}

&gt;         1    0.000    0.000    0.000    0.000 {method 'pop' of 'dict' objects}

&gt;         2    0.000    0.000    0.000    0.000 {method 'put' of '_queue.SimpleQueue' objects}

&gt;        18    0.000    0.000    0.000    0.000 {method 'release' of '_thread.RLock' objects}

&gt;        24    0.000    0.000    0.000    0.000 {method 'rfind' of 'str' objects}

&gt;        37    0.000    0.000    0.000    0.000 {method 'startswith' of 'str' objects}

&gt;        16    0.000    0.000    0.000    0.000 {method 'update' of 'collections.OrderedDict' objects}

&gt;         6    0.000    0.000    0.000    0.000 {method 'values' of 'dict' objects}

&gt;         8    0.000    0.000    0.000    0.000 {method 'write' of '_io.TextIOWrapper' objects}

---

## 2024-05-06 13:22:27 - general channel

**Adrian**

Ahh ok i looked up cprofilev but I'm not familiar with it

Yes i just ran the same strategy on a single day to generate a whole log (if you still want it) and it was at least 100 times faster than loading the whole month

---

## 2024-05-06 13:14:17 - general channel

**Adrian**

Sure, thanks for checking it out

&gt; {"asctime": "2024-05-06 12:11:19,275", "levelname": "INFO", "message": "Removing market 1.227403968", "clients": {"Betfair": {}, "Simulated": {"34jhdr5": {"username": “34jhdr5”, "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 1, "transaction_count_total": 1, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x15fcf0950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 6, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 7997365952)&gt;"]}

&gt; {"asctime": "2024-05-06 12:11:19,275", "levelname": "INFO", "message": "Completed historical market '/Users/adrian/Projects/betfair/data/historic/PRO/2024/Apr/11/33180336/1.227403968.decompressed'"}

&gt; {"asctime": "2024-05-06 12:11:19,275", "levelname": "INFO", "message": "Starting historical market '/Users/adrian/Projects/betfair/data/historic/PRO/2024/Apr/11/33180336/1.227403983.decompressed'", "market": "/Users/adrian/Projects/betfair/data/historic/PRO/2024/Apr/11/33180336/1.227403983.decompressed"}

&gt; {"asctime": "2024-05-06 12:11:19,275", "levelname": "INFO", "message": "[Register: 7000]: marketSubscription"}

&gt; {"asctime": "2024-05-06 12:11:19,275", "levelname": "INFO", "message": "[MarketStream: 7000]: \"MarketStream\" created"}

&gt; {"asctime": "2024-05-06 12:11:19,279", "levelname": "INFO", "message": "[MarketStream: 7000]: 1.227403983 added, 1 markets in cache"}

&gt; {"asctime": "2024-05-06 12:11:19,280", "levelname": "INFO", "message": "[MarketStream: 7000]: 1.227403983 added, 1 markets in cache"}

&gt; {"asctime": "2024-05-06 12:11:19,280", "levelname": "INFO", "message": "[MarketStream: 7000]: 1.227403983 added, 1 markets in cache"}

&gt; {"asctime": "2024-05-06 12:11:19,280", "levelname": "INFO", "message": "[MarketStream: 7000]: 1.227403983 added, 1 markets in cache"}

&gt; {"asctime": "2024-05-06 12:11:19,289", "levelname": "INFO", "message": "Adding: 1.227403983 to markets"}

&gt; {"asctime": "2024-05-06 12:11:19,290", "levelname": "INFO", "message": "Execution new hour", "current_transaction_count_total": 1, "current_transaction_count": 1, "current_failed_transaction_count": 0, "total_transaction_count": 1, "total_failed_transaction_count": 0, "client": {"username": "41f95cae", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 1, "transaction_count_total": 1, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x15fcf0950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}

---

## 2024-05-05 19:55:41 - strategies channel

**Dave**

I will check out bflw speed, thanks Liam. I ran profiler when backtesting which helped a lot with optimization within the callbacks, but obviously tells you about nothing network related. I'm basically seeing typically around 10millis between the update's publish time and me asking flumine to place an order. I know my logic is no more than around 1.5ms, so I'm wondering how the rest of the 8-9ms is distributed.

---

## 2024-05-05 19:50:07 - strategies channel

**liam**

Just load up a profiler and have a look.



I assume you are using bflw speed? After the network JSON decoding is slow but not much we can do about that, the streaming logic is heavily optimised (for python) but creating the python objects in bflw is the slow part however flumine does some clever stuff to try and limit/remove it. The ‘tick to trade’ code within flumine itself is very minimal and normally rounds to zero relative to what happens within a strategy. 

---

## 2024-05-05 13:26:55 - strategies channel

**Justice**

The people who develop these models are incredibly smart but know nothing about gambling. The price is by far the most important thing to consider. Also, especially in horse racing, I'd say the hardest aspect to overcome is the quality and richness of the data

---

## 2024-05-05 09:46:09 - strategies channel

**foxwood**

I'm sure lots of people will keep trying that path without regard to the fact of how many subtle errors happen in chatGPT's day job. At the other extreme I get 98% accuracy from my models when I leave the target in the dataset :upside_down_face:

---

## 2024-05-05 09:42:11 - strategies channel

**Rob**

For pandas this is very inefficient, but I very much subscribe to worrying about things that materialise. e.g. [https://stackify.com/premature-optimization-evil/](https://stackify.com/premature-optimization-evil/)



Compute is so cheap, we often don't need to worry about optimisation.

---

## 2024-05-05 09:06:40 - strategies channel

**Justice**

[@UC70576CB](@UC70576CB) My strategy doesn't seem to be overly sensitive to latency from my testing. All my feature engineering is done with polars, I much prefer it over pandas

---

## 2024-05-05 09:03:50 - strategies channel

**Rob**

Do you have any performance issues to worry about? If not, reusing the feature engineering code you used to build the strategy is a much bigger benefit IMHO, as there are so many edge cases to test if you reimplement processing.



If you need a more performant dataframe, consider [https://pola.rs/](https://pola.rs/)

---

## 2024-05-04 10:20:34 - strategies channel

**Justice**

Does anyone on here have any insights into migrating potentially hundreds of features created on a dataframe into a live production scenario, especially within the context of a flumine strategy? E.g. rolling windows, moving averages etc.

---

## 2024-05-04 09:52:48 - general channel

**foxwood**

I patch the hash once the BaseStrategy constructor has run and get values like "stratABCxxxxx-139340382301022140". Code at end of MyStrategy.add(...) shown below. This lets you identify the strat in the blotter and leaving the tail in place separates instances of the strat if required. Only works if you use a unique top level class name for each strat.

EDIT: this was my solution when first using flumine. Having now found out about config I'd probably go that route.

```self.ctxname = self.__class__.__name__

self.name_hash = self.__class__.__name__\

                 + "x"*(STRATEGY_NAME_HASH_LENGTH-len(self.__class__.__name__))```

---

## 2024-05-03 18:44:29 - general channel

**Bruno**

my goal is for them to be selectively visible. my question is what determines the visibility - I think it’s the (hash of the) supplied strategy class name

---

## 2024-05-03 18:43:35 - general channel

**Dave**

change customer_strategy_ref in flumine.config and your processes will only see their own orders (because they specify the strategy ref when subscribing to the order stream)

---

## 2024-05-03 16:32:58 - general channel

**Bruno**

self_orders is not defined in the global scope, it is only defined locally.

strategy_selection_orders returns orders when I pass it the fake strategy, but not the blotterwatch strategy. I believe this is because the strategy is also called ML_strategy in the other process.

```from flumine import Flumine, clients, BaseStrategy

import logging

import betfairlightweight

from credentials import username, password, app_key

from default_config import *

from config import *

import os

# from subprocess import Popen

from betfairlightweight.filters import streaming_market_filter



logging.basicConfig(filename='strategy.log', level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO), format='%(asctime)s:%(levelname)s:%(message)s')

trading = betfairlightweight.APIClient(username, password, app_key, "./certs")

client = clients.BetfairClient(trading)



bought_markets = []

# max_markets=1



framework = Flumine(client=client)



class ML_strategy(BaseStrategy):

    pass





class BlotterWatcher(BaseStrategy):

    def start(self):

        print('BlotterWatcher started')

    def check_market_book(self, market, market_book):

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True

    def process_market_book(self, market, market_book):

        self_orders=market.blotter.strategy_orders(strategy=self)

        fakestrat_orders=market.blotter.strategy_orders(strategy=fakestrat)

        if self_orders:

            print('Self orders:',self_orders)

        if fakestrat_orders:

            print('Fakestrat orders:',fakestrat_orders)



filter=streaming_market_filter(

        event_type_ids=["7"],

        market_types=["WIN"],

    )



strategy = BlotterWatcher(market_filter=filter)

fakestrat=ML_strategy(market_filter=filter)

framework.add_strategy(strategy)

framework.add_strategy(fakestrat)

framework.run()```

---

## 2024-05-03 15:11:21 - general channel

**Bruno**

Hi Liam,



I think you may have misunderstood my question a bit, perhaps I did not make myself very clear.



please consider this MWE



```filter=streaming_market_filter(

        event_type_ids=["7"],

        market_types=["WIN"],

    )



class ML_strategy(BaseStrategy):

    pass

fakestrat=ML_strategy(market_filter=filter)



class BlotterWatcher(BaseStrategy):

    def start(self):

        print('BlotterWatcher started')

    def check_market_book(self, market, market_book):

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True

    def process_market_book(self, market, market_book):

        self_orders=market.blotter.strategy_orders(strategy=self)

        fakestrat_orders=market.blotter.strategy_orders(strategy=fakestrat)

        if self_orders:

            print('Self orders:',self_orders)

        if fakestrat_orders:

            print('Fakestrat orders:',fakestrat_orders)



strategy=BlotterWatcher(market_filter=filter)

framework.add_strategy(strategy)

framework.add_strategy(fakestrat)

framework.run()```

I have a strategy, _also called ML_strategy,_ running _in another process_.



this "blotter watch script" only prints out orders from fakestrat, not from self. contrary to what you said, I believe this is because the strategies share a class name, and the hostname is not the answer to my question. many thanks for your speedy reply and thank you for making an attempt to answer my question.



Many Thanks,



Bruno

---

## 2024-05-03 14:39:01 - general channel

**Bruno**

ok cool, so when I had 2 seperate instances of flumine running on the same machinec were their orders visible to each other through blotter.strategy_orders because the class names were the same?

---

## 2024-05-03 14:36:39 - general channel

**Bruno**

is this for `blotter.client_orders` or `blotter.strategy_orders`?

---

## 2024-05-03 14:03:41 - general channel

**Bruno**

when I ran two strategies with the same name, it seemed they could see each others' orders, whereas once I changed the name of the classes this seemed to stop. is this related to strategy.name_hash?

---

## 2024-05-03 13:55:41 - general channel

**Bruno**

hi, when we create a trade I understand that we need to pass an instance of a strategy class, and then later we can access the orders unique to that strategy using blotter.strategy_orders and similar, however my question is what aspect of the class exactly determines this uniqueness - is it the memory location of the class, the name of the class, the hash of the class, or have i misunderstood the scenario? in short, I want to run multiple instances of flumine and selectively reference orders between the instances, but I'm struggling to work out how I can achieve that

---

## 2024-05-03 00:05:10 - general channel

**Adrian**

Making $300 seems like a far off dream. But I'm confident my model has a positive expectation because i can beat bsp with a few tweaks, so being unrealistic i can imagine making thousands! Of course there is a reality called execution to deal with first

---

## 2024-05-02 22:04:01 - general channel

**Jonjonjon**

How do you know that your model has a positive expectation?

---

## 2024-05-02 16:38:39 - general channel

**Johnny**

With an untested model, offering prices screams adverse selection risk

---

## 2024-05-02 14:32:07 - general channel

**Adrian**

i know everyones going to scream at me again to go buy data or just run a simple strategy but $300 for a month of data is way out of my budget and every single "simple strategy" i have run ever has cost me an arm or leg

---

## 2024-05-02 14:13:45 - general channel

**Adrian**

the model gives each runner a probability of winning and they all sum to one

---

## 2024-05-02 13:46:41 - general channel

**Adrian**

there was a betfair guide floating around somewhere- how to build an ML model for greyhounds. i think he had something like 32% win rate prediction? could he find value with that model? I'm thinking that some of his predictions would be accurate and that sometimes those winners would be mispriced

---

## 2024-05-02 13:45:03 - random channel

**JL**

[@U4H19D1D2](@U4H19D1D2) oh I misunderstood. I meant the actual computation of EV using your predicted probability and the odds available. So just a better predictive model, got it

---

## 2024-05-02 13:39:08 - general channel

**Mo**

If you’re not getting value then your model needs improving

---

## 2024-05-02 10:59:55 - random channel

**liam**

But if you want the pain you can get your clients from within a strategy using `self.clients`

---

## 2024-05-02 10:57:26 - random channel

**liam**

In my experience its far more valuable (and profitable) to improve your EV calculation and work off a variation of kelly with a fixed balance

---

## 2024-05-02 10:49:18 - random channel

**liam**

What are you trying to do? Kelly is for optimising bet size using ev however in betting markets ev is so dependant on bet size/capacity that it has limits

---

## 2024-05-02 10:46:58 - random channel

**JL**

I'm guessing it's because of the chance of only getting partially filled? right now it works because I'm using a large fraction for fractional Kelly

---

## 2024-05-02 10:43:34 - random channel

**JL**

yeah I'm using the Kelly criterion

---

## 2024-05-02 10:39:42 - random channel

**liam**

I am questioning why you would want to know your balance from within a strategy 

---

## 2024-05-02 08:17:27 - strategies channel

**liam**

In bflw



```trading.scores.list_race_details(meeting_ids=['29162687'])



trading.scores.list_race_details(race_ids=['29162687.1430'])```

---

## 2024-05-01 20:21:03 - general channel

**Dave**

If I'd like to override customer_strategy_ref, is it just a matter of setting config.customer_strategy_ref before instantiating Flumine? I'd like to run multiple flumine instances on a single machine, and don't want instances becoming confused because of the same customer_strategy_ref they see in the order stream. (And I'd like to run multiple instances to use the multiple cores on the host in question)

---

## 2024-04-25 21:18:05 - issues channel

**Ammar**

It looks to me like there’s an unexpected response type (as `None`) which is coming thru from the call stack — which looks entirely plausible as I read thru the code all the way back to `betfairlightweight`



to be clear, this isn’t impacting the data stream; but it does look like very unhappy noise in the logs, which is never nice :)



steps to replicate:

• leave the market recorder going on one machine — this is _all_ I’m using flumine for, it’s a single process which I kick off each day.  (currently on a laptop, behind expressVPN, which may be a noteworthy point) 

• use betfair to manually execute and check markets via the mobile app, and other computers

• over the course of 8-10 hours the error will start to present



the fix could be very light in the keepalive (similar to how it’s handling a failure already)





```def keep_alive(context: dict, flumine) -&gt; None:

    """Attempt keep alive if required or

    login if keep alive failed

    """

    for client in flumine.clients:

        if client.EXCHANGE == ExchangeType.BETFAIR:

            if client.betting_client.session_token:

                resp = client.keep_alive()



                # start change

                if resp is None:  # this is the unexpected response type I'm seeing

                    client.login()

                # end chage



                if resp is True or resp.status == "SUCCESS":

                    continue

        elif client.EXCHANGE == ExchangeType.BETCONNECT:

            resp = client.keep_alive()

            if resp:

                continue

        # keep-alive failed lets try a login

        client.login()```

---

## 2024-04-25 10:54:44 - issues channel

**Ammar**

```

{"asctime": "2024-04-24 21:20:22,236", "levelname": "ERROR", "message": "BetfairClient `keep_alive` error", "exc_info": "Traceback (most recent call last):

File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/flumine/clients/betfairclient.py\", line 44, in keep_alive

return self.betting_client.keep_alive()

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/keepalive.py\", line 30, in __call__

(response, response_json, elapsed_time) = self.request(session=session)

                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                           File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/keepalive.py\", line 60, in request

                               self._error_handler(response_json)

                                 File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/keepalive.py\", line 67, in _error_handler

                                     raise self._error(response)

                                     betfairlightweight.exceptions.KeepAliveError: API keepAlive FAIL: NO_SESSION", "client": "APIClient", "trading_function": "keep_alive", "response": "API keepAlive FAIL: NO_SESSION"}





{"asctime": "2024-04-24 21:20:22,240", "levelname": "ERROR", "message": "Error in BackgroundWorker keep_alive: 'NoneType' object has no attribute 'status'", "exc_info": "Traceback (most recent call last):

File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/flumine/worker.py\", line 66, in run

self.function(

File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/flumine/worker.py\", line 106, in keep_alive

if resp is True or resp.status == \"SUCCESS\":

^^^^^^^^^^^

AttributeError: 'NoneType' object has no attribute 'status'", "worker_name": "keep_alive", "function": "[function keep_alive at 0x1041e99e0](function keep_alive at 0x1041e99e0)", "context": {}}```



---

raw json format from the logger

```{"asctime": "2024-04-24 21:02:11,658", "levelname": "ERROR", "message": "BetfairClient `account.get_account_details` error", "exc_info": "Traceback (most recent call last):\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/flumine/clients/betfairclient.py\", line 84, in _get_account_details\n    return self.betting_client.account.get_account_details()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/account.py\", line 54, in get_account_details\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 54, in request\n    self._error_handler(response_json, method, params)\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 80, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: AccountAPING/v1.0/getAccountDetails \nParams: {} \nException: None \nError: {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}}, 'id': 1}", "client": "APIClient", "trading_function": "account.get_account_details", "response": "AccountAPING/v1.0/getAccountDetails \nParams: {} \nException: None \nError: {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}}, 'id': 1}"}

{"asctime": "2024-04-24 21:02:11,762", "levelname": "ERROR", "message": "BetfairClient `account.get_account_funds` error", "exc_info": "Traceback (most recent call last):\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/flumine/clients/betfairclient.py\", line 98, in _get_account_funds\n    return self.betting_client.account.get_account_funds()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/account.py\", line 35, in get_account_funds\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 54, in request\n    self._error_handler(response_json, method, params)\n  File \"/Users/user/.virtualenvs/b2023/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 80, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: AccountAPING/v1.0/getAccountFunds \nParams: {} \nException: None \nError: {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}}, 'id': 1}", "client": "APIClient", "trading_function": "account.get_account_funds", "response": "AccountAPING/v1.0/getAccountFunds \nParams: {} \nException: None \nError: {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}}, 'id': 1}"}```

---

## 2024-04-25 10:36:57 - general channel

**Jorge**

I'll set a different customerStrategyRef in each of them to avoid this in the future

---

## 2024-04-25 10:20:30 - general channel

**liam**

flumine separates using the hostname (customerStrategyRef) which is what is probably causing your issues

---

## 2024-04-25 10:16:03 - general channel

**Jorge**

Which is affecting market.blotter.get_exposures() and making my strategy enter into a loop of replacing the same order again

---

## 2024-04-25 10:14:55 - general channel

**Jorge**

I think my Strategy is saving completed orders which are not sent by the Strategy (I know this because the context in those orders is empty, whereas it would be filled for my own orders)

---

## 2024-04-25 10:10:17 - general channel

**Jorge**

I didn't restart the framework in this case. Could it be because those orders are sent to the same market by a different flumine Strategy?

---

## 2024-04-25 10:01:56 - general channel

**Jorge**

Hi guys, I am recently getting a lot of "Order XXX not present in blotter" in my flumine Strategy. What do these mean?

---

## 2024-04-23 13:08:49 - strategies channel

**ShaunW**

You might be right James, things change.  I subscribed to half a dozen and ran tests, AWS came out on top. But if AWS is good enough for Netflix and NASA then it's certainly good enough for my a little betting system.

---

## 2024-04-19 07:30:18 - strategies channel

**Fab**

Andrew, it depends on how complex (so CPU-intensive) your strategy calculations are.



Start with a 1CPU 2GB machine then scale up if needed.

---

## 2024-04-18 22:29:02 - general channel

**Fab**

Noob question...



I'm simulating a strategy that places a lay bet then cancels any unmatched size after 30 seconds.



When using a lay stake of £1, the order profit appears in the blotter. When using a lay stake of £3 on exactly the same market, the order profit does not appear at all.



*Question: assuming that a £1 bet is fully matched, shouldn't at least £1 being matched on a £3 bet? Or perhaps the simulator treats £3 as "not matched at all"?*



```# How I run the simulation

framework = FlumineSimulation(client=client)

framework.add_strategy(strategy)

framework.run()



for market in framework.markets:

    for order in market.blotter:

        if order.average_price_matched &gt; 0:

            print(order.profit)```

```# Bet placing

stake = 1

order = trade.create_order(side = "LAY", order_type = LimitOrder(price=lay_odds, stake))

market.place_order(order)```

```# Bet canceling

for order in orders:

    if order.status == OrderStatus.EXECUTABLE:

        if order.size_remaining &gt; 0 and order.elapsed_seconds and order.elapsed_seconds &gt;= 30:

            market.cancel_order(order)```

---

## 2024-04-18 21:45:19 - general channel

**JL**

this one! [@U9JHLMZB4](@U9JHLMZB4)

[https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L100](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L100)

---

## 2024-04-18 19:43:34 - general channel

**Ralegh**

You’d need to read up on linear programming- the gist is you’ve got some variables (how much you bet on each selection) and you want to pick the best combination of values for those variables based on some criteria. In this case you want to minimize your exposure (make your worst case profit/loss as high as it can be). You could write a function to brute force this - calculate your new exposure after hedging by betting £0,£0,£0,£0,£1, then £0,£0,£0,£1,£0, etc (for each of 5 selections). But there are known algorithms you can use if you can formulate the problem in a specific way. Once you do that you can use e.g scipy.optimize and it will come up with a solution a lot faster than brute forcing, for complex problems it may not be possible to come up with a closed form formula so linear programming is sort of smart trial and error.

---

## 2024-04-18 17:40:40 - random channel

**Justice**

I have a probabilistic model using the TPD data and biggest problem by far is the accuracy of the data...

---

## 2024-04-17 20:50:02 - random channel

**Michael**

There are many obvious shortcomings but I can totally see why they did it that way. From the perspective of their prospective customers (bookies) the most important thing is to avoid creating opportunities for arbitrage with BF. The value of the bets can be generated just by apply an over round so the model needn't be intrinsically amazing. I can also see that trying to evaluate against actual outcomes would be a nightmare, especially given that the data set is relatively small. Still, I thought it was interesting, prior to that conversation I wondered if TPD had a model that could be simply deployed to out-bet us, but then I realised that they weren't even trying to make one. Their model has to generate accurate prices for every runner from start to finish, our job is much easier because we only have to be able to point and laugh when someone else is getting it wrong. The other interesting thing was that the developer wasn't interested in botting the markets himself. If I had access to his skills and resources I'd be all over that but it just didn't seem to be his bag, he seemed to think it was futile because BF prices are true, which is sort of right and wrong at the same time.

---

## 2024-04-17 20:19:53 - random channel

**Michael**

I had an interesting conversation once with one of the TPD guys about how they developed their prices model, he had been involved in trying to improve their early version which TPD had bought from a BF user. What I learned was that their target was to develop a model who's prices matched the BF prices, in other words they just assumed the BF prices to be true and assessed their model according to how well it replicated them. They didn't consider the prospect that the BF prices might not be true at all. I thought that was just wonderful.

---

## 2024-04-17 09:22:50 - issues channel

**Ammar**

maybe a silly q (and hopefully I’ve not missed something in docs); but can you add strategies after flumine has started running, or does it have to be done before the `run()` call?



this works as usual:

```# main thread only

for s in strategies:

    framework.add_strategy(s)



framework.run()```



doesn’t seem to work - debug logging isn’t showing files being written to (but it’s just been a quick spike this morning)

```# run() on background thread

framework_thread = threading.Thread(

    name="Flumine Main",

    target=framework.run,

)

framework_thread.start()



# add strategy via main thread

for s in strategies:

    framework.add_strategy(s)```

(the strategies are just MarketRecorder from the examples with custom market filters based on relevant events, countrycodes and market_types to avoid hitting the 200 makret subscription limit which betfair seem to have)



I’ve not tried adding strategies from a background thread yet, but will do that later today.



reason for this is that I want to have one flumine instance running on my ec2, with a trickling in of football events as they are 2hours from start.



so I’ll have the events stored in RDS (which are periodically refreshed) and then have a loop which grabs relevant event_id’s to construct the market_filter going into flumine



is there a better pattern to use for something like this?

---

## 2024-04-16 13:56:44 - random channel

**Paul**

Found this [https://blog.abctaylor.com/what-would-happen-to-low-latency-trading-if-exchanges-moved-to-the-cloud/|blog thinking through what would happen if a stock market went full cloud](https://blog.abctaylor.com/what-would-happen-to-low-latency-trading-if-exchanges-moved-to-the-cloud/|blog thinking through what would happen if a stock market went full cloud) quite interesting, but interesting parallels to BF, et al. :thinking_face:  HN discussion thread is [https://news.ycombinator.com/item?id=40050717|here](https://news.ycombinator.com/item?id=40050717|here)

---

## 2024-04-16 07:35:10 - issues channel

**Clive**

During a simulation, what would be the cause of messages such as:



`flumine.strategy.runnercontext - WARNING - Trade 'a5fb009a-fb61-11ee-bde9-eb5357042996' not present in RunnerContext live_trades on reset`

---

## 2024-04-15 11:22:35 - random channel

**D C**

"aspire to be bigger than Wetherhspoons". What a depressing business model...

---

## 2024-04-14 19:56:06 - general channel

**Unknown**

If you can run win and place together, or match odds, CS and OU as one sub, you can certain run markets that aren't even active at the same time. 



But I run each market/strategy combo in its own parallel process so mixed feeds aren't as much as an issue as high update rates on one.  You just need to move your hoppers to after the sorter if you can't keep up with the input.. :wink:

---

## 2024-04-14 19:18:13 - general channel

**AndyL**

[@U0128E7BEHW](@U0128E7BEHW) this is absolutley what I do, I was consuming all my 10 connections, but I combined my US, GB and AU horse racing under 1 Flumine instance, with 3 add_strategy's, the first thing each strategy check_market_book does is return False if market not for it....

I am now running with 6 connections :slightly_smiling_face:

Just wish I could find a new profitable strategy for the remaining 4 now :man-shrugging: !

---

## 2024-04-14 15:46:02 - general channel

**Dave**

Looking at optimizing some of my market stream subscriptions. Suppose I have two strategies, one trades AU WIN horse markets, and the other trades GB WIN horse markets. If I call add_strategy twice with each of these market filters, presumably that will use two connections.



If I call add_strategy twice but each time with the filter [(AU, GB), 7, WIN] - presumably it will only use 1 connection, but presumably I'd have to add logic to discard AU ticks in my GB strategy and visa versa. Is this correct? Does anyone have any intuition of whether this brings any benefits other than just freeing up a connection?

---

## 2024-04-14 10:23:28 - strategies channel

**foxwood**

There is only one market data stream per connection which is for all markets that match the filter you supply when adding the strategy to the framework. The subscription limit you mention is only applied each time a new subscription filter is made. Once set up on the connection the market subscription will run "forever" feeding data on current and all new markets as they arise that match your filter. Once the market is closed you would normally receive no more data from BF for it. Sometimes the market is closed in error and is re-opened or has to be opened/closed again to correct WP/winner errors. So, once a market is closed (excl BF issues) that is the end and it never appears on the stream again - all flumine has to do is handle its own objects. Not sure if somewhere in that your question is answered but it's the flow I understand and lets the stream run smoothly 24/7, automatically handling opeing/closing markets.

---

## 2024-04-12 20:34:17 - strategies channel

**liam**

No, tested the optimum stakes for your strategy 

---

## 2024-04-12 19:10:00 - strategies channel

**AndyL**

&gt; Trying to find a profitable strategy, was using £15 on horses pre race

took me 2 years to find my first profitable strategy, still looking for my "second"... :joy:

---

## 2024-04-12 13:55:22 - strategies channel

**river_shah**

Use min stakes. Also read up on kelly betting and bet proportional to your edge. Use 0.5 kelly. 3/4th returns, half the variance

---

## 2024-04-12 13:52:27 - strategies channel

**James Scott**

Trying to find a profitable strategy, was using £15 on horses pre race 

---

## 2024-04-11 22:50:53 - issues channel

**Matthew Lawrence**

Hi, trying to use flumine for the first time. I'm starting off by testing an adjusted version of betfair data scientists: how to automate 2. I can see from the logging that the bets are never being matched, although they are being requested at the correct price and size. Any help would be appreciated.

```trading = betfairlightweight.APIClient('...','...!',app_key='...')

client = clients.BetfairClient(trading, interactive_login=True)



# Login

client = clients.SimulatedClient()

framework = FlumineSimulation(client=client)



# Logging

logger = logging.getLogger()

custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # Set to logging.CRITICAL to speed up simulation



class BackFavStrategy(BaseStrategy):



    # Defines what happens when we start our strategy i.e. this method will run once when we first start running our strategy

    def start(self) -&gt; None:

        print("starting strategy 'BackFavStrategy'")



    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True



    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:



        # Collect data on last price traded and the number of bets we have placed

        snapshot_last_price_traded = []

        snapshot_runner_context = []

        for runner in market_book.runners:

                snapshot_last_price_traded.append([runner.selection_id,runner.last_price_traded])

                # Get runner context for each runner

                runner_context = self.get_runner_context(

                    market.market_id, runner.selection_id, runner.handicap

                )

                snapshot_runner_context.append([runner_context.selection_id, runner_context.executable_orders, runner_context.live_trade_count, runner_context.trade_count])



        # Convert last price traded data to dataframe

        snapshot_last_price_traded = pd.DataFrame(snapshot_last_price_traded, columns=['selection_id','last_traded_price'])

        # Find the selection_id of the favourite

        snapshot_last_price_traded = snapshot_last_price_traded.sort_values(by = ['last_traded_price'])

        fav_selection_id = snapshot_last_price_traded['selection_id'].iloc[0]

        [http://logging.info|logging.info](http://logging.info|logging.info)(snapshot_last_price_traded) # logging



        # Convert data on number of bets we have placed to a dataframe

        snapshot_runner_context = pd.DataFrame(snapshot_runner_context, columns=['selection_id','executable_orders','live_trade_count','trade_count'])

        [http://logging.info|logging.info](http://logging.info|logging.info)(snapshot_runner_context) # logging



        for runner in market_book.runners:

            if runner.status == "ACTIVE" and market.seconds_to_start &lt; 60 and market_book.inplay == False and runner.selection_id == fav_selection_id and snapshot_runner_context.iloc[:,1:].sum().sum() == 0:

                trade = Trade(

                    market_id=market_book.market_id,

                    selection_id=runner.selection_id,

                    handicap=runner.handicap,

                    strategy=self,

                )

                order = trade.create_order(

                    side="BACK", order_type=LimitOrder(price=runner.last_price_traded, size=5)

                )

                market.place_order(order)



# Fields we want to log in our simulations

FIELDNAMES = [

    "bet_id",

    "strategy_name",

    "market_id",

    "selection_id",

    "trade_id",

    "date_time_placed",

    "price",

    "price_matched",

    "size",

    "size_matched",

    "profit",

    "side",

    "elapsed_seconds_executable",

    "order_status",

    "market_note",

    "trade_notes",

    "order_notes",

]



# Log results from simulation into csv file named sim_hta_2.csv

# If the csv file doesn't exist then it is created, otherwise we append results to the csv file

class BacktestLoggingControl(LoggingControl):

    NAME = "BACKTEST_LOGGING_CONTROL"



    def __init__(self, *args, **kwargs):

        super(BacktestLoggingControl, self).__init__(*args, **kwargs)

        self._setup()



    def _setup(self):

        if os.path.exists("sim_hta_2.csv"):

            [http://logging.info|logging.info](http://logging.info|logging.info)("Results file exists")

        else:

            with open("sim_hta_2.csv", "w") as m:

                csv_writer = csv.DictWriter(m, delimiter=",", fieldnames=FIELDNAMES)

                csv_writer.writeheader()



    def _process_cleared_orders_meta(self, event):

        orders = event.event

        with open("sim_hta_2.csv", "a") as m:

            for order in orders:

                if order.order_type.ORDER_TYPE == OrderTypes.LIMIT:

                    size = order.order_type.size

                else:

                    size = order.order_type.liability

                if order.order_type.ORDER_TYPE == OrderTypes.MARKET_ON_CLOSE:

                    price = None

                else:

                    price = order.order_type.price

                try:

                    order_data = {

                        "bet_id": order.bet_id,

                        "strategy_name": order.trade.strategy,

                        "market_id": order.market_id,

                        "selection_id": order.selection_id,

                        "trade_id": order.trade.id,

                        "date_time_placed": order.responses.date_time_placed,

                        "price": price,

                        "price_matched": order.average_price_matched,

                        "size": size,

                        "size_matched": order.size_matched,

                        "profit": order.simulated.profit,

                        "side": order.side,

                        "elapsed_seconds_executable": order.elapsed_seconds_executable,

                        "order_status": order.status.value,

                        "market_note": order.trade.market_notes,

                        "trade_notes": order.trade.notes_str,

                        "order_notes": order.notes_str,

                    }

                    csv_writer = csv.DictWriter(m, delimiter=",", fieldnames=FIELDNAMES)

                    csv_writer.writerow(order_data)

                except Exception as e:

                    logger.error(

                        "_process_cleared_orders_meta: %s" % e,

                        extra={"order": order, "error": e},

                    )



        [http://logger.info|logger.info](http://logger.info|logger.info)("Orders updated", extra={"order_count": len(orders)})



    def _process_cleared_markets(self, event):

        cleared_markets = event.event

        for cleared_market in cleared_markets.orders:

            [http://logger.info|logger.info](http://logger.info|logger.info)(

                "Cleared market",

                extra={

                    "market_id": cleared_market.market_id,

                    "bet_count": cleared_market.bet_count,

                    "profit": cleared_market.profit,

                    "commission": cleared_market.commission,

                },

            )



# Searches for all betfair data files within the folder sample_monthly_data_output

data_folder = r"C:\Users\matth\OneDrive\Documents\output_2022_02"

data_files = os.listdir(data_folder,)

data_files = [f'{data_folder}/{path}' for path in data_files]



# Set Flumine to simulation mode

client = clients.SimulatedClient()

framework = FlumineSimulation(client=client)



# Set parameters for our strategy

strategy = BackFavStrategy(

    # market_filter selects what portion of the historic data we simulate our strategy on

    # markets selects the list of betfair historic data files

    # market_types specifies the type of markets

    # listener_kwargs specifies the time period we simulate for each market

    market_filter={

        "markets": data_files,

        'market_types':['MATCH_ODDS', 'BOTH_TEAMS_TO_SCORE'],

        "listener_kwargs": {"inplay": False, "seconds_to_start": 80},

        },

    max_order_exposure=1000,

    max_selection_exposure=1000,

)

# Run our strategy on the simulated market

framework.add_strategy(strategy)

framework.add_logging_control(

    BacktestLoggingControl()

)

framework.run()```



---

## 2024-04-11 21:52:42 - general channel

**JFP**

I'm wanting to log cleared profit for each strategy, I have a backtest logging control set for the client which logs net cleared market profit but would like breakdown of net profit for each strategy. Does the blotter get updated once orders are cleared? In the _process_cleared_markets() function can I just call orders from blotter and get profit per strat?

---

## 2024-04-11 11:45:48 - general channel

**JFP**

Just wondering if anyone can point me in the right direction in regards to logging total cleared profit for each strategy once market/orders are cleared.



I currently log cleared orders via _process_cleared_orders_meta() and market profit via _process_cleared_markets(), but would like to add total profit for each strategy.



I can just process the cleared orders in a dataframe and groupby sum profit based on strat name, but I am hoping there is a more Flumine way to tackle this.



Have retrieved cleared orders from betfair via "client.betting_client.betting.list_cleared_orders()" to sum based on strategy name, but strategy refs have been recorded as my device name. So it appears only Flumine knows which orders belong to each strategy.

---

## 2024-04-09 09:46:17 - general channel

**Trex44**

So, I think the problem was caused by a Jupyter notebook. I had one of the cells take a snap shot of market data when it was executed. I did have trading.logout() in the same cell but all I can think is this didn't execute properly. When I rebooted my IDE (that the notebook was running in) it seems to have fixed the issue. Will see if crops up again or not.

---

## 2024-04-08 18:34:27 - general channel

**Lee**

Just to clarify. Flumine will use 1 connection for the order stream and 1 for each market filter. In the case of your instance that’s collecting data it sounds like it would be 5 connections.

If you are not betting on that instance you can disable to order stream on the `BetfairClient`.

Can you combine some sports into the same filter?

---

## 2024-04-08 18:22:18 - general channel

**Trex44**

I am still going to have issues here. I collect data on 4 sports via one instance so thats 8 connections and then run strats on horses and football so that would be 12 connections total. I am not certain why it was letting me do this before today but now I am limited at 10.



 If I run the Football strats on the same instance, with the same filters, as the data collection is there a way to keep an instance of flumine running whilst shutting down some of the strategies running through it? I am thinking I will have to shut down the betting strats whilst keeping the data collection running.

---

## 2024-04-08 09:17:01 - random channel

**Paul**

To be honest unless you have an explicit reason to not use something like NordVPN, and you can explain and quantify the impact of running it on your prod strategy instance you should probably just buy some vpn software or just enjoy your holiday and leave things running while you’re away. If you’re worried, switch things off for a week or two. 

---

## 2024-04-06 15:49:22 - random channel

**Ralegh**

I assume the margins are large enough that they can get away with models that are 70% of the way there and focus on having traders ticking up/down parameters like in OMM, I know SIG likes more manual/intuitive trading vs full systematic, though they couldn’t look at flow on millions of different combinations of multiples. They could model correlation between bet types in generic cases and have the traders tweak them for specific matches, then price based on those discounts

---

## 2024-04-06 13:40:37 - random channel

**Paul**

Most insurance under-writers can’t pay out everything hitting. It sometimes takes a bad beating as an industry (for example, Lloyd’s in the 1980s), but the model is mature enough nobody is going bust if everyone involved has done their maths and got the right excel spreadsheets. If that’s how they have positioned themselves in the sports betting market, good luck to them!

---

## 2024-04-04 19:52:46 - random channel

**liam**

Yeah as above, sort of hinting at maybe the strategy is good but the execution is letting it down 

---

## 2024-04-04 15:20:17 - strategies channel

**tone**

Purely for tidiness really. I've organised the code so that it runs a single strategy/program instance per market and when the market completes it saves the results, and hopefully closes down. A scheduler starts the instances before the scheduled start time. I assume from your question that there's a better way to do this?

---

## 2024-04-04 15:02:38 - strategies channel

**tone**

Does anyone know a good way to exit a program/strategy when the live market is closes? This happens automatically in simulation but the program just hangs idly when running live!

---

## 2024-04-03 18:19:33 - issues channel

**Ammar**

```trading = betfairlightweight.APIClient(

        username=os.environ["BETFAIR_USER"],

        password=os.environ["BETFAIR_PASS"],

        app_key=os.environ["BETFAIR_APP_KEY"],

        certs="certs"

    )

client = clients.BetfairClient(trading, paper_trade=True)



framework = Flumine(client=client)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["1"],

        event_ids=["33135839"],

        # market_types=["WIN"],

        country_codes=["GB"],

    ),

    market_data_filter=streaming_market_data_filter(fields=["EX_ALL_OFFERS"]),

)



framework.add_strategy(strategy)



framework.run()```



---

## 2024-04-03 18:19:15 - issues channel

**Ammar**

Hi - me again — I’ve had confirmation my live key is streaming enabled, but I am getting this error back on the API when trying to run a simple strategy to just test the connection



`{"op":"status","id":2002,"statusCode":"FAILURE","errorCode":"UNEXPECTED_ERROR","errorMessage":"Unknown error authenticating","connectionClosed":true,"connectionId":"204-030424170351-166509"}`



I’ve raised a ticket to BDP, but wondering if anyone has any insight?

---

## 2024-04-02 14:17:22 - general channel

**Michael**

I'm not going to help you more than this so don't dm me about it; but there are some creative (but legitimate) options. If you're not that imaginative then maybe see if bumping your stakes slightly above the optimal increases your volatility without costing you overall. Otherwise you can try churning in a different sport at low margin, just don't do it in your main betting sport. Don't shit where you eat.

---

## 2024-04-01 10:50:55 - general channel

**The Marco**

Very much trying to wrap my head around lightweight/flumine. Will start with one question, but I have quite a few. Don't want to annoy everyone with a flumine of questions right away, though.



• I can get to competition_id > event_id > market_id using lightweight. 

• When it comes to market_book I can get it via lightweight, like so 

```market_books = trading.betting.list_market_book([mkt_id], price_projection={'priceData': ['EX_BEST_OFFERS']},                    lightweight=True)```

However, following [https://betfair-datascientists.github.io/api/apiPythontutorial/#get-market-books](https://betfair-datascientists.github.io/api/apiPythontutorial/#get-market-books) In [212] (about halfway through the page) suddenly uses dot syntax to access runner_book, though it was not introduced earlier, as far as I can tell. This syntax seems consistent with that in flumine's example strategy and plausibly comes from the MarketBook class inside bettingresources.py in betfairlightweight. I don't really get how to use it though.



Q: how do I get prices (EX_BEST_OFFERS or similar) using this class and dot syntax?

---

## 2024-03-31 17:38:15 - general channel

**D C**

I'd imagine the implied chance of winning from a TPD based model.

---

## 2024-03-29 13:06:59 - issues channel

**Ammar**

this is the console output (same when running via jupyter)



```&lt;bf&gt; ~/workspace/bf/lib *[master] » python -m bot2

/Users/bromar/.virtualenvs/bf/lib/python3.11/site-packages/pydantic/_internal/_config.py:322: UserWarning: Valid config keys have changed in V2:

* 'allow_population_by_field_name' has been renamed to 'populate_by_name'

* 'allow_mutation' has been removed

  warnings.warn(message, UserWarning)

None

starting strategy 'ExampleStrategy'```



and then nothing happens …

---

## 2024-03-29 13:05:41 - issues channel

**Ammar**

this is my code:



```import os

from flumine import Flumine, BaseStrategy, clients

from flumine.order.trade import Trade

from flumine.order.order import LimitOrder, OrderStatus

from flumine.markets.market import Market

import betfairlightweight

from betfairlightweight.filters import streaming_market_filter, market_filter

from betfairlightweight.resources import MarketBook







trading = betfairlightweight.APIClient(

        username=os.environ["BETFAIR_USER"],

        password=os.environ["BETFAIR_PASS"],

        app_key=os.environ["BETFAIR_APP_KEY"],

        # certs="../certs"

    )

client = clients.BetfairClient(trading, paper_trade=True, interactive_login=True)

print(client.login())



framework = Flumine(client=client)



class ExampleStrategy(BaseStrategy):

    def start(self) -&gt; None:

        print("starting strategy 'ExampleStrategy'")



    def process_new_market(self, market: Market, market_book: MarketBook) -&gt; None:

        # called when a market is newly added to the framework

        print(market_book.market_definition)

        return super().process_new_market(market, market_book)



    def process_sports_data(

        self, market: Market, sports_data

    ) -&gt; None:

        # called on each update from sports-data-stream

        print(market, sports_data)



    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

        # process_market_book only executed if this returns True

        print(market_book.market_definition)

        return True



    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:

        # process marketBook object

        for runner in market_book.runners:

            print(runner.selection_id)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["1"],

        event_ids=["33115229"],

        # market_types=["WIN"],

        # country_codes=["GB"],

    )

)



framework.add_strategy(strategy)



framework.run()```

---

## 2024-03-29 09:08:11 - issues channel

**Paul**

I'm trying to do something very basic with betfairlightweight's streaming (long story, I don't want flumine for this). Here is some of my code based on [https://github.com/betcode-org/betfair/blob/f730238df65a9e0f86f3fe9690bf5a7ecff77715/examples/examplestreaming.py|the streaming example](https://github.com/betcode-org/betfair/blob/f730238df65a9e0f86f3fe9690bf5a7ecff77715/examples/examplestreaming.py|the streaming example) in the repo:

```trading = betfairlightweight.APIClient([...])

trading.login()

output_queue = queue.Queue()

listener = betfairlightweight.StreamListener(output_queue = output_queue)

stream = trading.streaming.create_stream(listener = listener)

market_filter = filters.streaming_market_filter(

    event_type_ids          = ["7"],

    market_types            = ["WIN"],

)

market_data_filter = filters.streaming_market_data_filter(

    fields=["EX_BEST_OFFERS, EX_MARKET_DEF"], ladder_levels=1

)



streaming_unique_id = stream.subscribe_to_markets(market_filter = market_filter, market_data_filter=market_data_filter, conflate_ms = 200)

t = threading.Thread(target=stream.start, daemon = True)

t.start()```

This ^^ is obviously not very exotic. I'm asking for single ladder level and the market definition for all WIN horse racing market, with conflation at 200ms. Straight out of the box...

```2024-03-29 08:52:35: [Register: 1]: marketSubscription

2024-03-29 08:52:35: [MarketStream: 1]: "MarketStream" created

2024-03-29 08:52:35: [MarketStream: 1]: connection_id: XXX-XXXXXXXXXXXXX-XXXXXXX

2024-03-29 08:52:35: [MarketStream: 2]: SUCCESS (7 connections available)

2024-03-29 08:52:35: [MarketStream: None]: INVALID_INPUT: Failed to un-marshall: '{"op": "marketSubscription", "id": 1, "marketFilter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"]}, "marketDataFilter": {"fields": ["EX_BEST_OFFERS, EX_MARKET_DEF"], "ladderLevels": 1}, "initialClk": null, "clk": null, "conflateMs": 200, "heartbeatMs": null, "segmentationEnabled": true}'```

My understanding is the `INVALID_INPUT` is from the API as per [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Exchange+Stream+API#ExchangeStreamAPI-ErrorCode|the docs](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Exchange+Stream+API#ExchangeStreamAPI-ErrorCode|the docs), but there isn't much else to go on. :thinking_face: Only thing obvious is that there are extra attrs in there that I didn't create that could be confusing it, but I expect that this is normal bflw behaviour.



While I go and get some caffeine to see if that helps, any Idiot Adjustments you can offer to my obviously feeble brain would be welcome. :slightly_smiling_face:

---

## 2024-03-28 13:17:18 - random channel

**ShaunW**

Design a more efficient test? Or just use every 3rd or 4th update. ML is just analysis, a guide, so doesn't need the resolution a simulation does.    Modern hardware speeds means loading everything or just running backtests has become de regueur,   but reintroduce some of the forgotten methodology that makes analysis a distinct disciple in itself.   We had terabytes of data back in the 90s and pathetic hardware, still managed to develop strategy without waiting a month for a figure.

---

## 2024-03-28 09:48:07 - random channel

**PeterLe**

I was just looking at some notes I made when I looked at this.

```# Random Forest Accuracy: 0.9120607771513096

# Total Profit/Loss using Simple strategy: £-193834.88816246387

# Total Profit/Loss using ML strategy for sys4: £17935.374273080262```

I found out other things too that Ive never considered before. One is so obvious now but Id never noticed it.

Just enjoy the journey!

---

## 2024-03-28 08:35:23 - issues channel

**Adrian**

Does anyone know what this means?

```Traceback (most recent call last):

  File "/Users/adrian/Projects/betfair/valbet/simulation.py", line 137, in &lt;module&gt;

    framework.add_strategy(strategy)

  File "/Users/adrian/miniconda3/envs/flumine/lib/python3.11/site-packages/flumine/baseflumine.py", line 98, in add_strategy

    self.streams(strategy)  # create required streams

    ^^^^^^^^^^^^^^^^^^^^^^

  File "/Users/adrian/miniconda3/envs/flumine/lib/python3.11/site-packages/flumine/streams/streams.py", line 44, in __call__

    market_definition = get_file_md(market)

                        ^^^^^^^^^^^^^^^^^^^

  File "/Users/adrian/miniconda3/envs/flumine/lib/python3.11/site-packages/flumine/utils.py", line 76, in get_file_md

    first_line = f.readline()

                 ^^^^^^^^^^^^

  File "&lt;frozen codecs&gt;", line 322, in decode

UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte```

---

## 2024-03-27 21:33:32 - general channel

**Ammar**

I’m currently building my data pipeline and ML model after a few years of eyeballing and manually validating something;  and want it all joined up so the trading is happening based on the latest from the model

---

## 2024-03-27 19:58:23 - general channel

**Lee**

You can log your bets using [https://betcode-org.github.io/flumine/controls/#logging-controls|logging controls](https://betcode-org.github.io/flumine/controls/#logging-controls|logging controls) to csv/db/api/etc. I certainly wouldn’t be wrapping flumine into a flask app.

Streaming doesn’t work in the way of adding markets on the fly, you have a wide filter which automatically picks up new markets. You decide in the strategy if you want to bet on that market.

As for the kill switch, you can stop flumine with a [https://github.com/betcode-org/flumine/blob/master/examples/workers/terminate.py|TerminationEvent](https://github.com/betcode-org/flumine/blob/master/examples/workers/terminate.py|TerminationEvent) or more simply, just turn off the vm.

---

## 2024-03-27 19:37:49 - general channel

**Ammar**

how the strategy is doing when running, being able to force a terminate, being able to throw another market in there parametrically

---

## 2024-03-26 17:45:58 - issues channel

**Derek C**

I put something into the strategy context to flag whether it's a simulation or not, but I wouldn't claim that's canonical.

---

## 2024-03-26 09:02:44 - issues channel

**Mo**

Basic question but what's the canonical way of accessing framework from inside a strategy or should I be saving a reference myself in... `add()`?

---

## 2024-03-25 20:30:26 - random channel

**Michael**

[@UUE6E1LA1](@UUE6E1LA1) You're just looking for something that separates better bets from less good bets, that could be something to do with the way you're analysing the race or it could be something to do with the market conditions, or something else like understanding that your model only out-performs the market at certain stages of the race, anything as long as you can show it with reasonable confidence and it makes sense. Once you've got that in place you can go back and look at your other variables and see if they predict profit, if they don't then you ditch them. That way you can continually drive up your margin without your volume trending towards zero.



I'd have to say that I don't think reducing profit volatility is a goal in itself as it will mostly come down to the odds you're betting at. The better goal is just to drive up margin however you measure it.



[@UEA14GBRR](@UEA14GBRR) from my experience going for a lot of bets at low EV pretty much the worst thing you can do in running. You'll get hammered by adverse selection and you'll be continually rigging the market against yourself by not letting value develop where it might otherwise have done.

---

## 2024-03-25 20:15:47 - random channel

**D C**

I don't know what to say - my models are based purely on fundamentals and at plenty of stages they will see what it considers to be value. Based on your suggestions though I guess if I want to reduce profit volatility I might want to apply some market based filtering on top of things.

---

## 2024-03-25 17:07:10 - random channel

**D C**

Yeah that does make sense, but the trouble is you don't know that the race will evolve that way until it is in action. I never bet when I expect to lose - I think its related to exposure. I won't know that the 6/4 favourite hits the front and never get challenged until the race is done - doesn't mean that the bets I've placed on the rest of the field were not value at the points where the model thinks it is value.

---

## 2024-03-25 16:53:05 - random channel

**D C**

I think my biggest problem is with staking and exposures to be honest and this is why I do get battered on occasion. Model prices change, but it is still a mystery as to how best spread my exposure across the duration of the race (do you go apeshit on value once they are first out of the gate or save some exposure for later for example). This of course is related to staking as I know that for certain points in the race my models perform better than at others. I think if I had a model that was flawless from start to finish in the race life would be easier but thats never likely to happen to me. I've done things similar to [@U4H19D1D2](@U4H19D1D2)’s chart above where I retrospectively "prune" future bets based on finding parameter ranges on old bet histories which do badly. I do suffer from having too many different strategies running simultaneously and I do not truly understand how they interact with one another (be that positively or negatively)

Maybe I should strip things back a bit and go for lower and more stable returns.

---

## 2024-03-25 14:43:35 - random channel

**Michael**

....but yeah I guess if you had a model that out-performed price in all situations they you could evaluate according to whether win-probability &gt; x at any point before finish.

---

## 2024-03-25 13:27:22 - random channel

**ShaunW**

Very interesting. I've recently started running an in-running strategy ( everything prior had been pre-race and small edge/high volume) . I've been getting iro 15%+ vs < tenth of that pre and I thought it was wildly unrealistic and unsustainable. Maybe not.    



Biggest difference though is that without a benchmark to measure EV I'm at the mercy of results which is a novelty. I don't usually care what the cash is so long as the underlying EV is there. 



All good fun though, I was bored to death with pre and in-running has been a nice change.  ..... But it's come about cos I improved/rewrote my results analyser, tested it on some 3year old backtest logs I still had, and it revealed a parameter tweak that made it profitable.  :face_with_rolling_eyes:

---

## 2024-03-25 12:31:43 - random channel

**Unknown**

Example here of a strategy where I focussed on removing the neg ev bets at the same time prioritising less bets over total profit, bottom graph is ROI which nearly doubled over 6 months ish

---

## 2024-03-25 12:14:48 - random channel

**D C**

As I said, until a chat a few months ago with Lee I never even calculated ROI at all. I've no doubt there is lots of room to improve. I'm sure my execution is naive compared to most but my models just don't perform well backing under 2.0 for some reason.

---

## 2024-03-25 00:10:04 - issues channel

**Chris Pudney**

I'm using the Flumine SimulatedClient to test a strategy on recorded data (Flumine MarketRecorder) and am experiencing odd behaviour. The strategy simply places a back bet at price P for amount W. Run the sim client on a recorded event and it is not matched. Repeat the simulation this time at a _higher_ price, e.g. 2P and it gets matched. No other change just the increase back price. Any suggestions?

---

## 2024-03-24 10:20:42 - general channel

**liam**

Not sure I understand the question but a strategy would only get orders it has created in process_orders 

---

## 2024-03-21 23:09:29 - general channel

**Brøndby IF**

Guys, I saw a conversation here a few days ago suggesting limiting the number of ticks below the current odds when using `place_orders()` (strategy where must enter the market immediately and not set a standard odds for everything, but instead define how many ticks would be an acceptable limit). If anyone's interested, I've created (to keep it handy for perhaps a future need) a function that accepts both tick increments and decrements. In case it's useful for anyone, here it is (if by any chance someone has a smarter method than this or if any errors are discovered, please let me know):



```from betfairlightweight import utils



def tick_ladder(current_odds:float, ticks:int) -> float:

    """

    Limit odds based on the reference odds and the number of ticks away.



    Args:

        current_odds (float): The reference odds to be used.

        ticks (int): The number of ticks to be added or subtracted from the reference odds.

                     Positive values move up the ladder, while negative values move down the ladder.



    Returns:

        float: The new odds after applying the ticks adjustment.



    Raises:

        ValueError: If the adjusted index exceeds the limits of the ladder.

    """

    full_ladder = [1.01]

    ticks_list = list(utils.TICK_SIZES.keys())



    for i, pattern in enumerate(ticks_list[:-1]):

        while full_ladder[-1] < ticks_list[i+1]:

            new_value = round(full_ladder[-1] + TICK_SIZES[pattern], 2)

            full_ladder.append(new_value)



    index_current_odds = full_ladder.index(current_odds)

    if index_current_odds + ticks < len(full_ladder):

        return full_ladder[index_current_odds + ticks]

    else:

        raise ValueError("Exceeded ladder limits")```

---

## 2024-03-21 13:55:26 - general channel

**tone**

Thanks Liam. I think selection_exposure(self, strategy, lookup: tuple) might be what I'm looking for, but I'm having a bit of trouble using it. What is the "lookup" param for and how do I pass it?

---

## 2024-03-20 08:34:49 - general channel

**liam**

For live you need a worker, here is mine



```import logging

from flumine.utils import chunks

from betfairlightweight import BetfairError

from flumine.events.events import CustomEvent



logger = logging.getLogger(__name__)





def poll_race_card(context: dict, flumine) -&gt; None:

    client = flumine.clients.get_betfair_default()

    trading = client.betting_client

    if trading.race_card.app_key is None:

        trading.race_card.login()

    markets = _get_markets(flumine.markets)

    for market_ids in chunks(markets, 10):

        try:

            race_cards = trading.race_card.get_race_card(market_ids=market_ids)

        except BetfairError as e:

            logger.error(

                "poll_race_card error",

                exc_info=True,

                extra={"trading_function": "get_race_card", "response": e},

            )

            continue

        if race_cards:

            flumine.handler_queue.put(CustomEvent(race_cards, callback))





def _get_markets(markets: list, event_type_id: str = "7") -&gt; list:

    """Restrict to open and eventTypeId"""

    _markets = []

    for market in markets:

        if not market.closed and market.event_type_id == event_type_id:

            _markets.append(market.market_id)

    return _markets





def callback(flumine, event):

    # update market context

    race_cards = event.event

    for race_card in race_cards:

        for market in flumine.markets:

            for race_card_market in race_card.race.markets:

                if market.market_id == race_card_market.market_id:

                    market.context["race_card"] = race_card```



---

## 2024-03-19 10:55:31 - general channel

**mon mon**

hi all. I am trying to get the current account balance from within a strategy but can't seem to extract it - is there a std way to do this?

---

## 2024-03-19 03:59:38 - general channel

**Jared King**

Hi All, is there a way to limit the number of connections used per strategy?

---

## 2024-03-18 21:45:17 - general channel

**Testes Squads**

[@UGV299K6H](@UGV299K6H) I'll take this precaution about 1.01, I've been working for a while but I always ran into difficulties when it came to choosing an odds and ending up with stakes waiting to be matched because the odds dropped by 1 tick or 2 and I had to keep cancelling, so I decided to learn how to program the basic just to get the automation to work, because I had never thought about it and no one had ever told me that betting on some lower odds would correspond to the current odds and so on.

---

## 2024-03-18 19:06:24 - general channel

**Testes Squads**

Hi [@U05L8PZD2FM](@U05L8PZD2FM) so do I just do it like this below?



```limit_order = betfairlightweight.filters.limit_order(size=xxxxxx.xx, price=1.01)

instruction = betfairlightweight.filters.place_instruction(

    order_type="LIMIT",

    selection_id=45321,

    side="BACK",

    limit_order=limit_order

)

place_orders = trading.betting.place_orders(

    market_id="1.123456789",

    instructions=[instruction]

)```

And I will do this in Tennis in a specific game scenario only in the third set of women's matches, but I will manually define the runner_id and activate the code, it will not run automatically, if it were I could comment in more detail on what I will do.

---

## 2024-03-17 21:13:35 - random channel

**Mo**

But I know the organisers and they're legends within the football modelling space (e.g. [https://rss.onlinelibrary.wiley.com/doi/abs/10.1111/1467-9884.00366](https://rss.onlinelibrary.wiley.com/doi/abs/10.1111/1467-9884.00366))

---

## 2024-03-17 10:22:37 - strategies channel

**Paul**

If things are working for you, maybe your strategy is indifferent. I’d definitely take a look at whether the event has “Hcap” in the description and see if there is an optimisation there. :-) 

---

## 2024-03-12 00:39:05 - general channel

**Herugrim**

I seem to have fixed this error, just by removing a trading.logout() line

---

## 2024-03-11 16:35:27 - issues channel

**foxwood**

I think [@U012XF5CNPN](@U012XF5CNPN) explains it well and encapsulates the reasons I have turned the "feature" off. There are a mass of issues that can cause Python to throw concrete excpetions and they are not just related to Python, flumine or flumine strategy code. They include exceptions from the operating system and bugs in any of the host of python packages used - all of which would be ignored by flumine. Imho the probability of an exception arising is real and I favour the dead bot theory rather than the faulty live one.

---

## 2024-03-11 14:15:37 - issues channel

**liam**

I agree there are some nuances but the controls are there to prevent issues, the simulation / paper trading is also there as a way to test (integration) but obviously there is a limit when it comes to betfair exceptions / edge cases etc.

---

## 2024-03-11 14:13:48 - issues channel

**Paul**

I think this default behaviour might be surprising behaviour to most. I think order controls in flumine in general can be a little surprising (selection exposure is not related to P&amp;L, only net exposure of trades on that selection, correct?), and in live trading these surprises could get expensive. I think defaults could defer to risk minimisation and that might make more sense: a dead bot that crashed out due to an exception can’t win big, but it also critically can’t lose big either. You can’t say that about a faulty live one…

---

## 2024-03-11 05:36:14 - general channel

**Herugrim**

Hi,

I'm using the example code here: [https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py](https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py)

I'm getting the below error:



```betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listCurrentOrders

Params: {'orderProjection': 'EXECUTION_COMPLETE', 'customerStrategyRefs': ['MELWKS-4535'], 'dateRange': {'from': None, 'to': None}}

Exception: None

Error: {'code': -32099, 'message': 'ANGX-0005', 'data': {'APINGException': {'requestUUID': 'ie2-ang14b-prd-01291035-005af2205e', 'errorCode': 'NO_SESSION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0005', 'data': {'APINGException': {'requestUUID': 'ie2-ang14b-prd-01291035-005af2205e', 'errorCode': 'NO_SESSION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}```

I'm able to use Flumine without the middleware and am only getting the error when calling listCurrentOrders

---

## 2024-03-10 14:11:21 - issues channel

**Newbie99**

I just updated flumine and now I can't get it to start (looks like an issue with BFLW if I'm interpreting this correctly):



```  File "/home/ec2-user/trading/env/projects/startup.py", line 4, in &lt;module&gt;

    import betfairlightweight

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/__init__.py", line 3, in &lt;module&gt;

    from .apiclient import APIClient

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/apiclient.py", line 6, in &lt;module&gt;

    from . import endpoints

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/endpoints/__init__.py", line 10, in &lt;module&gt;

    from .streaming import Streaming

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/endpoints/streaming.py", line 2, in &lt;module&gt;

    from ..streaming import (

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/streaming/__init__.py", line 1, in &lt;module&gt;

    from .betfairstream import BetfairStream, HistoricalStream, HistoricalGeneratorStream

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/streaming/betfairstream.py", line 10, in &lt;module&gt;

    from .listener import BaseListener

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/streaming/listener.py", line 5, in &lt;module&gt;

    from .stream import BaseStream, CricketStream, MarketStream, OrderStream, RaceStream

  File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/streaming/stream.py", line 116

    if (cache := self._caches.get(market_id)) is not None and cache.active```

---

## 2024-03-10 10:50:58 - general channel

**foxwood**

Just construct and add all strategies to the framework before calling `framework.run()`

All bets on the market regardless of strategy end up in `market.blotter`

---

## 2024-03-10 10:46:30 - general channel

**liam**

It will do what you want by default, if the market filter matches on each strategy they will ‘share’ the updates 

---

## 2024-03-10 09:21:52 - general channel

**Unknown**

Is there a way to run a simulation of, say, 5 strategies on the same list of markets? In a way that a market gets processed once while all 5 strategies get applied.



Looking at Github example, it makes me think that perhaps each strategy has an independent list of markets, so they would get looped through 5 times, once per strategy.

---

## 2024-03-08 14:02:51 - general channel

**ShaunW**

Price action doesn't necessarily require an exit strategy [@U012XF5CNPN](@U012XF5CNPN). My interpretation has each decision made on the same criteria. Ie a continual buy/hold/sell loop.

---

## 2024-03-07 14:46:54 - issues channel

**foxwood**

Had an issue last week with a test strategy running live. It was going through the runners placing bets and then hit an outlier not allowed for that resulted in a divide by zero. Flumine neatly ate the exception and fed the next `mc` to the strategy which placed bets, hit the outlier again and crashed again - rinse and repeat.



The impact of this was to start draining the bank rather quickly - fortunately I was monitoring it but it still took a big bite. After investigating, I discovered that flumine ate non-flumine exceptions due to `config.raise_errors = False` Taken 2+ years to fall down that hole. I know all the guff about testing and defensive code etc but the reality is that most of us are in permanent beta and things slip through.



I think this should default to `True` which would stop any runaways like mine and, more importantly, would be the expected behaviour for people new to flumine. In the meantime all my flumine wrappers set it to `True` right at the start.

---

## 2024-03-06 10:13:55 - general channel

**Paul**

Trading is definitely not frowned upon here. If you’re referring to the “never green” take, that’s because if you’re doing the work to find value, then put in a +EV bet at kelly stakes, the question has to be what is it you’re actually doing when you green up other than throw away some of that value?

---

## 2024-03-04 20:50:50 - general channel

**Fab**

Thanks for your help Paul and foxwood. My idea was to back a runner a few minutes before the start then lay at BSP, so I wanted back/lay stake must be the same.



I accept that my understanding of BSP laying was incomplete and that type of order cannot be placed with a given stake but only with a given liability.



So, I'll focus on backing only, without closing my "trade" at BSP. Hopefully not many people read this inner thread, given how frowned up "trading" is here. :smile:

---

## 2024-03-02 21:08:45 - issues channel

**Jeff Waters**

Hi



I've just tried placing a bet with a persistence of 'PERSIST'. This was my code:



```trade = Trade(

    market_id=market_book.market_id,

    selection_id=runner.selection_id,

    handicap=runner.handicap,

    strategy=self,

    reset_seconds=3,

    place_reset_seconds=3

)

order = trade.create_order(

    side="BACK",

    order_type=LimitOrder(price=10, size=2.00, persistence_type="PERSIST"),

)

market.place_order(order)```

The JSON response suggested that the bet had been submitted successfully:



"order_type":{

      "order_type":"Limit",

      "price":10,

      "size":2.0,

      "persistence_type":"PERSIST",

      "time_in_force":null,

      "min_fill_size":null,

      "bet_target_type":null,

      "bet_target_size":null,

      "price_ladder_definition":"CLASSIC"

   },

   "info":{

      "side":"BACK",

      "size_matched":0.0,

      "size_remaining":2.0,

      "size_cancelled":0.0,

      "size_lapsed":0.0,

      "size_voided":0.0,

      "average_price_matched":0.0

   },

   "responses":{

      "date_time_placed":null,

      "elapsed_seconds_executable":null

   },

   "runner_status":null,

   "line_range_result":null,

   "status":"Pending",

   "status_log":"Pending",



I was told in a subsequent message that:



   "message":"1 order packages executed in transaction",



The selection was a favourite, so I wasn't expecting it to be matched before being converted to a BSP bet. However, my bet was not displaying as pending on the Betfair site, and it wasn't converted to BSP.



What was I doing wrong, please?

---

## 2024-03-01 19:56:52 - general channel

**Sen**

Hi Guys. So I do a ton of fundamental modelling and predictions and basically no quick in and out strategies. Basically 0 in play betting. I was thinking of trying to improve my execution using the stream API. Does this make sense? Or is it really only designed for the high frequency betting during in-play markets? 



Does anyone have any know how big the latency diff is in terms of millisecodns between the standard API and the stream API is?

---

## 2024-02-29 17:23:39 - general channel

**Andrey Luiz Malheiros**

Hey guys, recently I asked if it was possible to get "Betting Forecast" or "Timeform 1-2-3" from Betfair for greyhound and horse races. Mo helped me with that, and we can use the `race_card.get_race_card` method to obtain that information. However, I'm only getting results for horse races using this method. Is anyone getting "Betting Forecast" results for greyhound races from Betfair?

---

## 2024-02-29 09:42:09 - strategies channel

**Lee**

You mentioned you’re using listener kwargs for your backtest, are actually you filtering in a similar way within the strategy when running live?

It should be quite easy to spot what’s going on just comparing bets of the two.

---

## 2024-02-28 11:41:54 - strategies channel

**Andrey Luiz Malheiros**

Both scenarios have a market filter for WIN markets for greyhound racing in GB, and both have the same middlewares. The live strategy is running with no listener_kwargs, while the simulated one is running with listener_kwargs={"seconds_to_start": 600, "inplay": False}

---

## 2024-02-28 11:23:47 - strategies channel

**Andrey Luiz Malheiros**

Hey guys, I'm running a strategy in live paper trade mode and recording the markets with a market recorder. When I run a simulation for the same strategy over the same period using recorded files, I'm noticing a significant difference in results. So, I have two questions:

• Is there a big difference in results between the simulation and live paper trade mode?

• If not, can someone tell me the possible reasons why I'm seeing such a significant difference? (I'm observing a 320% difference in net profit)



---

## 2024-02-26 13:56:14 - issues channel

**Al**

Hi, I have a question. Should the profit that is calculated in the model from the order execution price be considered as net_pnl or gross?

---

## 2024-02-26 10:01:53 - general channel

**Fab**

Hello, I have a question about streaming. Let's say I add 3 strategies to the same Flumine instance, they all use exactly the same streaming_market_filter. For example:



```strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["4339"], # greyhounds

        country_codes=["GB"],

        market_types=["WIN"],

    )

)```

• A) Is my understanding correct that Flumine connects to Betfair WebSocket only once and reuses the same incoming messages for both strategies?

• B) What if I add another strategy to the same Flumine instance, this time for horse racing markets so `event_type_ids=["7"]`: does this establish a new WebSocket connection?

---

## 2024-02-25 19:47:52 - issues channel

**foxwood**

Probably doing something stupid but I'm getting an exception `Execution unknown error` thrown live (ok on backtest) using `market.replace_order()` called from within override of `stratBase.process_orders()` From the log the exception is thrown because the dictionary item `new_price` is missing from `update_data` although generated solely by `order.replace()` as part of the normal flow.

The scenario is playing with sub £1 bets by laying at very low odds, changing the size (works ok every time) and then replacing the order with a new price - which fails on about 2% of bets - I have a workaround that ensures the size/price combo doesn't hit `INVALID_PROFIT_RATIO` error.

All seems to happen on different thread - sample stack trace below. Can't reproduce at will. Feels like could possibly be python assign/copy issue around the "lost" dictionary item. Any clues / ideas welcome



`{"asctime": "2024-02-25 18:26:59,554", "levelname": "CRITICAL", "message": "Execution unknown error", "exc_info": "Traceback (most recent call last):`

  `File \"\\flumine\\execution\\betfairexecution.py\", line 251, in _execution_helper  response = trading_function(order_package, http_session)`

  `File \"\\flumine\\execution\\betfairexecution.py\", line 222, in replace  instructions=order_package.replace_instructions,`

  `File \"\\flumine\\order\\orderpackage.py\", line 164, in replace_instructions  return [`

  `File \"\\flumine\\order\\orderpackage.py\", line 165, in &lt;listcomp&gt;  order.create_replace_instruction()`

  `File \"\\flumine\\order\\order.py\", line 425, in create_replace_instruction  return {\"betId\": self.bet_id, \"newPrice\": self.update_data[\"new_price\"]}`

  `KeyError: 'new_price'", "trading_function": "replace", "exception": "'new_price'", "order_package": {"id": "4baba968-543d-49d4-84b4-a75355ab6a94", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x000001FE966E3EB0&gt;", "market_id": "1.225213820", "orders": ["139281784190412005"], "order_count": 1, "package_type": "Replace", "customer_strategy_ref": "stratXX", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}`

---

## 2024-02-24 15:11:07 - general channel

**Trex44**

```max_selection_exposure=20,

max_order_exposure=20,

max_live_trade_count=2,

context={"stake": 20},```

Been using the strat for months and this has never occurred before. Luckily it won, so I can have a few extra pints later. Note strat_y also fired on the runner and behaved as expected, only placing one bet.

```

bet_id,strategy_name,market_id,selection_id,trade_id,date_time_placed,price,price_matched,size,size_matched,profit,side,elapsed_seconds_executable,order_status,market_note

339328190102,strat_x,1.225197849,42355492,4bb70e45-4e65-4378-adf8-e7eaeaf04249,2024-02-24 14:22:00.240611,3.05,0.0,20,0.0,0.0,BACK,20.14354,Execution complete,"3,3.05,3"

339328318899,strat_y,1.225197849,42355492,e15ba5ef-b32d-425d-a3e4-8c7e9a88a63a,2024-02-24 14:22:20.712415,2.94,0.0,20,0.0,0.0,BACK,20.203602,Execution complete,"2.92,2.94,2.94"

,strat_x,1.225197849,42355492,1565f6b5-d914-418d-bb6b-6529bc9dccc7,2024-02-24 14:22:40.971425,2.8,0.0,20,0.0,0.0,BACK,0.000393,Execution complete,"2.78,2.8,2.78"

339328394435,strat_x,1.225197849,42355492,4c1d4558-64ad-475c-96d1-fff3ea21dff8,2024-02-24 14:22:41.247138,2.8,0.0,20,0.0,36.0,BACK,20.15453,Execution complete,"2.78,2.8,2.8"

339328470581,strat_x,1.225197849,42355492,e75483b8-ea3f-4dc1-af85-c135771fbb7e,2024-02-24 14:23:01.665815,2.8,0.0,20,0.0,36.0,BACK,20.068519,Execution complete,"2.78,2.8,2.78"

339328552148,strat_x,1.225197849,42355492,995c2e62-c080-49c0-a92a-c3ace657498b,2024-02-24 14:23:21.966241,2.88,0.0,20,0.0,37.6,BACK,20.04243,Execution complete,"2.86,2.88,2.86"

339328632974,strat_x,1.225197849,42355492,943480d6-e9e4-48ab-9eae-4916ae78012c,2024-02-24 14:23:42.393435,2.88,0.0,20,0.0,17.86,BACK,20.438296,Execution complete,"2.86,2.88,2.86"

339328660906,strat_y,1.225197849,42355492,79919a27-7708-49c4-a01c-58635c5c0ea6,2024-02-24 14:23:50.201002,2.84,2.86,20,20.0,37.2,BACK,20.193885,Execution complete,"2.86,2.88,2.86"

339328709246,strat_x,1.225197849,42355492,4ab65045-1cd0-42a6-a8e9-d6e9d013263c,2024-02-24 14:24:03.043500,2.84,0.0,20,0.0,36.8,BACK,20.144299,Execution complete,"2.82,2.84,2.84"

339328835977,strat_x,1.225197849,42355492,7daaea34-4351-4fb7-bad3-e2d58ab24584,2024-02-24 14:24:23.507317,2.86,2.86,20,20,37.2,BACK,15.967436,Execution complete,"2.84,2.86,2.84"```



---

## 2024-02-24 15:10:59 - general channel

**Trex44**

Guys does anyone know how the following is possible. I had a strategy misfire and place multiple bets on a single runner (see logs below, strategy is strat_x). It misfired because it thought many of the bets weren't matched (see the size_matched column in the logs attached) so kept placing bets. However the bets were matched and flumine has correctly registered the profit in the profit column in the logs which is odd. I have the following parameters set for the strategy so not sure how it did this.

---

## 2024-02-24 06:34:58 - strategies channel

**Jared King**

meh I tried some different calibration methods but nothing produced better results. A well tuned xgboost model fits well enough for value betting.

---

## 2024-02-22 13:09:49 - issues channel

**liam**

No don't put things in `runner.ex` that is not to be touched, keep things simple:



```    def process_market_book(self, market, market_book):

        for runner in market_book.runners:

            if runner.selection_id == 19221310:

                if self.get_runner_context(market.market_id, runner.selection_id).trade_count == 0:



                    price = self.get_price(ret_model_price)



                    trade = Trade(

                        market_id=market_book.market_id,

                        selection_id=runner.selection_id,

                        handicap=runner.handicap,

                        strategy=self,

                    )

                    order = trade.create_order(

                        side="BACK",

                        order_type=LimitOrder(

                            price=price,

                            size=2,

                            persistence_type="PERSIST"

                        ),

                    )

                    market.place_order(order)



    def get_price(self, ret_model_price):

        price = self.context["price"]

        if price == "price1":

            return ret_model_price

        elif price == "price2":

            return get_nearest_price(ret_model_price * 1.5)

        elif price == "price3":

            return get_nearest_price(ret_model_price * 0.5)

        elif price == "price4":

            return get_nearest_price(ret_model_price * 0.9)```

---

## 2024-02-22 13:06:20 - issues channel

**Al**

def process_market_book(self, market, market_book):

        # get context

        for runner in market_book.runners:

                    if runner.selection_id == 19221310:

                        if self.get_runner_context(market.market_id,runner.selection_id).trade_count == 0:

                            trade = Trade(

                                            market_id=market_book.market_id,

                                            selection_id=runner.selection_id,

                                            handicap=runner.handicap,

                                            strategy=self,

                                        )



                            order = trade.create_order(

                                            side="BACK",

                                            order_type=LimitOrder(

                                                price=runner.ex.target_price,

                                                size=2,

                                                persistence_type="PERSIST"

                                            ),

                                        )

                            market.place_order(order)

---

## 2024-02-22 13:03:25 - issues channel

**Al**

class ExampleStrategy(BaseStrategy):



    def tuning_price(self, runner, ret_model_price):

        if strategy.context['price'] == "price1":

            runner.ex.target_price = ret_model_price

        elif strategy.context['price'] == "price2":

            runner.ex.target_price = get_nearest_price(ret_model_price * 1.5)

        elif strategy.context['price'] == "price3":

            runner.ex.target_price = get_nearest_price(ret_model_price * 0.5)

        elif strategy.context['price'] == "price4":

            runner.ex.target_price = get_nearest_price(ret_model_price * 0.9)

---

## 2024-02-22 12:57:28 - issues channel

**liam**

Where is the strategy code that uses the context?



`self.context["price"]`

---

## 2024-02-21 17:44:01 - general channel

**Ralegh**

Pythons always my goto for research, ideally you should be able to load ML models into other languages at runtime, or use python bindings if available, or at a worst case run python in a separate process and feed targets/forecasts into the trading process. Worst case as in performance but still a very valid approach, anything that latency sensitive can probably be a simpler model anyway

---

## 2024-02-21 16:37:52 - general channel

**Peter**

I started in PHP as I had a lot of years experience of and expertise in it. Then about 3-4 years ago, I learnt Python as it became clear that it had way better tools for data science and Betfairlightweight specifically for trading, Since then Flumine has arrived to more than justify the initial investment in learning a new language.

---

## 2024-02-21 14:57:43 - issues channel

**liam**

Any price should be done in the strategy, the execution class is for different exchanges / http libraries it is *not* for changing the price

---

## 2024-02-21 14:57:36 - general channel

**ShaunW**

... But once the code is done then it's no problem. I designed a fully generic trading solution that's driven from my own scripting 'language' and very rarely touch code. It's a rip-off of something I designed in the PAYE job about 20yrs ago, if you don't know what someone wants, give them a generic solution. 



Like DC I'm very much over all that, when I quit work in 2009 I swored I'd never do an IT job ever again.... now look what's happened. :face_with_rolling_eyes:.

---

## 2024-02-21 14:30:28 - general channel

**ShaunW**

PiQ, not taking your own money, not taking money more than once, latency etc. And still it's only part of a system. There's some sort of pre/post trading analytics to build around it too.

---

## 2024-02-21 13:49:48 - issues channel

**Al**

I want to see the price of the model (for example, the average) and be able to adjust it at the Simulated client level to see how the model behaves

---

## 2024-02-20 16:27:58 - strategies channel

**Unknown**

Here is a simple model output screen from MySportsAI if you check 3/4 way down you will see a TTDrift figure, this means the average drift across the two input features is 0.532but if I run it with just TRinrace the TTDrift is 0.522 so clearly and expectedly days since the run had the higher drift factor. Numbers closer to 0.5 mean the data distribution is more alike in the train and test sets (good in other words)

---

## 2024-02-20 15:33:57 - strategies channel

**Mark Littlewood**

Maybe of help [https://towardsdatascience.com/which-features-are-harmful-for-your-classification-model-6227859a44a6](https://towardsdatascience.com/which-features-are-harmful-for-your-classification-model-6227859a44a6)

---

## 2024-02-20 15:27:16 - strategies channel

**Mark Littlewood**

[https://markatsmartersig.wordpress.com/2022/07/10/simple-in-running-tennis-model/](https://markatsmartersig.wordpress.com/2022/07/10/simple-in-running-tennis-model/)

---

## 2024-02-20 14:03:51 - general channel

**Jared King**

[@U01D23DDMTQ](@U01D23DDMTQ) didn't think to use a pickled file (use it for model load, monkey see..) - good suggestion to disconnect. [@U4H19D1D2](@U4H19D1D2) thankyou for your input as always. [@U05C31YKZ1C](@U05C31YKZ1C) you a legend, code err borrowed.

---

## 2024-02-20 12:40:48 - strategies channel

**liam**

Use a [https://github.com/betcode-org/flumine/blob/master/examples/workers/inplayservice.py|worker](https://github.com/betcode-org/flumine/blob/master/examples/workers/inplayservice.py|worker), in [https://github.com/betcode-org/betfair/blob/9dfed6a2acd18550a6c2192c8c67bc6b0d2ce27e/betfairlightweight/endpoints/scores.py#L16|bflw](https://github.com/betcode-org/betfair/blob/9dfed6a2acd18550a6c2192c8c67bc6b0d2ce27e/betfairlightweight/endpoints/scores.py#L16|bflw):



```trading.scores.list_race_details()```

---

## 2024-02-20 12:19:12 - general channel

**Mark Littlewood**

Hi All I am new to this chat so looking forward to exploring the content. My background is in Machine Learning modelling for sports. I have also written a series of blog posts on accessing the Betfair API. For those of you interested in no code required sports betting modelling I have created a GUI based approach to ML modelling sports data called MySportsAI. My blog is [https://markatsmartersig.wordpress.com/](https://markatsmartersig.wordpress.com/)

---

## 2024-02-20 09:01:16 - general channel

**James**

Heres a worker I use to do something like  that [@U06DURYFXK7](@U06DURYFXK7)

[https://gitlab.com/-/snippets/3675960](https://gitlab.com/-/snippets/3675960)



I use it to It to filter markets by competitions. I schedule it to run every hour, It fetches the Betfair navigation calls “process_navigation” on any strategy where the method is defined. Each strategy can decide what it needs from nav, and if it doesn’t need nav I just don’t define the process_nav function.

---

## 2024-02-20 08:38:39 - general channel

**liam**

Yeah this suits a worker, load at startup/hourly/daily and store the data in `strategy.context`  for execution but as above a db (competent) or API (pro)

---

## 2024-02-20 05:11:45 - general channel

**Andrew**

I’d put the collection script is a separate schedule process. The output files would be named accordingly. Inside the strategy when each market is ready to process (“few seconds before the jump”) then open the appropriate presaved csv to read your necessary racedata. Alternatively use a database rather than CSV or maybe a preprocessed pickled file for quick loading. But definitely disconnected processes.

---

## 2024-02-20 04:09:27 - general channel

**Jared King**

Hi All, I run a script before each day's racing to collect 'raceday' data for my models to use. This data is stored in a csv, and a ref to the csv is created in the start function of the strategy. The model is run x seconds before jump in the strategy class to determine bets etc.



I would like to use a background worker to run the raceday data collection every x hours. What is the best practice to do this?

Could I run the collection script, then re-run the strat start function using the worker function? Is there anything else i need to do?



Happy for suggestions on how i can do the whole process betterrerr :slightly_smiling_face:



Update: I have placed the 'get data' code inside the start func and re run start() using the worker. Seems ok?

---

## 2024-02-20 01:36:21 - strategies channel

**dan**

I hear you, feel like it has to be some ML model not multiple regression to be manageable

---

## 2024-02-19 16:57:24 - random channel

**Unknown**

The last drinks inspired me to turn a flat strategy into a profitable one based on the last 13 days of data, so it pays for itself if you're prepared to think a bit about what people are saying. :slightly_smiling_face:

---

## 2024-02-18 10:34:36 - strategies channel

**Unknown**

Sorry now with winning horse identified correctly :grinning:

If Ive read it and interpreted the data correctly, it looks like selection ID 50724537 (inthewaterside) reached the end of the race first (prog = 0) whereas in fact it got beat greater than 2 lengths

Maybe there is a strategy there after all :grinning:

---

## 2024-02-17 12:38:09 - strategies channel

**Justice**

Agree with the part about having edge no one else has. TPD is available to anyone and therefore is not an edge on its own- but your sophisticated model or strategy that uses the data might be

---

## 2024-02-16 19:51:57 - general channel

**Unknown**

I think the point of these is to stop your strategy from firing repeatedly due to the same signal on every update to market_book. As a way of throttling order creation?

---

## 2024-02-16 19:47:08 - issues channel

**Jeff Waters**

In terms of connections, how does that work? If I open another instance of Flumine and run the same strategy, does it split the markets between the connections?

---

## 2024-02-16 12:25:43 - strategies channel

**foxwood**

Wow that was useful for all sorts of other stuff that vanishes as well. Betfair discussion from Oct22 Neil advised:

• For performance reasons, all bet matching takes place in a bulk betting matching cycle, each of which takes ~100 m/s.

So it follows that the 9 - 10 updates per second that I am seeing recorded is realistically best performance and not missing anything :slightly_smiling_face:. It's actually slower than I thought - was thinking 50ms for some reason.

Thanks [@U4H19D1D2](@U4H19D1D2)

---

## 2024-02-16 10:50:30 - issues channel

**Peter**

Hi [@U06KEECDXBJ](@U06KEECDXBJ) The exchange can be confused at first, but it's vitally important to get to understand it at a fairly deep level, as there are lots of very smart people, including in this Slack, waiting to take your money if you get it wrong.



If you want to back at 280, you're asking somebody to accept a lay that would cost them 280 - 1 = 279 per unit if they get it wrong. If the best back price is 1.1, then the layer willing to take the biggest risk is only prepared to risk 1.1 - 1 = 0.1 unit. The gap between 0.1 and 279 is sooo big, that it's not surprising that the bet is not matched.



Conversely if you try to lay at 280, when the best lay price is 560, that tells us that the least aggressive backer wants a potential profit of 559 before risking his hard earned points. But you're only offering him (or her) 279, so again no surprise that the bet isn't matched.



This is a simulation based on what actually happened, so the market never got to see your bets at 280. It is possible that had they been made in the live market, that would have caused the market to move and even get one or other of these bets matched, but realistically they're so far from the prices at that stage in the market's formation that it's very unlikely.



[@U4H19D1D2](@U4H19D1D2)’s cheat code allows you to test whether your strategy would be profitable if you were matched. It's useful for testing whether, over a large number of markets, your strategy is fundamentally profitable (or not). However, as you'll quickly find it's not that difficult to uncover strategies that would be profitable if somebody else were willing to take the bets, but a lot more difficult to find strategies with counter parties whose view of the market is sufficiently different to yours that you can get those matches.

---

## 2024-02-16 10:45:48 - general channel

**liam**

No flumine does the hard work for you as you have both available, the market object which has the `market.market_book` as it was at time x and the `sports_data` ie the tpd race update, this is how you would develop a TPD strategy as well, no change from simulating to live, its very powerful



```def process_sports_data(self, market, sports_data) -&gt; None:

    # called on each update from sports-data-stream

    print(market, sports_data)```

---

## 2024-02-16 07:33:44 - issues channel

**Al**

Hi. What kind of reporting can I receive as a result of strategy execution? Where to look. I kind of found this. Is it possible to get something else from the simulation results? `for market in framework.markets:`

    print("Profit: {0:.2f}".format(sum([o.profit for o in market.blotter])))

    for order in market.blotter:

        print(

            order.selection_id,

            order.responses.date_time_placed,

            order.status,

            order.order_type.price,

            order.average_price_matched,

            order.size_matched,

            order.profit,

        )

---

## 2024-02-16 06:46:41 - issues channel

**PeterLe**

Jeff, the consensus from the guys on here is to have a standalone recorder. This is one I use:

```import time

import logging

import betfairlightweight

from pythonjsonlogger import jsonlogger



from flumine import Flumine, clients

from flumine.streams.datastream import DataStream

from marketrecorder import MarketRecorder

# from flumine import MarketRecorder



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



myacc = str(input("uk horses please enter account name: "))

app_key = str(input("Please enter key: "))

mypass = str(input("Please enter Password and 2FA: "))

trading = betfairlightweight.APIClient(myacc,mypass, app_key, certs=r"/home/ubuntu/certs")



client = clients.BetfairClient(trading, order_stream=False)



framework = Flumine(client=client)



strategy = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE"],

        market_types=["WIN"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/home/ubuntu/flumine",

        "force_update": False,

        "remove_file": True,

    },

)



framework.add_strategy(strategy)



framework.run()```



---

## 2024-02-15 23:49:54 - strategies channel

**foxwood**

Still get the same number running a minimal strategy so think 10ps is what is in the file. Will look at the raw json tomorrow. Confused because other (paid for) software suggests a fastest refresh rate of 20ms ie 50 updates per second being possible. Something to do with conflate parameter maybe ? Works for me as is but trying to see what is possible.

---

## 2024-02-15 23:45:46 - issues channel

**Jeff Waters**

Hi Derek



I literally copied all of the code in the page relating to the first link, and pasted it into its own module. I then imported that module into another module, and added the relevant code from the other page:



`strategy = MarketRecorder(`

    `name="WIN",`

    `market_filter=betfairlightweight.filters.streaming_market_filter(`

        `event_type_ids=["7"],`

        `country_codes=["GB", "IE"],`

        `market_types=["WIN"],`

    `),`

    `stream_class=DataStream,`

    `context={`

        `"local_dir": "/tmp",`

        `"force_update": False,`

        `"remove_file": True,`

        `"remove_gz_file": False,`

    `},`

`)`



`framework.add_strategy(strategy)`



`framework.run()`

---

## 2024-02-15 20:54:43 - issues channel

**Unknown**

Hi



I'm trying to set up market recording. I copied and pasted the code from [https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py](https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py) into a module. I also created a strategy as shown in the example at [https://github.com/betcode-org/flumine/blob/master/examples/marketrecorder.py](https://github.com/betcode-org/flumine/blob/master/examples/marketrecorder.py) and added it to my framework. However, although a folder appears in the tmp directory I created, it's empty.



What am I doing wrong, please?



Thanks



Jeff

---

## 2024-02-15 14:05:00 - issues channel

**Al**

Please tell me what condition should be prescribed in the strategy so that when the max_trade_count = 1 parameter is set, the strategy stops and does not continue to try to create new orders and does not issue "message": "Order status update: Violation", "violation_msg": "strategy.validate_order failed: trade_count (1) &gt;= max_trade_count (1)". Thanks

---

## 2024-02-15 09:38:18 - issues channel

**liam**

Yeah thats fine, just give them different names to make things easier to untangle



```framework.add_strategy(

    MakeMoney(name="a", context={"side": "BACK"})

)

framework.add_strategy(

    MakeMoney(name="b", context={"side": "LAY"})

)```

---

## 2024-02-15 09:35:14 - issues channel

**Al**

Hi. I have a question. Is it possible to add the same strategy to flumine several times, only in one case side= back, in the second = back. and maybe there is an example for this. or you need to create 2 strategies with different sides separately. thanks

---

## 2024-02-14 12:48:58 - issues channel

**Peter**

Look at the [https://github.com/betcode-org/flumine/blob/master/examples/strategies/pricerecorder.py|price recorder](https://github.com/betcode-org/flumine/blob/master/examples/strategies/pricerecorder.py|price recorder) example strategy and adapt it to record the specific field that you want.

---

## 2024-02-12 21:16:00 - general channel

**Paul**

Let’s suppose you have hold out data of x games. Does a model that works on x games produce value? What about 2x? Or 3x? I think it’s always worth thinking about over fitting, especially when the game is evolving. I’d argue some sports evolve faster than others, that gives you opportunities and also presents threats.

---

## 2024-02-12 19:14:20 - general channel

**Ralegh**

I look at data as proof, you want enough of it to reach some confidence level. The level isn’t some fixed thing, it depends on the complexity model/chance of overfitting and the number of avenues you’ve tried with the data. The more ideas you try the more likely you are to get ‘lucky’ and find something which only made money by accident. Ultimately it’s down to your intuition. 

---

## 2024-02-12 17:59:06 - general channel

**Tony**

hey all, i have been thinking about this more recently, how  much data is really needed to create a 'decent' model? I look at football and tennis and how valuable is the last 10 seasons with various changes in each sport e.g. tennis court speed, racquets, fitness, covid etc - I'm a big believer of its the quality of the data rather than the amount. Just interested to see what other people think.

---

## 2024-02-11 18:51:17 - strategies channel

**John Foley**

hard without knowing exactly what feature A is but perhaps:



“hello AGI overlord, please can you: 

• suggest ways I can make feature A more robust 

• suggest transformations on feature A that I could add into my model

• help me figure out what statistical distribution feature A follows

• suggest other ML algorithms for me to try given that feature A is really important and follows a {answer from above} distribution”

---

## 2024-02-11 18:09:25 - strategies channel

**John Foley**

there doesn’t necessarily need to be a “next step.” I wouldn’t feel the need to start removing features unless I was looking to optimise for memory/compute/training time etc. to me it’s for insights and explainability. it’s for questions like:

• which features should I invest time/money in improving?

• why did the model come up with this strange prediction? 

• does the model rely most heavily on the features that I would use if I were making a prediction myself? 

---

## 2024-02-11 18:02:09 - strategies channel

**Jonjonjon**

Thanks. This might be dumb, but suppose I find the most useful 5 features, what would the next step be? If I fit my models on those 5 features, I will have cherry picked the best features and it becomes an in-sample result.

---

## 2024-02-11 17:39:18 - strategies channel

**John Foley**

Not a top guy by literally any definition but: 

tree based sklearn models and xgboost python library have a `.feature_importances_` attribute built in which is a handy starting point. for anything more generic or custom i’ve used also shap values which are great but can need a lot of compute 

---

## 2024-02-11 15:40:18 - strategies channel

**ShaunW**

Horses are the hardest to model imo. So many variables. At least on dogs you don't have a jockey, all the tracks are basically the same and the same going, same field size, bigger datasets.     If the bigger money is the appeal on horses then why not tennis, that's just a dog race with only two dogs. Aminals+humans+weather is a tough gig.

---

## 2024-02-10 17:38:12 - strategies channel

**Jonjonjon**

How do the top guys analyse the feature importance in their ML models?

---

## 2024-02-10 11:32:48 - general channel

**Ben Coleman**

Hey guys, I'm wanting to know if there is a way I can filter for markets that start less then 30 mins away using streaming_market_filter for implementation of my strategy using flumine? If not I notice that instead there is an argument in market_filter that allows me to do that and but can this be used when streaming with flumine? Also just generally, is flumine constanty updating the markets that fit the criteria in the market filter or is it just ran every minute or so?

---

## 2024-02-09 22:41:04 - general channel

**mzaja**

Can someone explain this behaviour to me? I've created a test strategy which places a single fill or kill order on a single market. It is a dead market with no updates. The order gets placed and then moves to `EXECUTION_COMPLETE` status. Nothing happens afterwards so I would expect no updates. However, Flumine keeps calling `process_orders` like mad for some reason, despite there being no changes in orders. The strategy is initialised with `streaming_timeout=None,` so it should not be down to `snap` being called on cache.

``` Time                    | Source              |   Order count | Order status log

-------------------------+---------------------+---------------+-----------------------------

 2024-02-09 22:35:05,801 | process_market_book |             1 | Pending

 2024-02-09 22:35:05,847 | process_orders      |             1 | Pending

 2024-02-09 22:35:06,009 | process_orders      |             1 | Pending

 2024-02-09 22:35:06,273 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:06,526 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:06,780 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:07,034 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:07,287 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:07,538 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:07,790 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:08,044 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:08,298 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:08,549 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:08,799 | process_orders      |             1 | Pending, Execution complete

 2024-02-09 22:35:09,051 | process_orders      |             1 | Pending, Execution complete```

---

## 2024-02-09 15:25:32 - random channel

**D C**

I used to find strategy reference string a really useful thing but it ultimately ended up hampering my performance and in conjunction with other things, cost me a lot of money.

I don't use it at all now and just use distinct suffix per strategy on customer order reference strings to distinguish between strats. You live and learn...

---

## 2024-02-09 14:34:14 - random channel

**ShaunW**

Sounds like you guys use logging as some sort of temp db?  Why don't you just stick the CustStrategyRef on the orders? There's clearly a good reason for the flumine way, it but I can't see it.

---

## 2024-02-09 12:46:16 - random channel

**liam**

No, flumine is designed for you to use logging control to store your order data and you should ignore the strategy ref

---

## 2024-02-09 12:44:02 - random channel

**PeterLe**

Thanks Alex,

Yes for use with Flumine Liam. So if I have a single instance (running on one account) with say 5 strats, you cant set the customer_strategy_ref per strategy?

In that case (and assuming you are running on one account) would you have five separate instances each with the customer_strategy_ref set for that instance only?

hope that makes sense? Thanks

---

## 2024-02-09 12:20:15 - random channel

**Alex A**

By filtering the order subscription to a set of strategy refs.

---

## 2024-02-09 12:18:54 - random channel

**Alex A**

It’s also useful if you have multiple strategies that might bet independently on the same market, and you don’t want them messing with bets from another strategy.

---

## 2024-02-09 12:15:50 - random channel

**PeterLe**

I'm not sure how to use this :

`customer_strategy_ref`

I take it if you are running more than one strat on a single account, you can set it within the strat eg laysys1, laysys2 then when looking at results you can determine the results of each strat. Is that how you guys use it?

if so how/where do you set set it?

Sorry I know its a basic question, but if you don't know you dont know :grinning:

Thanks in advance

---

## 2024-02-08 16:27:49 - strategies channel

**dan**

Sure sorry guys [@UBS7QANF3](@UBS7QANF3) [@U012XF5CNPN](@U012XF5CNPN). I was looking into greyhound or horse racing as I felt those would be the easiest to model, Whatever relevent variables I can find like weight, past performance etc. I come from an ML background but not got much experience in this field so no idea how to find good data!

---

## 2024-02-05 20:45:26 - general channel

**Peter**

I wouldn't recommend it. `runner_context` isn't protected and could easily get overwritten. Better would be to store the data in `market.context`.



Personally I'd also consider calculating it in middleware rather than `process_market_book`. This keeps the strategy code clean, makes the result available to all strategies being run on the Flumine instance, and encapsulates the calculation allowing it to be easily re-used elsewhere.

---

## 2024-02-05 09:18:05 - issues channel

**PeterLe**

Jeff thats the beauty of Flumine. You can create a strategy, backtest it and then just uncomment a few lines and you can then run it live. Testing to live in 10 seconds

Liam has wriiten the code for everything you need to do. There no point writing your own.

Ill send you a couple of files to get you started

---

## 2024-02-04 20:32:45 - issues channel

**Jeff Waters**

Fair point, Peter, and working out how to do logging that is more useful than the basic  logging.DEBUG("message") stuff is on my to do list.



My situation at the moment is that I have a system that I've back tested, which I'd like to try applying on automated betting on. However, before I can do that, I need to properly investigate how this stuff works, and then build a bet placement app that also keeps track of how my bets fare. At the moment, I'm just at the research/exploration phase (which I'm finding really interesting, by the way! :slightly_smiling_face: ).



Thanks.

---

## 2024-02-04 19:49:45 - general channel

**ShaunW**

I seperate my data collection and trading [@U013K4VNB6D](@U013K4VNB6D). If you ever need to stop your strategy then the collection is unaffected. Plus a hair of a speed advantage if the trading instance isn't also recording although that can be done asynchronously if you're short of available connections and have to trade and record at the same time. But I'm not using flumine so it could be different in terms of routing one api connection to multiple strategy instances.

---

## 2024-02-04 19:42:20 - issues channel

**Jeff Waters**

Hi Peter



Thanks for taking a look.



I'm not using logging. This is the stack trace, though:



*Exception in thread Thread-1:*

*Traceback (most recent call last):*

  *File "C:\Users\User\AppData\Local\Programs\Python\Python39\lib\threading.py", line 973, in _bootstrap_inner*

    *self.run()*

  *File "C:\Users\User\AppData\Local\Programs\Python\Python39\lib\threading.py", line 910, in run*

    *self._target(*self._args, **self._kwargs)*

  *File "C:\Users\User\Documents\golive\venv\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 60, in start*

    *self._read_loop()*

  *File "C:\Users\User\Documents\golive\venv\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 232, in _read_loop*

    *self._data(received_data)*

  *File "C:\Users\User\Documents\golive\venv\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 273, in _data*

    *raise ListenerError(self.listener.connection_id, received_data)*



This is my full code:



```import betfairlightweight

import queue

import threading

import json



from betfairlightweight.filters import streaming_market_filter, streaming_market_data_filter

from log_in import log_in_and_get_API_client_object



# [https://github.com/betcode-org/betfair/blob/master/examples/examplestreaming.py](https://github.com/betcode-org/betfair/blob/master/examples/examplestreaming.py)



trading = log_in_and_get_API_client_object()

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)



# create stream

stream = trading.streaming.create_stream(listener=listener)



# create filters (GB WIN racing)

market_filter = streaming_market_filter(

    event_type_ids=["4339"], country_codes=["GB"], market_types=["WIN"]

)

market_data_filter = streaming_market_data_filter(

    fields=["EX_BEST_OFFERS", "EX_MARKET_DEF"], ladder_levels=3

)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



# start stream in a new thread (in production would need err handling)

t = threading.Thread(target=stream.start, daemon=True)

t.start()



"""

Data can also be accessed by using the snap function in the listener, e.g:



    market_books = listener.snap(

        market_ids=[1.12345323]

    )



Errors need to be caught at stream.start, resubscribe can then be used to

prevent full image being sent, e.g:



    streaming_unique_id = stream.subscribe_to_markets(

        market_filter=market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=1000,  # send update every 1000ms

        initial_clk=listener.initial_clk,

        clk=listener.clk,

    )



The streaming unique id is returned in the market book which allows multiple

streams to be differentiated if multiple streams feed into the same queue.

"""



# check for updates in output queue

while True:

    market_books = output_queue.get()

    print(market_books)



    for market_book in market_books:

        print(

            json.dumps(market_book.streaming_update),  # json update received

        )```

If I change the event type id back from "4339" to "7", the app works fine.

---

## 2024-02-04 17:05:14 - random channel

**Jonjonjon**

Are there other pre trained models available to try? Apologies but I have little experience in the use of pre trained models.

---

## 2024-02-04 16:42:34 - random channel

**Paul**

Not yet, the article suggests they're releasing it later this year after they've done the usual ethical and moral rails tweaking that all these models need to go through these days.

---

## 2024-02-04 14:30:18 - general channel

**Mo**

There are no concrete rules that anyone is aware of for how much volume is enough volume. Here’s an example strategy you could run that would probably be better than placing random bets: [https://github.com/betcode-org/flumine/blob/master/examples/strategies/lowestlayer.py|https://github.com/betcode-org/flumine/blob/master/examples/strategies/lowestlayer.py](https://github.com/betcode-org/flumine/blob/master/examples/strategies/lowestlayer.py|https://github.com/betcode-org/flumine/blob/master/examples/strategies/lowestlayer.py)

---

## 2024-02-04 13:57:57 - general channel

**Simon Chan**

Hi guys, I'm interested in using the betfair Stream API to collect price data. I'm aware that betfair only allows this usage as long as you show some regular betting activity.  Is there anyone doing similar things and can share how to go about it??  My idea is placing bets randomly with small stakes and always immediately hedge out ,but I don't know how many of these "surrogate" bets are enough to satisfy betfair (let's say if I run my collection bot every day)

---

## 2024-02-04 10:07:14 - strategies channel

**JL**

I had an idea of trying to find arbitrage using graph theory, shortest paths with negative weights but applied to sports. You would need multiple bookies though with automated betting

[https://blog.skz.dev/arbitrage-as-a-shortest-path-problem](https://blog.skz.dev/arbitrage-as-a-shortest-path-problem)

---

## 2024-02-04 09:28:58 - random channel

**Jonjonjon**

Can that timesfm model be downloaded? If so Google for it, I just find the article you shared above

---

## 2024-02-04 09:13:46 - random channel

**Paul**

A few months back there was a release of some time series model or another, and the orange website was full of people saying "we've given up on ML approaches to time series - it's all rubbish, just do some moving averages, it's useful", which surprised me, although I've not dived in much yet into that stuff yet (but planned to)

---

## 2024-02-04 09:11:55 - random channel

**Paul**

Few people need to actually build these things, you want to use someone else's model. What made me curious about this one - due to be released later this year - is that its trained on "100 billion" time series data points, which I think is relatively small, and it includes some "public domain financial series". Is that going to be good enough to make predictions on price movement on betfair? Will be interesting to see.

---

## 2024-02-03 11:39:19 - random channel

**Paul**

Transformer architectures are coming for time series forecasting. [https://blog.research.google/2024/02/a-decoder-only-foundation-model-for.html|https://blog.research.google/2024/02/a-decoder-only-foundation-model-for.html](https://blog.research.google/2024/02/a-decoder-only-foundation-model-for.html|https://blog.research.google/2024/02/a-decoder-only-foundation-model-for.html) 

---

## 2024-02-03 10:36:10 - general channel

**D C**

[@U05REBJ21EC](@U05REBJ21EC) how does this approach hold up in situations where you have multi-selections with one winner, but where number of selections is variable across groups (so basically horse race scenario for modelling winner probability). Does this hold up theoretically in such cases or would you have to analyse separately according to field size ?

---

## 2024-02-03 00:38:51 - general channel

**ShaunW**

Is it all selections or not.  If a strategy selects runners then the assumption that a randomly seleted sample will have an overall 0ev BSP goes out of the window as it's no longer random.

---

## 2024-02-02 20:36:01 - general channel

**JL**

this is quite good, compare with BSP:

[https://betfair-datascientists.github.io/modelling/greyhoundModellingPython/#5-evaluate-model-predictions](https://betfair-datascientists.github.io/modelling/greyhoundModellingPython/#5-evaluate-model-predictions)

---

## 2024-02-02 20:31:29 - general channel

**Jonjonjon**

For betting. One set is actually the prices. The other set will be some sort of model forecast.



Or maybe I'll be comparing two different sets of modell forecasts

---

## 2024-02-02 20:30:08 - general channel

**Ralegh**

Depends what you want them to be better for, if you’re betting then you probably need prices but if you just want an accurate probability model I would use both and stick in a logistic regression 

---

## 2024-02-02 20:29:38 - random channel

**Jonjonjon**

I had a go at fitting Poissons models a few years ago, but my methodology didn't lead to strong returns.

---

## 2024-02-02 17:56:45 - general channel

**ShaunW**

Hi. Try to focus on the specfic things you're investigating. You only need the whole stream for high frequency stuff and that can't really be explored in CSVs, you'd use a backtest for that. But try using a backtest (with no actually betting strategy, just a blitz through the data)  as a means of logging if the data doesn't directly store what you need, or to extract at a lower frequncy, or just in certain conditions.  Also work on just a subset of your data warehouse and then test against the remaining data to safeguard against backfitting and to speed up your analysis.

---

## 2024-02-02 13:37:10 - issues channel

**PeterLe**

Anyone seeing any issues this afternoon like this ;

AccountAPING/v1.0/getAccountDetails \nParams: {} \nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=6.05)", "client": "APIClient", "trading_function": "account.get_account_details", "response": "AccountAPING/v1.0/getAccountDetails \nParams: {} \nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=6.05)"}



Thanks



edit : Seems fine again now :+1:

---

## 2024-02-01 14:37:34 - issues channel

**PeterLe**

I use certificate's too, although it must have been pure luck getting it working :grinning:

from memory I think I used the instructions here ; [http://www.betfairprotrader.co.uk/2015/08/creating-digital-certificate-for-betfair.html](http://www.betfairprotrader.co.uk/2015/08/creating-digital-certificate-for-betfair.html)



you will need to add something like this in your code too :

```trading = betfairlightweight.APIClient(myacc, mypass, app_key, certs=r"C:\certs")```



---

## 2024-02-01 12:53:59 - issues channel

**Brian Morton**

Guy's I am not new to trading but I am new to Flumine and I am now starting to follow the instructions in 'How To Automate 1' in Betfair



What is your take on the paragraph



You can use the Flumine package with or without certificates. There have been quite a lot of discussions of how useful the security certificates are on the [https://betcode-org.slack.com/ssb/redirect|Betcode (formerly Betfairlightweight) slack group](https://betcode-org.slack.com/ssb/redirect|Betcode (formerly Betfairlightweight) slack group), but the general consensus is that its not too useful. Considering it is an extreme hassle to create the certificates and there is no really added benefit I prefer to log in without the certificates.



Do you guys use certificates or not.

---

## 2024-02-01 12:51:43 - issues channel

**Brian Morton**

Guy's I am not new to trading but I am new to Flumine and I am now starting to follow the instructions in 'How To Automate 1' in Betfair

---

## 2024-01-29 09:58:40 - general channel

**Jonjonjon**

I don't think making £1 per market would be trivial for someone without a good starting strategy. If done consistently, I'd consider it a great achievement

---

## 2024-01-28 21:17:15 - strategies channel

**Ralegh**

Makes sense, and yeah shouldn’t matter either way if not latency sensitive.



I think generally I try to keep trading code stateless so the logic by default would just be to ignore failed orders and only retry if conditions are still true. Target position = (calculation)… trade while position &lt; target position. Or target position at price level = (calculation) and the same

---

## 2024-01-28 19:23:46 - strategies channel

**thambie1**

For those going based of price action, I can see why they might. If based on fundamentals, the strategy should retry on its own without being explicitly told to do so

---

## 2024-01-28 14:21:41 - general channel

**JazzMan**

Same strategy. Just been improving it over the years by adding in amount matched per second, and spliting it up for different prices

---

## 2024-01-28 14:08:32 - general channel

**liam**

I assume a similar strategy still used, has this been a gradual drop or a big bang when it comes to profit as that is a big difference!

---

## 2024-01-28 10:13:11 - strategies channel

**James**

Are many here making money off predictable market dynamics/behavioural trends as opposed to modelling and fundamentals?

I may be wildly off but It seems the majority of the big fish here seem to do it on modelling/ml/statistical analysis rather than behavioural things is this true or am I off the mark?

---

## 2024-01-28 10:08:34 - general channel

**D C**

He was a strange one. I remember all that stuff like "my codebase providing the most advanced betting framework out there" was hard to take. Then we had gems like "there is more than one value price for an outcome". Could never get my hear around why someone who had worked for a horse syndicate would start off his solo career with a partner who modelled tennis!! Ended up blocking him on twitter as his ego was writing cheques that his IQ could not deliver. Last I heard he was doing something with GPS and greyhounds.

Honestly surprised he never released an e-book.

Genuinely miss him though. We need more quirky characters!!

---

## 2024-01-27 12:56:23 - general channel

**Jonjonjon**

Strangely, some of the psychology and mindset stuff helped me, though I admit that most trading/psychology related material is a scam.

---

## 2024-01-27 10:19:52 - strategies channel

**D C**

Yeah I don't blame you [@U4H19D1D2](@U4H19D1D2) just thinking about all of the interactions and complexities makes my head hurt. I'm going to just leave mine as it is and use it as a rough indicator of a strategy being worth moving to live or not. It might make me design strategies in a way that minimises these issues from now on though.

---

## 2024-01-27 10:14:41 - strategies channel

**liam**

[@UUE6E1LA1](@UUE6E1LA1) it doesn’t, I have tried to keep a a balance of accuracy and complication, as I have found adding things such as simulated updates or removing amounts available just adds more noise. I would rather it have a decent benchmark on matching/profit over a wide range of scenarios and use the market itself for fine tuning a strategy.

---

## 2024-01-27 10:08:34 - strategies channel

**D C**

I was thinking about it all day after your initial message made the penny drop for me. I suppose it might only be a problem if you are placing large numbers of bets within a smal time frame. I thought I had a dirty "solution" but I didn't bother implementing it because I then thought of another issue. Not sure if flumine caters for this but  my own simulator certainly doesn't: if your strat uses LTP or TV as a signal when you place an actual bet, you'd receive an API update with the LTP and your own traded volume. In simulation you'd not receive these values - to properly simulate you'd need to artificially insert a new stream update containing your own simulated match (or add to an existing update if the times matched - does flumine actually do this??).

So in reality, any strategy (and other concurrently run strategies) running live, is potentially acting on market signals that they themselves create - but my simulator doesn't add these extra stream updates.

This made me start thinking about running simulations on recorded market data that your own strategies ran on historically - so you could be simulating matches of your own offered money, or competing with your own historical orders.

So basically the whole quantum mechanical nature of simulation made me slightly depressed and ask if it is even worth trying to get more accurate.

Don't get me wrong though [@U016TGY3676](@U016TGY3676) -  deep down I am glad you posted your original post. It's always good to try and find holes in your own code.

---

## 2024-01-27 03:35:43 - general channel

**Jared King**

whats the strategy? ill code it up for you

---

## 2024-01-27 00:28:23 - strategies channel

**birchy**

[@UUE6E1LA1](@UUE6E1LA1) you described the issue perfectly. [@UBS7QANF3](@UBS7QANF3) so all of my simulation stuff assumes bpe is off as I've not (yet) found a single strategy that is better with it enabled. I used to keep track of the previous price and only checked my signals if the price had changed in the current update. That has an issue where: if the price was adjusted but the size available remains the same, then I'm still taking more money than is available.

I also tried various delays and also forcing my bets to be passive, where I enter at 1 tick away from where I want to be but then the strategy is no longer executing at the desired price.

The main issue is simulating strategies which are operating on market movement where missing the target price affects profit. I've currently settled for one bet per price/side/selection but that significantly reduces the hit rate. Testing these strategies live, I'm seeing different matches vs simulation of the same markets. My best live strategy (which has been running for several years) would of been binned if I had simulated it before going live and still performs poorly in simulation, so I guess I'm operating within XM/market impact territory and live testing with small stakes is probably the way forth.

---

## 2024-01-26 13:45:55 - general channel

**Mo**

I can't comment on that guide. Take a look at [https://github.com/betcode-org/flumine|flumine](https://github.com/betcode-org/flumine|flumine), especially the [https://github.com/betcode-org/flumine/tree/master/examples|examples](https://github.com/betcode-org/flumine/tree/master/examples|examples) and specifically an [https://github.com/betcode-org/flumine/blob/master/examples/strategies/lowestlayer.py|example strategy](https://github.com/betcode-org/flumine/blob/master/examples/strategies/lowestlayer.py|example strategy)

---

## 2024-01-26 13:40:29 - general channel

**jnik**

Hi I have found a winning strategy on greyhounds (around 3 months of data), I've successfully tested this strategy past few days,  but problem is I need to spend 12 hours a day betting and its extremely tiring. So I'd like to automate this.



The information is contained in my own db -&gt; mysql and server is a remote server that runs  ubuntu.



Is their any guide to building this automated bot?

---

## 2024-01-26 13:34:55 - strategies channel

**birchy**

When using Flumine simulation, what's the best practice for _taking_ prices where the strategy could be potentially taking the same size multiple times because the available size hasn't been reduced accordingly?

---

## 2024-01-25 08:41:42 - general channel

**Jared King**

Hi All, wondering if someone could help me with the flumine way to close out a bet? eg lay runner at $1.50 and close out all liability when price is $2.50. Currently tracking orders with a separate dict (i know). Should I implement in process_orders? Or use the blotter? One more thing, if I use `get_exposures(self, strategy, lookup: tuple, exclusion=None)` to get strategy/selection exposures, what would the lookup tuple look like?

Many thanks!

---

## 2024-01-24 14:44:46 - strategies channel

**Jared King**

You helped me yesterday so maybe I can help back :stuck_out_tongue:

You could use CalibratedClassifierCV from sklearn.calibration, You use your original model eg XGBoost as the base classifier. Plot your calibration curve before and after.

```def show_calib_curve(x, y, bins=20):

    cal_y, cal_x = calibration_curve(x, y, n_bins=bins)

    plt.figure(figsize=(12, 9))

    plt.plot(cal_x, cal_y, marker='o', linewidth=1)

    plt.plot([0, 1], [0, 1], '--', color='gray')

    plt.title("Calibration curve");```

I also like to plot my strike rate against SP strike rate to see how close it looks.

`show_strike_rate(test_data['prob_LogisticRegression'], test_data['StartPrice_probability'])`

```def show_strike_rate(x, y, bins=100):

    sns.displot(data=[x,y], kind="hist",bins=bins, height=7, aspect=2)

    plt.title('StartPrice vs LogisticRegression probabilities distribution')

    plt.xlabel('Probability')

    plt.show()```

Apologies if i misunderstood what you are after :confused:

---

## 2024-01-23 19:46:53 - strategies channel

**liam**

Opposite I think, ie a high ev is showing back profit, the price available is better than my models probability.



After some discussion and getting myself very confused I am going back to my model to try a simulation technique to see if I can improve my prediction.

---

## 2024-01-23 16:07:44 - strategies channel

**Bert Raven**

sorry my language wasn't clear, but the idea is that you bucket your model probabilities into say 100 buckets, do the same with the SP probabilities, then you match them. So the highest 1% of model probabilities then have a market price of the highest 1% of SPs.



just to be clear wrt chart, small -ve ev back bets show -ve profit, but high -ve ev bets show +ve backing profits?

---

## 2024-01-23 11:31:15 - strategies channel

**liam**

[@U01QCEQD9MF](@U01QCEQD9MF) this is showing backing only, I might need this explaining to me like I am 5



&gt; a simple rescaling would be to say the x-percentile of your model probability maps to the y-percentile of the SP distribution

[@UUE6E1LA1](@UUE6E1LA1) no idea, let me try and visualise that

---

## 2024-01-23 11:21:59 - strategies channel

**D C**

Are your model probabilities well calibrated to start with or does it perform badly for certain ranges?

---

## 2024-01-23 11:06:42 - general channel

**Jared King**

Ahh Thanks Liam, I understand how flumine works now wrt instance/strategy. I will check out your example. Thanks you so much :)

---

## 2024-01-23 11:05:53 - strategies channel

**Bert Raven**

a simple rescaling would be to say the x-percentile of your model probability maps to the y-percentile of the SP distribution, or you could use a simple regression (though imo that doesn't work well), or you can use a classifier as you've linked to

---

## 2024-01-23 10:57:32 - strategies channel

**liam**

I think [https://machinelearningmastery.com/calibrated-classification-model-in-scikit-learn/|this](https://machinelearningmastery.com/calibrated-classification-model-in-scikit-learn/|this) solves my problem but I need it in english

---

## 2024-01-23 10:53:46 - strategies channel

**D C**

So is it a bit like your model output gives a rating (for want of better word) per runner and you want to map those to probabilities for betting purposes - but runner SP is not one of your model inputs?

---

## 2024-01-23 10:47:42 - strategies channel

**Unknown**

Yeah, sorry, so I have taken my model predictions and created a probability (no reference/knowledge of market sp or price) using a normal dist, I have then compared this prediction to the current price to get an EV.



```ev = model_probability - (1 / price)```

Graph below shows this EV against cumulative profit, which is great because it is showing that my model is correctly showing where the value is (ev &gt; 0). However I know that this model/prediction is very naive due to it not taking into account the prior probability (SP) which is highlighted in the original graph when I bucket by SP.

---

## 2024-01-23 10:25:17 - strategies channel

**Bert Raven**

I'm probably not adding any value here and don't understand what the axes on the chart are, but it sounds like you are trying to calibrate model probabilities to implied market probabilities. There is quite a bit of literature on that. Personally I find a relatively straightforward scaling (before looking at ev and profitability) to be robust. The important step imho is effectively adjusting the confidence and appropriate bet size afterwards

---

## 2024-01-23 09:52:52 - general channel

**liam**

So flumine hacks the `customerStrategyRef` as a filter for which 'instance' makes the bet as opposed to the strategy level (as you want) To handle this the 'flumine' way is to record all of your bets using loggingcontrol and then link them up, an example [https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|here](https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|here) where you could record the betId and strategy name.



Currently by changing the config you will break the order stream as these orders' wont be received/processed.

---

## 2024-01-23 09:20:56 - general channel

**Jared King**

I dont understand how to use loggingcontrol to set customerStrategyRef for each of those strategies. Im sure there is a v good reason, but i would have intuitively set customerStrategyRef in the trade.create_order() function. Thanks for your time, i do love the software.

---

## 2024-01-23 09:20:27 - general channel

**Jared King**

my 'setup' is like (eg):

```horseracing_main.py - trading, client and framework created here

greyhounds_main.py

strategies/

   horseracing1.py - BaseStrategy classes

   horseracing2.py

   horseracing3.py

   greyhounds1.py```

---

## 2024-01-23 09:16:48 - general channel

**Jared King**

i create order like this:

```config.customer_strategy_ref = 'HR_main'

trade = Trade(

    market_book.market_id,

    runner.selection_id,

    runner.handicap,

    self,

)

order = trade.create_order(

    side="BACK",

    order_type=MarketOnCloseOrder(self.context["stake"]),

    notes=OrderedDict(strategy='pick_winner'),

)                     

market.place_order(order)```

---

## 2024-01-23 09:12:52 - general channel

**Jared King**

Hmm my understanding was that you could run multiple strategies eg horseracing strat, greyhound strat, tennis etc. I was using strategyRef as a way for the betfair account to have a ref for my strategy's orders, so when I list cleared orders I can filter by strategyRef. Have I fundamentally misunderstood?

---

## 2024-01-23 08:58:09 - strategies channel

**Unknown**

I have been continuing my machine learning strategy from fundamentals and having an issue with EV and SP. When converting my predictions to probability the EV is shifted depending on the SP. I can see that this would be expected but I am intrigued to how others handle this, current ideas:



&gt; Dynamic prediction -&gt; probability conversion based on SP

&gt; Bucket SP's and fit 



---

## 2024-01-23 08:17:42 - general channel

**Jared King**

Hi all, wondering if there is a way to set customerStrategyRef per strategy or is it only instance wide? Currently setting config.customer_strategy_ref = 'my_strategy' just before i place an order. Doesn't seem right.

---

## 2024-01-22 16:42:08 - random channel

**Paul**

Also might be worth looking at the distribution of latencies. [@U4H19D1D2](@U4H19D1D2) posted about being non-profitable at 250ms added latency the other day. If you were running that strategy with p95 +/- 10ms, you’d be probably fine. But at p99 +/- 500ms, maybe not…

---

## 2024-01-21 19:23:32 - random channel

**Ralegh**

Jiggling about with servers to get a good connection is a valid strategy 

---

## 2024-01-21 15:57:59 - general channel

**liam**

streaming_timeout on the market filter / strategy from memory 

---

## 2024-01-21 10:38:02 - random channel

**Jonjonjon**

Surely the models required are very different?

---

## 2024-01-21 10:37:44 - random channel

**Ralegh**

These guys can bring models from tradfi that have been in development since years before crypto exchanges even existed. 

---

## 2024-01-21 10:36:04 - random channel

**Ralegh**

Significantly higher startup costs though, and you can only make that money on the best fee tiers. Like you need probably $1-5M for data and model calibration (compute costs on 5 years of tick data across 100 symbols, 30 exchanges), these guys are at HFs so they have much more support. Models meaning you need to have short term price forecasts which is where (I assume) a lot of the alpha is, and that requires tons of signal research. Then you need to be doing probably $100M-$1B or more monthly volume across the exchanges to get low enough fees to be profitable. 

---

## 2024-01-21 10:14:59 - random channel

**Ralegh**

Depends who you believe, Michael Lewis says they were extremely profitable (without customer funds) and that their traders were pretty arrogant about it. Their first big trade was a mass crypto cross-exchange bot and the twitter post seems to be operating on several exchanges. I think traditional quant firms have taken that over now, and I’ve heard of one team at a HF who made billions over the last few years doing that (with more complex strategy ofc), so there was definitely profit to be made before competition arrived. 

---

## 2024-01-21 09:15:38 - random channel

**Ralegh**

Seems to be, again weird the lack of tech knowledge, you’d assume they didnt write much of the code themself, maybe someone who kept strategy code from a firm (maybe a crypto firm that went bust like alameda)

---

## 2024-01-20 14:15:50 - issues channel

**NAS**

Hi



I have a 23hr/day login limit on my account, have been in touch with customer service and they claim it's impossible to remove... Seems weird that everyone in here should be capped at 23 hours of trading/day, if someone knows how to get around it please let me know! :slightly_smiling_face:

---

## 2024-01-19 14:29:35 - strategies channel

**thambie1**

[@UBS7QANF3](@UBS7QANF3) variance in returns or some similar metric solves the first problem way better. ROI (calculated as discussed) is a poor proxy for figuring out how much capital a strategy is tying up. Best to track that directly

---

## 2024-01-19 14:15:59 - strategies channel

**Mo**

Obvious reasons? If strategy A is risking 10 times the amount per bet to strategy B then you need some kind of standardisation. If strategy C has the same profit as strategy D but C had to risk a lot to get there then it might not be worth tying up capital on strategy C, or you might infer that strategy C is much closer to liquidity limits

---

## 2024-01-19 14:06:32 - strategies channel

**Mo**

In my apparently wrong opinion it should be `sum(profit) / sum(liability)` where for back bets the liability is equal to the matched stake. I also use ROI as the headline metric in comparing strategies, monitoring for degrading strategy performance, identifying areas where strategies need improvement, and evaluating the impact of said improvements

---

## 2024-01-19 13:46:33 - strategies channel

**birchy**

I suppose I'm just trying to get a number to use for comparing strategy A vs B and thinking about it like an interest rate or investment return. I've also seen people use their bankroll growth to calculate, i.e. deposit £500, bankroll now = £750 = 250 / 500 = 50%. 



[@U4H19D1D2](@U4H19D1D2) I am inclined to agree but laying £1 @ 100 is £99 risk rather than £1, so what are your thoughts/findings on just using matched sizes?

---

## 2024-01-19 13:30:11 - strategies channel

**birchy**

Curious, how are others calculating ROI/ROT, particularly for LAY bets? I do the following but not sure if it's the best way to get a ballpark figure for strategy comparison...

`back_roi = sum(profit) / sum(matched_stakes)

lay_roi = sum(profit) / sum(liabilities)`



I treat every bet as an individual but there's also an argument for calculating at market level which is more complicated. There's also an argument for calculating lay bets using the matched stakes only which gives like for like comparison between back and lay bets, however that doesn't fully reflect the liability/risk?

---

## 2024-01-18 13:48:21 - random channel

**ShaunW**

Didn't know that [@UQL0QDEKA](@UQL0QDEKA) I use 4.5 and it told me I couldn't give it a whole project? Fully compiled [@UUE6E1LA1](@UUE6E1LA1) I don't have any special setting for the compiler. With placement being anywhere from 80ms to 170ms I spend more time on improving the strategy than trying to shave off half a millisecond. I process market change messages and orders asynchronously anyway so not struggling for speed too much.

---

## 2024-01-17 20:47:26 - general channel

**Unknown**

Hi All relatively new, just started reading “Sports Trading On Betfair” appreciate some of you may think these book are useless, but it’s helped me brainstorm a few ideas. 



Anyway the author attached figure 15 which shows for a given horse it’s previous races, including it’s Betfair SP and Inplay high. 



This type of data I would love to scrape/obtain for the horses. Has anyone seen where this exists? The author says the “Timeform/Betfair” website, but I can’t find anything remotely similar. 



If it no longer exists or never did, is my best option to obtain some historic data and try to derive my own BetfairSp/Inplay high? What’s the best way to go about that. 



Appreciate any help :heart: 

---

## 2024-01-17 19:29:19 - random channel

**Andrey Luiz Malheiros**

Hey guys, how much time on average does it take to run a simulation of a single strategy for 2000 markets?

---

## 2024-01-16 17:41:03 - general channel

**Unknown**

the pitchforks may get pointed at me for this but - just an opposing view on betfair basic data. because it gets a very bad rap in here and needs some friends



• it is definitely useless if you’re trying to do anything low-latency/inplay/high frequency/purely market data-driven

• if your work (like mine) does not fall into this category, its a totally fine place to start. i found it extremely useful when starting out

• a runner’s last traded price accurate to within 1 minute (available in basic data) is far from useless. could be the thing that makes your purely fundamentals model into something profitable

---

## 2024-01-16 12:52:17 - general channel

**Jonjonjon**

If your strategy is simple, well written and clean, you can even run over 100 of them on a micro instance.

---

## 2024-01-15 20:40:56 - general channel

**Steve**

Hello :wave:  apologies I'm new to this and I'm sure you've probably seen my questions 100 times before, but I was just hoping for a little direction if possible:



1. I'm looking to parse the historic data files for American football data and preferably to analyse in a csv file.  For this I thought I might need to use betfairlightweight rather than flumine? As I'm not looking to do automatic trading atm I thought BFW was the right program for that?

2. If so, I was looking at the [https://github.com/betcode-org/betfair/blob/master/examples/examplestreaminghistorical.py|example historical stream](https://github.com/betcode-org/betfair/blob/master/examples/examplestreaminghistorical.py|example historical stream). Given the data file structure is in the format of `{month}/{day}/{marketID}/{...bz2}` I guess I need to traverse the folders and load in each file individually?

3. I've seen people talk about recording prices themselves though the [https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py|MarketRecorder](https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py|MarketRecorder) rather than buying historic data after the fact. Do you generally put that on an EC2 or something running 24/7?

Apologies if these are all very basic!

---

## 2024-01-15 19:48:23 - issues channel

**Gooat**

Sweet. I need to learn how to monkey patch now. (orderstream, customer_strategy_refs=[] and current_order.customer_order_ref = blah if "")

---

## 2024-01-15 19:25:13 - general channel

**Jonjonjon**

I'm only part time, but I could live off my Betfair winnings. A reason I don't is that my model could stop working at any point in time (similar to being able to get fired at any time I guess), and that being employed gives you benefits such as NI contributions (but if you have children, you can claim child benefit and that will give you NI contributions too without having to work).



But in your favour, I think some of the most successful guys here are software devs. I'm a professional-level Python dev (which doesn't mean I'm one of the best, it just means that I'm good enough to convince people to pay me to do it.)



One thing to consider is... What was your worst ever losing day, and how did you feel about it?

---

## 2024-01-15 18:11:44 - issues channel

**foxwood**

Funnily enough just noticed that today - bets placed from another system show up in the log as not being in the blotter. Looking at the code I think flumine then tries to recreate the order and finally gives up when it can't find the strategy. So, if you know what the alien bets are you should be able to plug in and add them to your strategy as if you made them ? Top level function `create_order_from_current()` in flumine.order.py  tries to recreate - that's as far as I got - may help,

---

## 2024-01-15 16:56:20 - issues channel

**Gooat**

Trying to get Flumine to handle/see orders on the stream not placed by it and with no customerStrategyRefs on those bets. If I subscribe to the orderstream without a ref then add the bets to blotter like the middlewear example will anything catch on fire?

---

## 2024-01-15 10:05:02 - issues channel

**foxwood**

doh ! wood for trees - thank you. Think it is the issue since Trade will not have the order in it's list.

At least my normal stuff does it properly. I was trying to work out a way of placing multiple bets in a single call to BF - the API supports list of orders it seems but can't see a way of doing that in flumine since the Trade is tied to a single selection.

Arose trying to save processing time and get the bets back asap after strategy requirement seen.

---

## 2024-01-14 15:31:12 - issues channel

**Derek C**

Possibly related issues: I do not see TPD data coming through Flumine from version 2.3.0 onwards. I've been upgrading from old versions so could have missed some steps.



> pip3 install flumine==2.2.7

I see output from "process_sports_data"



> pip3 install flumine==2.3  # or 2.5.4, 2.5.6

no output from following example:



```

class ExampleStrategy(BaseStrategy):

    def process_sports_data(self, market, sports_data) -> None:

        # called on each update from sports-data-stream

        print('***',market, sports_data)



client = clients.BetfairClient(trading)



framework = Flumine(client)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"], market_types=["WIN"],

            country_codes=['GB' ],

    ),

    sports_data_filter=['raceSubscription'],  "raceSubscription"

)

framework.add_strategy(strategy)



framework.run()```



---

## 2024-01-14 15:01:05 - issues channel

**Derek C**

Does anybody else experience this error with Flumine 2.5.6?



>  line 182, in _process_sports_data

>     event_id = sports_data.event_id

> AttributeError: 'Race' object has no attribute 'event_id'

It seems a genuine error when I inspect in the debugger - there is no 'event_id' in the Race object. If I switch to Flumine 2.5.4 then the error doesn't occur because the code references market_id instead of event_id in 2.5.4.



My sample code to reproduce the error:



```

class ExampleStrategy(BaseStrategy):

    def process_sports_data(self, market, sports_data) -> None:

        # called on each update from sports-data-stream

        print('***',market, sports_data)



client = clients.BetfairClient(trading)



framework = Flumine(client)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"], market_types=["WIN"],

            country_codes=['GB' ],

    ),

    sports_data_filter=['raceSubscription'],  

)

framework.add_strategy(strategy)



framework.run()```

---

## 2024-01-14 13:37:04 - issues channel

**foxwood**

Call strategy.placeOpenBets() once from process_market_book() - example to lay 10p at current lay price on every runner - not Asian since hcap forced



    `def placeOpenBets(self, market, market_book):`

        `for r in range(len(market_book.runners)) :`

            `if market_book.runners[r].status != "ACTIVE": continue`

            `trade = Trade(market.market_book.market_id, market_book.runners[r].selection_id, 0, self, )`

            `o = BetfairOrder( trade=trade, side="LAY",`

                                `order_type=LimitOrder(price=1.10, size=1.00),`

                                `notes=OrderedDict(`

                                    `required_size=0.10,`

                                    `required_price=market_book.runners[r].ex.available_to_lay[0]["price"],`

                                `),`

                            `)`

            `market.place_order(o)`



    `def process_orders(self, market, orders):`

        `for order in orders:`

            `if order.trade.strategy != self : continue`

            `if order.status != OrderStatus.EXECUTABLE: continue`

            `# completed order - change stake or odds if needed`

            `if "required_size" in order.notes:`

                `if order.notes["required_size"] != 0.00:`

                    `size_reduction = 0.90`

                    `market.cancel_order(order, size_reduction=size_reduction)`

                    `order.notes["required_size"] = 0.00`

                `elif order.notes["required_price"] != 0.00:`

                    `# ensure size reduction has gone through - if not leave it at £1 @ 1.10`

                    `if order.size_cancelled == 0.90:`

                        `market.replace_order(order, new_price=order.notes["required_price"])`

                        `order.notes["required_price"] = 0.00`

---

## 2024-01-10 10:09:27 - general channel

**river_shah**

Hi Peter, unfortunately my guess would be as good as any others. Crypto is model driven, short term trading for me.

I am biased long as I believe in the anarcho capitalist, alternate monetary system narrative but the sharpe ratio on that view is pretty miserable

---

## 2024-01-09 08:43:45 - random channel

**lorenzo**

thanks of reply! just to double check - adding each one of the 100 with `add_strategy` ?

---

## 2024-01-07 19:39:43 - strategies channel

**liam**

Very strategy dependant 

---

## 2024-01-07 16:25:48 - strategies channel

**JazzMan**

This is very interesting because when I roll out a new strategy it's profitability decreases after the first week. Continues to go down before stableising

---

## 2024-01-06 22:07:05 - strategies channel

**birchy**

Given that ML is popular, does anyone else here randomise execution to avoid becoming predictable? I've been testing it recently and it does seem to have a positive impact. Or random is better than my strategy. :grinning:

---

## 2024-01-06 15:31:26 - random channel

**AndyL**

[@U4H19D1D2](@U4H19D1D2) "tick to trade", so does this mean the time between your strategy seeing the "signal" and the time the trade is placed/matched ?

---

## 2024-01-06 12:35:02 - random channel

**liam**

I normally don’t go above 5, strategy dependant, they are called sequentially and in order so it depends how sensitive you are to latency. When optimising the preference would be 1 strategy per instance, I record tick to trade to monitor this 

---

## 2024-01-06 12:16:32 - random channel

**Alex A**

What’s a back to lay strategy?

---

## 2024-01-04 13:39:13 - random channel

**D C**

A few discussions on here recently got me thinking and I wanted to pose a question about CLV / BFSP efficiency. The TLDR is basically:



_Betfair betting volumes are in decline over recent years, could this lead to BFSP becoming less accurate?_



I am asking this as much to fill gaps in my own knowledge and understanding, but AFAIK, the whole CLV premise is based upon prices converging to probability X at time of event start because of information flow over time and sharper players exploiting value when it presents itself (I am guessing this is analogous to market efficiency hypothesis in finance??). So IF we were to show that BFSP was STILL just as accurate 5 years ago as it was now, could you effectively deduce that it is only "dumb" money that is abandoning the markets? If you actually wanted to measure the efficiency of BFSP and its fluctuation over time, what statistical approaches could you use? I know people use brier score to rate probabilistic forecasts so could you use something like this split over a time partition and compare? Up to know, I've not really cared much about CLV as I exclusively bet IP where it is not really applicable. Similarly, I've not been much bothered with measuring my edge (until recently never even bothered calculating ROI until a discussion on here with someone) and just let profit be the measure (I don't lose sleep if Joseph Buchdahl labels me a victim of survivorship bias). But I want to move into pre-off horses and so been thinking more and more about BFSP and the recent drop in volume topic got me thinking about this. I often hear that BFSP is "accurate on average" but never seen any hard numbers and certainly never an analysis of its accuracy change over time.

---

## 2024-01-03 16:58:04 - random channel

**Peter**

Providing liquidity isn't a problem for most pros. It's finding enough liquidity on the other side to match against. So if liquidity overall is down that suggests to me that non-pros are betting less, rather than more.

---

## 2024-01-03 12:05:19 - general channel

**Trex44**

Thanks for the info Mo. Very interesting. I have hardly any edge in horse racing. The strategies have back tested well but have been live for such a short amount of time that I can't get confident enough to put large sums into them yet. They don't require live data feeds but I spend a fair bit on AWS services crunching through the data to find the edge. I picked betfair trading to try my hand at over financial markets back in 2017ish as I thought it would be easier that financial markets :woozy_face:. I did Peter Webb's course about 5 or 6 years ago, met him in person. Lovely guy, but realised I would never have the temperament to sit in front of a screen and do what he does, would much rather automate it but didn't know how then. So it went on the back burner whilst other things took over. Got serious about it again at the start of 2023. Part of the appeal for getting back into it was Flumine, I wanted to learn python and having a project to work on rather than craming leet code is a good way to do it. It has been great for learning python and how AWS works.

---

## 2024-01-03 11:46:13 - general channel

**Mo**

1. I have one core strategy and everything else I've tried to expand into hasn't worked. From speaking to other people, I think this is reasonably common

2. I think any of the established players you talk to will tell you this game is getting increasingly harder. How much of that is down to lower liquidity versus increased competition is hard to say. And how much of an impact on liquidity the affordability checks are having is anyone's guess

3. For example, [@U4H19D1D2](@U4H19D1D2)’s shared that his pnl is down 30% for the year. It doesn't take that happening many years in a row for there to be (much) easier ways to make money

4. I can't go into details about the costs but if you think of a number and then multiply it by 100 you might be getting close to the total. Another factor is a lot of them are denominated in foreign currency so the exchange rate is another vector by which I can get be screwed over

5. I've tried to expand into market making and have been getting fucked in the arse by Betfair transaction charges. The lack of support from Betfair to encourage liquidity provision has been really disappointing

---

## 2024-01-03 10:28:46 - strategies channel

**Unknown**

Sorry for the delay, Liam. I'll send the code in a file just to try to make it easier. But basically, instead of generating a file and saving it, I'm storing all the updates in a string and, in the end, uploading it to a database. I use Django, so the StrategyManagementMarketRecorder is the model responsible for inserting into the database. The structure is based on your market recorder code.

---

## 2024-01-03 08:06:11 - general channel

**river_shah**

Happy new year everyone! '23 saw some good growth within sports betting. My goals for '24 are to keep focusing on more scalable and robust research methods and automating ever more. Also one of the key goals is to find exceptional people to work with. If you are an experienced researcher / trader constrained on technology, capital or market access and could benefit from collaborating, please DM me for an exploratory chat. Focus is sports betting &amp; crypto.

---

## 2024-01-02 15:50:09 - general channel

**Ricky**

Hi everyone! I'm fairly new to the automated betting world and would like to start by getting my hands on some of the historical data that betfair supplies at [https://historicdata.betfair.com/#/home](https://historicdata.betfair.com/#/home). Problem is that I live in Sweden and this service is not accessible for us swedes... Does anyone know an alternate way to get access to historical data? Thanks in advance! :raised_hands:

---

## 2024-01-01 23:02:16 - general channel

**PeterLe**

more of a reason than a strategy...and that is to test myself against some of the brightest minds. It brings many more benefits that just monetary gains

---

## 2024-01-01 22:53:57 - general channel

**Jonjonjon**

What is your strategy for maintaining enthusiasm?

---

## 2024-01-01 21:02:58 - general channel

**Jonjonjon**

I just want to improve my model calibration skills.



I roughly maintained my annual PNL in 2023.



Would like to increase it by 10x this year, which would put me in the [@UBS7QANF3](@UBS7QANF3) league

---

## 2023-12-29 10:14:03 - random channel

**D C**

I'd been at it for years off and on. Started botting on the SOAP API but only data gathering. In truth everything I was doing was pretty half arsed - the only things I had working models for there was zero money available on Betfair (MLB basically). I turned it around getting on for 4 years ago now. Started off at minus £50K after years of recreational betting and failed "systems" (although on the plus side that heavy usage means I still don't pay PC)

---

## 2023-12-29 08:59:57 - random channel

**Mo**

How can you be building ML models if you don't even have decent price data? Stop fucking around and just start recording the price stream

---

## 2023-12-26 18:24:14 - general channel

**Matthieu Labour**

Hello

In the following tennis example [https://github.com/betcode-org/flumine/blob/master/examples/tennisexample.py#L30](https://github.com/betcode-org/flumine/blob/master/examples/tennisexample.py#L30), what is the timestamp for Score and the timestamp for MarketBook that I can use to compare the timeline of those events?

Should it be the Score’s datetime_created or datetime_updated? (They seem to be identical) [https://github.com/betcode-org/betfair/blob/master/betfairlightweight/resources/baseresource.py#L14C28-L14C28](https://github.com/betcode-org/betfair/blob/master/betfairlightweight/resources/baseresource.py#L14C28-L14C28)

and, as far as the MarketBook is concerned, should it be publish_time_epoch, publish_time, _datetime_created (in BaseResource), _datetime_updated (in BaseResource)?

The reason that I am asking is because I want to enable inplay betting within N seconds after the score is established.

Thank you for your help

---

## 2023-12-25 17:39:20 - general channel

**Matthieu Labour**

Hi all,



I am looking for guidance to implement properly in Flumine what I have done below in a hacky way. I would be grateful for any help on how to leverage flumine constructs as opposed to the hacks I have in place. Thank you in advance!



The purpose is to run a simulation in tennis with scores and marketdata.



The historical file that is being streamed has both mb and score



Example:

```[...]



"op": "mb", "clk": "APTx4AcAw63/BgDA8+cH", "pt": 1698962123328, "mc": [{"id": "1.220368399", "rc": [{"atb": [[1.55, 133.58]], "id": 51718172}]}]}



{"op": "score", "clk": "", "pt": 1698962127237, "mc": [{"eventTypeId": 2, "eventId": 32753994, "score": {"home": {"name": "Hunter/Mertens", "score": "15", "halfTimeScore": "", "fullTimeScore": "", "penaltiesScore": "", "penaltiesSequence": [], "games": "0", "sets": "0", "gameSequence": [], "isServing": true, "highlight": true, "serviceBreaks": 0}, "away": {"name": "Krawczyk/Schuurs", "score": "15", "halfTimeScore": "", "fullTimeScore": "", "penaltiesScore": "", "penaltiesSequence": [], "games": "1", "sets": "0", "gameSequence": [], "isServing": false, "highlight": false, "serviceBreaks": 0}}, "currentSet": 1, "currentGame": 2, "fullTimeElapsed": {"hour": 0, "min": 0, "sec": 0}}]}



{"op": "mb", "clk": "AJv04AcA+a//BgC29ucH", "pt": 1698962128901, "mc": [{"id": "1.220368399", "rc": [{"trd": [[2.82, 66.15]], "ltp": 2.82, "tv": 916.22, "id": 43352014}, {"atb": [[1.55, 13.23]], "trd": [[1.55, 120.35]], "ltp": 1.55, "tv": 1413.85, "id": 51718172}], "tv": 2330.07}]}



[...]```

And the strategy is the example of the tennis strategy in flumine



```class ExampleStrategy(BaseStrategy):

  def process_market_book(self, market, market_book):

        # process marketBook object

        if "score" in market.context:

            score = market.context["score"]

            print(

                score.match_status,

                score.current_game,

                score.current_set,

                score.current_point,

                score.score.home.score,

                score.score.away.score,

            )```



I have the following hacks in place



In `historicalstream.py`, I combine the lines mb and score lines so I get the score in the mb message

```[...]

    def on_data(self, raw_data: bytes) -> Optional[bool]:

        try:

            data = json.loads(raw_data)

        except ValueError:

            logger.error("value error: %s" % raw_data)

            return



        # remove error handler / operation check



        # skip on_change / on_update as we know it is always an update

        publish_time = data["pt"]

        if data["op"] == "score":

            self.last_score = data

        if data["op"] == "mb" and self.last_score:

            data["mc"][0]["score"] = self.last_score["mc"][0]

            self.last_score = None

        return self.stream._process(data[self.stream._lookup], publish_time)



[...]```



In `simulation.py`, I attach the score to the context of the market



```def _process_market_books(self, event: events.MarketBookEvent) -> None:

[...]

            # process market

            market(market_book)



            if "score" in market_book["streaming_update"]:

                market.context["score"] = Scores(

                    eventId=market_book["streaming_update"]["score"]["eventId"],

                    eventTypeId=market_book["streaming_update"]["score"]["eventTypeId"],

                    currentGame=market_book["streaming_update"]["score"]["currentGame"],

                    currentSet=market_book["streaming_update"]["score"]["currentSet"],

                    fullTimeElapsed={"hour": 0, "min": 0, "sec": 0},

                    score=market_book["streaming_update"]["score"]["score"],

                )

[..]```

---

## 2023-12-20 08:53:46 - general channel

**Johnny Boston**

```

    def _process_cleared_orders_meta(self, event):

        orders = event.event

        updated_orders = []

        for order in orders:

            if order.order_type.ORDER_TYPE == OrderTypes.LIMIT:

                size = order.order_type.size

            else:

                size = order.order_type.liability



            if order.order_type.ORDER_TYPE == OrderTypes.MARKET_ON_CLOSE:

                price = None

            else:

                price = order.order_type.price



            order_data = {

                "bet_id": order.bet_id,

                "market_id": order.market_id,

                "selection_id": order.selection_id,

                "trade_id": order.trade.id,

                "date_time_placed": order.responses.date_time_placed,

                "price": price,

                "price_matched": order.average_price_matched,

                "size": size,

                "size_matched": float(order.size_matched),

                "side": order.side,

                "market_type": order.market_type,

                "elapsed_seconds_executable": order.elapsed_seconds_executable,

                "customer_strategy_ref": order.trade.strategy.name,

                "order_status": order.status.value,

                "market_note": order.trade.market_notes,

                "trade_notes": order.trade.notes_str,

                "order_notes": order.notes_str,

                "is_cleared_order": True

                if order.cleared_order

                else False,  # it is either None or True, so need to coerce

                **order.context,

            }

            updated_orders.append(order_data)



        if updated_orders:

            cleared_orders = [o for o in updated_orders if o["is_cleared_order"]]

            [http://logger.info|logger.info](http://logger.info|logger.info)(f"Writing {len(cleared_orders)} cleared orders meta to S3")

            self.write_logs(data=updated_orders, write_table="cleared_orders_meta")```

---

## 2023-12-19 07:32:16 - general channel

**liam**

Because flumine filters by customerStrategyRef / hostname it won’t pull in manually placed bets without using some middleware (see examples for the startup version)

---

## 2023-12-15 18:19:14 - general channel

**Paul**

Does your strategy not hold up at say, 1 second after going in-play? Or are you betting into markets that don’t go in play?

---

## 2023-12-15 04:02:48 - general channel

**Johnny Boston**

I wish you would have told me `check_market` doesnt exist in the new Flumine ( `BaseStrategy` ) - cost me a bit :disappointed:

---

## 2023-12-14 10:25:23 - general channel

**liam**

Search the logs, any patterns on missing orders per strategy/market etc or is it just random

---

## 2023-12-14 10:16:22 - general channel

**Johnny Boston**

I use meta to save the strategy name and I am finding i cant id that for all my orders

---

## 2023-12-14 02:43:20 - issues channel

**Outthebox sports trading**

What’s the strategy? Not had much success on the tennis

---

## 2023-12-13 10:00:22 - strategies channel

**liam**

Remove the delay is my answer, or create a third strategy `OrderSender` push all your orders into `Market.context["pending_orders"]` and then just send them all at once

---

## 2023-12-13 09:48:38 - strategies channel

**Adam**

Follow up question [@U4H19D1D2](@U4H19D1D2) (or anyone): are strategies run in their own threads (in parallel) or are they run sequentially, in the order they’re added to the framework (e.g. if an event comes in relevant to both strategies, strategy1 will process it first, then strategy2).

---

## 2023-12-13 08:18:43 - strategies channel

**liam**

Its all in the [https://betcode-org.github.io/flumine/sportsdata/#data-recorder|docs](https://betcode-org.github.io/flumine/sportsdata/#data-recorder|docs), the recorder strategy code needs to be modified in regards to the marketId lookup

---

## 2023-12-12 21:39:29 - strategies channel

**Derek C**

I think you will need this import at the top of the file:



```from flumine.streams.datastream import RaceDataStream```

and then add this to the TPDStrategy params:



```stream_class=RaceDataStream,```



---

## 2023-12-12 21:25:39 - strategies channel

**Unknown**

```strategy_gps = S3MarketRecorderGPS(

        name="GPSWIN",

        market_filter=None,

        stream_class=RaceDataStream,

        sports_data_filter=['raceSubscription'],

        context={

            "bucket": BUCKET_NAME,

            "local_dir": data_dir_gps,

            "force_update": False,

            "remove_file": True,

            "remove_gz_file": True,

        }

)



framework.add_strategy(strategy_gps)```

One above works, have you missed out the stream_class?

---

## 2023-12-12 21:12:25 - strategies channel

**PeterLe**

Evening. All this chat about TPD :grinning:, although I've never made it pay in all honesty.

I thought that id start to record it anyway by adding a second strategy to my current recorder



Would someone kindly check I've added it in correctly please?

I can see its recording the non TPD data, but i don't think there are anymore TPD races this evening in the US?

If someone can just cast their eye over it for comment ?

thanks



```import time

import logging

import os

import json

import betfairlightweight

from pythonjsonlogger import jsonlogger



from flumine import Flumine, clients, BaseStrategy

from flumine.streams.datastream import DataStream

from marketrecorder import MarketRecorder



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



myacc = str(input("TPD uk horses please enter account name Test1: "))

app_key = str(input("Please enter key: "))

mypass = str(input("Please enter Password and 2FA: "))

trading = betfairlightweight.APIClient(myacc, mypass, app_key, certs=r"C:\certs")



client = clients.BetfairClient(trading, order_stream=False)



framework = Flumine(client=client)



# First strategy

strategy = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE"],

        market_types=["WIN"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": "E:/ukhorses",

        "force_update": False,

        "remove_file": True,

    },

)



framework.add_strategy(strategy)



# Second strategy tpd

class TPDStrategy(BaseStrategy):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        self.data_directory = "E:/ukhorses/tpd"

        os.makedirs(self.data_directory, exist_ok=True)



    def process_sports_data(self, market, sports_data) -&gt; None:

        filename = os.path.join(self.data_directory, f"{market.market_id}.json")

        with open(filename, 'a') as file:

            json.dump({"market": str(market), "data": sports_data}, file)

            file.write('\n')



strategy_tpd = TPDStrategy(

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE", "US"],

        market_types=["WIN"]

    ),

    sports_data_filter=[

        "raceSubscription"

    ],

)



framework.add_strategy(strategy_tpd)



framework.run()```

Thank you

---

## 2023-12-12 15:27:20 - random channel

**Justice**

[@UUE6E1LA1](@UUE6E1LA1) I accept a margin of error, and the odd glitch but, at least back then, it was far too frequent to warrant the significant effort to train a model or code some automation strategy. It must have improved since

---

## 2023-12-12 15:07:07 - random channel

**D C**

Interesting. I can't help but feel that you might have missed a trick. I mean, I agree with you about the occasional positional errors but to go to such lengths to pay for the data and write a stream listener app AND a viewer and then give up is an odd one. I wish I'd had access around when you did as there were far fewer GPSers around then. Out of interest what were you paying back then when you had it. I think I was quoted about £40 a meeting but you are the only person I've ever spoken to who has paid for the UDP feed direct from TPD as opposed to getting it via Betfair or OTS trading applications.

---

## 2023-12-12 12:51:42 - random channel

**Justice**

I can tell you it was unbelievably good for around 6 months since racing returned after covid. Then it started to get harder once more started teaming up to purchase drones. Then one particular individual, whose business model is not to bet but rather sell the pictures (also sold facetime pictures back in the day), purchased a drone. That killed it completely as it opened access to 100+ other players

---

## 2023-12-12 09:15:56 - strategies channel

**Adam**

Hey quick question: does Flumine manage streams at the framework level or the strategy level? e.g. If I start two seperate strategies within the same framework that stream events from the *exact same markets (i.e* `framework.add_strategy(strategy1)` and `framework.add_strategy(strategy2)`), would it open one stream that both strategies ingest from, or two separate streams? If it’s the latter, would that increase latency since the network request is doubled?

---

## 2023-12-12 09:08:40 - issues channel

**Mo**

My bread and butter tennis strategy has been working for 8 years

---

## 2023-12-12 08:55:31 - general channel

**D C**

Proform is popular. Apparently you can export the DB which would be useful for anyone doing fundamental modelling. Downside is that it is/was only available for use on Windows (although there is a cheaper sub option to acccess the online racecards only too). This was the case when last I used it which was over a year ago so maybe different now.

---

## 2023-12-12 08:40:33 - general channel

**Justice**

Depends what you're doing. RacingPost has fairly accurate data that is very easy to scrape. You can get BSP and in-play high and low from Timeform with a free account, although scraping is very slow- they rate limit you. They have an API but it is seriously expensive. TPD is more for in-running, although I have heard from some in this community that their historical data is doctored to more accurately reflect the position of the horse, and does not reflect the data you receive in real-time- therefore it's useless for modelling

---

## 2023-12-05 08:46:31 - strategies channel

**PeterLe**

Hi [@U016TGY3676](@U016TGY3676), yes it did:

```# Feature Importance

print("Calculating the feature importance....")

importances = random_forest_model.feature_importances_

sorted_indices = np.argsort(importances)[::-1]

print("Feature Importance:")

for index in sorted_indices:

    print(f"{features[index]}: {importances[index]}"```

But it doesn't tell you much detail, that's why I opted for SHAP as i thought it would provide more detailed info

By the way; its been pointed out to me that whilst my initial thoughts were to see if ML could enhance a current system, the ML strat maybe a completely different strat to what my live one is

So now i know there is a better strat that the one im running live, I just have to work out what it is :grinning: :exploding_head:

---

## 2023-12-04 20:44:37 - strategies channel

**birchy**

[@UQL0QDEKA](@UQL0QDEKA) have you looked at the feature importances? They can sometimes be useful to view good/bad features of your model

---

## 2023-12-04 17:44:33 - strategies channel

**PeterLe**

Yes the 80% Accuracy, is a measure of how accurate the model is making predictions on both the validation and test data (the fact that they are very similar  is a good indicator

Thanks for the link, Ill have a read of that

---

## 2023-12-04 17:40:26 - strategies channel

**Derek C**

As for the SHAP results, I had to look it up to refresh my memory but I think this graph is showing most useful features from top to bottom. Feature 1 predicts a winner when it has a low value, as does 2 &amp; 3 (all the red dots are clustered together). I think feature 7 isn't very predictive - both high and low values are mostly red. That is my understanding but happy to be corrected. [https://datascience.stackexchange.com/questions/65307/how-to-interpret-shapley-value-plot-for-a-model](https://datascience.stackexchange.com/questions/65307/how-to-interpret-shapley-value-plot-for-a-model)

---

## 2023-12-04 17:27:42 - strategies channel

**Derek C**

Does the 80% accuracy mean it was correct for 80% of the rows in the input data set, or correct for 80% of the markets? Reason I ask is that I found the precision measure more useful in my modelling - predicting the wrong result when LAYing is more expensive than missed opportunities :grimacing:

---

## 2023-12-04 17:08:57 - strategies channel

**Derek C**

Hi [@UQL0QDEKA](@UQL0QDEKA), thanks for posting this. Is the model predicting win/lose/(draw) or is it predicting a price?

---

## 2023-12-04 10:22:05 - random channel

**Johnny**

I'm just using the example marketrecorder.py.  It seems to die (docker container restarts) on match days which means I have a load of incomplete market files - been checking the logs and get a load of "latency high" lines followed by a timeout error.  Maybe subscribing to too many markets is the issue, will try narrowing it down next



```{"asctime": "2023-12-03 13:12:51,407", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.11/site-packages/flumine/worker.py\", line 235, in _get_cleared_market\n    cleared_markets = betting_client.betting.list_cleared_orders(\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/betfairlightweight/endpoints/betting.py\", line 434, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 54, in request\n    self._error_handler(response_json, method, params)\n  File \"/usr/local/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 80, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.221745228'], 'customerStrategyRefs': ['d69966378a3d'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00af825869', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00af825869', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.221745228'], 'customerStrategyRefs': ['d69966378a3d'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00af825869', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00af825869', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}```

---

## 2023-12-04 10:19:32 - strategies channel

**liam**

For us mere mortals I think your last paragraph sums it up for me. So far for me the biggest insight has been its ability to quantify / visualise relationships between pnl and variables which aren't always linear.



However I have then taken the value out and updated my models / if statements to cater for the non linear relationship. In my case I have been keeping some features static and literally plugging in values to graph the change in outcome from the model, its dirty and could probably be replicated using regression but it works. Simply using the ML model was just matching or falling short of my previous strategies but using ML to advance things is a process that works well on my current strategies.

---

## 2023-12-04 09:37:19 - strategies channel

**Unknown**

Morning All,

I thought Id take a look at one of my existing profitable long term strats to see if i could improve it with ML

These are the basic steps that the ML took ;



loading data Set into dataframe....

Creating Histogram and Density plot....

Creating Correlation Matrix considering only numeric columns....

Selecting features and target....

Split the data....

Train Random Forest....

Making Predictions....

Calculating Random Forest Accuracy....

Validation Accuracy: 0.7990462572417981

Test Set predictions accuracy....

Test Accuracy: 0.7989358028340348

Calculating the feature importance....

Calculating SHAP values for model interpretability...

Analyzing overall feature contributions...



Based on 3 months of inplay data (Circa 35m rows of CSV)



The ML model was significantly better than my simple model and I though it was a good idea to use SHAP to try and understand what the model was doing ...(Now I know next to nothing about ML so not sure if those who work in this field use SHAP or whether it is any good??)



The output of SHAP is shown in the attached illustration.

(Ive removed the descriptions of the features for now)



From Top down, Im only using features 1, 4 and 5 in my day to day strat, but it seems to suggest that these three features have a negative impact on the P/L? So that has confused me :grinning:

Should I really be focusing on features 6 and 7 that have a high positive impact?  (Incidentally use feature 6 in a separate strat successfully)



How would you ML guys delve down deeper? (I though that maybe I could use Pandas to look at each feature independently, although I realise that it wouldn't give a complete picture as it maybe dependent on the values of other features, if that makes sense)

Or maybe I could run SHAP again but on selected features?

My head thinks just use pandas (as the ML stuff takes ages to run). The more I play around with ML, the more I think the simple methods of data interpretation are much quicker and provides good enough insight/indicative ie good enough == good enough

I just thought it may be an interesting topic for discussion, thanks for any thoughts

---

## 2023-12-03 18:57:18 - issues channel

**AndyL**

[@UUCD6P13J](@UUCD6P13J) you mean these ?

```{"asctime": "2023-12-02 22:49:10,557", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/flumine/worker.py\", line 229, in _get_cleared_market\n    cleared_markets = betting_client.betting.list_cleared_orders(\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/betting.py\", line 434, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 54, in request\n    self._error_handler(response_json, method, params)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 80, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.222016636'], 'customerStrategyRefs': ['AAAA'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00ae6c3413', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00ae6c3413', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.222016636'], 'customerStrategyRefs': ['AAAA'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00ae6c3413', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang26b-prd-09131022-00ae6c3413', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}```

---

## 2023-12-03 07:08:21 - strategies channel

**liam**

Flumine uses strategy ref to isolate different running instances, instead logging control should be used to record/log all trades/orders/markets etc.

---

## 2023-12-03 04:42:43 - general channel

**James**

I tend to think about it as the available price += a couple of ticks unless there is a large volume of money or large gaps there.



It really depends a lot on market dynamics though.



If I have a biiiig gap in prices. IE a back price of $5 and a lay price of $10 the price isn’t really clear. Should you try lay at 5.1 or 7 or 9? it really depends on what you see as value. And just because you can’t get instantly matched, doesn’t mean you couldn’t get matched at on a back bet at $9.5 if you place it with the understanding it might not be matched.



Sometimes you want a quick match because you see a galloper in a harness race so you want to lay it at any price below $50, other times you only want to lay it if someone will take what you think it unders. It;s all pretty dependent on your strategy :slightly_smiling_face:

---

## 2023-12-03 03:12:22 - general channel

**Adam**

Hey all, hoping someone can help me understand the ‘available to back’ price and sizing for runners (horses) in a WIN market.

From a conceptual perspective, I want to understand how the available to back prices equate to traditional book makers odds in order to get a better understanding what I’m looking at in betfair markets. This isn’t for building a strategy, just to help aid my knowledge when analysing betfair market book data.



In a traditional market (e.g. on [http://bet365.com|bet365.com](http://bet365.com|bet365.com) or [http://www.tab.com.au|www.tab.com.au](http://www.tab.com.au|www.tab.com.au) etc) the fixed-odds available in a race is set by the platform and are traditionally BACK odds. In this example on bet365, at a point in time *Horse A is given a 9.7 odds to win*. The same Horse A on Tab sports has 9.8 odds to win.

In Betfair we receive the following EX for Horse A:

```Horse A - EX Details:

 - Available to Back: [{'price': 9.6, 'size': 7.03}, {'price': 9.4, 'size': 18.77}, {'price': 9.2, 'size': 12.29}]

 - Available to Lay: [{'price': 10.5, 'size': 11.79}, {'price': 11, 'size': 18.89}, {'price': 11.5, 'size': 3.6}]

 - Traded Volume: []```

Since betfair operates as a betting exchange, where bettors can bet against each other in a market exchange, we are provided with the market book for that runner. My understanding is that therefore the best available price to back on betfair for Horse A is *9.6* and this is the true reflection of the price provided by the other markets. But this maybe naive because it doesn’t consider the size or volume traded at this price. E.g. since the size is 7.03 is less than half of the size available at price 9.4, maybe is 9.4 a truer representation of the best backed odds for this horse? Do we need to take some average or consider volume or size to find this equivalence?

---

## 2023-12-03 00:13:43 - strategies channel

**James**

Also whilst on the potentially stupid questions. how can I set my strategy ref per strategy? I’m running multiple strategies in the same markets so running them in the same Flumine instance, the only place I can see it set is globally in config.

---

## 2023-12-02 23:22:56 - strategies channel

**James**

Hey, I’m looking at migrating a strategy to Flumine where I have some bets in place pre-play. and the kill them at a certain point in time in play.

I see fill and/or kill plastered all over the place in flumine and the betfair docs, and it seems to be what I want, but i can’t seem to find how to configure the duration before the kill. Can someone point me to the obvious thing I’m missing or do I need to iterate the strategy orders myself at the point in time and cancel any manually?

---

## 2023-12-02 10:42:13 - random channel

**Mo**

Sort out your Kelly staking 

---

## 2023-12-01 20:46:13 - random channel

**D C**

I don't do much with lay bet placements so it is very naive - just laying to win a flat stake if it is odds against and laying to win a slightly larger flat stake if it is odd on. Until I can work out kelly stakes appropriate for laying I've just kept if very simple.

---

## 2023-12-01 15:25:36 - betfair-news channel

**Carl**

Hi everyone,

I'm pleased to announce the launch of our 3-part Cricket webinar which can be found below;



[https://betting.betfair.com/betfair-announcements/exchange-news/forecasting-for-cricket-markets-webinar-watch-episode-1-of-our-expert-guide-221123-272.html|https://betting.betfair.com/betfair-announcements/exchange-news/forecasting-for-cricke[…]webinar-watch-episode-1-of-our-expert-guide-221123-272.html](https://betting.betfair.com/betfair-announcements/exchange-news/forecasting-for-cricket-markets-webinar-watch-episode-1-of-our-expert-guide-221123-272.html|https://betting.betfair.com/betfair-announcements/exchange-news/forecasting-for-cricke[…]webinar-watch-episode-1-of-our-expert-guide-221123-272.html)



In a bid to increase Cricket education amongst our more technical clients, we've teamed up with Ian McHale (Professor of Analytics, University of Liverpool) and Muhammad Asif (Head of Statistics at the University of Malakand). Alongside Ed Hawkins, they run through the basics of Cricket before progressing quite quickly on to the more technical elements, including areas of their academic research such as the Duckworth & Lewis method.



Part 2 will focus on factors of their own in-play model which should be released before Xmas. Part 3 will follow in the new year and is _expected_ to introduce player ratings although this is subject to change.

---

## 2023-12-01 15:04:15 - random channel

**D C**

Its basically testing value prices from a new model - lay bets only offered at a fixed scaling of the model value price (max 50-1 offered). Inplay horses.

---

## 2023-12-01 08:10:11 - general channel

**liam**

You have `self.clients` however my experience is that many use a fixed bank when using kelly on sports (ie ignore it)

---

## 2023-12-01 07:40:13 - general channel

**birchy**

Using Flumine, how do we access account balance at strategy level? More specifically, if we are using a staking strategy like Kelly, is there a way to set a theoretical bank, e.g. start at £500 and calculate from there?

---

## 2023-11-29 09:08:26 - strategies channel

**liam**

Its an xgb model, I have used the xgboost library rather than sklearn as I found it to be considerably faster, hence the matrix conversion

---

## 2023-11-29 08:51:03 - strategies channel

**Unknown**

I have a model and starting to use it in anger, out of interest is this the best way to be calling it in a production env, seems mega hacky..

---

## 2023-11-27 19:52:28 - strategies channel

**Adrian**

those probs look a bit wild to me. but it depends what you're feeding the model. and when is the prediction being made?

---

## 2023-11-27 16:27:17 - strategies channel

**Leo**

[@UUE6E1LA1](@UUE6E1LA1)  depends what your goal is. Not always the case but often there is a trade off between predictive power and explainability, that's the nature of ML. I might not care about how a model came to a prediction if I'm confident though empirical tests that those predictions are useful for my intended goal. 

---

## 2023-11-27 15:46:46 - random channel

**Javier Martín Pérez**

Hi! Not sure if anybody else has this problem but in terms of football trading Saturday and Sunday afternoons require a lot of computing and need to upgrade my server. At the moment I am using [http://MVPS.net|MVPS.net](http://MVPS.net|MVPS.net) and the prices grow a bit too much when you go from 4 processors to 8. However I have seen others like OVH that offers the same for a quarter of the price. Any experience with them?

---

## 2023-11-27 10:51:10 - strategies channel

**foxwood**

Idle thought - if you sum the probabilities (average if multiple bets on same selection) of your bets for each selection and convert that to odds then that could be used as the "single" effective odds to use on Kelly ?

This link has lots of official looking formulae to confuse things [https://www.aussportsbetting.com/2010/07/18/kelly-criterion-backing-andlaying-bets-with-betfair/#:~:text=The%20Kelly%20criterion%20for%20laying%20a%20bet&amp;text=In%20this%20case%2C%20you%20will,f*(d-1)](https://www.aussportsbetting.com/2010/07/18/kelly-criterion-backing-andlaying-bets-with-betfair/#:~:text=The%20Kelly%20criterion%20for%20laying%20a%20bet&amp;text=In%20this%20case%2C%20you%20will,f*(d-1))).

---

## 2023-11-27 10:37:56 - strategies channel

**D C**

If you are placing lay bets in a field with more than 2 participants, when it comes to calculating kelly staking, do you just view each bet as a back bet at reciprocal odds on the remainder of the field? Or does the fact that your "win" event now is not from a set of mutually exclusive outcomes in some way invalidate the theory behind Kelly based staking. I am hoping that the answer is "yes" but if not can anyone point me to something that explains calculation of kelly stake for laying?

---

## 2023-11-27 09:47:29 - strategies channel

**D C**

I assume ML methods don't preclude you doing this anyway though [@U030GKBMCBF](@U030GKBMCBF)? I mean we can fit a quadratic to cubic data - the fit will be poor but you'll get a set of parameters as a solution. Do you get similar things in ML like you do for classical stats (other than generalisations of R^2).

I mean things for checking model assumptions like normality of residuals, uncorrelated residuals etc or is the onus on the user to check for a linear relationship prior to conducting an analysis?

I think part of the reason that I avoid ML stuff is because what I've read seems to just suggest that you can throw generic tools/algorithms at any old shit and you'll get a "solution" - but the adequacy of that solution always seems to be based simply on come cross validation on test data. Maybe I've just reached that age where enthusiasm for learning new things has dried up maybe its because I just prefer a type of analysis where parameters are "meaningful" when it comes to interpreting your results.

---

## 2023-11-26 19:25:06 - strategies channel

**liam**

Ok, lots more things I don’t understand. I need to do some work to match up my data / models / prices and simulation which I am going to work on tomorrow so should have an update.



Assuming others are still interested in my struggles :joy: 

---

## 2023-11-26 19:04:03 - general channel

**Peter**

Use a loose filter to capture all horse racing then use your strategy's `check_market_book` method to filter out the races that you're not interested in, and then the updates prior to the 80 seconds from the start for those you do want. You'll get all updates including inplay, and can access related markets through the `market.event` object.

---

## 2023-11-26 13:53:52 - strategies channel

**R**

Just a comment on meta stuff.



A meta model is typically a model that predicts another model.  E.G. model-A predicts the coefficients of your equation (w1, w2, w3) while model-B predicts the parameters of model A itself.  Model-B is then known as the meta-model.



This is getting into advanced ML though and I would first look at how well a logistic (maxEnt) classifier does with these price inputs.  The results are quite literally a linear combination as you describe with weights learned to satisfy a probabilistic loss on a binary outcome.  You could extend it to multi-class easily too.



I'd be happy to lend a hand if you wanted to demo it as part of your ML series too!

---

## 2023-11-26 00:15:25 - general channel

**Adam**

```thoroughbreds_event_filter = {

        "eventTypeIds": ["7"],

        "marketCountries": ["AU"],

        "marketStartTime": {"to": end_of_day_str},

        "marketTypes": ["WIN"],

        "raceTypes": ["Flat"]

    }

market_filter={

            "markets": market_ids,

            'market_types': ['WIN'],

            "listener_kwargs": {"inplay": False, "seconds_to_start": 80},

            "event_processing": True

        },```

```strategy = Strategy(

    market_filter={

        "markets": market_ids,

        'market_types': ['WIN'],

        "listener_kwargs": {"inplay": False, "seconds_to_start": 80},

        "event_processing": True

    },

    market_data_filter=market_data_filter,```

Hi all. I have generated a list of market_ids (e.g `market_ids = [1.170212754, 1.170212755, 1.170212759, …]`) which consists of all thoroughbred markets that start and end in a given day (determined by `thoroughbreds_event_filter`).

The goal is that for each race, the flumine strategy only starts processing events 80 seconds before the start of each race and continues receiving events while the race is in play. My question is, can I use `listener_kwargs` param with multiple `market_ids`? Do I need to set `inplay` to true if I want to monitor events while the race is live, and do I need to set `event_processing` to True? Thank you

---

## 2023-11-24 20:32:52 - random channel

**D C**

RNG :joy:  I've not used a bookied in years so I don't know if they actually do offer inplay horses now but I remember asking TPD about their price model and I was told it was only available to bookies.

---

## 2023-11-24 13:17:29 - random channel

**D C**

[https://twitter.com/Ascot/status/1728034480445608109](https://twitter.com/Ascot/status/1728034480445608109)



Just saw this pop up on my feed. Likely nobody knows but do you think these win% are generated from the same model that they sell to bookies to allow them to offer inplay odds?

Are TPD allowed to trade on Betfair? If so, do they?

---

## 2023-11-23 09:45:18 - strategies channel

**liam**

:rolling_on_the_floor_laughing: I think the dark arts are causing my problems as I try and do things with ML :exploding_head:



Started coming up with some mad ideas involving meta model and looking at feature importance at different stages of the game

---

## 2023-11-23 09:39:53 - strategies channel

**D C**

With the GPS, my better performing models contains the BFSP. If I include things like LTP or current back/lay on offer, the effect of that in the model seems to overpower some of the other parameters - which makes perfect sense in most situations. Not sure about how to deal with that but I've found that the SP is significant - until it is not

---

## 2023-11-23 09:03:01 - strategies channel

**liam**

[@UCQB6S222](@UCQB6S222) good point, updated



Meta model sounds interesting, I am then not sure what my target becomes / I am well out of my depth already tbh.



Regarding the decay is it stupid to assume a linear 'weight decay' of the SP from 1 to 0 at full time?

---

## 2023-11-23 08:38:13 - strategies channel

**Mo**

You could use a meta model (not sure if this is technically the correct term) which has the individual model outputs as features. If you use a non linear modelling technique this allows you to combine the predictions in a non linear way

---

## 2023-11-21 23:08:24 - random channel

**Unknown**

Hi all,

In my little spare time I've been working on various pre-race odds modelling ideas from scraped Racing Post data, but I've no experience writing betfair trading bots and none of the ideas i had have worked out, so I'm looking for anyone else that wants to partner up and use my highly organised/normalised database including:

• back history as far back as you want (currently it is back to about 2008 but there is no reason I can't add more)

• daily racecards parsed into the databased and marked as "racecard" in a status field

• as soon as results are available they are fetched and committed to the database to replace the racecard

• some custom things I made such as trainer/jockey/horse observed/expected ratios based on SP, and collateral horse ratings.

• map tables to identify the matching meeting/race/horse records between BF and RP (only back to ~2015)

Attached is a diagram of the schema that will be included, so you can see how verbose it it. It includes pretty much everything that is available in the RP results page.

The database is maintained in the cloud, so I think the easiest way to onboard would be to supply anybody interested with a read-only username/password. A possible alternative is async replication but I've never set that up before so it might be a lot of hassle.

Send me a message if you're interested or have any questions :)

---

## 2023-11-21 17:03:07 - random channel

**Mo**

Step one: take your pick of an assumed joint probability distribution for the goals. Some suggestions:



1. Bivariate Poisson ([https://betcode-org.slack.com/archives/C4H05KKMY/p1694621314786749](https://betcode-org.slack.com/archives/C4H05KKMY/p1694621314786749))

2. Bivariate Weibull count model ([https://www.sciencedirect.com/science/article/abs/pii/S0169207017300018](https://www.sciencedirect.com/science/article/abs/pii/S0169207017300018))

Step two: use numerical optimisation to fit the parameters of your chosen distribution to the available odds on the AH/total lines (optionally include other markets as well)



Step three: use the fitted parameters to calculate the matrix of probabilities of each scoreline

---

## 2023-11-20 13:56:54 - random channel

**Ralegh**

To be honest if you’ve got flat files working with your setup there’s basically no reason to change. Also storing ML models in a database seems kinda pointless to me, how would you use it any different to on disk?

---

## 2023-11-20 11:00:02 - random channel

**Adrian**

I think I might be able to skip SQL altogether and go for something like MongoDB. It's looking pretty promising from what i've seen. It could possibly even store ml models and associated dataframes/transformer objects,

---

## 2023-11-20 09:58:17 - general channel

**liam**

[https://ero.betfair.com/www/sports/exchange/readonly/v1/bymarket?_ak=nzIFcwyWhrlwYMrh&amp;alt=json&amp;currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.221401681&amp;rollupLimit=1&amp;rollupModel=STAKE&amp;types=MARKET_STATE,MARKET_RATES,MARKET_DESCRIPTION,EVENT,RUNNER_DESCRIPTION,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_METADATA,MARKET_LICENCE,MARKET_LINE_RANGE_INFO,RUNNER_SP|eg](https://ero.betfair.com/www/sports/exchange/readonly/v1/bymarket?_ak=nzIFcwyWhrlwYMrh&amp;alt=json&amp;currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.221401681&amp;rollupLimit=1&amp;rollupModel=STAKE&amp;types=MARKET_STATE,MARKET_RATES,MARKET_DESCRIPTION,EVENT,RUNNER_DESCRIPTION,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_METADATA,MARKET_LICENCE,MARKET_LINE_RANGE_INFO,RUNNER_SP|eg)

---

## 2023-11-19 22:00:53 - general channel

**Trex44**

Hey all, is there a way to get the timestamp (e.g. "pt":1534433284382) betfair send with each update via Flumine? I am trying to access it via a strategy.

---

## 2023-11-18 11:35:11 - general channel

**Prime**

if you have a streaming json decoder then its not such a big deal. however if, like most people, you download the whole json message then decode it in one go and then handle each market in sequence, you will do much better if the snapshot is segmented because you can start doing your market handling faster, while the rest of the json downloads and decodes on another thread and feeds that process. on betfair's side, they prefer segmented messages because it reduces memory load when assembling very large messages and allows them to send you data faster as the first message will be ready more quickly. generally, most of the time, because this is all startup stuff its not very relevant. on our systems we certainly never bother with it. we talk to betfair via 1/10 Gbit links and initial decoding only happens once before any trading etc kicks in. imo it's all Joe's fault.

---

## 2023-11-17 19:48:23 - issues channel

**AndyL**

[https://github.com/betcode-org/flumine/blob/3d697cdb4d186b66af574afcf8001f18776f331d/flumine/strategy/strategy.py#L13C1-L23C2](https://github.com/betcode-org/flumine/blob/3d697cdb4d186b66af574afcf8001f18776f331d/flumine/strategy/strategy.py#L13C1-L23C2)

---

## 2023-11-17 19:22:59 - issues channel

**AndyL**

[@U4H19D1D2](@U4H19D1D2) thanks Liam, yes, I think i've worked it out, it's not a memory leak per-se. Basically since I added PLACE to the listener, I am now subscribing GB,IE and WIN,PLACE for this one strategy, and it actively trades from 3hours out from startTime. What I see is a gradual increase in CPU towards mid-day when the main afternoon races fall within that 3hour window. I roughly calculated the market processing thread will be going around 50 markets, and my strategy code is probably not as efficient as it could be... My VM CPU then hits 50% in a 2vCPU box, which then starts to limit it, the affect it had was to cause the market update processing to lag the live updates, causing a steady progression of increase in latency, eventually towards a latency of 30mins!!! My trading  logic once the latency hit around 5mins was starting to put orders in for markets that were now closed! Thus getting lots of BF errors, and what made things worse for my hedge bets I was rather stupidly immediately re-placing the failed hedge causing yet more of a race......and eventually bang!

What i've learned:

1. I need to profile my strategy code more to try and make it more efficient. I've already done a good set of fixes...

2. I'm perhaps pushing my luck adding PLACE and doubling the number of active markets in that 3hour trade window, running on a single Flumine instance....

3. Importantly I need to monitor "latency" to prevent this sort of CPU race condition

I've done a set of fixes for 1 & 3 and I'm testing them now.....

---

## 2023-11-17 14:08:31 - issues channel

**foxwood**

I keep the catalogue files in the same folder as the data files - seems simpler to me - you can build list of data files to be fed to strategy filtered out something like this

`for d in dataDir:`

    `files = listdir(d)`

    `for f in files:`

        `fullName = join(d, f)`

        `if isfile(fullName) and f.endswith(".gz") and f.find("json") == -1 :`

		        `marketFiles.append(fullName)`

---

## 2023-11-17 13:37:37 - issues channel

**Jimmy**

Just come back to Flumine and have been recording some data — trying to set up a simulation using the data. Based it off the WOM example [@U4H19D1D2](@U4H19D1D2) shared: [https://github.com/liampauling/flumine-strategy-development/blob/master/main.py](https://github.com/liampauling/flumine-strategy-development/blob/master/main.py)



Hits this error when I chuck a few files at it:



```  File "path removed", line 68, in &lt;module&gt;

    framework.run()

  File "/flumine/venv/lib/python3.11/site-packages/flumine/simulation/simulation.py", line 96, in run

    for event in stream_gen():

  File "/flumine/venv/lib/python3.11/site-packages/flumine/streams/historicalstream.py", line 224, in _read_loop

    if listener_on_data(update):

       ^^^^^^^^^^^^^^^^^^^^^^^^

  File "/flumine/venv/lib/python3.11/site-packages/flumine/streams/historicalstream.py", line 209, in on_data

    publish_time = data["pt"]



KeyError: 'pt'```

---

## 2023-11-16 17:45:57 - issues channel

**AndyL**

Hi [@U4H19D1D2](@U4H19D1D2) what does this mean in real terms please?

```{"asctime": "2023-11-16 11:55:48,259", "levelname": "WARNING", "message": "High latency between current time and OrderPackage creation time, it is likely that the thread pool is currently exhausted", "trading_function": "cancel", "session": "&lt;requests.sessions.Session object at 0xffff62401130&gt;", "latency": 0.29, "order_package": {"id": "14c7f3f3-8477-11ee-98e5-77b81b73792a", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0xffffb03a1ac0&gt;", "market_id": "1.221270586", "orders": ["139194285340131329"], "order_count": 1, "package_type": "Cancel", "customer_strategy_ref": "aaaa", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}, "thread_pool": {"num_threads": 18, "work_queue_size": 0}}```

followed by lots of these later on:

```{"asctime": "2023-11-16 13:28:46,316", "levelname": "WARNING", "message": "High latency between current time and MarketBook publish time", "market_id": "1.221270587", "latency": 68.93769669532776, "pt": "2023-11-16T13:27:37.379000"}```

---

## 2023-11-16 14:41:05 - strategies channel

**Peter**

Hi All, I'm confused by some flumine backtest results I'm experiencing with a new strategy. When I place a limitOrder, I sometimes see an average price matched that is lower than my submission price - I'm confused by this as the Betfair API docs say that with a limitOrder the price submitted is the lowest price at which any fraction of the bet may be matched. If anyone could help me understand why this occurs I'd really appreciate it

---

## 2023-11-15 09:42:40 - random channel

**D C**

[@UQL0QDEKA](@UQL0QDEKA) I did try this. I was out of work at the peak of pandemic as my contract was not renewed so turned to this full time. Was approached by a betting company and started working there - great chaps but I honestly could not get motivated. I was getting paid a quarter of what I was making in profits on Betfair and the London commute was costing me 3 hours a day (had to be on site 3 days a week). That combined with not enjoying what they had me working on meant my motivation just dropped off a cliff and I ended up resigning. I think that I would have the same problem anywhere else now so if I did end up on the grid again I think I would have to just be self-employed in some way. Didn't help that it was a startup and most of the people were really enthusiastic youngsters at that live-to-work stage of their lives. They were all great people but I am at that age now where going on the piss after work is not what I am looking for so I missed out on a lot of the social stuff I would have lapped up 20 years ago. The penny finally dropped when they had some golf up on one of the internal TVs and some young shaver referred to Sergio Garcia as "one of the old guard"

---

## 2023-11-14 09:56:04 - general channel

**Justice**

[@U028Z5T4AF6](@U028Z5T4AF6) Do you use the `RacingpostRating` in your model? The historical ratings I have scraped are retrospectively revised (collateral handicapping etc.) and so I can't use them for machine learning without leaking data into my model.

---

## 2023-11-13 08:13:52 - random channel

**liam**

As above, here is an example repo



[https://github.com/liampauling/flumine-strategy-development](https://github.com/liampauling/flumine-strategy-development)

---

## 2023-11-11 15:34:53 - issues channel

**Unknown**

[@U4H19D1D2](@U4H19D1D2) so found error from logging as to why my place_order is occaisionally failing:

```{"asctime": "2023-11-11 15:25:56,077", "levelname": "INFO", "message": "Order Place: FAILURE", "bet_id": null, "order_id": "1072113949238803678", "status": "FAILURE", "error_code": "INVALID_CUSTOMER_ORDER_REF"}```

:

```{"asctime": "2023-11-11 15:25:56,076", "levelname": "INFO", "message": "execute_place", "trading_function": "place", "elapsed_time": 0.04937458038330078, "response": {"customerRef": "a897131b2ef44081b9581b8d9d7d72bc", "status": "FAILURE", "errorCode": "BET_ACTION_ERROR", "marketId": "1.221016025", "instructionReports": [{"status": "FAILURE", "errorCode": "INVALID_CUSTOMER_ORDER_REF", "instruction": {"selectionId": 49020468, "handicap": 0.0, "limitOrder": {"size": 47.18, "price": 1000.0, "persistenceType": "MARKET_ON_CLOSE"}, "customerOrderRef": "653232d17db55-1072113949238803678", "orderType": "LIMIT", "side": "BACK"}}]}, "order_package": {"id": "a897131b-2ef4-4081-b958-1b8d9d7d72bc", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0xffffb6d03c40&gt;", "market_id": "1.221016025", "orders": ["1072113949238803678"], "order_count": 1, "package_type": "Place", "customer_strategy_ref": "AAAAAA", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}```

This is happening about 25% of my hedge bets, and I am sure this was not happening a week ago...

---

## 2023-11-10 19:09:41 - issues channel

**AndyL**

so in the example above, the one being cancelled was active for 8mins, and was cancelled in the logic show above, here's the response on that one, which appears at the exact same time as the above placed order (completion!)

```{"asctime": "2023-11-10 17:19:30,301", "levelname": "WARNING", "message": "HEDGE_COMPLETE: BACK : 29 : 1.220974195:32494174 size_matched 0.0 avg_price_matched: 0.0 req_size: 7.36 req_price: 1000.0 order : Order 328103107234: Execution complete : {\"market_id\": \"1.220974195\", \"selection_id\": 32494174, \"handicap\": 0, \"id\": \"63929374292148811\", \"customer_order_ref\": \"653232d17db55-63929374292148811\", \"bet_id\": \"328103107234\", \"date_time_created\": \"2023-11-10 17:11:26.564031\", \"publish_time\": \"2023-11-10 17:11:25.635000\", \"market_version\": null, \"async\": false, \"trade\": {\"id\": \"acf023f5-f990-4a2e-ac25-2d9475cb5477\", \"strategy\": \"LiveHorseUK\", \"place_reset_seconds\": 0.0, \"reset_seconds\": 0.0, \"orders\": [\"63929374292148811\"], \"offset_orders\": [], \"notes\": \"\", \"market_notes\": \"21,22,22\", \"status\": \"Complete\", \"status_log\": \"Pending, Live, Pending, Live, Complete\"}, \"order_type\": {\"order_type\": \"Limit\", \"price\": 1000.0, \"size\": 7.36, \"persistence_type\": \"MARKET_ON_CLOSE\", \"time_in_force\": null, \"min_fill_size\": null, \"bet_target_type\": null, \"bet_target_size\": null, \"price_ladder_definition\": \"CLASSIC\"}, \"info\": {\"side\": \"BACK\", \"size_matched\": 0.0, \"size_remaining\": 0.0, \"size_cancelled\": 7.36, \"size_lapsed\": 0.0, \"size_voided\": 0.0, \"average_price_matched\": 0.0}, \"responses\": {\"date_time_placed\": \"2023-11-10 17:11:26.684107\", \"elapsed_seconds_executable\": 483.44282}, \"runner_status\": null, \"status\": \"Execution complete\", \"status_log\": \"Pending, Executable, Cancelling, Execution complete\", \"violation_msg\": null, \"simulated\": {\"profit\": 0.0, \"piq\": 0.0, \"matched\": []}, \"notes\": \"513,21.5,GB,WIN\", \"market_notes\": \"21,22,22\", \"client\": \"aaaa\"}"}```

---

## 2023-11-10 18:38:46 - issues channel

**AndyL**

Hmm [@U4H19D1D2](@U4H19D1D2) not sure I can explain this order, it's a MARKET_ON_CLOSE placed at 30secondToStart, and immediately EXECUTION_COMPLETE, notice time elapsed: 1.3e-05

and notice "size_remaining\": 6.73 . It's a TakeSP bet completed, also orderId is None:

```1.220974195:32494174 size_matched 0.0 avg_price_matched: 0.0 req_size: 6.73 req_price: 1000.0 order : Order None: Execution complete : {\"market_id\": \"1.220974195\", \"selection_id\": 32494174, \"handicap\": 0, \"id\": \"1076299499178434720\", \"customer_order_ref\": \"653232d17db55-1076299499178434720\", \"bet_id\": null, \"date_time_created\": \"2023-11-10 17:19:30.003743\", \"publish_time\": \"2023-11-10 17:19:29.994000\", \"market_version\": null, \"async\": false, \"trade\": {\"id\": \"f2462edf-5e87-4e87-8f59-98259226e948\", \"strategy\": \"LiveHorseUK\", \"place_reset_seconds\": 0.0, \"reset_seconds\": 0.0, \"orders\": [\"1076299499178434720\"], \"offset_orders\": [], \"notes\": \"\", \"market_notes\": \"23,24,24\", \"status\": \"Complete\", \"status_log\": \"Pending, Live, Complete\"}, \"order_type\": {\"order_type\": \"Limit\", \"price\": 1000.0, \"size\": 6.73, \"persistence_type\": \"MARKET_ON_CLOSE\", \"time_in_force\": null, \"min_fill_size\": null, \"bet_target_type\": null, \"bet_target_size\": null, \"price_ladder_definition\": \"CLASSIC\"}, \"info\": {\"side\": \"BACK\", \"size_matched\": 0.0, \"size_remaining\": 6.73, \"size_cancelled\": 0.0, \"size_lapsed\": 0.0, \"size_voided\": 0.0, \"average_price_matched\": 0.0}, \"responses\": {\"date_time_placed\": \"2023-11-10 17:19:30.046825\", \"elapsed_seconds_executable\": 1.3e-05}, \"runner_status\": null, \"status\": \"Execution complete\", \"status_log\": \"Pending, Execution complete\", \"violation_msg\": null, \"simulated\": {\"profit\": 0.0, \"piq\": 0.0, \"matched\": []}, \"notes\": \"29,23.5,GB,WIN\", \"market_notes\": \"23,24,24\", \"client\": \"aaaa\"}"} ```

---

## 2023-11-10 02:00:40 - random channel

**Brett Riley**

I use custom python or a modified Flumine strategy file

---

## 2023-11-10 01:59:43 - issues channel

**Unknown**

Has anyone else found that when running a simulation in Flumine that it'll match any price you give a MARKET_ON_CLOSE bet? Ignoring the lay bets, the initial back bet placed at 1 sec from start with market_on_close is getting matched far higher than the BSP

```trade = Trade(market_id=market_book.market_id,selection_id=runner['selection_id'],handicap=0,strategy=self,)

order = trade.create_order(side=strSide, order_type=LimitOrder(price=MoveMarketOdds(nAmount,100,1), size=1.0, persistence_type='MARKET_ON_CLOSE')) # MARKET_ON_CLOSE

market.place_order(order)```



---

## 2023-11-09 19:24:32 - issues channel

**AndyL**

[@U4H19D1D2](@U4H19D1D2) had a bit of an issue with one of my Flumine processes that eventually crashed the VM, thought i'd pass it by you incase it looks familiar. My naive view it looks a bit like a run-away thread/resource issue..?

• Flumine 2.4.2 betfairlightweight 2.17.3

looking at the "logs", the issue looked to start gradually with periodic:

```High latency between current time and OrderPackage creation time, it is likely that the thread pool is currently exhausted", "trading_function": "cancel", "session": "&lt;requests.sessions.Session object at 0x7f70f376bc40&gt;", "latency": 0.381, "order_package": {"id": "xxxxx", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f7119b1b6a0&gt;", "market_id": "1.220926100", "orders": ["139188221331829894"], "order_count": 1, "package_type": "Cancel", "customer_strategy_ref": "XXXXX", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}, "thread_pool": {"num_threads": 26, "work_queue_size": 3}}```

then a few mins later got:

```"High latency between current time and MarketBook publish time", "market_id": "1.220920848", "latency": 2.08534836769104, "pt": "2023-11-09T11:37:19.521000"}```

this repeated then "continuously" with latency time steadily increasing... message being issued about 50/second

```{"asctime": "2023-11-09 11:40:30,227", "levelname": "WARNING", "message": "High latency between current time and MarketBook publish time", "market_id": "1.220926100", "latency": 14.246732711791992, "pt": "2023-11-09T11:40:15.981000"}```

then about 150 warnings/second

```{"asctime": "2023-11-09 11:54:22,299", "levelname": "WARNING", "message": "High latency between current time and MarketBook publish time", "market_id": "1.220920734", "latency": 176.0338258743286, "pt": "2023-11-09T11:51:26.266000"}```

eventually the increasing CPU usage killed the AWS VM which I had to reboot via the console

---

## 2023-11-08 12:23:04 - general channel

**Brian Sexton**

Hi All. Im looking to build a an ML model for tracking in game tennis price movements. I have historcal data from betfair and I want to combine it with pre match stats on the players. The issue im having is putting the 2 datasets together so I can start to train some models and get started. In the  betfair data I have market, selection and event id and also the selection name. Has anyone experience with this and how do you approach getting the data prepared so a model can be trained with various datasets?

---

## 2023-11-06 13:54:44 - random channel

**Johnny**

Yeah the catalogues are all there - I populate the market filter using a list of market ids where both the .gz and .json.gz present.  Then in check_market_book (in simulation) I look for the market type and do logic based on the type of market - and that's where the strategy finds 'None' where I would expect it to find the file.  I'll check out the middleware docs as haven't tried that avenue

---

## 2023-11-06 13:38:59 - random channel

**liam**

Yeah, I don't really understand your problem



&gt; strategy can't find the market_catalogue files

Catalogues are for markets, added via middleware, do you have all the catalogues? / or do you want to skip some?

---

## 2023-11-06 13:36:01 - random channel

**Johnny**

Tried providing full path, and manually pushing market_catalogue into the market object, but in truth I think I just need to understand how the strategy and framework program flow works!

---

## 2023-11-06 13:32:04 - random channel

**Johnny**

I guess you are referring to "event_processing":True ... after adding that, the strategy can't find the market_catalogue files (.json.gz) which are in the same place as the market files (.gz)

---

## 2023-11-04 13:24:39 - strategies channel

**liam**

What the hell is a [https://x.com/quantbeckman/status/1720717180029768110?s=46&t=MabdsEbyfbpsJHPcnVHwaQ|metamodel](https://x.com/quantbeckman/status/1720717180029768110?s=46&t=MabdsEbyfbpsJHPcnVHwaQ|metamodel)? 

---

## 2023-11-02 18:20:45 - general channel

**Peter**

Can't see any reason why streaming activity would interfere with manual betting. Also you can have a number of subscriptions for your API key - the number varies by account as more active users can request an increase - but you need at least 2 to be able to subscribe to markets and the order stream and I believe the default is 10.



Can you provide more specifics as to the problem / interference you're experiencing.

---

## 2023-11-02 17:13:05 - random channel

**PeterLe**

been out all day Liam (unexpectedly)...

I made some changes to a few systems and was hoping to watch what happened...left them running anyway

Having a quick look, I think every strategy has made a profit today, but not massive PL (At one time Liam that image above would have paid for a family holiday, not these days sadly :neutral_face:)

(Two races had XM off, Thurles and one at Wolv), did ok on them

Hope you are having a good day Chaps! :grinning:

---

## 2023-11-02 13:17:10 - general channel

**birchy**

Scratching is a common "trading" strategy

---

## 2023-11-01 21:10:47 - general channel

**Trex44**

[@UUCD6P13J](@UUCD6P13J) No the instances were on different EC2 environments. I didn't notice that behaviour again so shut down the test instance and am just continuing with the main one. I am willing to bet the firing of the strat on one instance an not the other is related to the seconds_to_start_parameter in the strategy as its possible for this to be different across two different instances for the same market update due to the EC2's local clock being used in the calculation.  I am very happy with the fix and am pushing ahead, I was just reporting back to you guys to let you know.



Curious, as I haven't used GitHub much before, will the commit that fixed this now become part of the main codebase?

---

## 2023-10-31 13:23:51 - strategies channel

**liam**

1. The [https://github.com/betcode-org/flumine/blob/06451c28252b87a94132dc1f29777cc696937f98/examples/strategies/lowestlayer.py#L46|code](https://github.com/betcode-org/flumine/blob/06451c28252b87a94132dc1f29777cc696937f98/examples/strategies/lowestlayer.py#L46|code) currently just checks for live orders on a market and places if zero, but you could change this to look at `runner_context.trade_count`

2. As above 

3. To simulate you just run the script? To run live you would just copy/paste the [https://github.com/betcode-org/flumine/blob/master/examples/example.py|example](https://github.com/betcode-org/flumine/blob/master/examples/example.py|example) but change the strategy 

---

## 2023-10-31 13:20:48 - strategies channel

**Riccardo Fresi**

Hi guys, looking at lowestlayer is not clear to me:

1. once placed an order for a marketid the strategy add new orders till market is open? or it make just 1 order for 1 market once the logic match?

2. if n°1 is true (more orders for 1 market) is there any way to place just one?

3. i don't get how to simulate it, i mean, i use simulation script as template, but i don't get how to use it on live event?

---

## 2023-10-30 19:42:38 - general channel

**birchy**

Ah yes...I run multiple strategies per flumine instance, hence the reason I filter by strategy name.

---

## 2023-10-29 18:11:49 - issues channel

**birchy**

`orders = market.blotter.strategy_selection_orders(strategy=self, selection_id=sel_id)

for o in orders:

    ...`

---

## 2023-10-29 13:15:37 - issues channel

**foxwood**

As I understand it the function definition `def selection_exposure(self, strategy, lookup: tuple) -&gt; float:` requires a tuple which I am presuming should contain one or more selection ids



That means (to me) that `market.blotter.selection_exposure(self,(mything.selection_id,))` should work ok. No matter what construct I use for the tuple it fails with an error of one sort or another.



Eventually I found that `market.blotter.selection_exposure(self,(0,mything.selection_id))` seems to work correctly.



If my understanding is right, cause of problem may be in `blotter.get_exposures() ... for order in self.strategy_selection_orders(strategy, *lookup[1:]):` which looks to me that it expects to start from subscript 1 and not 0.



Is something else expected in subscript position 0 ?

---

## 2023-10-29 11:48:15 - general channel

**birchy**

You'll get ALL orders. Personally, I have a logging control for each strategy instance and filter by strategy name, although it would be more efficient to run a single instance of logging control if you're pushing to a database or whatever.

---

## 2023-10-29 11:16:29 - general channel

**Dave**

Suppose I am running an instance of flumine, with a logging control that dumps my orders in `_process_cleared_orders_meta` by looping over `for order in event.event`. Suppose I run another instance of flumine with the same logging control, that trades on the same market. Will both instances each log orders submitted by both instances, or only their own? Does this depend on whether i'm running those two instances on the same host (and therefore their customer_strategy_refs will be different)?

---

## 2023-10-28 19:23:50 - strategies channel

**Jonjonjon**

that doesn't seem to work for me.



I've used your excellent market_id_to_random function to assign each market to one of two strategies... Strategy A and Strategy B.



Strategy A has a max stake of £100.

Strategy B has a max stake of £200.



They both make about the same amount of money.

---

## 2023-10-28 19:06:43 - strategies channel

**Jonjonjon**

What generic, non strategy related techniques, do people use to get more size off?

---

## 2023-10-27 17:13:47 - general channel

**Lee**

sorry, I’ve not been at my computer much the last couple of weeks



• are you running two instances on the same machine? Are you setting different hostnames/customer_strategy_ref in the flumine config? not sure how often you see this but is betfair resettling the market? 

• the worker changed wouldn’t/shouldn’t effect the strategy triggering

---

## 2023-10-27 11:31:15 - general channel

**Terry**

Sorry, screenshot from greyhounds prediction models.

---

## 2023-10-26 15:57:54 - random channel

**Peter**

If you're firing off multiple requests per second for the same strategy, that's a pretty big clue that you should be using Flumine. But for housekeeping, keep it simple.

---

## 2023-10-26 11:32:57 - random channel

**Mo**

I believe so. It’s teaching you to think about markets and where there might be inefficiencies that you are in a position to exploit and how to do that in a process driven way. Although the markets talked about in the course are tradfi/crypto, the principles apply to any kind of market. Robot James started taking an interest in betting markets over the past year or so so for all I know he will at least touch on these as well



I thought some of the best content in the course was Robot James doing a live demo of some exploratory data analysis. Fundamental stuff which can apply to any kind of data but the value is in the way he articulates it. That part gave me an idea for a new (small scale) betting strategy that more than covered the cost of the course

---

## 2023-10-26 08:35:08 - general channel

**Herugrim**

He asked for the percentages as displayed in the image which is what I explained. The rated prices are a result of a machine learning model that isn’t publicly available. 

---

## 2023-10-26 07:39:26 - general channel

**Herugrim**

[https://www.betfair.com.au/hub/racing/horse-racing/predictions-model/|https://www.betfair.com.au/hub/racing/horse-racing/predictions-model/](https://www.betfair.com.au/hub/racing/horse-racing/predictions-model/|https://www.betfair.com.au/hub/racing/horse-racing/predictions-model/)

---

## 2023-10-22 22:51:55 - strategies channel

**Adam**

Hey Mo, thanks for responding. I am streaming. So just subscribe to all races I care about (e.g. all Australian horse markets) when I init my strategy at the beginning of the day, and remove the markets throughout the day as they become suspended/closed by calling `remove_market`

---

## 2023-10-22 19:01:55 - general channel

**Trex44**

Hey Guys. So the TLDR is the fix worked. Thanks very much.



A few more details. I set up another instance and ran the patch on that one. I ran the same strategies at the same stakes on the patched instance as the for the unpatched instance. I couldn't get the install to work using the CLI even though everything seemed to download/install ok so I manually overwrote the workers file using the updated workers file Lee created. It might not have worked via the CLI because I am inexperienced using GitHub so did something wrong.



All the printed results in the the patched instance had the 'profit' column in the csv filled in correctly. The unpatched instance displayed the same error as before with zeros in sometimes present in the profit column.



• I have noticed that sometimes the same line or set of lines will be written twice. This occurs on both instances but not necessarily for the same results on each instance. My guess is its a different bug to the one that has just been fixed. It doesn't bother me as I only upload each unique bet id once to my results database. See below for an example from the patched instance. The same strategy executes on two markets but the results from the first market print again after the second.

`325529200273,strat_x,1.219940406,6846739,e75cea8e-7019-11ee-b135-17589b09afd9,2023-10-21 13:58:25.603658,3.65,3.7,1,1,-1.0,BACK,0.034584,Execution complete,"3.65,3.7,3.7",,"{'runner_id': 6846739}"`



`325538377913,strat_x,1.219940554,15914199,ca20765c-701e-11ee-b135-17589b09afd9,2023-10-21 14:33:24.004443,3.4,3.4,1,1,-1.0,BACK,0.021638,Execution complete,"3.4,3.45,3.45",,"{'runner_id': 15914199}"`



`325529200273,strat_x,1.219940406,6846739,e75cea8e-7019-11ee-b135-17589b09afd9,2023-10-21 13:58:25.603658,3.65,3.7,1,1,-1.0,BACK,0.034584,Execution complete,"3.65,3.7,3.7",,"{'runner_id': 6846739}"`





• A strategy that was active on both instances and fired on both instances over the two day test period fired on one extra market on the patched instance than on the un patched instance. Uncertain why this happened, possible could be strategy related so will need to look into the code to see. 

I will leave the two instances running the next few days to see what is generated. The unpatches instance is one I use at low stakes for my test strategies. I will be upgrading my main instance to the new patch of the back of these results.

---

## 2023-10-22 14:13:04 - strategies channel

**Aaron Smith**

[@UUE6E1LA1](@UUE6E1LA1) never checked those, would have to research that, however i m not sure if it makes much sense to use those to calculate EV, i d feel a lot less confident in those than betfair prices, as those are the ones im competing against. Also, if the ones from your site were more accurate, it can only really be by a tiny margin, as otherwise ppl would just arb between the two.



[@UQL0QDEKA](@UQL0QDEKA) interesting idea, however i wouldnt have much to compare with, as i ve never checked it before :smile:



[@U016TGY3676](@U016TGY3676) did this effect your EV or volume? or PNL? what eggs me is that volume and EV have remained stable and solid through out all this. I ve had it before that a strategy wouldnt work anymore after some time, but that would always be reflected in the EV. Not much to wonder there, the market evolved some, but here i m just confused.

---

## 2023-10-22 13:20:26 - strategies channel

**birchy**

[@UUE6E1LA1](@UUE6E1LA1) volume looks to be same at a quick glance. I think someone is trying out a new model. :wink:

---

## 2023-10-22 13:07:53 - strategies channel

**Adam**

Apology in advance if this is the incorrect channel to ask this question. If so, please let me know where to go, thank you :slightly_smiling_face:



Hey all, I’m new to flumine and I’m following through this amazing guide: [https://betfair-datascientists.github.io/tutorials/How_to_Automate_1/](https://betfair-datascientists.github.io/tutorials/How_to_Automate_1/). When it comes to streaming horse markets, I was wondering if there is a way to continually add markets to an strategy (that is already streaming events) as the markets become live?

The reason being is I want to set up the strategy at the beginning of the day, and as races become live, I want to add that race to the strategy for processing, and remove it as the race becomes closed or suspended. I can see there’s a `remove_market` method in the `BaseStrategy` but I can’t see an equivalent `add_market`. This suggests that the way it’s supposed to work is that we create the strategy filtering on all the australian horse markets at the beginning of the day and remove them when they’re suspended? There’s also a method called `process_new_market` but is this called when a market becomes live or does this suggest it can be used for what I’m asking?

---

## 2023-10-22 12:17:52 - strategies channel

**Unknown**

[@U01DVUAE2G1](@U01DVUAE2G1)  I just came here to ask the same question. Something has definitely changed on the WIN markets for both UK and Aus. The TVs are trading in much tighter ranges across every runner...

---

## 2023-10-19 10:55:42 - general channel

**liam**

:+1: if you just copy the LowestLayer strategy and debug through / print stuff you can see how it works/simulates things

---

## 2023-10-19 10:25:00 - general channel

**liam**

'The attached code is attempting to use a MarketRecorder strategy to record a simulated market'



what?

---

## 2023-10-19 10:24:12 - general channel

**Unknown**

Hi folks,



I think I may be getting somewhere, but very slowly!

The attached code is attempting to use a MarketRecorder strategy to record a simulated market but I'm running into the attached error in marketrecorder.py.

It seems there is no "id" property in the data object. I've tried hard-coding market_id to be the actual market id but this then creates a some new problems, which I'm happy to go into if anyone thinks necessary.

---

## 2023-10-17 17:17:25 - betconnect channel

**MMW**

Cancel Order single bet



[https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/|https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/](https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/|https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/)



C# 

{"params": {"marketId": "1.219815567", "instructions":[{"betId": "325032312929"}]}, "id": 1}



How to cancel a single bet I am trying to cancel a bet but cancel all bets back or lay kindly help me, please

---

## 2023-10-17 16:36:58 - issues channel

**MMW**

Cancel Order single bet



[https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/|https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/](https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/|https://api.betfair.com/exchange/betting/rest/v1.0/cancelOrders/)



{"params": {"marketId": "1.219815567", "instructions":[{"betId": "325032312929"}]}, "id": 1}



How to cancel a single bet I am trying to cancel a bet but cancel all bets back or lay kindly help me, please

---

## 2023-10-17 13:22:30 - general channel

**tone**

Hello again,

Any pointers re how I might record the data in "raw" format? I'm currently attempting to do this using using the below code but the results don't look right for use in replay / simulation mode.

I'm guessing it could be something to do with the stream_class!

Any help would be very welcome.



import time

import logging

import betfairlightweight

from pythonjsonlogger import jsonlogger



from flumine import Flumine, clients

from flumine.strategy import strategy

from flumine.streams.datastream import DataStream

from local_marketrecorder import MarketRecorder

import betfairlightweight



logger = logging.getLogger()

custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = betfairlightweight.APIClient("###", "###", devKey, certs=(###))

client = clients.BetfairClient(trading)



framework = Flumine(client=client)



strategy = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["AU"],

        market_types=["WIN"],

        market_ids=["1.219765628"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": "d:/BetFair/data",

        "force_update": True,

        "remove_file": False,

        "remove_gz_file": False,

        "load_market_catalogue": True,

    },

)



framework.add_strategy(strategy)

framework.run()

---

## 2023-10-16 18:23:00 - issues channel

**Andrey Luiz Malheiros**

I managed to solve it.

The issue was that I needed to pass the DataStream instead of the MarketStream to the stream_class parameter on strategy

---

## 2023-10-16 10:33:40 - strategies channel

**Unknown**

*ML Day 70*



Haven't given up, after exploring a few algos I found that using XGBoost seemed to be the most applicable / get the best results in terms of accuracy on the problem I was trying to solve. Using my current prediction I used the algo to predict the error (delta), from my understanding this is a common technique (does it have a name?) and proved to be far more accurate than starting 'fresh'.



Had a few issues with latency when simulating using the sklearn integration as its considerably slower compared to using the low level [https://xgboost.readthedocs.io/en/stable/python/python_api.html|library](https://xgboost.readthedocs.io/en/stable/python/python_api.html|library).



However the improvements just didn't equate to more profit, I have since worked on trying to get the algo to reveal what it was doing. I started reverse engineering / brute force by plugging in values that I believe had the highest importance and graphing the results. Without revealing too much this gave me a regression model for the variables as opposed to an 'if statement' on the min/max, not sure this is how I am supposed to be using machine learning but its working for me right now :joy:

---

## 2023-10-16 00:25:50 - issues channel

**Andrey Luiz Malheiros**

I'm having trouble running the marketrecorder located at flumine/examples/strategies/marketrecorder.py within the flumine Git repository. It seems that the process_raw_data is not being executed. Do I need to make any changes to the marketrecorder (such as returning True in the check_market_book or passing the strategy's stream_class as DataStream instead of MarketStream)?

---

## 2023-10-15 21:46:27 - general channel

**Rishab**

Does running all the markets for a sport(say horse racing) in just 1 flumine instance affect the strategy in any way if my strategy is latency sensitive?

---

## 2023-10-13 19:12:57 - issues channel

**liam**

*Each market filter uses a connection (you can have multiple per strategy) 

---

## 2023-10-13 18:57:17 - issues channel

**AndyL**

[@U01MPC0GUK1](@U01MPC0GUK1) So yes i'm using those options for the BetfairClient, but I had 3 MarketRecorder instances, as I had various market_filter's, and it seems each MarketRecorder DataStream class creates 1 Connection, hence for my 3 recorder strategies it needed 3.... i've now reduced it to 2 and it start fine now.

I did not realise each MarketRecorder strategy used a connection

[@U4H19D1D2](@U4H19D1D2)

---

## 2023-10-13 13:34:36 - general channel

**Peter**

Skip trying to do this with betfairlightweight and start with Flumine. It's a trading framework wrapped around betfairlightweight, and adds many of the tools you'll need when you want to start acting on those triggers.



Take a look at the lowest layer example in the repo to see how this would work.

---

## 2023-10-13 13:09:05 - general channel

**andres gonzalez**

Hello, very new to using the betfair API, at the moment I'm simply trying to create a bot that tracks prices of specific markets I want to and want to to notify me when available back or lay liquidity is what I'm looking for. going through the betfairlightweight GitHub to try and do this step by step. Currently trying to find in the documentation all the use cases of trading.betting on python.

---

## 2023-10-12 11:20:25 - issues channel

**Riccardo Fresi**

new error, random during the recorder

```{"asctime": "2023-10-12 10:19:03,147", "levelname": "WARNING", "message": "_get_cleared_orders error", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\riccardo.fresi\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\flumine\\worker.py\", line 195, in _get_cleared_orders\n    cleared_orders = betting_client.betting.list_cleared_orders(\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\riccardo.fresi\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\betfairlightweight\\endpoints\\betting.py\", line 434, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\riccardo.fresi\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 54, in request\n    self._error_handler(response_json, method, params)\n  File \"C:\\Users\\riccardo.fresi\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 80, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.219555230'], 'customerStrategyRefs': ['C11-8C3Y06BQHRN'], 'settledDateRange': {'from': None, 'to': None}, 'fromRecord': 0} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie2-ang13b-prd-09131022-003f2bc994', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}```

any ideas?

---

## 2023-10-10 12:08:19 - general channel

**Muhammad Adeel Zahid**

Thanks [@U4H19D1D2](@U4H19D1D2). I think it should solve my problem. Just for information, how would I access the `tv` field in Flumine. `BaseStrategy` seems to pass `EX_TRADED_VOL` in `marketDataFilter` but there is no object exposing this value

---

## 2023-10-10 11:25:40 - general channel

**Peter**

Firstly welcome.



All the data you currently want, and more, is available in the files generated by the market recorder, but it needs a slight shift in how you think about them.



The way we approach this here is to save those files as raw data. Then run them through Flumine in simulation mode to extract the specifics that we want for the analysis being done at the time and save it in a format conducive to that analysis.



Later we may return, stream the same raw data but extract different parts of it, e.g. trading volumes, or SP estimates, or some metric that we derive from the raw data. We don't assume that what we want now is what we will want in the future, Hence keeping the data in it's raw form allowing for maximum flexibility.

---

## 2023-10-09 16:19:13 - issues channel

**Riccardo Fresi**

Hi,



new error today, i had to downgrade python from 3.12 to 3.11, now on market recorded i got this, any idea?

Traceback (most recent call last):

  File "c:\Users\riccardo.fresi\OneDrive - Accenture\Downloads\Odds\streaming_soccer.py", line 61, in [module](module)

    framework.run()

  File "C:\Users\riccardo.fresi\AppData\Local\Programs\Python\Python311\Lib\site-packages\flumine\flumine.py", line 48, in run

    self._process_market_catalogues(event)

  File "C:\Users\riccardo.fresi\AppData\Local\Programs\Python\Python311\Lib\site-packages\flumine\baseflumine.py", line 263, in _process_market_catalogues

    market.market_book.streaming_unique_id in strategy.stream_ids

    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

AttributeError: 'NoneType' object has no attribute 'streaming_unique_id'

---

## 2023-10-09 14:10:11 - general channel

**Muhammad Adeel Zahid**

Ok. Below are my strategy parameters

```strategy = LayStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"], # Horse racing

        country_codes=["GB", 'IE'],

        market_types=["WIN"], # Win Markets

    )

)



framework.add_strategy(strategy)



framework.run()```

and this is my `process_orders` function in `LayStrategy`

```def process_orders(self, market: Market, orders: list) -&gt; None:

    print('process orders')

    if orders:

        print(orders)

    aorders = [o for o in market.blotter.live_orders]

    if aorders:

        print('process order')

        print(aorders)

    for order in orders:

        print(order)```

But not even the first statement is being called (`print('process orders')`. I don't know what is wrong with this code.  Nothing shows up related to orders

---

## 2023-10-06 10:42:45 - general channel

**Trex44**

```import csv

import logging

from flumine.controls.loggingcontrols import LoggingControl

from flumine.order.ordertype import OrderTypes

import datetime



logger = logging.getLogger(__name__)

today_date = datetime.datetime.now().strftime("%d-%m-%Y--%H:%M")



FIELDNAMES = [

    "bet_id",

    "strategy_name",

    "market_id",

    "selection_id",

    "trade_id",

    "date_time_placed",

    "price",

    "price_matched",

    "size",

    "size_matched",

    "profit",

    "side",

    "elapsed_seconds_executable",

    "order_status",

    "market_note",

    "trade_notes",

    "order_notes",

]





class StandardLoggingControl(LoggingControl):

    NAME = "Standard_Logging_Control"



    def __init__(self, *args, **kwargs):

        super(StandardLoggingControl, self).__init__(*args, **kwargs)

        self._setup()



    def _setup(self):

        with open(f"orders_{today_date}.txt", "w") as m:

            csv_writer = csv.DictWriter(m, delimiter=",", fieldnames=FIELDNAMES)

            csv_writer.writeheader()



    def _process_cleared_orders_meta(self, event):

        orders = event.event

        with open(f"orders_{today_date}.txt", "a") as m:

            for order in orders:

                if order.order_type.ORDER_TYPE == OrderTypes.LIMIT:

                    size = order.order_type.size

                else:

                    size = order.order_type.liability

                if order.order_type.ORDER_TYPE == OrderTypes.MARKET_ON_CLOSE:

                    price = None

                else:

                    price = order.order_type.price

                try:

                    order_data = {

                        "bet_id": order.bet_id,

                        "strategy_name": order.trade.strategy,

                        "market_id": order.market_id,

                        "selection_id": order.selection_id,

                        "trade_id": order.trade.id,

                        "date_time_placed": order.responses.date_time_placed,

                        "price": price,

                        "price_matched": order.average_price_matched,

                        "size": size,

                        "size_matched": order.size_matched,

                        "profit": order.profit,

                        "side": order.side,

                        "elapsed_seconds_executable": order.elapsed_seconds_executable,

                        "order_status": order.status.value,

                        "market_note": order.trade.market_notes,

                        "trade_notes": order.trade.notes_str,

                        "order_notes": order.notes_str,

                    }

                    csv_writer = csv.DictWriter(m, delimiter=",", fieldnames=FIELDNAMES)

                    csv_writer.writerow(order_data)

                except Exception as e:

                    logger.error(

                        "_process_cleared_orders_meta: %s" % e,

                        extra={"order": order, "error": e},

                    )



        [http://logger.info|logger.info](http://logger.info|logger.info)("Orders updated", extra={"order_count": len(orders)})



    def _process_cleared_markets(self, event):

        cleared_markets = event.event

        for cleared_market in cleared_markets.orders:

            [http://logger.info|logger.info](http://logger.info|logger.info)(

                "Cleared market",

                extra={

                    "market_id": cleared_market.market_id,

                    "bet_count": cleared_market.bet_count,

                    "profit": cleared_market.profit,

                    "commission": cleared_market.commission,

                },

            )```

---

## 2023-10-06 08:40:21 - general channel

**Muhammad Adeel Zahid**

Hello. I am using the simple strategy from the Flumine tutorial. Below are some code snippets

```strategy = LayStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"], # Greyhounds

        country_codes=["AU", "NZ"], # Australia

        market_types=["WIN"], # Win Markets



    )





)

def check_market_book(self, market: Market, market_book: MarketBook) -> bool:

    # process_market_book only executed if this returns True

    if market_book.status != "CLOSED":

        return True



# If check_market_book returns true i.e. the market is open and not closed then we will run process_market_book once initially

#  After the first initial time, process_market_book runs every single time someone places, updates or cancels a bet

def process_market_book(self, market: Market, market_book: MarketBook) -> None:

    if market.seconds_to_start <= 120:

        for runner in market_book.runners:

            logging.info(f'runner.selection_id ,{runner.selection_id},Status :{runner.status},Matches{[(m.price, m.side)for m in runner.matches]}'

                         f'Orders:{[(o.price, o.size_matched, o.size_cancelled) for o in runner.orders]},TMthd{runner.total_matched},HdCpd{runner.handicap}'

                         f',SP:{[runner.sp.actual_sp, runner.sp.lay_liability_taken, runner.sp.near_price, runner.sp.far_price, runner.sp.actual_sp]}')

            logging.info(f'Complete orders = {runner.orders}')```

I am trying to log the matched orders for each market but no order shows up in the log file. Can anyone guide what I am doing wrong?

---

## 2023-10-05 12:50:10 - general channel

**liam**

what are you doing in pandas? / my understanding is that you are only placing one bet so surely you just need to do the dirty pandas stuff once per market/strategy?

---

## 2023-10-05 06:39:33 - general channel

**Andy B**

Ah okay, so the runner.context is exclusive to the strategy?

---

## 2023-10-05 06:38:53 - general channel

**liam**

Just copy the [https://github.com/betcode-org/flumine/blob/796ec51060328edac7e14678c6defd63a964d250/examples/strategies/lowestlayer.py#L46|example](https://github.com/betcode-org/flumine/blob/796ec51060328edac7e14678c6defd63a964d250/examples/strategies/lowestlayer.py#L46|example) but change the if to



```if runner_context.trade_count == 0:```

ie. just place one trade/bet per runner per strategy

---

## 2023-10-05 06:36:37 - general channel

**Andy B**

If there is a better way to do my back tests, I'm happy to learn.  I have three strategies in the one back test, and I want to be able to place no more than 1 bet on a runner in each strategy.  I was using the following to speed up market processing:

if 'processed' not in market.context:

                market.context['processed'] = True



This has the impact of preventing other strategies from processing that market and that means my test results are incorrect.  I changed that code to:



if 'processed' not in self.context:

                self.context['processed'] = True



This appears to allow each strategy to process the market, although I haven't definitively proved that yet.    If there is a better way to do this, let me know.

---

## 2023-10-04 16:46:55 - general channel

**foxwood**

It's strategy data specific to the market. It makes it possible for different strats to talk/check with each other when they know the name and meaning of values of the other strat eg `if market.context["strat999"]["someValue"] == 0 :`  Not used in anger but there if needed. I use the strategy context for immutable parameters - usually. It was either that or have dictionary of markets and their data in the strategy context - design decision. Or is there a better way ?

---

## 2023-10-04 13:03:08 - general channel

**liam**

Sounds like you should be using `strategy.context` if its strategy data

---

## 2023-10-04 11:31:39 - general channel

**Andy B**

Actually, it's not a bug, it's because I set this in another strategy:

if 'processed' not in market.context:

                market.context['processed'] = True

---

## 2023-10-04 11:00:03 - general channel

**Johnny**

Do you guys mean a separate Docker container, or a separate strategy added to the existing framework?

---

## 2023-10-04 10:52:37 - general channel

**liam**

Its per strategy instance, so yes 5 strategies could place 5 bets, one bet per runner per strategy

---

## 2023-10-04 10:51:39 - general channel

**Andy B**

Quick question.  When I set up a strategy and set max_trade_count and max_live_trade_count to 1 in a simulation, is that only for the specific strategy?  If I have 5 strategies, could I in theory place 5 bets on the same runner, or is it governed by the max_trade_count and max_live_trade_count setting in another strategy?  The code I am currently using is:



strategy_A = SimsAll_A(

        market_filter={

            "markets": markets,

            'market_types':['PLACE'],

            "listener_kwargs": {"inplay": False, "seconds_to_start": 80},

            "event_processing": True

            },

    max_order_exposure= 50, # Max bet sizes of $50

    max_trade_count=1, # Max of trade/bet attempt per selection

    max_live_trade_count=1, # Max of 1 unmatched Bet per selection

    )

---

## 2023-10-03 21:52:37 - general channel

**Clive**

Do people generally run the recorder alongside a main strategy or in a separate process?

---

## 2023-10-03 21:25:48 - issues channel

**foxwood**

Log full of 503 errors on the streams from 6ish until it came back at about 08:05 then automatically sorted itself out and carried on as normal. Any fancy middleware ? My setup is just basic flumine and inheriting from BaseStrategy.

---

## 2023-10-01 15:48:34 - general channel

**Good Job**

Also, to the best of my knowledge it is quite literally the best price data there is in most if not all terms, and some of it being missing is quite unfortunate. I have not come across a paper using said exchange data to test model  profitability, but I have seen quite a few using stuff like B365 etc...

---

## 2023-10-01 09:18:08 - general channel

**Andy B**

I have it set up in flumine like this:

# Searches for all betfair data files within the folder sample_monthly_data_output

data_folder = 'Greyhounds\\Data'

data_files = os.listdir(data_folder,)

data_files = [f'{data_folder}/{path}' for path in data_files]



def run_process(markets):

    """Replays a Betfair historic data. Places bets according to the user defined strategy and tries to accurately simulate matching by replaying the historic data.



    Args:

        markets (list: [file paths]): a list of file paths to where the historic data is stored locally. e.g. user/zhoui/downloads/test.csv

    """

    # Set Flumine to simulation mode

    client = clients.SimulatedClient()

    framework = FlumineSimulation(client=client)



    # Set parameters for our strategy

    # strategy = FlatIggyModel(

    strategy = BoxPercSim(

        market_filter={

            "markets": markets,

            'market_types':['WIN','PLACE'],

            "listener_kwargs": {"inplay": False, "seconds_to_start": 80},

            "event_processing": True

            },

    max_order_exposure= 50, # Max bet sizes of $50

    max_trade_count=1, # Max of trade/bet attempt per selection

    max_live_trade_count=1, # Max of 1 unmatched Bet per selection

    )

    framework.add_strategy(strategy)



    framework.add_logging_control(

        BacktestLoggingControl()

    )

    framework.run()



# Multi processing

if __name__ == "__main__":

    all_markets = data_files  # All the markets we want to simulate

    processes = os.cpu_count()  # Returns the number of CPUs in the system.

    markets_per_process = 8   # 8 is optimal as it prevents data leakage.



    _process_jobs = []

    with futures.ProcessPoolExecutor(max_workers=processes) as p:

        # Number of chunks to split the process into depends on the number of markets we want to process and number of CPUs we have.

        chunk = min(

            markets_per_process, math.ceil(len(all_markets) / processes)

        )

        # Split all the markets we want to process into chunks to run on separate CPUs and then run them on the separate CPUs

        for m in (utils.chunks(all_markets, chunk)):

            _process_jobs.append(

                p.submit(

                    run_process,

                    markets=m,

                )

            )

        for job in [http://futures.as|futures.as](http://futures.as|futures.as)_completed(_process_jobs):

            job.result()  # wait for result



So it should be populating the list of markets correctly I think.

---

## 2023-10-01 09:06:07 - general channel

**Andy B**

Thanks (again) Liam.  I'm still not getting the response I was expecting though.  My strategy looks like:



strategy = BoxPercSim(

        market_filter={

            "markets": markets,

            'market_types':['WIN','PLACE'],

            "listener_kwargs": {"inplay": False, "seconds_to_start": 80},

            "event_processing": True

            },

    max_order_exposure= 50, # Max bet sizes of $50

    max_trade_count=1, # Max of trade/bet attempt per selection

    max_live_trade_count=1, # Max of 1 unmatched Bet per selection

    )



And then the rest of my code is:



place_market = market.event["PLACE"]

                            print(place_market)

                            for a in place_market:

                                print('event:', a.event, 'market_type:', a.market_type, 'place_market_type:', type(place_market))

                            place_market_book = place_market[0].market_book



I put that bit of debug in there to try and see what is being returned and I can see that place_market is indeed a flumine object as per my code in the live stream - &lt;flumine.markets.market.Market object at 0x000001B593B74AF0&gt;.



In the second part of the debug, I can see the output as:

event: defaultdict(&lt;class 'list'&gt;, {'WIN': [&lt;flumine.markets.market.Market object at 0x000001B592FECDF0&gt;], 'PLACE': [&lt;flumine.markets.market.Market object at 0x000001B593B74AF0&gt;]}) market_type: PLACE place_market_type: &lt;class 'list'&gt;



Using the vscode debugger, I can see that market.event = 'WIN" and the value of place_market is an empty list i.e. [].  Presumably I need to be getting the value for place_market from somewhere else, but looking through the debuger output in vscode isn't giving me the answers I expect.  I did wonder if the market I was accessing was only a WIN market, but it does this for every market when I let the back test run, so that can't be the answer.  It has to be the way I am trying to access it.

---

## 2023-09-28 14:34:47 - strategies channel

**joe taylor**

[@UEA14GBRR](@UEA14GBRR)  if we agree to the fact that overall hedging at bsp gives 0 EV, it would also mean that EV of any strategy(pre-inplay)would be equal to pnl of all its trades hedged at bsp. I don’t understand why you say that one of your strategy would be loosing if unhedged

---

## 2023-09-28 14:27:20 - strategies channel

**liam**

[https://robotjames.com/posts/kwant-signal-trade-offs-in-the-real-world/|kwant signal trade-offs in the real world](https://robotjames.com/posts/kwant-signal-trade-offs-in-the-real-world/|kwant signal trade-offs in the real world)



Well worth reading the other posts, he is able to articulate a lot of what I do a lot better than I have ever managed :joy:



&gt; *&lt;https://robotjames.com/posts/how-scalable-is-this-strategy/

&gt; |how scalable is this strategy?&gt;*

&gt; friend asks "how do i know how scalable this strategy is?"

&gt; one very simple thing you can do to get an idea, is to look at the decay in simulated performance when you delay acting upon your signals.

&gt; how much worse does it look if you delay your rebalance trades by 15m, 60m, 4h etc?

&gt; slow decay means you might have a chance of sizing it up.

&gt; if it falls off a cliff, you probably gotta stay small and nimble in that strategy.

&gt; we're always trading at other people's prices and can only eat what we are fed.

&gt; beep....boop

---

## 2023-09-28 13:08:07 - strategies channel

**ShaunW**

[@UPMUFSGCR](@UPMUFSGCR) "Hedging is for losers that have been brainwashed by PW's YouTube tutorials.". You're wrong, it's very straightforward to test that hypothesis and in certain situations it's very useful to hedge.... Besides, with bsp being 0ev it's a harmless bet, but it has the effect of reducing the size of the wins and gains which reduces commission (unless you're keen to acrue more).  There's no hard and fast rule, I have one strategy that is better not hedging and another which would lose if I wasn't hedging.   Saying you should never hedge is as daft as saying you always should.

---

## 2023-09-27 17:48:21 - general channel

**Trex44**

Hey guys. Has anyone ever had an issue where the 'profit' column in their logs shows as 0 even though the bet was a win or a loss? The last 3 bets in the information below were all wins or losses on 1 pound bets . I have been using a StandardLoggingControl class for months with no issue. Its a modified version of the [https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|BacktestLoggingControl](https://github.com/betcode-org/flumine/blob/master/examples/controls/backtestloggingcontrol.py|BacktestLoggingControl). It only started doing this yesterday so wondering if the issue actually lays with Betfair. Strangely the first bet of the day logged correctly.

```bet_id,strategy_name,market_id,selection_id,trade_id,date_time_placed,price,price_matched,size,size_matched,profit,side,elapsed_seconds_executable,order_status,market_note,trade_notes,order_notes

322399496435,back_A,1.218753189,58855793,66405328-5c73-11ee-8cd1-b9568a354032,2023-09-26 13:48:40.490287,3.55,3.55,1,1,2.55,BACK,0.023866,Execution complete,"3.5,3.55,3.6",,"{'secs_to_start': 79.845224} 

22403591681,back_C,1.218753209,58928490,47d0dbec-5c78-11ee-8cd1-b9568a354032,2023-09-26 14:23:36.850423,5.2,5.2,1,1,0.0,BACK,13.330706,Execution complete,"5.1,5.2,5.1",,"{'secs_to_start': 83.423703}

22413152508,back_B,1.218753428,1224675,29a2fde9-5c83-11ee-8cd1-b9568a354032,2023-09-26 15:41:30.800658,3.45,3.45,1,1,0.0,BACK,0.9553,Execution complete,"3.4,3.45,3.4",,"{'secs_to_start': 209.332741} 

322414591274,back_A,1.218753244,18565272,bd43c7fd-5c84-11ee-8cd1-b9568a354032,2023-09-26 15:52:48.223042,2.78,2.78,1,1,0.0,BACK,11.308602,Execution complete,"2.76,2.78,2.76",,"{'secs_to_start': 132.004036} ```

---

## 2023-09-27 13:04:56 - strategies channel

**Mo**

You are sort of correct about laying at BSP being winning strategy but two points. Number one - because you don’t know the exact price you will end up laying it, sizing is difficult to get right. Number two - you need to consider commission which is arguably the reason why BSP has an overround

---

## 2023-09-27 11:21:07 - strategies channel

**joe taylor**

Hi all! Had a question for people who do some pre-inplay trading. Hedging at bsp vs carrying the position and not hedging, which has better EV? (I know from betfair’s research EV should be same, but wanted hear everyone’s experience on on this) 

---

## 2023-09-26 16:16:25 - general channel

**Mona**

Hi if I set the `conflat_ms` in strategy initialization, does that apply to `MarketStream`  only or does it also apply to its `OrderStream`. is there a way to set different `conflat_ms` values in `MarketStream` and `OrderStream`?

---

## 2023-09-26 10:32:37 - random channel

**foxwood**

Looking to change my server provider so checking out the confusing Amazon offers and it ended up suggesting a server at 4 times the cost I currently pay ! I've probably ticked the wrong boxes so can anyone who runs a Windows server with Amazon (ec2 ?) give an indication of the size/model reference they find works for live running about 10 strategies 24x7 with about 40GB storage and all backtest / development done locally ? Tried a different configuration and a "t3" seemed a vague possibility - sadly it's a jargon nightmare.

---

## 2023-09-25 13:44:06 - general channel

**Jorge**

Hi, looks like the [https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py#L10|OrdersMiddleware](https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py#L10|OrdersMiddleware) has a bug because it is not filtering by market.market_id (in [https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py#L23|list_current_orders](https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py#L23|list_current_orders) ) when processing orders. Is anyone else using it?



This is the code I use to add the Middleware:

```....



framework.add_strategy(strategy)

framework.add_market_middleware(RestoreOrdersMiddleware(framework))

framework.run()```

---

## 2023-09-25 07:44:49 - general channel

**D C**

When I started I wrote a GUI app with a price grid trading tool with the view to using it as a visual aid to manually trading. In retrospect this was rather stupid for a variety of reasons, but I am actually quite glad I started off like this because watching the rendered GPS in real time made it very clear what kind of "surprises" the data can throw at you. Especially when watching a race replay after and comparing with the GPS visuals. I don't want to criticize though  - there is still plenty of information there despite the errors.

---

## 2023-09-24 12:52:41 - general channel

**Justice**

[@UBS7QANF3](@UBS7QANF3) I sympathise with that. I created a machine learning model that had the racing post and timeform ratings as a feature. Back testing showed huge profits. Thankfully, I thought better of it. After looking into it, turns out these ratings are revised retrospectively, causing data to leak into the model

---

## 2023-09-24 12:02:27 - general channel

**Justice**

[@UBS7QANF3](@UBS7QANF3) Really? I did not know that. I wanted to mess around and train a reinforcement learning model using Betfair price data and TPD tracking data, but guess that's useless if that's true. Do you know why that is the case? That's very poor. But tbh, my whole experience with the TPD (albeit several years ago) was very poor in general

---

## 2023-09-22 09:10:18 - general channel

**casper**

Getting quite a few Status Code Error 502 lately and some “Connection aborted” messages when using trading.betting endpoints. Anyone experiencing similar things? Yesterday had particularly a lot of those.

---

## 2023-09-21 14:41:33 - general channel

**mzaja**

Thanks, I see where I went wrong now. It calls `strategy.check_market` , not `check_market_book` , which does what I'd expect it does.

---

## 2023-09-21 14:12:47 - general channel

**liam**

No it will check if the strategy is subscribed to that particular stream

---

## 2023-09-21 13:34:05 - general channel

**Unknown**

Am I reading this correctly? On any MarketBook event, Flumine will call all strategies, irrespective of whether that strategy is subscribed to that particular market? So if I have one strategy subscribed to football markets and one subscribed to horse racing, both of them will get called on both football and horse racing market updates?

---

## 2023-09-21 08:36:35 - general channel

**liam**

No, all strategy execution is within the main thread, have you profiled your code? You must be doing something very inefficient

---

## 2023-09-20 21:07:55 - general channel

**Mona**

I see, if I add another strategy like the pricerecorder in your example that process the data and store it in a csv, would it uses a different thread and solve the problem?

---

## 2023-09-20 11:08:38 - random channel

**river_shah**

so i think it makes total sense to keep betfair / sports modelling in the mix while looking at other markets. the math and principles underlying these are the same

---

## 2023-09-20 10:52:31 - random channel

**river_shah**

I suck(ed) at infra pieces as always had teams of engineers to help with that. had to learn this side of trading systems

---

## 2023-09-20 10:51:33 - random channel

**river_shah**

No using flumine (thank lord for [@U4H19D1D2](@U4H19D1D2)) The modelling layer wrote myself and then started to refactor it to be general purpose across markets

---

## 2023-09-20 10:38:30 - random channel

**river_shah**

Well depends on strategy modules. Some are very focused on betting that have no translation for other markets. But many things are shared. Crypto volumes are falling off a cliff but what it means is that larger HFTs pulling back due to regulatory concerns. Better for solo / small teams

---

## 2023-09-20 10:28:48 - random channel

**Ralegh**

I’m guessing you’re an (ex) quant [@U01B8031PM1](@U01B8031PM1) is your betfair stuff more like trad trading or modeling outcomes?

---

## 2023-09-20 10:25:20 - random channel

**river_shah**

Yes, sorry more difficult as in the tech / modelling

---

## 2023-09-20 10:14:29 - random channel

**river_shah**

Maybe worth digging if TradingView supports python connectors. 1hr+ horizons in microcaps etc likely could work on NYSE for a sharp smaller trader

---

## 2023-09-20 09:52:18 - strategies channel

**James**

I've been trying to come up with some punting strategies for Aus racing. I've found something that looks promising but CL2 races seem to be unprofitable. The strategy looks for selections in CL1-CL6 races. It is profitable over a decent sample in all classes except for CL2 which seems odd. It is possible it is just variance or a quirk in the data but unlikely. I know very little about Aus racing so wondered whether there is anything unique about CL2 races?

---

## 2023-09-19 12:46:38 - general channel

**Andy B**

I haven't been able to figure this out, so looking for a bit of assistance if possible.  My existing strategy looks like:



class MyStrat (BaseStrategy):



    def start(self) -&gt; None:

        print("starting strategy")



    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True



    # If check_market_book returns true i.e. the market is open and not closed then we will run process_market_book once initially

    # After the first inital time process_market_book has been run, every single time the market ticks, process_market_book will run again

    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:



        if market is not None:

            if market is not None and market.market_catalogue is not None and market.market_catalogue.market_name is not None:

                RaceNumber = market.market_catalogue.market_name.split(' ')[0].replace("R","").strip()



        if market.seconds_to_start &lt;= 5 and market_book.inplay == False:

            TrackName = market.venue.lower()

            for runner in market_book.runners:

                RunnerName = [x.runner_name for x in market.market_catalogue.runners if x.selection_id == runner.selection_id]

                RunnerName = RunnerName[0].split('. ')[1].lower()

                if runner.status == "ACTIVE" and runner.ex.available_to_back: # and runner.ex.available_to_lay[0]['price']:

                    filtered_row = pd.DataFrame()

                    if market.market_type == 'WIN':

                        filtered_row = GreysList[(GreysList['TrackName'] == TrackName) &amp;

                            (GreysList['RaceNumber'] == int(RaceNumber)) &amp;

                            (GreysList['DogName'] == RunnerName)]



                    if not filtered_row.empty or market.market_type == 'PLACE':

                        if not filtered_row.empty:

                            runner_odds = filtered_row['ODDS'].iloc[0]

                            current_price = runner.ex.available_to_back[0]['price']

                            bet_price = get_nearest_price(round((current_price),2))

                            if runner_odds &lt; current_price and runner_odds &gt; 0 and current_price &gt;=2.5 and current_price &lt;= 10 and market.market_type == 'WIN':

                                print(market.market_type)



                                if market.market_type == 'WIN':

                                    stake = round((3/current_price),2)

                                    if stake &lt; 0.1: stake = 0.1

                                    print(TrackName, RunnerName, runner_odds, current_price, stake)

                                    trade = Trade(

                                    market_id=market_book.market_id,

                                    selection_id=runner.selection_id,

                                    handicap=runner.handicap,

                                    strategy=self,

                                    )

                                    order = trade.create_order(

                                        side="BACK", order_type=MarketOnCloseOrder(liability=stake)

                                    )

                                    market.place_order(order)

									

									# At this point, I want to also make a place bet but I need to get the value of runner.ex.available_to_back[0]['price'] from the PLACE market.

									# At the start of my script, I get a list of WIN and PLACE markets and store them in a dataframe called TodaysRaces.

									# I can locate the PLACE market id by querying this dataframe, but I don't know how to utilise Market.event["PLACE"] to get the value of runner.ex.available_to_back[0]['price'], so that I can set up the trade and order to place the bet.

									# Can someone point me in the right direction please?

---

## 2023-09-19 09:13:30 - random channel

**Ralegh**

Which asset class and time frame? [@UPMUFSGCR](@UPMUFSGCR) 

Id suggest focusing on getting good forecasts/models (which needs good data) before worrying about simulation. Should be able to manage with some pandas 

---

## 2023-09-18 21:11:35 - random channel

**Jonjonjon**

How much latency would I expect trading via IBKR?

---

## 2023-09-18 13:47:05 - strategies channel

**liam**

It's not for strategy creation, think development / monitoring, so your first paragraph isn't relevant

---

## 2023-09-18 13:41:39 - general channel

**Peter**

Yes.



Betfairlightweight supports the Betfair API's listCurrentOrders, which delivers all orders (with a 1000 per page limit) irrespective of how you placed them. So your website bets can be filtered based on the absence of customerStrategyRef.



Flumine's `market.blotter.orders` will return all orders (including those placed on the website) for the specific market for which you're receiving an update. Note though that the orders delivered to a strategy's `process_orders` method, will be limited to orders for that specific strategy and so would not include your website orders.

---

## 2023-09-18 13:39:27 - strategies channel

**D C**

OK thanks for a more detailed explanation. I can see that there must be a lot more to it and maybe how you determine 100% match is specific to each strategy (for example, if I back everything at 1000-1 and assume it matches I will be winning on a simulation).



I can also see how it might be useful for pre-start betting but still struggle with inplay because every back bet placed inplay (that is left to run) will almost certainly be matched for all losers, but the same can't be said of losers in pre-off markets. I guess I need to do some deeper thinking.

---

## 2023-09-18 13:34:26 - general channel

**Peter**

The market recorder provides the changes to the market only in a raw format. To see the actual state of the market you would run this through Flumine which creates and maintains an internal record of the state of the market as it would be after each update and makes it available to your trading strategies.



No the sample for the live event doesn't save the data to a local file. But once you have the data and have decided in which data and in what format, writing it out to a file is the easy bit. One tip for doing that would be to ensure that you record the time that the data is received, so that you can match that with the market data later.



It's easier to run separate scripts to collect event and market data. especially as the market recorder is already written for you. But there will come a point at which you want to be able to collect both together in order to make trading decisions and place bets. So it's worth working out how to do that early. If you're looking at external sources of data, you'll want to look at how Flumine supports works and middleware. These can be very useful for polling external data sources and merging event data with market data (via the market.context attribute) and feeding it to your trading strategies. There's not an easy way to answer the "how?" part of this as it depends a lot on how your accessing event data and how you plan to use it in your trading strategies.

---

## 2023-09-18 13:11:15 - strategies channel

**liam**

You can also use it see if a drop in pnl over time is due to matching / model performance / market

---

## 2023-09-18 11:11:48 - strategies channel

**D C**

Yeah I am trying the linear model type approach using very similar explanatory variables - simply because it is easy to get predicted results (one of the reasons I don't like ML - getting the predicted values out of the black box when you don't use python). Accuracy could be better but I think it will be good enough - particularly given how much variation you get in when betfair decide to throw the market inplay anyway.

---

## 2023-09-18 10:53:16 - strategies channel

**D C**

I still don't quite get it [@U016TGY3676](@U016TGY3676) - if I decided that my strategy was just to lay at the best back price and back at the best lay price, assuming a 100% match rate is going give me large simulated profits. I really feel I am missing something here.

---

## 2023-09-17 18:13:50 - general channel

**Riccardo Fresi**

thanks!

i runned the market recorded, even if i need to understand better the output json (not so clear to me)

tha sample for event live event does not save anything to local file right? i have to implement that in the strategy?

is it better to run different script with different strategies or the tool foreseen to run different strategies' if yes, how?

---

## 2023-09-17 16:37:06 - strategies channel

**birchy**

[@UUE6E1LA1](@UUE6E1LA1) You're absolutely right, a strategy that lays all runners at 1.01 would clearly make a profit with 100% match rate. All of my stuff is very close to the spread, i.e. within a couple of ticks so assuming a higher match rate gives an indication of where my bets are vs the 'true' price.

MC simulation takes a similar approach, where it assumes your bet price was the 'true' price.

---

## 2023-09-17 15:15:41 - strategies channel

**D C**

What do you mean by "assume a 100%" match rate [@U016TGY3676](@U016TGY3676)? Surely we could fabricate any strategy that is "profitable" if we assume that? What am I missing?

---

## 2023-09-17 12:52:52 - general channel

**Andy B**

Hi All, I have a question about whether it is possible to place a PLACE bet, while placing a WIN bet.  The scenario I am trying to figure out is a strategy where the criteria for a WIN bet is fulfilled and the bet is placed, but I also then want to place a PLACE bet.  I know the market_id values are different, but if I know the market_id and selection_id for the PLACE market, is it possible to return the runner.ex.available_to_back[0]['price'] value from the PLACE market while still processing the WIN market?  I only want to place a PLACE bet if I have successfully placed a MarketOnClose bet for the WIN.

Sorry if that seems garbled, I do suspect I am not thinking about the right way to go about this, but I have been going in circles all day trying to figure out the right execution strategy.

---

## 2023-09-17 12:27:40 - general channel

**Peter**

The exposures are evaluated against the strategy-market-runner-handicap combination so yes, it's correct to set them for the individual strategy.



They don't really over-ride other code. They're used as parameters by the trading controls when order placement is assessed.



I'd recommend looking at your logs, since each time they prevent an order being placed an order violation with explanatory message is logged.

---

## 2023-09-17 10:11:45 - general channel

**PeterLe**

Morning,

I noticed i had some STRATEGY_EXPOSURE errors  yesterday (This is a new strategy; I was expecting a lot more bets to be placed than it did)

I have a number of strategies all running on a single system...

Each one of which is run from the command line...

The code at the bottom of each strat is like so:



`strategy = Sub6(`

    `name="WIN",`

    `market_filter=betfairlightweight.filters.streaming_market_filter(`

        `event_type_ids=["7"],`

        `country_codes=["GB", "IE"],`

        `market_types=["WIN"],`

    `),`

    `max_order_exposure=50,`

    `max_selection_exposure=100,`

    `max_trade_count=5000,`

    `max_live_trade_count=8`

`)`

`framework.add_strategy(strategy)`



`framework.run()`



I can also see that we also have these settings in strategy.py too :



 `def __init__(`

        `self,`

        `market_filter: Union[dict, list],`

        `market_data_filter: dict = None,`

        `sports_data_filter: List[`

            `str`

        `] = None,  # 'raceSubscription', 'cricketSubscription'`

        `streaming_timeout: float = None,`

        `conflate_ms: int = None,`

        `stream_class: Type[BaseStream] = MarketStream,`

        `name: str = None,`

        `context: dict = None,`

        `max_selection_exposure: float = 15, # 15`

        `max_order_exposure: float = 2,`

        `max_trade_count: int = 1000,`

        `max_live_trade_count: int = 15,`

        `multi_order_trades: bool = False,`

    `):`



So my question is: Am I correct in setting the exposures in the individual strategy files and if so, do these setting take precedence/over ride over any other areas of code?

Thanks in advance

---

## 2023-09-16 13:10:32 - strategies channel

**birchy**

I have a couple of strategies that are basically churners which are in the 5% - 10% range when run through the MC sim. My 'best' strategy is &lt; 0.1% and zero if I feed it &gt; 2000 bets. FYI, setting the sim count &gt; 10K doesn't make much difference other than it takes longer to run.

---

## 2023-09-16 12:08:22 - strategies channel

**mandelbot**

I have a strategy that I've run a monte carlo sim on (thanks to [@U016TGY3676](@U016TGY3676) for sharing the code). It gets beaten by monte carlo around 6% of the time. (~1700 low odds lay bets). Does this sound like a viable strategy or not enough info?

---

## 2023-09-16 08:39:54 - random channel

**Mo**

There's the [https://betcode-org.github.io/faq/|FAQ](https://betcode-org.github.io/faq/|FAQ) but personally I think some kind of getting started in your "career" document is missing from the betcode resources. Not just how do you get started running a strategy in flumine but how do you get started setting up all of the processes you will need. Feel free to get started on this as you continue to make mistakes :wink:

---

## 2023-09-15 21:43:57 - random channel

**foxwood**

Maybe it's a case of "it aint broke" ? Could supply a `buffer_size` argument in the strategy constructor that feeds down into `MarketStream` to allow users to try their own buffer sizing - bit like the current `market_filter` ? That could provide some useful feedback as to what works best.

---

## 2023-09-15 10:47:22 - general channel

**Andy Bason**

It's a laying strategy which places multiple bets pre-off

---

## 2023-09-15 10:37:45 - general channel

**liam**

Perfect, flumine uses classes for your strategy creation, so get stuck in

---

## 2023-09-15 03:00:40 - issues channel

**Pramod S**

Hi I am trying to use flumine for getting data stream to get horse racing complete data for GB

While using sample code i am getting error



starting strategy 'ExampleStrategy'

Traceback (most recent call last):

  File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt;

    framework.run()

  File "C:\Python37\lib\site-packages\flumine\flumine.py", line 33, in run

    self._process_market_books(event)

  File "C:\Python37\lib\site-packages\flumine\baseflumine.py", line 151, in _process_market_books

    market = self._add_market(market_id, market_book)

  File "C:\Python37\lib\site-packages\flumine\baseflumine.py", line 204, in _add_market

    self.markets.add_market(market_id, market)

  File "C:\Python37\lib\site-packages\flumine\markets\markets.py", line 21, in add_market

    if market.event_id:

  File "C:\Python37\lib\site-packages\flumine\markets\market.py", line 133, in event_id

    return self.market_book.market_definition.event_id

AttributeError: 'NoneType' object has no attribute 'event_id'

---

## 2023-09-14 10:39:02 - issues channel

**liam**

Can you share the logs from this:



```# setup logging

logging.basicConfig(level=logging.DEBUG)  # change to DEBUG to see log all updates



# create trading instance (app key must be activated for streaming)

trading = betfairlightweight.APIClient("/")



# login

trading.login_interactive()



# create stream

stream = trading.streaming.create_stream()



stream._connect()

stream.authenticate()```



---

## 2023-09-13 21:27:00 - issues channel

**Ke**

I'm backtesting the strategy with locally recorded market data. i have market data saved in *.gz and catalogue data saved in *.json.gz file. How to load both market data and catalogue data at the same time?

---

## 2023-09-13 18:15:19 - random channel

**Riccardo Fresi**

Already check this? [https://scikit-learn.org/stable/auto_examples/linear_model/plot_poisson_regression_non_normal_loss.html#|https://scikit-learn.org/stable/auto_examples/linear_model/plot_poisson_regression_non_normal_loss.html#](https://scikit-learn.org/stable/auto_examples/linear_model/plot_poisson_regression_non_normal_loss.html#|https://scikit-learn.org/stable/auto_examples/linear_model/plot_poisson_regression_non_normal_loss.html#)

---

## 2023-09-13 14:46:07 - general channel

**rob smith**

This is a basic question but I'm a self-taught beginner and can't work it out. I moved my scripts to a vps and they worked as normal for the first few days before returning a "ConnectionResetError: [WinError 10054] An existing connection was forcibly closed by the remote host" error at login. Betfair's support have asked me for the json request and the response. This is where I'm stuck. I'm using trading.login_interactive() to login. How do I get the json request/response? Thanks

---

## 2023-09-12 16:55:28 - general channel

**Kishore Kumar**

Hi I am new to Betfair APIs and flumine. I am trying to get list of events for today and using below. From response I am not getting total available liquidity for that event. Is there any parameter I need to pass to get that , or I need to get list_market_catalogue and sum all?

`trading.betting.list_events({"eventTypeIds":[2]})`

---

## 2023-09-12 14:08:11 - issues channel

**Unknown**

Hi - a newbie question: I get an INVALID_APP_KEY error APINGException when trying to run trading.betting.list_event_types(). Any ideas here?

I think login is okay (can see session_token and expired=false)

Using python 3.10.6

---

## 2023-09-11 19:56:56 - random channel

**Jonjonjon**

Ha yes that's what I meant. My forecasting model has had a bad day.:disappointed:

---

## 2023-09-11 19:53:13 - random channel

**Jonjonjon**

Has there been anything unusual about today's racing? My models have behaved very strangely

---

## 2023-09-11 09:30:22 - general channel

**D C**

Yeah charging for the API was something I couldn't believe when I first heard about it. Feels like pure greed - same with charging for historical data. I can't understand creating obstacles to automation like that - I remember when I first started dabbling with automation years ago I would lose hundreds of quid on a new strategy while ironing out the bugs. Probably says more about my slapdash approach to things back then but I can't be the only one who has lost more than £299 learning the hard way along the way.

---

## 2023-09-11 09:18:36 - general channel

**D C**

Yeah makes no sense at all. The feed as it was offered must still exist and presumably is how Betfair access it (emphasis on presumably). I can understand them offering a price tiered subscription model integrated with OTS trading software but removing the option for the raw feed at the same time sounds like throwing money away.

---

## 2023-09-09 19:48:57 - general channel

**liam**

32gb? I average about 100mb per strategy

---

## 2023-09-08 21:33:43 - strategies channel

**Dave**

ahh okay, your 1045ms is total roundtrip, with 1000 being in-play delay, so 45ms includes: (book recv latency + trading logic latency + order submission latency + ack latency), so your actual reaction time to the market book tick may well be single digit ms (which is what I am measuring, i.e. how long between book publish time and triggering an order to Betfair).

---

## 2023-09-08 20:55:40 - strategies channel

**Dave**

That's correct Liam, I am computing as (time.time()*1e3 - book.publish_time_epoch). I'll double check my clock and make sure it's not behind for some reason. I am sure I am trading on fewer events though which could explain it (and possibly simpler logic). Possible dumb question: I assume you have n flumine instances running a number of strategies each - even though your machine's CPU may not be saturated, have you looked at latency impact of just splitting one of those instances across two boxes (i.e. cheap way to truly parallelize with no GIL in the way)?

---

## 2023-09-08 12:55:20 - general channel

**Alejandro Pablos Sánchez**

Hello everyone ! I'm working on my project and I got a couple of questions. First, before placing an order for the MATCH_ODDS market for instance, I like to check the trading price for a given runner. However, I do this via the _last_price_traded_ attribute of the corresponding runner, and I think that I'm getting its corresponding LAY price instead of the BACK one, which is the one I would like to get. How could I get the BACK one? Any clue? 



And another thing, say I wanna bet a selection with size 20€ at a price of 1.70€ but there are 15€ available to match at higher price (1.75€ for instance) and 10€ at 1.72€. Is there any way to set the matching process at the highest available possible and hence increase the initially planned price?  



Hope I made myself clear enough. Thanks for your help :innocent: !

---

## 2023-09-08 09:40:35 - strategies channel

**D C**

8-10 ms latency? Wow - I just looked at august and the lowest latency I had was 1045 milliseconds (inplay horses). However, I measure mine from time the order is created by a strategy, to the time that I receive the bet on the order stream. I place with the async flag and the lowest latency I have on the placement is 20ms. My SQL is quite basic and I am not familiar with how to extract the median.

---

## 2023-09-08 09:30:11 - issues channel

**Riccardo Fresi**

copy from example, but the while at the end

```# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# create trading instance (app key must be activated for streaming)

trading = betfairlightweight.APIClient(BETFAIR_USER, 

                                       BETFAIR_PASSWORD, 

                                       app_key=BETFAIR_APPKEY, 

                                       certs=CERT_PATH, 

                                       locale='italy')



# login

trading.login()



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)



# create stream

stream = trading.streaming.create_stream(listener=listener)



# create filters (GB WIN racing)

market_filter = streaming_market_filter(

    event_type_ids=["7"], country_codes=["GB"], market_types=["WIN"]

)

market_data_filter = streaming_market_data_filter(

    fields=["EX_BEST_OFFERS", "EX_MARKET_DEF"], ladder_levels=3

)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



# start stream in a new thread (in production would need err handling)

t = threading.Thread(target=stream.start, daemon=True)

t.start()```

same error



```INFO:betfairlightweight.streaming.listener:[Register: 1]: marketSubscription

INFO:betfairlightweight.streaming.stream:[MarketStream: 1]: "MarketStream" created

Exception in thread Thread-5 (start):

Traceback (most recent call last):

  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.1520.0_x64__qbz5n2kfra8p0\Lib\threading.py", line 1038, in _bootstrap_inner

    self.run()

  File "C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.1520.0_x64__qbz5n2kfra8p0\Lib\threading.py", line 975, in run

    self._target(*self._args, **self._kwargs)

  File "C:\Users\riccardo.fresi\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\betfairlightweight\streaming\betfairstream.py", line 67, in start

    self._read_loop()

  File "C:\Users\riccardo.fresi\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\betfairlightweight\streaming\betfairstream.py", line 226, in _read_loop

    received_data_raw = self._receive_all()

                        ^^^^^^^^^^^^^^^^^^^

  File "C:\Users\riccardo.fresi\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\betfairlightweight\streaming\betfairstream.py", line 256, in _receive_all

    raise SocketError(

betfairlightweight.exceptions.SocketError: [Connect: 2]: Connection closed by server```



---

## 2023-09-08 09:04:11 - issues channel

**Riccardo Fresi**

from here everything ok

```logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# login

trading.login()

# create queue

output_queue = queue.Queue()

output_queue

# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)

listener

# create stream

stream = trading.streaming.create_stream(listener=listener)

stream

# create filters (GB WIN racing)

market_filter = streaming_market_filter(

    event_type_ids=["1"]#, country_codes=["GB"], market_types=["WIN"]

)

market_data_filter = streaming_market_data_filter(

    fields=["MATCH_ODDS"], ladder_levels=3

)

# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)

# start stream in a new thread (in production would need err handling)

t = threading.Thread(target=stream.start, daemon=True)```

INFO:betfairlightweight.streaming.listener:[Register: 1]: marketSubscription

INFO:betfairlightweight.streaming.stream:[MarketStream: 1]: "MarketStream" created



from here i got the warning message

```t.start()```

after that the line "market_books = output_queue.get()" is endless

```streaming_unique_id = stream.subscribe_to_markets(

        market_filter=market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=1000,  # send update every 1000ms

        initial_clk=listener.initial_clk,

        clk=listener.clk,

    )

# check for updates in output queue

while True:

    market_books = output_queue.get()

    print(market_books)



    for market_book in market_books:

        print(

            market_book,

            market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

            market_book.streaming_update,  # json update received

            market_book.market_definition,  # streaming definition, similar to catalogue request

            market_book.publish_time,  # betfair publish time of update

        )```



---

## 2023-09-07 17:01:43 - strategies channel

**thambie1**

I have all three strategies currently deployed for various models/situations. #3 is ideal but takes more effort, #1 is second best and is super easy, #2 for when the loss is too little to be worth adapting your strategy for.

---

## 2023-09-07 16:49:11 - strategies channel

**Unknown**

Say you have a model that you are happy with for the most part but falls off at the extremes....do you

---

## 2023-09-06 12:07:35 - general channel

**AI Trader**

[@U4H19D1D2](@U4H19D1D2), does bflw allows the creation of a historical stream using multiple files? To simulate the strategy running in multiple markets? It seems like the function create_historical_stream only takes a file_path, not multiple as input. Thanks again

---

## 2023-09-06 09:47:38 - general channel

**D C**

I hope you are right Michael. From memory, the white paper states a non-invasive credit check would be made on as little as a £150 loss over 24 hours or £1K across 30 days (might have those figures wrong I am going from memory).

I share your sentiment about not taking people's last penny but people with a problem (the people that these changes are supposed to protect) will still gamble. I say that as someone who was once very close to having a serious gambling problem, who even took out payday loans at times to bet, and was a cigarette paper's width from having to get an IVA due to using credit cards to gamble. Based on my own betting patterns I know for a fact that you can spot a certain type of problem gambler just from deposit + bet patterns. Bookies and casino's have known this for ages (if not they are criminally stupid) but were too greedy for too long. I still find it unbelievable that these morons at the GC think their proposed measure will do anything other than relocate the problem.

---

## 2023-09-06 09:36:13 - general channel

**Mo**

On what basis did you decide:



1. You needed one VM per strategy

2. You needed that particular type of VM (which must be quite well resourced to be costing you that much per month)

---

## 2023-09-06 08:15:07 - general channel

**Steve**

Hi, I've been remotely hosting a python script for a little while. I use Azure which has been costing me circa $180AUD (90 Pound, $115USD) a month per virtual machine. I run each strategy I have on a different VM, and these costs have been prohibihiting me from trading some of my more marginally profitable strategies. Are other people paying something similar? And does anyone have some advice for how I can remotely host some python scipts (with access the certs that BF requires) in a cost effcient manner?

---

## 2023-09-05 21:12:23 - strategies channel

**Dave**

Does anyone measure their trading latency? If anyone is willing to share, I'm particularly interested in (order_submit_time - book_publish_time), separately for pre-play and in-play. :slightly_smiling_face:

---

## 2023-09-05 12:02:43 - betconnect channel

**Mo**

```settled_bets = api_client.betting.my_bets(side=betconnect.BetSide.BACK, status=betconnect.BetRequestStatus.SETTLED, limit=1000).bets

problem_bets = pd.DataFrame(

    {

        "price": bet.price.price,

        "matched_stake": bet.matched_stake,

        "profit": bet.profit,

        "correct_profit": correct_profit

    }

    for bet in settled_bets

    if bet.matched_stake &gt; 0 

    and bet.profit != (correct_profit := int((Decimal(bet.price.price) - 1) * bet.matched_stake))

)

ok_bets = pd.DataFrame(

    {

        "price": bet.price.price,

        "matched_stake": bet.matched_stake,

        "profit": bet.profit,

        "correct_profit": correct_profit

    }

    for bet in settled_bets

    if bet.matched_stake &gt; 0 

    and bet.profit == (correct_profit := int((Decimal(bet.price.price) - 1) * bet.matched_stake))

)```

problem_bets:

```  price  matched_stake  profit  correct_profit

0  2.40            500     200             700

1  5.75            500    1875            2375

2  4.30            500    1150            1650

3  2.45            500     225             725

4  4.50            500    1250            1750

5  5.33            500    1666            2165```

ok_bets:

```    price  matched_stake  profit  correct_profit

0    2.50            500     750             750

1    2.00            500     500             500

2    3.70            500    1350            1350

3    3.40            500    1200            1200

4   1.909            500     454             454

5    3.25            500    1125            1125

6    2.00            500     500             500

7    3.60            500    1300            1300

8    4.50            500    1750            1750

9    5.50            500    2250            2250

10   2.60            500     800             800

11   4.50            500    1750            1750

12   5.25            500    2125            2125

13   7.50            500    3250            3250

14   5.50            500    2250            2250

15   3.20            500    1100            1100

16   4.60            500    1800            1800

17   3.10            500    1050            1050

18   7.50            500    3250            3250

19   3.20            500    1100            1100

20   6.50            500    2750            2750

21   7.00            500    3000            3000

22  2.375            500     687             687

23   4.50            500    1750            1750

24   2.50            500     750             750```



---

## 2023-09-05 11:10:09 - issues channel

**foxwood**

Still puzzling over this since had some more last night and it's not something I've noticed before so trying to understand the flumine/bflw jigsaw - seems to be some sort of timing/threading issue maybe or is it incorrect BF responses ? As previous post the order definitely has the status `EXECUTABLE` when `process_closed_market()` is called.. Looking at the logs more carefully I see an entry arising from `BetfairExecution._execution_helper()` as shown below. This has the status set to `EXECUTION_COMPLETE` immediately  - as would be expected for a "take" bet. Can anyone explain why therefore later messages variously show Pending or Executable and the order fails to pick up the matched status as returned by the execution helper even when the market is closed ? Confused lol.

`{"asctime": "2023-09-04 13:12:30,255", "levelname": "INFO", "message": "execute_place", "trading_function": "place", "elapsed_time": 0.21911835670471191, "response": {"customerRef": "51e793094b1c11ee9720020000008598", "status": "SUCCESS", "marketId": "1.217888463", "instructionReports": [{"status": "SUCCESS", "instruction": {"selectionId": 42320105, "handicap": 0.0, "limitOrder": {"size": 1.75, "price": 7.0, "persistenceType": "MARKET_ON_CLOSE"}, "customerOrderRef": "stratxxxxxxxx-139131223500362504", "orderType": "LIMIT", "side": "LAY"}, "betId": "319679639999", "placedDate": "2023-09-04T12:12:31.000Z", "averagePriceMatched": 7.0, "sizeMatched": 1.75, "orderStatus": "EXECUTION_COMPLETE"}]}, "order_package": {"id": "51e79309-4b1c-11ee-9720-020000008598", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x0000003CAC713370&gt;", "market_id": "1.217888463", "orders": ["139131223500362504"], "order_count": 1, "package_type": "Place", "customer_strategy_ref": "xxxxxxxxxxxxxxx", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}`

---

## 2023-09-04 14:09:54 - general channel

**Jorge**

Seems to be working. Does it only add orders from strategies with the same customer_strategy_ref as config.customer_strategy_ref?

---

## 2023-09-04 13:14:32 - general channel

**Jorge**

I'm trying to keep the state of my flumine Strategy after a restart. I'd like market.blotter.get_exposures(self, lookup=selection_lookup) to return exposures considering the previous Strategy. Is there any way of doing this inside flumine? Maybe saving market.blotter._orders and overwriting it after the restart?

---

## 2023-09-04 11:21:03 - general channel

**Jorge**

Ah, I found the [https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L154C13-L154C13|finish(self, flumine)](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L154C13-L154C13|finish(self, flumine)) function, so disregard my question :smile: (maybe worth to add it to the FAQ?)

---

## 2023-09-04 11:07:46 - general channel

**Jorge**

This is what I have tried, but got an error: `raise RuntimeError('cannot schedule new futures after shutdown')`



```    framework.add_strategy(strategy)



    try:

        framework.run()



    finally:

        log_error('Exiting. Canceling all open orders and saving state of the bot...')

        for market in framework.markets:

            for order in market.blotter:

                if order.status == OrderStatus.EXECUTABLE:

                    log_error('Canceling order {}', order)

                    market.cancel_order(order) ```

---

## 2023-09-04 10:37:20 - general channel

**Jorge**

Hi, I'd like my Strategy to cancel all open orders when stopping the script (i.e. Ctrl+C but also in case of a bug). Would you put this inside process_market_book() or is there a better place for it?



Also, I save the exposures per runner/market_id when the Strategy stops, so I could continue from there if I need to restart it.

---

## 2023-09-03 11:39:58 - strategies channel

**AndyL**

[@U05L8PZD2FM](@U05L8PZD2FM) yes, that's exactly the problem I was thinking about, trying to equate ML with a real world strategy, as you say it typically adapts to what us matched, and adverse selection is probably hard to model..?

I think I'll head down the optimization route, as i can see through my current backtesting workflow im probably not being very good at optimising 

Thanks

---

## 2023-09-03 11:34:09 - strategies channel

**Joe**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) possibly it depends how simple your strategy is, i've definitely improved things by putting an ML optimised filter on the output of existing strategies which is I think what you are suggesting. The problem comes if the strategy is adaptive / contextual placing multiple bets into each market contingent on previous bets placed / matched. I think most strategies are really like this right? Depend on real world info, market data, AND current position. You can't optimise such a strategy by filtering simple tabulated output data/bets since if you remove one bet then in reality your strategy wouldn't go onto place some others which you may want to keep.

---

## 2023-09-03 11:04:54 - strategies channel

**AndyL**

Thanks [@UQL0QDEKA](@UQL0QDEKA) [@U05L8PZD2FM](@U05L8PZD2FM) [@U4H19D1D2](@U4H19D1D2)

Yes, I have merged the race winner for W/L, and thus PnL.

So I think where I want to head, is I have a rough "Idea", but don't really know what variables might help make it more profitable (assuming it is to start with!)... So I was doing an initial simple baseline to understand the process... but then not sure I could equate having many many thousands of bets how you would use that in reality or refine it.

Your step by step is useful thanks [@UQL0QDEKA](@UQL0QDEKA) i've done some of the first few...

[@U05L8PZD2FM](@U05L8PZD2FM) I think I probably want to implement the basic Flumine strategy for my "idea", even though it maybe rough and ready and probably make it not too selective, and possibly not very profitable (or -EV)! Then run that through the Flumine simulator capturing CSV data for the bets, and to refine using ML what the dependent features are that would improve it?

I don't think going down the brute force, lots of hardware route sounds right for me.

---

## 2023-09-03 10:19:44 - strategies channel

**Unknown**

I was just looking at my code..

I dont know if this helps Andy (or hinders :grinning:) but these are the building blocks I used:



```# Load your dataset



# Histogram and Density Plot for 'X'



# Correlation Matrix considering only numeric columns



# Take a 100% random sample of the dataframe (Or reduced value to save time etc)



# Selecting features and target



# Handling any NaN values



# Splitting the data



# Training Random Forest model



# Making predictions



# Calculating Random Forest Accuracy



# Test set predictions and accuracy



# Feature Importance



# Confusion Matrix



# Initialize profit/loss tracking for all three strategies



# Lists to store profit/loss over bets



# Simple, SimpleSP and ML strategies



    # Simple Strategy



    # SimpleX Strategy



    # ML Strategy



# Plotting the Profit/Loss graph```

Re the matching rate as Liam mentioned, I know from real bets that I have a matching rate of 52% so i factored that in

Hope that helps? (Conscious Im new to this sort of thing, I hope Im not sending you down the wrong path, so Joe is worth listening to rather than me)

(PS I found the Correlation matrix worth looking at, its starts to get the old grey matter moving :grinning:)

---

## 2023-09-03 09:06:51 - strategies channel

**Joe**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) There are two different things going on.



If you are trying to learn a strategy or parameters for a strategy I would use ML on real back tests running real execution logic with simulated exchanges rather than try and regress a dependent 'win' or 'profit' variable against some independent vars in some tabulated data when doing the type of profit training you are talking about.



If you are trying to create a model that produces a win probability (that will later be used as a strategy input/signal) from some independent vars then simple logistic regression of tabulated data is fine.



If you want to go full deep learning on this then you can use ML to train the lot at once, i.e. all parameters of all signals plus all hyper/execution parameters, with real execution logic in a simulated exchange. But this does require fast software and lots of hardware.

---

## 2023-09-02 22:40:26 - strategies channel

**PeterLe**

Andy (given my VERY basic knowledge of ML) I think you need to initially add some more features into the ML, ie so, back, lay and LTP book etc ( you can use pandas to create these for you very easily) then create a simple strategy ( or something you are doing currently). You can the use this to learn about ‘feature importance’ … and that led me to an area I’d not thought about before (in hind sight it makes perfect sense now)

so I used this to explore and investigate things, it’s not a back test though and won’t replace flumine

---

## 2023-09-01 21:02:24 - general channel

**Peter**

Trying to use the rust-based betfair_data package. Sadly it barfs on the first line of each of the marketrecorder files that I feed it with the following (example) parse error:

`file: 1.217507712 err: (JSON Parse Error) invalid type: null, expected a borrowed string at line 1 column 25`



Example first line:

```{"op": "mcm", "clk": null, "pt": 1692873297553, "mc": [{"id": "1.217507712", "marketDefinition": {"bspMarket": true, "turnInPlayEnabled": true, "persistenceEnabled": true, "marketBaseRate": 5, "eventId": "32583319", "eventTypeId": "7", "numberOfWinners": 1, "bettingType": "ODDS", "marketType": "WIN", "marketTime": "2023-08-26T12:50:00.000Z", "suspendTime": "2023-08-26T12:50:00.000Z", "bspReconciled": false, "complete": true, "inPlay": false, "crossMatching": false, "runnersVoidable": false, "numberOfActiveRunners": 6, "betDelay": 0, "status": "OPEN", "runners": [{"adjustmentFactor": 46.361, "status": "ACTIVE", "sortPriority": 1, "id": 46821369}, {"adjustmentFactor": 19.97, "status": "ACTIVE", "sortPriority": 2, "id": 36503217}, {"adjustmentFactor": 15.785, "status": "ACTIVE", "sortPriority": 3, "id": 41122645}, {"adjustmentFactor": 8.596, "status": "ACTIVE", "sortPriority": 4, "id": 2507254}, {"adjustmentFactor": 6.617, "status": "ACTIVE", "sortPriority": 5, "id": 122409}, {"adjustmentFactor": 2.673, "status": "ACTIVE", "sortPriority": 6, "id": 26486375}], "regulators": ["MR_INT"], "venue": "York", "countryCode": "GB", "discountAllowed": false, "timezone": "Europe/London", "openDate": "2023-08-26T12:50:00.000Z", "version": 5406653488, "raceType": "Flat", "priceLadderDefinition": {"type": "CLASSIC"}}, "img": true}]}```

Anybody know how to work around this?

---

## 2023-08-29 20:23:51 - general channel

**Andrey Luiz Malheiros**

Hey guys.

Let's suppose I run 2 different strategies for the same markets within the same instance of Flumine, Strategy A and B, both in paper trade mode. Let's suppose I placed an order using Strategy A. If I later place a new order using Strategy B, does Flumine take into account the bet previously placed with Strategy A in the market to handle new bet?

---

## 2023-08-29 17:29:19 - general channel

**Riccardo Fresi**

Guys,

what's wrong on this function?

```def place_order(size, price, selection_id, trading, market_id, lay="LAY"):

    # placing an order

    limit_order = filters.limit_order(size=size, price=price, persistence_type="LAPSE")

    instruction = filters.place_instruction(

        order_type="LIMIT",

        selection_id=selection_id,

        side=lay,

        limit_order=limit_order,

    )

    place_orders = trading.betting.place_orders(

        market_id=market_id, instructions=[instruction]  # list

    )

    return place_order```

```U.place_order(1, 1.1, 1.217703269, trading, 4940266, lay="BACK")```

```APIError: SportsAPING/v1.0/placeOrders 

Params: {'marketId': '4940266', 'instructions': [{'orderType': 'LIMIT', 'selectionId': '1.217703269', 'side': 'BACK', 'limitOrder': {'price': 1.1, 'persistenceType': 'LAPSE', 'size': 1}}]} 

Exception: None 

Error: {'code': -32602, 'message': 'DSC-0018'} 

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}```



---

## 2023-08-29 17:24:09 - general channel

**AI Trader**

*Trading System*



Hi guys,

I wrote my own trading system using betfairlightweight to keep the stream connection. One of the issues I face sometimes is that I get the marketbook stream update before the order stream update. For instance, when I manually cancel an order thorugh the UI, I might not replace it because the marketbook update came before the order update. Have you guys had this issue? How did you deal with it (Other than tweaking the conflate) ?

---

## 2023-08-29 09:25:52 - general channel

**Matthew**

Which kind of metrics do you use for tracking how well is doing really your model against the market? I mean, a metric which is able to determine if the model is having some negative variance or if it is really performing bad. I know about looking at the profit at BSP, I wonder if there are other methodologies. Thank you :pray:  

---

## 2023-08-26 08:47:15 - general channel

**Riccardo Fresi**

Yes, still not sure if it is the theoretical right value, I got so far 4 options:

1. Uncertainty of single prediction based on prediction model

2. Uncertainty of whole model

3. Implicit probability based on odds (I.e shin method, here Mo have already posted something about that)

4. real probability based on historical prediction, cumulative calculus (not convinced at all)

I got all of this, but I miss there theory so I don’t know what is the best approach

---

## 2023-08-26 06:51:40 - general channel

**Alex A**

You probably want to use the uncertainty, which should be associated with that individual prediction, not with the model as a whole.

---

## 2023-08-25 15:10:07 - general channel

**Riccardo Fresi**

y_pred are my forecasted data, a list of value [true,false,false,true,false]

y_test are actual data, an other list of value for same events [false,false,false,true,false]

on this sample i got 4 on 5, so precision 0.8, that is also my model probability

---

## 2023-08-25 14:59:46 - random channel

**D C**

Maybe it should be added to Hilbert's list. Everything you say does seem sensible Mo, but there always seem to be more questions - like how do you adjust for volumes and number of bets placed? When model disagrees with market, you bet more, and in a longer event (4 mile chase versus 5 furlong sprint) you have more time to disagree. I do tend to analyse things by stratifying slightly by event type but still no idea if this is valid or not.



I can see why the likes of Buchdahl only focus on pre-off markets and relies on pinnacle closing lines to reach his conclusions.



I should probably stop thinking about it - it only serves to exacerbate my imposter syndrome.

---

## 2023-08-25 14:49:08 - general channel

**Riccardo Fresi**

i have implemented few ML prediction model with sklearn library (hope you know), this library set the model and run it splitting train set and test set, (X_train, Y_train, X_test, Y_test)

X_train, X_test, y_train, y_test = train_test_split(X, y, shuffle=True, random_state=43214)

model.fit(X_train, y_train)

then predict a new dataset of result, called Y_pred, based on X_test

y_pred = model.predict(X_test)

the precision is the % of correct Y_Pred on Y_test

precision = precision_score(y_test, y_pred)



I assume that the precision is equal to probality

---

## 2023-08-25 14:41:20 - general channel

**Riccardo Fresi**

also, i saw you post on goto_conversion, should i use that as input for kelly method? seems the one i need, i still not convinced to use my precision prediction value

---

## 2023-08-25 14:29:53 - random channel

**D C**

Yes I can see the sense in that. It again leads to numerous questions. For foorball, the game is 90 minutes (give or take injury time). But how about a tennis match of indeterminate duration? Similarly, how about uniformity of model performance with respect to time? I guess I am not expecting any answers, but every time I try to analyse things in a statistically sound manner I am always just left scratching my head when it comes to inplay.



As you say Mo, one prediction per event makes everything more simple but in truth I don't know where to start when it comes to open ended IP stuff.

---

## 2023-08-25 14:22:52 - random channel

**D C**

I find these methods interesting, but whenever I start digging into it I am always left confused about how you interpret things. For example, in Mo's linked competition entry, the entrant seems to take Brier score as their choice of metric for determining that their method is "better" than Shin, power etc.



I've seen lots of people talk about Brier but how is this affected by multiple "measurements" of an event? For example, is a Brier score still "valid" if it is calculated for all price changes on an event from opening show to closing price? I can see that it might be so in the case of monotonically increasing/decreasing odds but we all know that is never satisfied.  Similarly, can you use a Brier score for an in-play model where we have essentially a time series of updated probabilities?

If not, what other metrics are available for assessing your modelled probabilties in cases where we have longitudinal probabilties per event/participant pairing?



I'm very low tech in this regard and I basically use profit as the metric/justification that my price estimates are "good" (however you interpret that).

---

## 2023-08-25 14:13:55 - general channel

**Riccardo Fresi**

this seems intresting

• page 17 [http://www.eecs.harvard.edu/cs286r/courses/fall12/papers/Thorpe_KellyCriterion2007.pdf](http://www.eecs.harvard.edu/cs286r/courses/fall12/papers/Thorpe_KellyCriterion2007.pdf)

• [https://vegapit.com/article/numerically_solve_kelly_criterion_multiple_simultaneous_bets](https://vegapit.com/article/numerically_solve_kelly_criterion_multiple_simultaneous_bets)



---

## 2023-08-25 14:04:15 - general channel

**Riccardo Fresi**

separate football match, i mean, the balance is an input for kelly method, but it can't be the same, if the fraction to invest for 2 concurrent event is 0.8 i cannot invest 1.6  of my initial balance. so should i prioritize which event? the one with hyphotetical higher fraction the recalculate with this priority set and netting the balance for every step?

---

## 2023-08-25 13:48:28 - general channel

**Riccardo Fresi**

got the point, too risky, but we still talking on a almost certain odds, maybe can be reasonable to have a cap of the fraction, let me think about it;

now i'm running on sequential bet, how kelly should work on concurrent event, any ideas?

---

## 2023-08-25 12:33:37 - general channel

**Mo**

1. Use your prediction

2. Don't bet at full Kelly stake. Use a fraction such as one-half or one-quarter (I prefer the latter). Fractional Kelly protects you against uncertainty in your predictions and also greatly reduces volatility for only a relatively small cost in long term expected wealth

---

## 2023-08-25 10:53:41 - general channel

**Unknown**

hi guys, need some help



i implemented a kelly method function

```def kelly_method(odds):

    b = odds - 1

    p = 0.94 #0.9851668726823238  # precision value for prediction model or historical win rate

    f = ((odds * p) - 1) / b

    return odds, b, p, f```

i have some doubt: p should be the % winning probability of the bet, i'm not sure to use the precision of model or the ex-post % based on actual historical results



in the first case i have a very bad performance

in the second case, not so bad;



by the way also the function give me negative results if the odds has more implicit probability respect the p variable (it makes sense to you?) so i use a 0.5 fixed for negative value (it also make sense to you?)



Other thing: the one i've loss, i suspect that i collect very bad the live odds for this single event, may i ask you if you can send me the historical data for that since seems in italy we cannot retrieve historical data? of course if is not a problem

---

## 2023-08-25 02:32:39 - issues channel

**Rishab**

Hi all! Question regarding execution in flumine. I'm trying to backtest my strategy using fluminesimulation and stuck with how orders are executed. Market for a runner was at 1.65-1.66, I had a limit order @1.66 for 186. In the next tick market moved to 1.66-1.67 &amp; actual volume traded in market was 245.82 &amp; I got a fill @1.66 for 122 size. Firstly, how does flumine allocates size in case market moves through your price? 2. I changed the profit variable in the LoggingControl(the one available on git)  simply with order.profit as with the usual one was giving profit variable as 0 for all the orders &amp; this change actually worked. But for the order described above it assumes that I got full(186 size) fill &amp; then calculates the PnL.

---

## 2023-08-24 18:08:33 - strategies channel

**Riccardo Fresi**

i use this self-made function, maybe can help, or improved

```def get_statistics(in_play_only=None):

    for event_type in Calcio_event_type_id:

        # prints id, name and market count

        #print(event_type.event_type.id, event_type.event_type.name, event_type.market_count)

        calcio_id = event_type.event_type.id



        # list of events

        event_list = trading.betting.list_events(

            filter=filters.market_filter(

                event_type_ids=[calcio_id], # filter on just football

                in_play_only=in_play_only,  

                #market_countries=["IT"],  # filter on just GB countries

                # market_type_codes=["WIN"],  # filter on just WIN market types



            ), locale="IT"

        )[:10]  # Seleziona solo i primi 10 elementi della lista

        

        combined_runner_dict = {}  # Dizionario per memorizzare i dati dei runner fusi

        for event in event_list:

            #print(event.event.id, event.event.name)

            inplay = trading.in_play_service.get_event_timeline(event_id=event.event.id)

            

            market_catalogues = trading.betting.list_market_catalogue(

                filter=filters.market_filter(

                    event_type_ids=[calcio_id],  # filter on just football

                    event_ids=[event.event.id],

                    # market_countries=["GB"],  # filter on just GB countries

                    market_type_codes=["MATCH_ODDS"],  # filter on just WIN market types

                ),

                market_projection=[

                    "COMPETITION",

                    "EVENT",

                    "EVENT_TYPE",

                    "MARKET_START_TIME",

                    "MARKET_DESCRIPTION",

                    "RUNNER_DESCRIPTION",

                    "RUNNER_METADATA",

                ],  # runner description required

                max_results=10, locale="IT",

            )

            #print("%s market catalogues returned" % len(market_catalogues))

            for market_catalogue in market_catalogues:

                #print(market_catalogue.market_id,

                    #market_catalogue.market_name,

                    #market_catalogue.market_start_time,)

                

                for runner in market_catalogue.runners:

                    #print(runner.selection_id, runner.runner_name, runner.handicap)

                    if inplay.status:

                        

                        runner_data = combined_runner_dict.setdefault(f"{market_catalogue.market_id}_{runner.selection_id}_{inplay.time_elapsed}",{})

                        runner_data["event_id"] = event.event.id

                        runner_data["event_name"] = event.event.name

                        runner_data["market_id"] = market_catalogue.market_id

                        runner_data["market_start_time"] = market_catalogue.market_start_time

                        runner_data["selection_id"] = runner.selection_id

                        runner_data["runner_name"] = runner.runner_name

                        runner_data["handicap"] = runner.handicap

                        market_books = trading.betting.list_market_book(

                            market_ids=[market_catalogue.market_id],

                            price_projection=filters.price_projection(

                            price_data=filters.price_data(ex_all_offers=True)

                            ), locale="IT",

                        )

                        for market_book in market_books:

                        #print(market_book.market_id,

                            #market_book.inplay,

                            #market_book.status,

                            #market_book.total_matched,)

                            for runner in market_book.runners:

                            #print(runner.selection_id, runner.status, runner.total_matched, runner.last_price_traded)

                                runner_data = combined_runner_dict.setdefault(f"{market_catalogue.market_id}_{runner.selection_id}_{inplay.time_elapsed}", {})

                                runner_data["selection_id"] = runner.selection_id

                                runner_data["total_matched"] = runner.total_matched

                                runner_data["last_price_traded"] = runner.last_price_traded

                                runner_data["Status"] = market_book.status

                                

                                #runner_data = combined_runner_dict.setdefault(f"{market_catalogue.market_id}_{runner.selection_id}_{inplay.time_elapsed}", {})

                                runner_data["Home Score"] = inplay.score.home.score

                                runner_data["Away Score"] = inplay.score.away.score

                                runner_data["Home Corners"] = inplay.score.home.number_of_corners

                                runner_data["Away Corners"] = inplay.score.away.number_of_corners

                                runner_data["Time Elapsed"] = inplay.time_elapsed

                                runner_data["Match Status"] = inplay.in_play_match_status

                                

                                

                                available_to_back = runner.ex.available_to_back

                                available_to_lay = runner.ex.available_to_lay

                            

                            

                            

                                combined_runner_list = list(combined_runner_dict.values())

        if combined_runner_dict:

            df = pd.DataFrame(combined_runner_list)  

            #df.sort_values(by=['event_id'], inplace=True)    

        else:

            df = pd.DataFrame()  # Create an empty DataFrame

            #trading.race_card.login()

            #race_cards = trading.race_card.get_race_card(market_ids=[market_catalogue.market_id])

            #results = trading.race_card.get_race_result(market_ids=[market_catalogue.market_id])

            #print(results)

    

    return df ```

---

## 2023-08-24 14:41:55 - general channel

**Trex44**

Hey both. Thanks very much. I am actually a Flumine user (just not a good one). Had issues trying to build a strategy that logged data and had that other script bookmarked from a while back so went with it. I will try and implement the Flumin version. thanks very much for your help both of you.

---

## 2023-08-24 13:41:58 - random channel

**Unknown**

So this is the plot [@U4H19D1D2](@U4H19D1D2) in conjunction with this info...

Validation Accuracy: 0.8703854015340546

Test Accuracy: 0.8699371399724771

Total Profit/Loss using Simple strategy: £26015.709999999857

Total Profit/Loss using ML strategy for X : £25605.64000000001

The interesting thing is when this was printed out initially, it looked like the ML model wasnt as good as the simple strat.

That's not the case though as you will see the ML beat the simple strat for the same number of bets.

I found that the partial dependence plot interesting two when I chose two random features.

I can see from that, that I'm in the right ball park area, with a bit of tweaking

My initial thoughts now are to maybe create another CSV for a different month of data to see if the feature importance is similar for both months.

Then I will delve down a bit deeper into the feature importance and partial dependence.

Then Ill explore something ML related...

NB: Early on in this, I found something that I hadn't really considered for inplay before&lt; i left it out for this discussion (for obvious reasons) but keen to look deeper.

Anyway with that; Ill stop boring you all with this. I feel confident to take this further in the background and explore

if nothing else I've enjoyed my first venture into ML (even though the wife called me a 'geek' when I excitedly shown her how the 3D plot could pivot :joy:)

Just wanted to thank those who contributed in this thread and DM's cheers

---

## 2023-08-23 17:32:16 - random channel

**PeterLe**

Yep he plus version Foxwood

Ive just recoded to include the comments by Leo, results are:

Random Forest Accuracy: 0.9062742305480078

Total Profit/Loss using Simple strategy: £26007.66999999987

Total Profit/Loss using ML strategy for X 1.19: £22294.659999999945

             Feature  Importance

0  last_price_traded    0.116026

1               back    0.093928

2                lay    0.107229

3          back_book    0.206596

4           lay_book    0.203972

5           ltp_book    0.193442

6             Spread    0.075818

7     cross_matching    0.002990

(note: I found an error in my simple strategy :grinning: that why it was such a massive negative in previous text)

What is interesting now is that the ML seems to give a worse result :thinking_face:

---

## 2023-08-23 15:53:18 - random channel

**PeterLe**

[@U030GKBMCBF](@U030GKBMCBF) Just some feedback...

I asked chatgpt to comment on your suggestion in the context of my code...this is what is said ;



_The advice your colleague provided is quite accurate. Default feature importances from Random Forest models in scikit-learn can indeed be biased, particularly when the dataset includes different types of features (e.g., categorical and numerical). This bias might lead to incorrect conclusions about the importance of the features._

_In your code, you were using the default feature importance method by calling the `feature_importances_` attribute from the Random Forest model. This approach calculates feature importance based on the average depth at which each feature appears in the trees of the forest. While it is a common approach, it can be misleading._

_A more reliable way to assess feature importance is to use permutation importance. Permutation importance works by randomly shuffling the values of a single feature and measuring the resulting decrease in the model's performance. This decrease reflects the importance of that feature._



(provided some suggestions for code)



_This method will give you a more unbiased estimate of feature importance, taking into account the potential correlation between features and the different scales and types of features._

_Remember to remove or comment out the old code that calculated feature importance using `feature_importances_`._

_So, to answer your question, considering permutation importance would be an excellent improvement to your code, and it aligns with best practices in machine learning._



So spot on, thanks again :+1:

---

## 2023-08-23 14:24:14 - strategies channel

**George**

in the Kelly package (or elsewhere!) is there a way to do the numerical optimisation for simultaneous multiple mutually-exclusive bets in the same market?

---

## 2023-08-23 12:41:39 - strategies channel

**liam**

No easy abstraction in the strategy itself but I normally put the client in the `strategy.context`

---

## 2023-08-23 11:02:35 - random channel

**Joe**

These are two quite different tasks, 1) optimise strategy parameterisation using ML and 2) generating new strategies using ML, I'm not going to discuss 2 as it is vast topic and I've used many different approaches from simple recurrent networks to genetic programming.



Task 1 however is easier to describe. You have a set of (many 1000s of) markets with supporting data, M. You have a strategy S (m, p) that takes a single market's data m and p parameters and returns a profit. S is just conditional logic and state (e.g. its current position), p are the parameters of that logic (e.g. the 'x' in if (price &lt; x) ). Your goal is to find p that maximises something you want, we'll use profit here but in reality you'll want to fiddle with this. The complexity is you (usually) cannot label up all the data in M with a dependent variable "should_i_bet", if you can then easy - simple classification problem solvable through any supervised ML procedure, however in almost all cases you cannot since the answer to "should_i_bet" is infact what we are searching for.



A way around this is currying the above into a new function F (p) = C(S, M) which returns the total profit when S is run over the full set of markets M with params p.



We can now use brute force, or preferably some guided brute force (unsupervised ML) to find p that maximises profit.



We do the usual train / test split on the data, and start searching for p with an appropriate search algorithm, I would suggest particle swarm optimisation as a simple starting point. I don't use python but there will definitely be implementations of PSO available.



So we effectively execute

``` MTrain, MTest = split(M)

 FTrain = C(S, MTrain)

 FTest = C(S, MTest)

 p = PSO.search(Ftrain, Ftest) ```

So that is one way to do it, there are many others but which is right depends completely on how you phrase/frame the problem you are trying to solve. The obvious drawbacks of this approach are 1) you need a strategy to optimise, 2) there are many tricks that are needed to avoid overfitting / curse of dimensionality, 3) you need to quite a lot of hardware, code and data optimisation to get the execution frequency required for this type of ML.



One implication of rephrasing an existing strategy for this type of search is you may find other applications of it. Imagine the profit surface wrt p looks like the Alps. You have manually tweaked p over the years and are squarely centered on Mont Blanc. With a bit of ML guided search with some diversity forced into the mix, you maybe able to find p for other profit peaks such as the Matterhorn or Finsteraarhorn. What you have now achieved is not an ensemble but a set of independent profitable strategies.

---

## 2023-08-23 09:35:27 - random channel

**PeterLe**

For X, Think of something that makes sense/logical (or gut feel). then branch out and see where it takes you

By the way, I recorded he following in my CSV:





```def process_market_book(self, market, market_book):

    with open(self.file_directory, "a") as f:

        writer = csv.DictWriter(f, fieldnames=HEADERS)

        for runner in market_book.runners:

            writer.writerow(

                {

                    "market_id": market_book.market_id,

                    "publish_time": market_book.publish_time,

                    "status": market_book.status,

                    "inplay": market_book.inplay,

                    "selection_id": runner.selection_id,

                    "last_price_traded": runner.last_price_traded,

                    "back": get_price(runner.ex.available_to_back, 0),

                    "lay": get_price(runner.ex.available_to_lay, 0),

                    "sp": runner.sp.actual_sp,

                    "cross_matching": market_book.cross_matching,

                    "runner_matched": runner.total_matched,

                    "venue": market.venue,



                }

            )```

and I included SP and Runner Matched in the features of the ML. For my  Inplay strat it rated SP and Runner Matched of high importance using ML, which is what you would expect. This gave me some confidence that the model was working as intended.

PS looking at the CSV header you posted I think you need to add more stuff in there as a minimum back book, lay book, Back,lay and LTP etc

---

## 2023-08-22 22:30:18 - random channel

**AndyL**

Doh, penny dropped finally!

So a Random Forest Classifier, is for "classifying" groups as best as possible,  so you need to have a strategy to start with say "X", which says makes £1000, and you can then train a RFC to optimize the "X" entry points for "profit". So once you have trained your RFC, when using "live", rather than doing "X", you simply ask "RFC" will the entry here be profitable? Yes or No ? .... and with a bit of luck you may end up with £2000 !

Right, so I just need to find a decent "X"......!

---

## 2023-08-22 21:55:52 - random channel

**AndyL**

Thanks [@UQL0QDEKA](@UQL0QDEKA) so yeah the programming i'm good with, my head is just missing some part of the "workflow" here, I think i'm nearly there with your help above.

So in my huge data.csv, i've got something like:

```market_id, selection_id, secToStart, lay_price, winner, P/L

1.1111,    1023,         -12.1,      1.08,      False,  £1

1.1111,    1023,         -12.2,      1.06,      False,  £1

1.1111,    1023,         -12.3,      2.46,      False,  £1

...```

The "classifier" is basically going to tell me "when to place the bet" ?

So I don't see how from above the ML is going to work out when to place a bet?

Don't you need a running cumulative P/L ?

The end goal is when I run this "model" over a dataset, it achieves the best net Profit having made a decision of "when to place a bet" over all the markets.

My head is still missing what it's trying to tell me!

I'm going to ask ChatGPT again!

---

## 2023-08-22 21:08:42 - random channel

**PeterLe**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) I started out by learning how to create the CSV  (using the price recorder) into Pandas DF's etc. (I know you are much more accomplished than me in terms of programming by the way)

The added in a couple more columns to include winner, P/L Sum of the books etc

I then started with something simple like regression

And then a random forest (ive only got the estimators set low for the time being)

I have two strats one a simple one and one an ML. They both use the same parameters eg, if the simple strat has a condition tha says back &lt; 10 then so does the ML.

to answer your question - Kind of :grinning: (remember we all do things differently and I know next to nothing about this) You need to have a 'Target'.  In my case I chose the target as 'winner' (from that you can determine whether you bet won or lost) Set up a value in the P/L column in your CSV based on say £1. if you dont have the CSV data (Which is every update) you need to get that up and running first (Lee helped me get this running, but is simple enough). use the price recorder against your recorded data (One month is plenty)

ChatGPT is great for this sort of thing it bootstraps your learning,

For your simple model just create something simple like lay the fav (in running) when X occurs. The ML will work it out for itself. The problem I had is understanding what the ML did so that I could employ that in my live stuff. Ive got some new stuff to look at now thanks to the earlier posts.

---

## 2023-08-22 19:42:10 - random channel

**Rishab**

So R2sq is a strictly increasing function wrt no. of features. So if u just keep on increasing features ur R2 will increase but ML models suffer from something known as curse of dimensionality. So Adjusted R2 takes this into consideration &amp; tells you the ideal point where the variance is balanced wrt to no. of features. To answer your second question ML models are generally complex in nature,  just with 4-5 features you can interpret a RF using the tree but can't do the same for a large number of features. I think in general you can't find exactly what the model is doing(i.e there are more complex model that combines various trees to make stronger models), but you can get a good feel for it by understanding the general working of the model, then using tools like feature imp., R2, confusion matrix etc

---

## 2023-08-22 19:14:03 - random channel

**PeterLe**

Thanks [@U02RN7YDRQ9](@U02RN7YDRQ9) yes I intend to split out certain things and test. Although I do know that the ltp book and lay book do have a bearing on results as Im running this  as a live strat

I agree, the differences between the two strat does look suspicious. The results were taken from one of the first tests I ran, as I progressed it looked more like this :



```# Total Profit/Loss using ML strategy: £9322.959999999966

# Total Profit/Loss using simple strategy: £2207.2800000000384```

It was interesting (and though provoking for me) to think that ML could turn a large losing strat into a positive? :thinking_face:

The data was split into two sets (80% training, 20% testing). there is no separate validation set in the code. Thanks for this, Ill edit to include this.

Train : 60%

Test: 20%

Validation ; 20%

(Would that look about right?)

Re PM: There is a slice of secret sauce in here :grinning:, come to he next meet up if you can, worth th trip :grinning:

[@U05KECSV68N](@U05KECSV68N) Thanks for the reply. Ive just read up on that...AmI correct in thinking that R-squared is more suited to regression models (Whereas the bit that gave me the most insight in the code was a RandomForset Classifier and that it may not be a great fit for that?)

By the way, Im not just going to use the regression and Random Forest, Im going to look at other methods too, its just as a learning exercise if nothing else.

My main questoin was, once you had an ML Model how do you then interpret whats happening in he background so you can incorporate those things into a live environment?

(This is all in play by the way)

---

## 2023-08-22 18:05:04 - random channel

**Rishab**

You can look at Adjusted R sq. to find out if adding another feature actually improves the model performance or not

---

## 2023-08-22 15:01:49 - random channel

**PeterLe**

In a similar post to the above, I was recently inspired by Joe at the meet up who talked a little about ML.

Im only just getting to grips with Python but thought Id have a stroll down the ML path to see what I could find. if you dont look you dont find :grinning:

These are the steps Ive taken so far but would welcome any thoughts as to my approach and whether Im going off course...(remember this is all new to me)

Steps :

Capture recorded data with Flumine.

Then use the PriceRecorder to extract certain features to a CSV (for about a month of racing UK /IRE)

Using this ;-



`import pandas as pd`

`import numpy as np`

`from sklearn.model_selection import train_test_split`

`from sklearn.ensemble import RandomForestClassifier`

`from sklearn.metrics import accuracy_score`



Then Loaded the data into a df...

Clean the data to remove NaN

Train a random forest classifier making predictions.

(I also wanted to plot  the partial dependence but having problems with the code for now...)



Then setup some features Im interested in ...(winner as a target)



`features = ['last_price_traded', 'back', 'lay', 'back_book', 'lay_book', 'ltp_book', 'Spread', 'cross_matching']`

`X = df[features].copy()`

`X['cross_matching'] = X['cross_matching'].astype(int)`

`X = X.fillna(X.median())`

`y = df['winner']`

`X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)`



`back_book_values = np.arange(1.19, 1.21, 0.01) # Just used a ouple here as a test..`



1.Then setup a simple system...

2.Then setup a system using an ML strategy...



...and determine the 'Feature importance' like so:

`feature_importance = random_forest_model.feature_importances_`

`feature_importance_df = pd.DataFrame({'Feature': features, 'Importance': feature_importance})`

`feature_importance_df = feature_importance_df.sort_values(by='Importance', ascending=False)`

`print(feature_importance_df)`



After running for a while I got the output like so:



# Random Forest Accuracy: 0.9120607771513096

# Total Profit/Loss using Simple strategy: £-193834.88816246387

# Total Profit/Loss using ML strategy for X 1.19: £17935.374273080262

# Random Forest Accuracy: 0.9120607771513096

# Total Profit/Loss using Simple strategy: £-193834.88816246387

# Total Profit/Loss using ML strategy for X 1.2: £17327.057237254136

# Random Forest Accuracy: 0.9120607771513096

# Total Profit/Loss using Simple strategy: £-193834.88816246387

# Total Profit/Loss using ML strategy for X 1.21: £16570.917359458937

# Best back_book value: 1.19, Profit: £17935.374273080262

#    Feature  Importance

# 3  back_book    0.209721

# 4   lay_book    0.203197

# 5   ltp_book    0.197272

# 2   lay    0.126964

# 0   last_price_traded    0.111824

# 1     back    0.082254

# 6     Spread    0.065538

# 7     cross_matching    0.003230



I can see that the ML strategy beats the simple strategy...and the back_book is the feature with the most importance...



So my question is: How do you uncover what makes the ML model significantly better?

Is it by looking at (and trying to understand the individual decision trees (a subset off)

Other things that seem relevant are a Partial Dependence Plot or form of Correlation Analysis?

What would the pro's suggest as a next step from the feature importance? Thanks in advance

---

## 2023-08-22 14:51:07 - random channel

**liam**

Yep, flumine is for live/simulation but when it comes to modelling/backtesting you want to get things into pandas

---

## 2023-08-22 13:10:00 - random channel

**liam**

Not a stupid question, easiest way is to create a flumine strategy which writes all the data to a csv (variables + W/L of runner etc) -&gt; load into pandas



[https://github.com/betcode-org/flumine/blob/master/examples/strategies/pricerecorder.py](https://github.com/betcode-org/flumine/blob/master/examples/strategies/pricerecorder.py)

---

## 2023-08-22 13:02:52 - random channel

**Newbie99**

A bit of a random dumb question, but I was looking at [@U4H19D1D2](@U4H19D1D2)’s thread on ML and there’s one (really basic) piece that confuses me.



Let’s assume I have a basic ‘model’ that obviously uses flumine recorded data for backtesting (which also takes place in flumine).



Let’s pretend the ‘model’ simply tries to back any runner where say VWAP * x &gt; best available back price (where x = a percentage set by me currently).



How can I ‘train’ my model, as the code is written for streaming data?



Do I have to re-write everything to look at a large Pandas/PySpark data frame with all the raw data?



I’m presuming not and I’m misunderstanding how it works, but it does confuse me as the examples I’ve seen all seem to take numpy arrays as inputs or Pandas data frames!

---

## 2023-08-22 10:48:31 - general channel

**Unknown**

Hi Guys,

i'm trying to figure out if is it possible to get an edge with a model prediction that predict a status SUSPENDED when is it OPEN, at the moment i collect no much data, unfortunately seems i cannot download histic data from italy so i have to collect from inplay.

this is the confusion matrix

the idea is to place an order when i predict suspended and it is still open (probably will be suspended in some moments), it make sense for you?

---

## 2023-08-21 17:43:04 - strategies channel

**AndyL**

Thanks, was expecting that. However, isn't aspects like "Running style", "pace", "race phase", all relevant as a "Variable" in these so called ML "Models" ?

---

## 2023-08-20 15:27:59 - general channel

**Y B**

*Context:* I'm trying to run a very simple strategy (always back the first runner at a certain level) on *basic* data (i.e. just last_price_traded without having access to order book depth). And my orders don't seem to ever get filled.

*Questions:*

• Is there anything that needs to be done to make orders get filled when backtesting on "basic" data?

• Is it even possible to get backtesting work on basic data? I'm fine with either assuming infinite depth at a certain level and/or some const value

• In basic data mode, if I place an order (back)  with "limit=X" 

    ◦ and currently the market (i.e. last traded price) is at A (A &lt; X)

    ◦ the next mkt data tick provides last traded price is at B (A &lt; X &lt; B) -- *will my order get filled?* 

---

## 2023-08-20 14:03:53 - general channel

**Y B**

Hi everyone, just getting started with flumine. Wondering how can I feed the market data from bz2 files downloaded from betfair into it?

```strategy = ExampleStrategy(

    market_filter={"markets": ["/tmp/marketdata/1.170212754"]}

)```

What exactly does the `markets` override accept?



is flumine capable of reading raw data as is or do I need to pre-process it by using e.g. [https://github.com/mberk/betfairutil](https://github.com/mberk/betfairutil)?

---

## 2023-08-20 12:45:47 - strategies channel

**AI Trader**

[@U4H19D1D2](@U4H19D1D2) If I understand correctly you are forecasting the WIN probability. This is a supervised classification problem. You can use any classification algo for the task (logistic regression, random forest, ...). What you said about the fact that there are way more loosers than winners might be very important. This has a name in ML: imbalanced classes. There are multiple ways to address this. One is oversampling, ie, just repeating the minority class (as I think you have done). Another technique is simply putting more importance in the classification of the minority classs. This can be achieved thorugh the  *class_weight = "balanced" parameter in RandomForestClassifier*.



Also, as people have mentionned, be careful with overfitting. The general idea in ML is to split your data in three groups: Train, Validation and Test. You use the train to train the model, the validation to test different hyperparameters, and the test to have an idea of the true accuracy of the model. This is extremely important for hyerparameter tunning in order to avoid overfitting.



Another important thing it to choose well the metric you are optimising. Just accuracy of the model alone is unlikely to be a good metric, especially if you size your bets based on probability. In that case I would suggest other metrics such as f1-score/auc.



I am happy to give more help if I can.

---

## 2023-08-19 00:11:10 - random channel

**river_shah**

Guys, what is the secret to this winning strategy?

---

## 2023-08-18 17:57:49 - issues channel

**Derek C**

I am slowly migrating stuff over to Flumine (from BFLW-based approaches). One issue I seem to have is that even when my market_data_filter specifies ladder_levels=5, the market_book has the whole ladder.



eg when I create the strategy I pass the following:





```market_data_filter=streaming_market_data_filter(

            fields=[

                "EX_ALL_OFFERS",

                "EX_LTP",

                "EX_TRADED",

                "EX_TRADED_VOL",

                "EX_MARKET_DEF",

            ], 

            ladder_levels=5,

    ),```

Yet  in market_book.runners[0].ex.available_to_back there are over 30 entries. What am I missing?

---

## 2023-08-18 11:42:35 - issues channel

**Peter**

Ah sorry. I suspect that there's a rather subtle 2nd requirement lurking in there, namely that the orders were created with the same customer_strategy_ref that you're using when you run Flumine. this ref is nothing to do with the Flumine strategy - rather it's the ref that Betfair recognises and by default is [https://github.com/betcode-org/flumine/blob/master/flumine/config.py|based by Flumine on your hostname](https://github.com/betcode-org/flumine/blob/master/flumine/config.py|based by Flumine on your hostname). So order created by other methods e.g. via the webUI won't get picked up. Not normally a problem when an instance of Flumine is restarted, but not helpful if your starting a fresh instance and want to pick up orders created by other methods.



To get around that I'd recommend tweaking the order middleware liked to earlier to remove the config.customer_strategy_ref filter and EXECUTION_COMPLETE filters, though you may experience side effects if Flumine needs to restart.

---

## 2023-08-18 10:36:18 - issues channel

**Peter**

Non-complete orders will come through in the order stream, and should show up in the blotter, but not in `process_orders` as that only handles orders for the strategy wrapping the method.

---

## 2023-08-18 09:44:12 - issues channel

**Harry Corrigan**

Would like to avoid using list_market_book as it's slower &amp; also don't want to have to keep making requests for orders made outside of strategy

---

## 2023-08-18 09:43:38 - issues channel

**Harry Corrigan**

Hi, how would i get orders made before application start with flumine, i want orders on the market irrelavent of if flumine made them or not sent into process_orders function on my strategy, is their any way to do this?

---

## 2023-08-17 22:33:21 - strategies channel

**George**

yes, it makes sense. I suppose as a human I was thinking, well, if I have multiple selections then probably it's more likely my model is wrong so i should be more cautious not more aggressive. but obviously that's not an input into the Kelly optimisation so I shouldn't have expected it to come out like that.

---

## 2023-08-17 22:15:50 - strategies channel

**George**

This evening I have been playing around with this fun tool: [https://www.sportsbookreview.com/betting-calculators/kelly-calculator/](https://www.sportsbookreview.com/betting-calculators/kelly-calculator/), using the Exclusive Outcomes option. I noticed something unexpected (to me, at least!).



If a bettor has two selections with expected positive value, they could calculate the Kelly stakes individually, as if the two bets were independent of each other, and place both bets. It might be a bit naive to do this, but of course it can be done. Let's call the wrongly-assumed-independent-Kelly stakes for the two runners: a1, and b1.



Then instead, if a bettor goes onto that website and uses the Kelly calculator for two bets using Exclusive Outcomes, they will be returned different (correct) Kelly stakes; we can call them a2 and b2.



I have been playing around comparing a1 with a2, and b1 with b2. To my surprise, I noticed that a2 &gt; a1, and of course b2 &gt; b1 also.



It seems that the conclusion is: if you have two selections with positive edge, you should bet MORE on each of them compared with if you had only had one selection. To me, that sounds counter-intuitive. Can anyone explain why this is?

---

## 2023-08-17 16:29:19 - random channel

**foxwood**

Had to install rust from [https://rustup.rs/](https://rustup.rs/) which was new to me. Numbers matched exactly - several thousand calls - shin output used in other calcs - identical down to 14 decimal places ! It was using `_optimise_rust` when I stepped it but no idea of speed difference since just used the new one as was for an existing strategy that uses the current release - not time critical for me.

---

## 2023-08-16 19:09:30 - general channel

**Frenkie**

Hi all, a newbie here. I am trying to go through the documentation of Flumine in order to deploy my own strategy, I wanted to check if there's any way to fetch my current exposure at each runner.

One way is for me to calculate this locally by tracking all my previous matchings but I wanted to know if there's any method/attribute that provides this, or how do you guys fetch this info?

---

## 2023-08-16 10:12:34 - general channel

**Michael**

Yeah, directly within the strategy. I do it within process_closed market, passing the market catalogue to the db write function and then writing to db from there. The DB is just storing the path and then certain parts of the market catalogue to help me filter during backtesting.

If you store the raw data and then process to db, do you not lose the ability to retrieve the market catalogue? Really, it doesn’t need to write to db instantly after the market is closed as long as it does it eventually

---

## 2023-08-16 06:00:10 - general channel

**liam**

How are you writing to the db? Within a strategy?



Common process is to store raw data using the market recorder and then process to db/csv etc 

---

## 2023-08-15 23:38:38 - general channel

**Rishab**

order_type=LimitOrder(price=runner.ex.available_to_back[5]['price'], size=12.0) is there any restrictions on size? my strategy in simulation works fine when size is small but doesn't execute with a big size(not able to place orders). Any clue?

---

## 2023-08-14 16:52:33 - strategies channel

**R**

[@UBS7QANF3](@UBS7QANF3) can't say on speed, I know it leverages other libs for certain routines based in C so it's fast enough that I've never thought to profile it against scipy.



Thing for me was just more granular API on optimization problems.

---

## 2023-08-14 16:45:21 - general channel

**mzaja**

The reason why I even dived into this matter is because I noticed that Flumine was rejecting order placement with

```"strategy.validate_order failed: live_trade_count (1) &gt;= max_live_trade_count (1)"```

when I tried to reuse the Trade to place a closing order. This never happened in the simulation so I investigated further and found out that a percentage of opening bets does not change status to "Execution complete" when the bet is fully matched (and even if it isn't, it should be cancelled). Therefore, it cannot be down to a delay in the logging controls because Flumine's behaviour on a live market confirms it.

---

## 2023-08-14 12:52:15 - strategies channel

**PeterLe**

Question Please: As a relative beginner to Python, Im learning pandas (dataframes etc) and how to model data. I've used the price recorder to create some data in the form a of a CSV file..from my recorded markets..

Then I'm using sklearn, LinerRegression, seaborn etc...

When I compare the relationship between Profit and a particular variable, when that variable is below x, I get :

Test 1

Coefficient: [-0.00026511]

Intercept: 0.8063449241964358

(Sloping downwards left to right) - Not good,but expected



Whereas when I run it when the variable is above x I get :

Test 2

Coefficient: [0.06673513]

Intercept: 0.10630060921962795

(Sloping left to right upwards) - Good and proven in real world bets



(It should be noted that this is a very small data set, Ill be running on bigger dataset when i have found my feet..)

Now I know that from real world bets placed this variable above x definitely increases profits, but in test 2, the coefficient is very small?



So questions please:

Is linear regression a useful tool? Do the pro's on here use it in a similar way?

Given that you only need a slight edge, should I be confident in the signal with such a low coefficient?

Other than ML (Which is way above my head for now :grinning:) and linear regression, what other python tools do you use to model your data?

Thanks in advance

---

## 2023-08-14 12:23:29 - general channel

**mzaja**

The way I see it, it is either:

1. Betfair erroneously does not send an update, hence I am asking whether someobody else experienced the same thing.

2. Betfair sends an update but it somehow gets dropped before it reaches me.

3. Betfair sends an update and it is received on my end, but Flumine does not process it.

The core issue is that Flumine leaves the trade in live state in the order does not complete, which then intereferes with the trading controls.

---

## 2023-08-14 12:16:29 - general channel

**mzaja**

How would I place it incorrectly? This is from the same strategy which uses only FILL_OR_KILL bets, so there is no risk of accidentally mixing them with regular orders. Moreover, the bet is clearly fully matched when it lands in the market, and I cannot find a reasonable excuse for the "Execution complete" update to take 9 minutes from then onwards.

---

## 2023-08-14 12:13:57 - general channel

**Carlos Vx**

I would like to use flumine to create a subscription and have all the orders tracked including orders that are not created using a BaseStrategy (directly on the betfair platform).

I used the example "betcode-org/[https://github.com/betcode-org/flumine/tree/master|flumine](https://github.com/betcode-org/flumine/tree/master|flumine)/[https://github.com/betcode-org/flumine/tree/master/examples|examples](https://github.com/betcode-org/flumine/tree/master/examples|examples)/example.py"

but I didn'tfind an easy way to achieve it. I can only see orders created on process_market_book function that are attached to the strategy implemented.

---

## 2023-08-14 11:54:44 - general channel

**Carlos Vx**

I have been checking flumine and I didn't find an easy way to get orders in streaming that are not attached a BaseStrategy. I would like to process all orders and not only the orders created using the BaseStrategy. Is there an easy way to achieve it?

---

## 2023-08-13 16:57:30 - random channel

**D C**

I've modded significantly since last year - async placement flag, collating bets into fewer requests, no further (explicit) use of a strategy ref string etc.

---

## 2023-08-13 14:03:44 - strategies channel

**Mo**

I think you can turn that into a pricing model

---

## 2023-08-13 13:59:22 - strategies channel

**Mo**

Not entirely clear what you mean. What is the output of your model? Is it a probability?

---

## 2023-08-13 13:57:37 - strategies channel

**AndyL**

[@UBS7QANF3](@UBS7QANF3) so yes i have a model i suppose, but my model is based upon the current price of a selection, rather than a model that says perhaps  horse1 fair price is 4.6, horse2 7.8, etc....

---

## 2023-08-13 12:26:23 - strategies channel

**R**

Also, so glad to see people leveraging Kelly and the repo looks fantastic.  I had built my own too, using cvxpy though instead of scipy optimizers

---

## 2023-08-13 12:25:28 - strategies channel

**R**

[@UBS7QANF3](@UBS7QANF3) solving kelly for multiple simultaneous outcomes only has analytical solutions for when they are mutually exclusive (i.e. only one horse can win a race and the rest lose - excluding draws).



For when things get more complex (e.g. placing WIN and FORECAST bets for example), don't you need to know the correlation structure between bets in order to determine kelly?

---

## 2023-08-13 11:18:57 - strategies channel

**Mo**

If you're predicting future price moves doesn't that mean you have a pricing model?

---

## 2023-08-12 18:16:30 - general channel

**BYD BET**

Hey guys,



I use in_play_service.get_scores on soccer match and sometimes i have no data for a football match.



For example :

`event_list = [32425345, 32425347, 32425348, 32425366, 32466972, 32504596, 32504599, 32504600, 32504601, 32504602, 32504603, 32504604, 32504605, 32504607, 32504608, 32504609, 32524091, 32536472]`

`[http://trading.in|trading.in](http://trading.in|trading.in)_play_service.get_scores(event_ids=event_list)` 



I never got any data for match 32504596 which took place yesterday. I have noticed this problem and I have not been able to explain why but it happens quite frequently.



Is it possible that betfair does not offer data for certain matches? This is very strange.



Thanks

---

## 2023-08-12 12:58:40 - strategies channel

**AndyL**

I really need to create myself a "pricing model", seems all you clever guys are into this...?

---

## 2023-08-12 09:30:45 - strategies channel

**Mo**

I found this nice short article on the three outcome case: [https://elliotnoma.wordpress.com/2013/04/21/the-kelly-criterion-for-three-outcome-gambles/](https://elliotnoma.wordpress.com/2013/04/21/the-kelly-criterion-for-three-outcome-gambles/)

---

## 2023-08-12 08:40:39 - strategies channel

**Mo**

You arrive at the standard Kelly formula by writing down your log expected wealth assuming you are placing a new back bet on one of the outcomes, then differentiate the log expected wealth with respect to the stake, set it to zero and solve for stake. Which is, in other words, finding the stake that maximises your log expected wealth



I'm doing exactly the same thing in this package. I am maximising the log expected wealth except handling more than 2 outcomes and both backing and laying. Partly for convenience and partly for necessity I'm doing it numerically rather than analytically. As a minor point I am minimising the negative log expected wealth which is obviously the same as maximising the log expected wealth



The intention is to add the closed form calculations for when there are two outcomes. You'll call the same function in the package and it will automatically skip the numerical optimisation in this case



In fact, there is a closed form solution for 3 outcomes which I am already using in Python but I found that numerically optimising in Rust is 3 times faster which blew my mind. Again, I will ultimately add the closed form solution for 3 outcomes to the package



For 3 outcomes, if you differentiate the log expected wealth and set it to zero you end up with a quadratic equation to solve. For 4 outcomes, you would end up with a cubic. For 5 outcomes, a quartic and so on. There are explicit formulas for solving cubics and quartics but no such formula exists for higher degree polynomials. Hence the need for numerical optimisation if you want to handle an arbitrary number of outcomes



I have thought about using a Taylor series approximation in the higher degree cases to avoid the numerical optimisation but I'm not sure if this would work or what the loss in accuracy would be like



All of this is assuming you are placing a bet on only one of the outcomes. Once you start thinking about placing bets on multiple outcomes simultaneously then you pretty much have to use a numerical method although there are specific "solvers" like [https://en.wikipedia.org/wiki/Kelly_criterion#Multiple_outcomes|the method described in the multiple outcomes section of the Wikipedia article](https://en.wikipedia.org/wiki/Kelly_criterion#Multiple_outcomes|the method described in the multiple outcomes section of the Wikipedia article)



I am surprised there is not a lot in the literature about closed form solutions for Kelly staking with "large" numbers of outcomes that you see in almost all horse races. It seems that the general philosophy is to throw a numerical solver at it which I think reflects academics' lack of real world experience. If you aspire to be doing these calculations on every market book update you need to be fast

---

## 2023-08-11 23:57:20 - strategies channel

**Jonjonjon**

[@UBS7QANF3](@UBS7QANF3) where can I learn about the mathematical details behind your Kelly algo? I'm only familiar with the standard Kelly, which has a closed form solution and does not need minimisation. Apologies if this is a dumb question.

---

## 2023-08-11 17:01:49 - issues channel

**Clive**

Imagine I have a historical time series of the number of people on the 59 bus, or something else. It doesn't matter. Now I want to call my strategy in a backtest with this dataset:



```strategy.process_passengers(self, ...)```

I need to get my passenger data into the time priority queue derived from the BetFair data, to ensure it is processed in order.



Does it make sense?

---

## 2023-08-11 16:43:26 - strategies channel

**Mo**

Absolutely helps compared to pure Python. If you try to do Kelly staking with many runners and have a time constraint on the calculations it would probably be impossible to do it in pure Python. I will add some benchmarks shortly 

---

## 2023-08-11 05:23:49 - strategies channel

**James**

I find in football markets that the top leagues are more reliably predictable and similar, as top coaches and players tend to behave similarly. There is obvious variance in style, but youth/teenage teams or those in developing football nations tend to be more erratic IMO as they aren’t so highly coached.



It depends on your strategy tho, if you can make money from erratic, maybe they’re your target.



If you want strong backtesting and you see a gap to exploit maybe top leagues are best for you.



Note that liquidity is also higher in top leagues so this too can have an influence on the success in smaller/lower leagues.

---

## 2023-08-10 14:58:49 - strategies channel

**liam**

But I have gone back to my model to improve using regression, it became *much* more accurate but has had zero impact (-ve) on pnl so it’s back to the white board.



Anyone else got anything interesting to share? 

---

## 2023-08-09 13:39:27 - general channel

**Simon Chan**

Hi, is Postgresql a good database stack to store and modelling data? I'm mostly familiar with Postgres because of work (web dev), but I want to know if someone has used a different stack

---

## 2023-08-08 15:57:45 - general channel

**Rishab**

[@UUCD6P13J](@UUCD6P13J) where do I need to put backtestloggingcontrol as an input? Im assuming it works similar to marketrecorder(create a strategy with marketrecorder &amp; then framework.addstrategy())

---

## 2023-08-08 14:56:41 - general channel

**joe taylor**

So I’m running it on a saved data. How do I see things like how strategy performs with time/ if I want to do some plotting on type of bets it’s taking Etc 

---

## 2023-08-08 14:46:15 - general channel

**joe taylor**

I think it’ll be helpful for beginners if someone can share an implementation/Anaylsis notebook of a basic strategy using flumine. I read the documentation but not much clear from there.  

---

## 2023-08-08 14:17:49 - random channel

**Vlad Gavrilov**

I’ve played around with it, thought that a temporal fusion transformer model could be useful to predict how market movements play out.. but never got too far into it. The model structure seems appropriate and useful for this application. One day!

---

## 2023-08-08 12:19:50 - general channel

**joe taylor**

I’m working on a quoting strategy will it be able to factor in the fact that if I’m able to quote on a level before everyone else I should be the one to get the fill first on that level?

---

## 2023-08-08 11:29:53 - general channel

**joe taylor**

I have recorded data using flumine- Can I simulate my strategy on this recorded data?

---

## 2023-08-08 10:11:38 - strategies channel

**foxwood**

I've used Google's tensorflow with python -  flexible for building / managing features - works well and now the docs appear sorted should be easier getting started. Any learning you do will transfer easily to other packages. If you are familiar with MS Visual Studio then their [http://ML.NET|ML.NET](http://ML.NET|ML.NET) add on is worth looking at - give it a csv then select fields to use and decide if feature or category is all you do - it then tries lots of different models to offer the best one. Seriously lacks ability to fine tune easily as in TF or SK but quick way to assess possibilities of datasets / models.

---

## 2023-08-08 09:14:16 - strategies channel

**Derek C**

Another consideration is whether the goal is to learn ML or get a good solution. Using an Auto-ML to generate features and models for you will give a better result than most people could do themselves,

---

## 2023-08-08 08:54:26 - strategies channel

**Joe**

Try to get an understanding of whether you need simple supervised learning, i.e. you have labelled data, or whether you are going full in on unsupervised learning using simply your parameterised branching strategy and a cost function (like -1 x profit). There is very little useful text on the latter.

---

## 2023-08-08 08:34:45 - strategies channel

**liam**

*Day 2*



Back to basics for me, the plan is to get a better understanding of how ML works when it comes to applying models to problems. Looking at going through the google ML unless anyone knows of anything better?



[https://developers.google.com/machine-learning](https://developers.google.com/machine-learning)

---

## 2023-08-07 21:22:43 - strategies channel

**Joe**

[@U4H19D1D2](@U4H19D1D2) I assumed you are trying to find parameters for your model that maximize the accuracy of your predictions, one way to do this in supervised learning is to use brier as your cost function.

---

## 2023-08-07 20:54:42 - strategies channel

**Jonjonjon**

Are all the top guys using classification models?

---

## 2023-08-07 19:02:50 - strategies channel

**foxwood**

Training per race would be slower but that is only while training - applying the model to live data would be no different. To add to the headache have a look at a regression model instead of classification - that should give you a score instead of a binary win/lose - effectively a probability.

---

## 2023-08-07 18:23:41 - strategies channel

**Lee**

is the first model also a win/lose or a pricing model?

---

## 2023-08-07 18:21:28 - strategies channel

**Lee**

by imbalanced classification do you mean the markets have more losers than winners so the model ends up with a bias?

---

## 2023-08-07 18:20:39 - strategies channel

**John Foley**

Also more generally - would be interested to hear what people have used as a target variable for supervised learning models that use market data only? Win/lose for a selection  I don’t think works well in most cases 

---

## 2023-08-07 18:20:22 - strategies channel

**liam**

The first model is very good at spitting out a prediction but the way it is formed is very unorthodox, no ML involved

---

## 2023-08-07 18:19:03 - strategies channel

**John Foley**

if you’re using predictions from another “model” as one of the input variables to your ML model - why not just use the input variables for your first model + input variables for your new model and make a training set from both? (i may not fully understand what you’re doing for the first model) 

---

## 2023-08-07 18:12:33 - strategies channel

**D C**

Nowt wrong with linear models [@U4H19D1D2](@U4H19D1D2) . Maybe you end up with something less optimal, but at least using classical inference you are not left with a black box type predictor. I'd love to get into ML but this thread has put me off (even thought I have found it really really interesting).

---

## 2023-08-07 17:57:56 - strategies channel

**liam**

[@U02RN7YDRQ9](@U02RN7YDRQ9) would that not be mega slow?



I think the only thing I have achieved today is a headache, certainly fallen into the overfitting trap, thanks [@U01B8031PM1](@U01B8031PM1) for sharing `GroupTimeSeriesSplit` makes sense and works well.



I have a pipeline that is working well and likely something that I will share as its very cool to be able to create a model and then run it within a flumine simulation with a few lines.



Really starting to question the suitability of using ML at this stage, maybe its the classifiers I am using but they just want to overfit. A few could have predicted this but I am going to go back to the beginning with my model predictions and see if that can be improved using regression.

---

## 2023-08-07 14:27:07 - strategies channel

**river_shah**

Copy pasted from [https://machinelearningmastery.com/k-fold-cross-validation/|machinelearningmastery](https://machinelearningmastery.com/k-fold-cross-validation/|machinelearningmastery):



```k-Fold Cross-Validation

Cross-validation is a resampling procedure used to evaluate machine learning models on a limited data sample.

The procedure has a single parameter called k that refers to the number of groups that a given data sample is to be split into. As such, the procedure is often called k-fold cross-validation. When a specific value for k is chosen, it may be used in place of k in the reference to the model, such as k=10 becoming 10-fold cross-validation.

Cross-validation is primarily used in applied machine learning to estimate the skill of a machine learning model on unseen data. That is, to use a limited sample in order to estimate how the model is expected to perform in general when used to make predictions on data not used during the training of the model.

It is a popular method because it is simple to understand and because it generally results in a less biased or less optimistic estimate of the model skill than other methods, such as a simple train/test split.

The general procedure is as follows:

Shuffle the dataset randomly.

Split the dataset into k groups

For each unique group:

Take the group as a hold out or test data set

Take the remaining groups as a training data set

Fit a model on the training set and evaluate it on the test set

Retain the evaluation score and discard the model

Summarize the skill of the model using the sample of model evaluation scores

Importantly, each observation in the data sample is assigned to an individual group and stays in that group for the duration of the procedure. This means that each sample is given the opportunity to be used in the hold out set 1 time and used to train the model k-1 times.```

---

## 2023-08-07 14:16:50 - strategies channel

**river_shah**

[https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.TimeSeriesSplit.html|TimeSeriesSplit](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.TimeSeriesSplit.html|TimeSeriesSplit) is your friend (grouped by market_id)

---

## 2023-08-07 13:50:20 - strategies channel

**liam**

Confirmed when I remove the shuffle from `train_test_split` I get a big drop in accuracy



```Model accuracy score: 0.8789```

---

## 2023-08-07 13:08:08 - strategies channel

**Lee**

Is this model using the random forest classifier?

---

## 2023-08-07 13:05:50 - strategies channel

**Unknown**

So I have a rough pipeline setup to allow model -&gt; flumine simulation, it works and I have results which point to some potential.



Stats: £30.0 profit per market, 14.0% roi, £59.4 matched per selection



A huge increase in matched amount which is not viable but the increase in ROI is most welcome, going to play around with some features and try and reduce the amount matched (probably a ML term for this when it comes to the model)

---

## 2023-08-07 10:19:04 - strategies channel

**liam**

Interestingly when I look at feature importance my model is at the bottom with 0.06% importance :joy:

---

## 2023-08-07 10:07:17 - strategies channel

**D C**

I was just wondering about what a lot of people have said about TPD on here - they have a model that works well without any TPD and use the TPD fields to improve on it. I only ask because I have a model that takes TPD inputs but I subsequently filter on some parameter ranges of those same inputs because it performs poorly on certain ranges and I want to exclude bet placement in those cases.

---

## 2023-08-07 10:05:00 - strategies channel

**liam**

[@UUE6E1LA1](@UUE6E1LA1) they are independent but likely related, i guess the end goal would be that they would all be fed into a model to get a single prediction 

---

## 2023-08-07 09:57:14 - strategies channel

**D C**

Are your C parameters in your if filter also inputs to the model that generates the initial probability estimate or completely independent of it?

---

## 2023-08-07 09:54:00 - strategies channel

**liam**

Ok, I follow, I think, this sounds like level 10 vs my current status of level 0.



It is already sounding like my current process of using a model and then filtering after with other features is less than ideal. However I feel starting with this using some simple models is probably going to see some improvements / move me onto level 1.

---

## 2023-08-07 09:25:56 - strategies channel

**Joe**

[@U4H19D1D2](@U4H19D1D2)ok so unlabeled unsupervised derivative free reinforcement learning with the goal of maximising profit or ROI. You need to get your data into a memory structure that can be executed at very high frequency then use a derivative free / metaheuristic search such as FF, PSO, etc. Your conditional betting logic would need to be rephrased to operate on the new memory model and you would need some type of environment that can minimally mimic the market if your logic takes actions based on its previous actions.

---

## 2023-08-07 09:14:46 - strategies channel

**liam**

[@UPMUFSGCR](@UPMUFSGCR) yes a lot more than 1



[@U05L8PZD2FM](@U05L8PZD2FM) currently the former



[@UBS7QANF3](@UBS7QANF3) more the former but I think its both, I hope this will help me learn where the value is coming from and probably form the basis of model v2 or even combine into a single model

---

## 2023-08-07 09:07:55 - strategies channel

**Joe**

Are you looking to optimise a set of thresholds in your IFs or are you looking to recombine your features in a non-linear model? i.e. are you trying to find C to optimise:

IF ( f1 &gt; c1 &amp;&amp; f2 &gt; c2 &amp;&amp; f3 &gt; c3 ) THEN placeBet()

or are you trying to learn a new function F:

IF (F(f1, f2, f3) &gt; 0) THEN placeBet()

---

## 2023-08-07 08:48:58 - strategies channel

**liam**

First step is to get all the data/features into a dataset I can process, this might be the most painful part.



I have the 'base' strategy analysed in terms of profit/roi but I am wondering if I should run typical ML analysis on my predictions, accuracy/precision/recall to then compare with future models?

---

## 2023-08-07 08:46:04 - strategies channel

**Unknown**

*Day 1*



Setting the scene, the plan is to improve a live (profitable) strategy by optimising its current parameters (features) using ML.  This is going to be a learning exercise so if you have any questions / advice / criticism please get involved :wave:



The strategy is for TPD inplay racing, low stakes and taking Lay prices, market impact can be ignored for now. To keep things simple I am going to limit to Flat racing for the past 6 months, Jan-June inclusive, which gives around 1500 markets.



One of the features is what I would call the model and gives a % chance of the horse winning/losing and is what I have used for the past 4 yrs as the most important feature in the `ifs`. However I know that with the inclusion of other features it can be improved but I have never been able to optimise manually and get results.



Stats: £6.5 profit per market, 11.6% roi, £15.8 matched per selection

---

## 2023-08-07 08:41:46 - general channel

**Jorge**

Hi, I am using the streaming_timeout parameter in my flumine strategy to force an update periodically after some seconds even if there's no update within this period. I would like it to force a first update on all the markets that I am subscribed to, instead of waiting until we receive the first market_book for the market. Is this possible with flumine?

---

## 2023-08-06 14:16:33 - general channel

**Alejandro Pablos Sánchez**

Hi guys !! While working with the different markets available in the exchange for football, I came up with the following question. When a particular market is not listed for a selected football match, is it because it is not available for that match, or because no one has put an order in that market? I'm saying this because a very popular market such as

"Both teams to score (BTTS)" appears as unavailable for all matches (it does not appear in the Betfair exchange betting interface). Then I wonder if this is due to it not being available or just because I need to be the first placing an order on it. Thanks !! :smile:

---

## 2023-08-06 10:03:48 - general channel

**Mo**

I think it depends on your definitions of:



1. Successfully

2. Trade

3. Financial markets

Does having a low frequency automated strategy for harvesting risk premia in an ISA count?



Do crypto markets count?

---

## 2023-08-04 18:15:25 - strategies channel

**Adam**

Will this be an in-play strategy? Another thing to consider will be model complexity and inference time. If using ensemble approaches (multiple, different types of algorithms), then by the time the prediction is made, you may miss the window

---

## 2023-08-04 17:44:02 - strategies channel

**Leo**

That said, the specific model is far less important than the quality of your features 

---

## 2023-08-04 16:41:25 - random channel

**Burrito**

What CPU utilization should a user expect on an AWS micro instance, running a strategy that does nothing, but which is subscribed to every horse racing market?

---

## 2023-08-04 15:38:08 - strategies channel

**liam**

I wont be sharing any data / models, just the process / results etc

---

## 2023-08-04 15:30:59 - strategies channel

**foxwood**

Did a lot of low-level experimenting with Encog about 10 years ago and later with Tensorflow, Keras etc and most recently [http://ML.NET|ML.NET](http://ML.NET|ML.NET). Have used recorded data and bought in data. To avoid complexities of integrating different packages for live I tend to use a csv file to handshake with the ML lol. Processing time was not generally important so easy solution. Sadly none of the ventures has proved better than "trad" methods of "if's" regardless of fields selected for training or type of model used. An itch I still scratch - so yes - very interested in this area. If you make the work as public as flumine though I think others will copy and edges will vanish.

---

## 2023-08-04 13:40:00 - strategies channel

**Andrew**

Do you have an idea what model type (algorithm) you’d try? Random Forest could be a place to start being just a complex array of ifs.

---

## 2023-08-04 12:19:57 - general channel

**joe taylor**

Hi guys! I want to work on some strategy around inplay horse racing. Had a few queries around this: how can I get real-time race data like runner distance left in race or position of each runner in race/speed 2. historical data for each runner with different features-timeform type data &amp; inplay data(like speed in last x fraction of race left etc)

---

## 2023-08-04 11:25:26 - strategies channel

**Mo**

Sounds good. It touches on something I have been thinking about recently. How much value add will you find from using the same data but with a more sophisticated model (i.e. ML vs if statements) vs value add from additional (orthogonal) data?

---

## 2023-08-04 11:06:08 - strategies channel

**liam**

No this would be using ML to create strategy predictions that are better than my current if statements using the same data.



Mentioned it being part II as part I is the only experience / skills I currently have when it comes to ML and is likely where I will start (RF) but want people to point me in the right/correct direction.

---

## 2023-08-04 11:03:15 - strategies channel

**Mo**

a) Of course, anything to breath life into this channel



By part II are you saying that specifically you want to start by improving the model in part I?

---

## 2023-08-04 10:57:15 - strategies channel

**liam**

After 10 years of ignoring it I think next week I am going to try applying some simple ML to a strategy which is currently using my trusty `if` statements.



a) Are people interested in me going through this process (data/model/predictions/flumine integration/execution etc) publicly on here?

b) Can I have some help from those that know what they are doing?



I see it being part II of my [https://medium.com/@paulingliam/using-ml-to-predict-horse-race-time-duration-6340776536e4|first attempt](https://medium.com/@paulingliam/using-ml-to-predict-horse-race-time-duration-6340776536e4|first attempt) (6 years on and still working / used daily), if so where do I start?

---

## 2023-08-04 09:41:39 - general channel

**Peter**

The reason I suggested that middleware might be preferable to a worker, in this specific case, was because the `__call__` method is executed on every market update, and it seemed likely that you would want to update your parameter each time the market updated.



By contrast, if you built this into a worker, it would be run on a schedule independently of market updates, so would be out-of-date some of the time, and may be being re-calculated unnecessarily at others.



Moreover, market middleware automatically receives the current state of the market and can save the calculated parameter straight back to the market.context where it would be available to any strategy interested in that market, whereas a worker would have be be told which markets interest you and would would then need to be coded to go digging into the flumine object to find them.

---

## 2023-08-03 16:51:53 - general channel

**George**

really i was just doing a little bit of testing guys - this was not a "deployed" strategy. i was just messing around with a few £ here and there. i totally agree about bankroll to stake ratio.

but point taken

---

## 2023-08-03 15:56:31 - general channel

**George**

totally agree. my strategy had passed the "sit and watch" stage by that point!

---

## 2023-08-03 15:50:52 - general channel

**George**

indeed! i made the numbers up for simplicity and to demonstrate the need for some way of disabling a strategy based on balance. it wasn't quite like what i described when i experienced it. i had a low exposure per market but had a very unlucky run of a large number of markets, followed by a lucky run which didn't get monetised properly ( although with tiny stakes)

---

## 2023-08-03 15:41:20 - general channel

**liam**

strategy.context seems more applicable 

---

## 2023-08-03 15:38:57 - general channel

**liam**

So why is speed an issue? Just use a worker to disable the strategy when balance &lt; x however just fix the issue 

---

## 2023-08-03 15:38:05 - general channel

**George**

i had it when testing something and the other controls didn't pick it up

the max-transaction-count froze me out for an hour instead

that's not ideal as i'd rather the strategy knows about the lack of balance and just doesn't send the order

---

## 2023-08-03 15:18:40 - general channel

**George**

Has anyone ever coded a trading control to validate that the account has sufficient funds to place the bet?

It seems like the latency involved makes it impossible. `get_account_funds` takes a really long time to return.

Has anyone solved this problem?

---

## 2023-08-03 15:14:55 - general channel

**Rishab**

I found this online from a really old post, is it the optimal way to load data? trading.streaming.create_historical_generator_stream(

    file_path="tmp/bafd8260/1.216640376",

    listener=listener,

) [@U4H19D1D2](@U4H19D1D2)

---

## 2023-08-02 20:12:57 - general channel

**Newbie99**

Then create a class something like:



```class CustomMiddleware(Middleware):

    def __init__(self, flumine):

        self.flumine = flumine

    def __call__(self, market):

        check_and_calc(market, strategy_list=self.flumine.strategies)



def check_and_caclc(market, strategy_list):

....do stuff```



---

## 2023-08-02 17:10:27 - general channel

**Newbie99**

Yes, market.context can be shared between strategies, so for a simple example, lets say you store your fair value in market context and you have 1 back strategy and 1 lay strategy, both could see the fair value level in market.context and place orders (or not) accordingly.

---

## 2023-08-02 16:48:09 - general channel

**Trex44**

Hey guys, if I save something to the market.context using a strategy will another strategy acting on the same market access the same market object and so the same context with the saved data if it calls market.context? I didn't think it did but now I am not so sure.

---

## 2023-08-02 14:32:23 - general channel

**rob smith**

Hello, is it possible to get the VWAP using bflw? Not for historical data but when trading live. Cheers

---

## 2023-08-02 13:43:33 - issues channel

**Mo**

```results = trading.betting.list_event_types()

print(results)



    raise APIError(None, method, params, e)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listEventTypes

Params: {'filter': {}}

Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retries exceeded with url: /exchange/betting/json-rpc/v1 (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate in certificate chain (_ssl.c:1002)')))```

Well there appears to be some certificate somewhere in his certificate store that _is_ getting used on these requests

---

## 2023-08-02 13:38:44 - issues channel

**Riccardo Fresi**

hi, anyone can help on generating certificate?

seems that i can login but i cannot reach betting endpoint

---

## 2023-08-02 10:28:21 - betconnect channel

**Riccardo Fresi**

Hi,

i nees assistance on connet, since here everything is ok

```session = requests.session()

trading = betfairlightweight.APIClient(

  'xxxxxxx', 

  'xxxxx', 

  app_key='xxxxxxs', 

  certs='C:/xxxxxxx/certs',

  locale='italy',

  session=session)```

then

```login = trading.login()

print(login.login_status)



&gt;&gt;&gt;SUCCESS```

later

```results = trading.betting.list_event_types()

print(results)



    raise APIError(None, method, params, e)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listEventTypes

Params: {'filter': {}}

Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retries exceeded with url: /exchange/betting/json-rpc/v1 (Caused by SSLError(SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate in certificate chain (_ssl.c:1002)')))```

what's wrong? should use endpoint '.it' but i see '.com'

or the problem is something else?

---

## 2023-07-31 18:53:13 - strategies channel

**Mo**

So what’s the update? Did you restart the strategy? Did you do any of the analysis we suggested?

---

## 2023-07-27 08:19:27 - general channel

**liam**

I have multiple instances of flumine running all communicating with it, sending/receiving market / order / trade / strategy / notes etc to it



I have a simple SPA running on top that allows me to view everything at a glance and update settings etc



I have a few lambda scripts that communicate on a daily basis to update / reconcile / check / record various things



Simulation scripts use it to pull in the relevant marketId's / data required (catalogues / sports data etc)



However when using juypter / pandas I communicate directly to the db with SQL as its quicker, whats your frustration? Speed?

---

## 2023-07-27 07:58:56 - issues channel

**Nacho Uve**

My Betfair account is in Spain. I was running Flumine on a server that I would like to cancel. I was completing the migration to an EC2 instance (region Paris), but when trying to connect from the server, it throws an error:

&gt; betfairlightweight.exceptions.LoginError: API login: BETTING_RESTRICTED_LOCATION

In Europe, EC2 offers regions: London, Dublin, Stockholm, Paris, or Frankfurt, none of which are in Spain.



Do you think any of these will work, or is there a way to operate from AWS with a Spanish account?

---

## 2023-07-26 13:35:32 - strategies channel

**mandelbot**

I think what's more likely than someone re-engineering your strategy is someone is manipulating the market to catch strategies like yours

---

## 2023-07-26 11:50:02 - strategies channel

**Aaron Smith**

reverse engineering a strategy with that low volume seems incredibly difficult and i dont think anyone who is capable of doing so (and i m not sure someone like that exists) would bother with 100 bucks from your strat. Honestly 4 races with a loss in a row seems like normal fluctuation to me? If -83 is far beyond your previous max loss per market, i d rather check what caused you to put in more volume than usual. That you lost that single race where you put in the volume doesnt really say anything,

---

## 2023-07-26 10:17:29 - issues channel

**Harry Corrigan**

Hi, i'm having an issue placing basic trades from within a strategy using flumine

on proccess_market_book being called i attempt to place an order but when i run market.place_order i get a runtime error raised by `self._thread_pool.submit(func, order_package, http_session)`  the error says cannot schedule new futures after interpreter shutdown, i have a custom stream to pipe data into the strategy which may be causing it? wondering if anyone has seen this error before and if so how did you fix it

---

## 2023-07-25 16:56:44 - general channel

**liam**

Like Lee I do a bit of both, all market files in a s3 bucket and then a mysql db with flat market / market cat / order / trade / strategy data all behind a django api. I find this is then the best way to get market data required for simulation:



market filter -&gt; api -&gt; return marketIds / data -&gt; download locally if required -&gt; simulate

---

## 2023-07-25 02:06:01 - general channel

**Felix Vasquez**

Hi [@U4H19D1D2](@U4H19D1D2)!, Thanks for your response!

The reason for this change is that I'm in a discovery process, studying all files and what is doing every function, imported library, decorators, and so on. I'm new in programming, python, betting, trading, and all this world. Basically, I am learning Python through betfairligthweigth library and further in my path with Flumine, to finally built some strategies there.

I was running it from the debug window in VSCode, I modified the `examplestreaming.py` file by adding calls to different endpoints, playing around with the response, and analyzing the data provided by de API. And all this worked fine, but I was surprised when saw the mentioned behavior.

What you say has total sense to me, and maybe the problem is that `examplestreaming.py` is importing the library and isn't using the code I download to my PC. I will change it to a relative import and see if this solves the problem.

Finally, you ask me why am I running from terminal?, is there any other way to run it?

Any advice to facilitate the learning process will be appreciated.

Cheers

---

## 2023-07-24 15:59:10 - general channel

**Mo**

Assuming you don't need tick data to build models, this resource is great: [https://promo.betfair.com/betfairsp/prices](https://promo.betfair.com/betfairsp/prices)

---

## 2023-07-24 09:45:15 - general channel

**Simon Chan**

Thank you all for the reply. I guess I will have to look for somewhere else to scrape data in order to build models. Any recommended sites? The technicality is not a big issue because I do quite a lot of web scraping on my day job (software dev)

---

## 2023-07-24 09:40:04 - general channel

**river_shah**

[https://huggingface.co/docs/transformers/main/model_doc/llama2](https://huggingface.co/docs/transformers/main/model_doc/llama2)

---

## 2023-07-24 08:50:03 - issues channel

**Mo**

I think a simple response along the lines of:



&gt; If you are unable or unwilling to implement robust error handling in your code I suggest you look at flumine which is a fully featured trading framework sitting atop betfairlightweight

would go a long way

---

## 2023-07-24 07:43:02 - general channel

**Mo**

1. No, delayed key is useless

2. You cannot just collect price data under any circumstances, there needs to be some betting activity on your account

3. You shouldn't be polling, use streaming

---

## 2023-07-23 08:23:20 - random channel

**Alex**

Yeah, data is a lot easier to come by (and cheaper) in crypto. Binance is the one with the best liquidity, data is good, no orderbook data (you can apply for it though). It all depends on the kind of strategy that you want to run.

---

## 2023-07-22 06:08:27 - random channel

**Alex**

I trade quant equities in my day job. It is definetly possible to make money, but it is not a trivial problem. If you just want to play around a bit, you are likely better off with crypto. ETF's are tough, you are essentially trading indices, you'll end up with very low sharpe ratio's there. Better to trade futures right away. Depending on the kind of strategy you want to run you will end up with a low return on capital, so you rely on leverage to make it worthwhile.

---

## 2023-07-21 10:06:30 - general channel

**Mo**

Look at the `CurrentOrder` definition: [https://github.com/betcode-org/betfair/blob/e4d58fd369312408c04519be1520e35b0dfc61dc/betfairlightweight/resources/bettingresources.py#L627](https://github.com/betcode-org/betfair/blob/e4d58fd369312408c04519be1520e35b0dfc61dc/betfairlightweight/resources/bettingresources.py#L627)

---

## 2023-07-21 10:03:54 - general channel

**anh**

hello everyone, I'm new to Python and coding in general and am in the process of moving from BA/Excel to BFLW (whilst learning on the job).  I'm very much a newbie so if betcode isn't the place for this question please let me know... I have implemented a few strategies so far but my next one requires me to check open orders (matched and unmatched) on different horse racing win markets. To do this I am trying to use list_current_orders - which I think is the right one - as follows: `open_bets = trading.betting.list_current_orders(market_ids=[market_id])`. This seems to return a list of objects but is where I'm stuck. How do I get the bet details from these objects?

---

## 2023-07-20 13:19:40 - issues channel

**Alex**

I have the same issue, just a simple strategy placing a limit order and then checking its status. I believe it was previously mentioned that middleware has to be used somehow to make sure that limit orders moved to ‘complete’ status?

---

## 2023-07-19 14:55:41 - general channel

**river_shah**

It seems that `BaseStrategy` does not expose framework so pass the framework into your derived strategy and then strategy can terminate program as needed

---

## 2023-07-19 14:00:06 - general channel

**Jorge**

Hi, from my flumine Strategy, how can I exit the Strategy so it does not trade anymore and closes the program. I am looking at [https://github.com/betcode-org/flumine/blob/d2e7d8e6cbc65687d2a0fb41e8f24bf133081f59/flumine/baseflumine.py#L429|baseclient.exit()](https://github.com/betcode-org/flumine/blob/d2e7d8e6cbc65687d2a0fb41e8f24bf133081f59/flumine/baseflumine.py#L429|baseclient.exit()) but no idea how to call from within process_market_book().

---

## 2023-07-18 09:39:59 - issues channel

**Nacho Uve**

Ahhh...



So... in this example of strategy, if I had made a real bet on betfair, yes, a match would take place, right? But when I'm in simulation mode a match will only be made if similar bets have been matched during recording, right?



I would like to test strategies over markets without so much "trade volume".

Do you think there would be a way to simulate that behavior of betfair where orders are matched when there is volume available for that price or higher?

---

## 2023-07-18 07:42:45 - issues channel

**Unknown**

Thanks [@UBS7QANF3](@UBS7QANF3)



Ok, there goes the file.



And here I put an extract of the output of the strategy where you can see how the order is waiting to be matched, but it seems that it is ignored during a lot of market_book updates, until the market is suspended.



```********** Orders *************

****  1/1

OrderStatus.EXECUTABLE

@1.11 2$

Matched: 0.0$

*******************************

Already one order... 

== market_book available to back ==

Time: 2023-06-04 16:47:11.895000

676464 [{'price': 1.15, 'size': 510.62}, {'price': 1.14, 'size': 3312.51}, {'price': 1.13, 'size': 7.62}]

60311 [{'price': 22, 'size': 69.49}, {'price': 21, 'size': 1.72}, {'price': 20, 'size': 6.89}]

58805 [{'price': 9.6, 'size': 64}, {'price': 9.4, 'size': 184.92}, {'price': 9, 'size': 18.95}, {'price': 8.8, 'size': 22.4}, {'price': 8.6, 'size': 4.07}, {'price': 7.8, 'size': 35.98}]

==================================

********** Orders *************

****  1/1

OrderStatus.EXECUTABLE

@1.11 2$

Matched: 0.0$

*******************************

Already one order... 

== market_book available to back ==

Time: 2023-06-04 16:47:12.792000

676464 [{'price': 1.15, 'size': 510.62}, {'price': 1.14, 'size': 3312.51}, {'price': 1.13, 'size': 7.62}]

60311 [{'price': 22, 'size': 69.49}, {'price': 21, 'size': 1.72}, {'price': 20, 'size': 6.89}]

58805 [{'price': 9.6, 'size': 64}, {'price': 9.4, 'size': 184.92}, {'price': 9, 'size': 18.95}, {'price': 8.8, 'size': 22.4}, {'price': 8.6, 'size': 4.07}, {'price': 7.8, 'size': 35.98}]

==================================

********** Orders *************

****  1/1

OrderStatus.EXECUTABLE

@1.11 2$

Matched: 0.0$

*******************************

Already one order... 

== market_book available to back ==

Time: 2023-06-04 16:47:14.425000

676464 [{'price': 1.15, 'size': 510.62}, {'price': 1.14, 'size': 3312.51}, {'price': 1.13, 'size': 7.62}]

60311 [{'price': 22, 'size': 69.49}, {'price': 21, 'size': 1.72}, {'price': 20, 'size': 6.89}]

58805 [{'price': 9.6, 'size': 62.28}, {'price': 9.4, 'size': 184.92}, {'price': 9, 'size': 18.95}, {'price': 8.8, 'size': 22.4}, {'price': 8.6, 'size': 4.07}, {'price': 7.8, 'size': 35.98}]

==================================

********** Orders *************

****  1/1

OrderStatus.EXECUTABLE

@1.11 2$

Matched: 0.0$

*******************************

Already one order... 

== market_book available to back ==

Time: 2023-06-04 16:47:15.100000

676464 [{'price': 1.15, 'size': 510.62}, {'price': 1.14, 'size': 3123}, {'price': 1.13, 'size': 7.62}]

60311 [{'price': 22, 'size': 69.49}, {'price': 21, 'size': 1.72}]

58805 [{'price': 9.6, 'size': 62.28}, {'price': 9.4, 'size': 184.92}, {'price': 8.6, 'size': 4.07}, {'price': 7.8, 'size': 35.98}]

==================================

********** Orders *************

****  1/1

OrderStatus.EXECUTABLE

@1.11 2$

Matched: 0.0$

*******************************

Already one order... 

== market_book available to back ==

Time: 2023-06-04 16:47:15.336000

676464 [{'price': 1.13, 'size': 7.62}]

60311 [{'price': 21, 'size': 1.72}]

58805 [{'price': 8.6, 'size': 4.07}, {'price': 7.8, 'size': 35.98}]

==================================

********** Orders *************

****  1/1

OrderStatus.EXECUTION_COMPLETE

@1.11 2$

Matched: 0.0$

*******************************

SUSPENDED```



---

## 2023-07-18 07:31:05 - issues channel

**Nacho Uve**

Here It is a simple dummy strategy to visualize the problem.

It use an example market  where this happens:

```import sys

import logging



from flumine import BaseStrategy



from flumine.order.trade import Trade

from flumine.order.order import OrderStatus

from flumine.order.ordertype import LimitOrder







MARKET_ID = "1.214780186"

SELECTION_ID = 676464



class Back_Dummy_Strategy(BaseStrategy):



    def check_market_book(self, market, market_book):

        if market.market_id != MARKET_ID:

            return False

        return market_book.inplay





    def process_market_book(self, market, market_book):



        if market_book.status == "SUSPENDED":

            import time

            print("SUSPENDED")

            try:

                import ipdb

                ipdb.set_trace()

            except Exception as e:

                print(e)



        if len(market.blotter):

            for oo in market.blotter:

                if oo.status == OrderStatus.EXECUTABLE:

                    print("Already one order... ")

                    self.available_to_back(market_book)

        else:

            trade = Trade(

                market_id=market.market_id,

                selection_id=SELECTION_ID,

                handicap=0,

                strategy=self

            )

            order = trade.create_order(

                side="BACK",

                order_type=LimitOrder(price=1.11, size=2),

                notes={1:f"My first dummy order"}

            )

            market.place_order(order)





    def available_to_back(self, market_book):

        print("== market_book available to back ==")

        print(f"Time: {market_book.publish_time}")

        for rr in market_book.runners:

            atb = rr.ex.available_to_back

            print(rr.selection_id, atb)

        print("==================================")



    def process_orders(self, market, orders):



        super().process_orders(market, orders)



        for i, oo in enumerate(orders):

            try:

                print("********** Orders *************")

                print(f"****  {i+1}/{len(orders)}")

                print(oo.status)

                print(f"@{oo.order_type.price} {oo.order_type.size}$")

                print(f"Matched: {oo.size_matched}$")

                print("*******************************")



            except Exception as e:

                print(e)```

Could I share the recorded stream file of example? or is there any restriction?

---

## 2023-07-18 07:12:42 - issues channel

**Nacho Uve**

Hi,



I'm stuck with a problem that I've encountered before when simulating football strategies.

Here are the steps:

1. I place an order at a price slightly higher than the current market price.

2. The order is marked as "EXECUTABLE," but

3. When the market reaches that price or a higher price, the bet remains unmatched (even though there is enough size available).

I've tried to check the simulation code in flumine to see what might be happening, but I can't find the source of the error. I suspect that for some reason, the order is no longer being evaluated during market_books stream updates. Am I understanding this correctly, or am I doing something wrong?



I have a recorded stream file and a simple strategy example that I can share if it would be helpful to review.



Thanks in advance!

---

## 2023-07-15 19:34:57 - random channel

**Alex**

My guess is: these events receive sponsorship money from (traditional) bookmakers. Bookmakers get adversely selected when people engage in courtside latency arb -&gt; bookmakers push to stop courtside betting.

---

## 2023-07-15 10:38:49 - general channel

**Peter**

[@U012CS8MP52](@U012CS8MP52), [@U4H19D1D2](@U4H19D1D2) isn't suggesting keeping market data in a database, since as you say, that would get very large. He's just advocating keeping enough information about races, markets and trades as an index that can be filtered to get a list of market_ids to pass to Flumine when running strategy simulations. The market data is kept in its raw form in a compressed file per market.

---

## 2023-07-14 11:49:21 - issues channel

**Andy**

Now this :



Do they mean by this comment that flumine can only handle 1k markets or they don’t want to increase above 1k…?



Hi Andy,

 

We’re not experts with using Flumine, but I managed to recreate the error message using the same filters.

 

It triggered the SUBSCRIPTION_LIMIT_EXCEEDED, then the TIMEOUT error that you received.

 

We can’t increase the market limit again as appears you’ll need to adjust your strategy to filter the number of markets to below 1000 and see if that works.

 

You could see if Liam (betcode) has any suggestions on why you’re not seeing the SUBSCRIPTION_LIMIT_EXCEEDED?

 

 

Filters

 

strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7","4339"],

        #country_codes=["GB"],

        market_types=["WIN","PLACE"],

    ),

 

 

Error Log

 

2023-07-14 16:32:54,606:ERROR:[MarketStream: 2001]: SUBSCRIPTION_LIMIT_EXCEEDED: trying to subscribe to 1258 markets whereas max allowed number was: 1000

2023-07-14 16:32:54,607:INFO:[MarketStream: 2001]: FAILURE (4 connections available)

2023-07-14 16:33:03,126:INFO:Client update account details

2023-07-14 16:33:10,123:ERROR:[MarketStream: None]: TIMEOUT: Connection is not subscribed and is idle: 15000 ms

2023-07-14 16:33:10,124:ERROR:MarketStream 2001 run error

Traceback (most recent call last):

  File "c:\Users\DouglasB\GitHub\How-to-Automate-Public-Version\.venv\lib\site-packages\flumine\streams\marketstream.py", line 44, in run

    self._stream.start()

  File "c:\Users\DouglasB\GitHub\How-to-Automate-Public-Version\.venv\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 67, in start

    self._read_loop()

  File "c:\Users\DouglasB\GitHub\How-to-Automate-Public-Version\.venv\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 233, in _read_loop

    self._data(received_data)

  File "c:\Users\DouglasB\GitHub\How-to-Automate-Public-Version\.venv\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 274, in _data

    raise ListenerError(self.listener.connection_id, received_data)

betfairlightweight.exceptions.ListenerError: connection_id: 209-140723063254-1955531, data: {"op":"status","statusCode":"FAILURE","errorCode":"TIMEOUT","errorMessage":"Connection is not subscribed and is idle: 15000 ms","connectionClosed":true,"connectionId":"209-140723063254-1955531"}

---

## 2023-07-14 07:22:52 - strategies channel

**Peter**

Stepping back, I use Monte Carlo simulation too, but (almost) always offline as part of my analysis to develop and evaluate strategies. I only have one strategy currently where it's integrated into the strategy itself. For that strategy, what's changing and warrants re-running the simulation is the state of the event itself, i.e. fundamental rather than market data. Updates to that are way slower than every 50 milliseconds. So I have a process that runs in parallel to my Flumine strategy to ingest external data about the state of the event, run the simulation and store the latest result, which can be read by my Flumine strategy as and when it needs it.



In my case it's an older home grown process (it's been around for a while). But Flumine provides [https://betcode-org.github.io/flumine/workers/|workers](https://betcode-org.github.io/flumine/workers/|workers) that are how I could do this job if I were writing this today. A worker runs in parallel to your Flumine strategy so (normally) won't slow it down (though if you have a single processor available to your Flumine instance it might). Thus you could run your simulations continuously in a worker function and, using the flumine object available to each worker, write the results back to your strategy or individual markets objects each time a simulation completes, from which your strategy can pick them up when processing market updates.

---

## 2023-07-13 12:29:39 - general channel

**George**

```def process_market_book(self, market, market_book):

    if first_half_of_execution:

        self.do_strategy_1()

    else:

        self.do_strategy_2()```

---

## 2023-07-13 12:27:24 - general channel

**George**

you can code your strategy in such a way that it changes its behaviour halfway through.

---

## 2023-07-13 12:20:27 - general channel

**Harry Corrigan**

I'm trying to create a scheduler that takes a list of events and subscribes to each one before it starts, these events may start on different days as the system is intended to run forever 

How would I do this if I can't update a strategies subscriptions? Would I have to remove one strategy and create a new one with a different filter when trying to subscribe to a new market?

---

## 2023-07-13 12:03:23 - general channel

**Harry Corrigan**

So if I want a strategy that changes market halfway through execution, that's not possible?

---

## 2023-07-12 17:43:15 - issues channel

**Peter**

Clearly something is going very wrong. the starting point would be to profile your code. See [https://betcode-org.github.io/flumine/performance/#strategy](https://betcode-org.github.io/flumine/performance/#strategy). Also are you experiencing any network issues at the location where you run your strategies?

---

## 2023-07-11 19:52:28 - issues channel

**Harry Corrigan**

Hi, does anyone know why, in a very simple strategy implemented in flumine, the function 'process_raw_data' isn't being called

I have authenticated and the process_market_book function is pushing out data

however the process_raw_data function, on the same strategy, is never called

Is there more you need to do in order to get the raw data coming in, or is there some other issue?

---

## 2023-07-11 18:10:39 - general channel

**George**

the error occurs because `strategy.process_market_book` requires access to the runner names which should be in `market.market_catalogue`

but `market.market_catalogue` is `None` even though the `poll_market_catalogue` worker is active

---

## 2023-07-11 18:08:45 - general channel

**George**

```22 def run():

23   start_time_seconds = 43000

 24   stop_time_seconds = 1800

 25   setup_logger(logging.DEBUG)

 26   trading = login_with_bflw()

 27   client = clients.BetfairClient(trading)

 28   framework = Flumine(client=client)

 29   strategy = get_strategy(start_time_seconds, stop_time_seconds)

 30   pred_worker = get_prediction_worker(framework, start_time_seconds)

 31   logging_control = MarketOrderControl()

 32   framework.add_strategy(strategy)

 33   framework.add_worker(pred_worker)

 34   framework.add_logging_control(logging_control)

 35   with patch.object(config, 'raise_errors', True):

 36     framework.run()

 37   return framework```

---

## 2023-07-10 21:52:01 - random channel

**Jonjonjon**

Suppose I have backtested a strategy. I am only making 1 back bet per market.



I have a series of `n` P&amp;Ls.



What's the preferred way to generate a p-value via Monte Carlo?



• Randomly resample the `n` P&amp;Ls. Then sort them and look for the quantile where it crosses above zero.

• Estimate the fair odds (perhaps use the best back price at scheduled off). Then use the fair odds to and my matched prices to simulate several streams of returns. Then sort them and look for the quantile where it crosses above zero.

---

## 2023-07-10 08:39:49 - issues channel

**Andy**

def start_stream(bfl_trading, bfl_client, event_types=["horse", "greyhound"]):

    """Retrieves a json dictionary with the stream data from the specified event types."""

    for event in event_types:

        event_types[event_types.index(event)] = EVENT_TYPE_IDS[event]



    # create queue

    output_queue = queue.Queue()



    # create stream listener

    listener = betfairlightweight.StreamListener(output_queue=output_queue)



    # create stream

    streamH = bfl_trading.streaming.create_stream(listener=listener)

    streamG = bfl_trading.streaming.create_stream(listener=listener)



    # Create filters to get the events

    horse_market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["AU"],

        market_types=["PLACE", "WIN"]

    )

    greyhound_market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["4339"],

        country_codes=["AU"],

        market_types=["WIN"]

    )



    market_data_filter = filters.streaming_market_data_filter(

        fields=["EX_BEST_OFFERS", "EX_MARKET_DEF"], ladder_levels=3

    )





    # subscribe

    horse_streaming_unique_id = streamH.subscribe_to_markets(

        market_filter=horse_market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=5000,  # send update every 1000ms

    )



    greyhound_streaming_unique_id = streamG.subscribe_to_markets(

        market_filter=greyhound_market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=5000,  # send update every 1000ms

    )



    # start stream in a new thread (in production would need err handling)

    tH = threading.Thread(target=streamH.start, daemon=True)

    tH.start()

    tG = threading.Thread(target=streamG.start, daemon=True)

    tG.start()



    return streamH, output_queue

---

## 2023-07-09 15:47:12 - general channel

**Gary Cook**

So if I snapshot all markets from say 50 games a day I should be fine? Of course, I will be giving them some of my money through betting/trading. I would imagine that is less demanding than watching a whole game with streaming.

---

## 2023-07-09 15:38:03 - general channel

**river_shah**

I think that is likely the problem. Your usage may look like just scraping the platform to inform some other commercial offering. I suggest using streaming, not snaps and betting through the api, generate commissions and you should not run into issues.

---

## 2023-07-09 15:36:26 - general channel

**Gary Cook**

I gather some data to inform my trades. I'm actually very good at it but I didn't mind losing money while testing some things.  I don't place trades with the API. I don't think that should matter though? The money is still going through Betfair just their normal web UI. The reason I mention that is because just gathering data I don't really need streaming. Im just doing snapshots, not in-play live trading with the API.

---

## 2023-07-06 18:17:00 - strategies channel

**Charaka A**

I'm new to using flumine and was wondering if anyone has an idea how to go about maintaining the state of the ladder as part of the strategy. I'd like to later visualise the ladder but initially would like to maintain my own ladder for each runner which would be updated based on the mc packets received

---

## 2023-07-05 11:31:08 - issues channel

**liam**

`market.context` or `strategy.context` or just store it in the middleware itself `self.myshit`

---

## 2023-07-05 11:30:11 - issues channel

**Alex**

Middleware doesn't seems to allow for a context object to get passed between different runs, unless I get this wrong. What's the best workaround around this? I could presumably add a context attribute to flumine. Or the strategy.

---

## 2023-07-05 10:50:31 - issues channel

**Alex**

When running a strategy with pro data I encounter: `'list' object has no attribute 'put'` when calling `flumine.handler_queue.put`, i.e. the handler_queue has been replaced with a list while it should supposedly be a queue object. Anyone else encounter this before? To add some context: this happens in a worker thread not in the main flumine thread

---

## 2023-07-04 17:00:05 - strategies channel

**liam**

Mo will correct me if I am wrong but I believe the matching cycle is 50ms so 20ms is fine, assuming you have one strategy etc 

---

## 2023-07-04 16:21:28 - strategies channel

**foxwood**

I tend to deal with outcomes in `process_closed_market` since there is no particular time issue once the market is over. To make it easy to identify things I also patch over the flumine hash which is used for `order.customer_order_ref` so that it is easy to pick out multiple orders by specific strategy eg the order ref for bets placed by this strategy would always start "strat999" (max 12 characters)  ...



`class strat999(BaseStrategy) :`



	`def add(self) -&gt; None:`

		`...`

	    `self.name_hash = self.__class__.__name__\`

			`+ "x"*(STRATEGY_NAME_HASH_LENGTH-len(self.__class__.__name__))`



	`def somefunc(self,market,market_book)`

		`for order in market.blotter:`

	            `# check order belongs to this strat`

        	    `if order.customer_order_ref[:len(self.name_hash)] != self.name_hash :`

                	`continue`

		

---

## 2023-07-04 13:27:07 - strategies channel

**R**

reason i'm asking is I want to use flumine to simulate inside of a monte carlo tester I have built.



So I was hoping to effectively add a strategy for each MC run, and then access the returns of each strategy separately so I can compute statistics

---

## 2023-07-04 13:23:18 - strategies channel

**R**

general question on using flumine with multiple strategies: is there a convenient way to plot the returns for each strategy separately rather than just using something like (pseudo code)



`for market in framework.markets:`

`... aggregate returns`

`plot`

---

## 2023-07-04 09:40:07 - issues channel

**Johnny**

Potentially a very basic question here.  I'm trying out the example marketrecorder.py and have changed only my login details and local_dir - it starts up and finds all the markets, and creates an empty folder with a UUID, but then all the workers stop.  The strategy continues to run though with no data being supplied.  Does anyone have what else I need to do to get the standard recorder working?



```{"asctime": "2023-07-04 08:31:24,036", "levelname": "INFO", "message": "[MarketStream: 2001] 1.215758531 added, 53 markets in cache"}

{"asctime": "2023-07-04 08:31:24,036", "levelname": "INFO", "message": "[MarketStream: 2001] 1.215758545 added, 54 markets in cache"}

{"asctime": "2023-07-04 08:31:24,037", "levelname": "INFO", "message": "[MarketStream: 2001] 1.215758486 added, 55 markets in cache"}

{"asctime": "2023-07-04 08:31:24,037", "levelname": "INFO", "message": "[MarketStream: 2001] 1.215758498 added, 56 markets in cache"}

{"asctime": "2023-07-04 08:31:24,038", "levelname": "INFO", "message": "[MarketStream: 2001] 1.215727888 added, 57 markets in cache"}

{"asctime": "2023-07-04 08:31:24,039", "levelname": "INFO", "message": "[FlumineStream: 2001]: 57 mc added"}

{"asctime": "2023-07-04 08:31:24,039", "levelname": "INFO", "message": "Adding: 1.215727854 to markets", "client": {"id": "61ef3ddb", "exchange": "Betfair", "betting_client": "APIClient", "chargeable_transaction_count": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxOrderCount object at 0x7f014c174310&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}, "markets": {"market_count": 0, "open_market_count": 0, "live_orders": false, "markets": []}, "streams": ["&lt;OrderStream(OrderStream, started daemon 139643035035200)&gt;", "&lt;DataStream(DataStream, started daemon 139643026642496)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 139643610474304)&gt;", "&lt;Thread(Thread-2, started daemon 139643479651904)&gt;", "&lt;Heartbeat(Thread-3, started daemon 139643471259200)&gt;", "&lt;HistorySavingThread(IPythonHistorySavingThread, started 139643446081088)&gt;", "&lt;ParentPollerUnix(Thread-1, started daemon 139643437688384)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 139643076998720)&gt;", "&lt;BackgroundWorker(poll_account_balance, started daemon 139643068606016)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 139643060213312)&gt;", "&lt;BackgroundWorker(poll_cleared_orders, started daemon 139643051820608)&gt;", "&lt;Thread(TEST_load_processor, started daemon 139643043427904)&gt;", "&lt;OrderStream(OrderStream, started daemon 139643035035200)&gt;", "&lt;DataStream(DataStream, started daemon 139643026642496)&gt;", "&lt;Thread(OrderStream_output_thread, started daemon 139642540127808)&gt;"]}

{"asctime": "2023-07-04 08:31:24,042", "levelname": "INFO", "message": "Stopped DataStream 2001"}

{"asctime": "2023-07-04 08:31:24,042", "levelname": "INFO", "message": "Shutting down Execution (SimulatedExecution)"}

{"asctime": "2023-07-04 08:31:24,042", "levelname": "INFO", "message": "Stopped OrderStream 1001"}

{"asctime": "2023-07-04 08:31:24,044", "levelname": "INFO", "message": "Shutting down Execution (BetfairExecution)"}

{"asctime": "2023-07-04 08:31:24,045", "levelname": "INFO", "message": "BackgroundWorker keep_alive shutting down", "worker_name": "keep_alive", "function": "&lt;function keep_alive at 0x7f0144ce3670&gt;"}

{"asctime": "2023-07-04 08:31:24,235", "levelname": "INFO", "message": "Stopped output_thread (OrderStream 1001)"}

{"asctime": "2023-07-04 08:31:28,046", "levelname": "INFO", "message": "BackgroundWorker poll_account_balance shutting down", "worker_name": "poll_account_balance", "function": "&lt;function poll_account_balance at 0x7f0144ce3940&gt;"}

{"asctime": "2023-07-04 08:31:32,047", "levelname": "INFO", "message": "BackgroundWorker poll_market_catalogue shutting down", "worker_name": "poll_market_catalogue", "function": "&lt;function poll_market_catalogue at 0x7f0144ce38b0&gt;"}

{"asctime": "2023-07-04 08:31:36,049", "levelname": "INFO", "message": "BackgroundWorker poll_cleared_orders shutting down", "worker_name": "poll_cleared_orders", "function": "&lt;function poll_cleared_orders at 0x7f0144ce39d0&gt;"}

{"asctime": "2023-07-04 08:31:40,172", "levelname": "INFO", "message": "Exiting flumine", "client": {"id": "61ef3ddb", "exchange": "Betfair", "betting_client": "APIClient", "chargeable_transaction_count": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxOrderCount object at 0x7f014c174310&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}, "markets": {"market_count": 1, "open_market_count": 1, "live_orders": false, "markets": ["1.215727854"]}, "streams": ["&lt;OrderStream(OrderStream, stopped daemon 139643035035200)&gt;", "&lt;DataStream(DataStream, stopped daemon 139643026642496)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 139643610474304)&gt;", "&lt;Thread(Thread-2, started daemon 139643479651904)&gt;", "&lt;Heartbeat(Thread-3, started daemon 139643471259200)&gt;", "&lt;HistorySavingThread(IPythonHistorySavingThread, started 139643446081088)&gt;", "&lt;ParentPollerUnix(Thread-1, started daemon 139643437688384)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 139643076998720)&gt;", "&lt;BackgroundWorker(poll_account_balance, started daemon 139643068606016)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 139643060213312)&gt;", "&lt;BackgroundWorker(poll_cleared_orders, started daemon 139643051820608)&gt;", "&lt;Thread(TEST_load_processor, started daemon 139643043427904)&gt;"]}

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-2-ce727f3ddda0&gt; in &lt;module&gt;

     20 framework.add_strategy(strategy)

     21 

---&gt; 22 framework.run()



~/anaconda3/lib/python3.8/site-packages/flumine/flumine.py in run(self)

     27 

     28                 elif event.EVENT_TYPE == EventType.RAW_DATA:

---&gt; 29                     self._process_raw_data(event)

     30 

     31                 elif event.EVENT_TYPE == EventType.CURRENT_ORDERS:



~/anaconda3/lib/python3.8/site-packages/flumine/baseflumine.py in _process_raw_data(self, event)

    211             for strategy in self.strategies:

    212                 if stream_id in strategy.stream_ids:

--&gt; 213                     strategy.process_raw_data(publish_time, datum)

    214 

    215     def _process_market_catalogues(self, event: events.MarketCatalogueEvent) -&gt; None:



TypeError: process_raw_data() missing 1 required positional argument: 'data'```



---

## 2023-07-03 16:13:33 - strategies channel

**George**

In simulation, I can see my strategy is matching against the exact same order hundreds of times until the risk controls kick in.

How can I stop this happening? Surely it is not expected behaviour?

---

## 2023-07-03 15:14:00 - general channel

**Michael**

I have done just that, I think its how I’ve written it / my OOO knowledge becoming a limitation. I’ve effectively rewrote the entire process_closed_market function in a class which inherits from the S3MarketRecorder strategy, I assumed this would then add the functionality of the new function without entirely overwriting the old function in the main strategy

---

## 2023-07-02 11:04:05 - issues channel

**Peter**

Probably a question(s) for [@U4H19D1D2](@U4H19D1D2), but if anybody else knows I'd love to hear from your.



I'm not hugely familiar with event handling in Python, but it looks to me as though Flumine has a single FIFO queue handled in the main thread. If so, I would speculate that this means that processing heavy custom events would be blocking and a source of latency.



Is there anything in Flumine that would allow custom events to be offloaded to a queue on a different thread, or better a different processor? Or would this basically require building a parallel event handling infrastructure in my strategy runner?

---

## 2023-07-01 02:32:25 - issues channel

**Tom**

Is order.trade the only way to access the trade objects? I'm trying to save them to runner_context so I can access them (can't figure out how else to call them), and if the program restarts, runner_context.live_trades and trades just has the trade id's. I'm trying to manage multiple orders through a single Trade object, but the flow of logic seems to be strategy-market-blotter-orders-trade; where I want it to be strategy-strategies-runner_context-trade-order where strategies are notes in trade and order used to identify them.



Any suggestions gentlemen?

---

## 2023-06-30 12:26:27 - strategies channel

**thambie1**

I've had this problem. I don't think there's one clear answer. If the amount of data over the 12 months is large enough of a sample size, that may be enough evidence. Understanding exactly what changed and why can be very helpful as well. Is your strategy more profitable because spreads have changed, or because the market is more erratic? If you can explain the reason why profitability has changed, then there's less reason to pin it on nebulous overfitting.

---

## 2023-06-30 11:28:30 - strategies channel

**Lee**

I’m working on improving a strategy with a simple (and logical) optimisation that I tested on a single month of real bet data. This also shows good results for the previous 12 months but eats into profit in the previous years. At what point am I optimising for the evolving market conditions vs overfitting?

---

## 2023-06-30 09:21:54 - general channel

**George**

OK, so basically have an ever growing dictionary inside the strategy object mapping market ID to number of active runners?

---

## 2023-06-29 17:32:43 - strategies channel

**Peter**

Personally I'd turn this around by holding the lookup dict in the market context and if/when the strategy spotted a selection_id that's not in the lookup, pass the market object to a custom event to query the market_catalogue and update the market.

---

## 2023-06-29 16:06:18 - strategies channel

**Aaron Smith**

I want to make a selection_id_to_name dict to use in process_market_book. As this doesnt change on each market_book update, i would like to only generate this once. Where would be the right place for this in a flumine strategy? Also, what happens with the names when a replacement runner gets introduced? Normally a name goes like "x. name", where x is the starting position. So if a runner comes in as a replacement, i guess the name would change, so i need to update this dict with every new market_catalogue?

---

## 2023-06-28 18:09:14 - general channel

**Aaron Smith**

where are they then? in the bought data? Before i start a strategy, i normally populate a selection_id_to_name dict if i need a name, but this always seemed weird to me. Is this what everyone else does aswell?

---

## 2023-06-28 17:34:15 - general channel

**George**

Now I think I understand workers and my code is working - thanks very much. But I still have an issue.

Whilst the simulation is of course much faster than "real-time", there is no equivalent way to speed up the worker code which is inherently slow (e.g. calls to an external database or API).

This means that the worker output - which writes to `market.context` - is totally misaligned (in terms of 'clock') with the market-book. Isn't this a huge issue for some users?

Now I am lucky, because my worker output does not change frequently over time. However, I do need the worker to execute its "first pass" before the first `process_market_book`  is called. I can, of course, instruct my worker to start 10 "minutes" before `check_market_book` returns True, but 10 simulation-minutes is much quicker than the time it takes for the worker output to be generated, so it solves the issue in live trading but not in simulation.

I think that I can workaround this issue by checking the `market.context` during the `check_market_book`. However, it is not ideal, because `check_market_book` will return False in the simulation, whereas, in real life it would have returned True.

Depending on how slow the worker is, most of the simulated trading window could have been missed, just waiting for the worker's first pass!

I imagine this is not a new question - what is the standard answer to dealing with this?

---

## 2023-06-27 04:54:46 - general channel

**Guy Incognito**

This is some reproducible code there are 3 market ids I put into streaming market filter. One is just a random market that was a few minutes from the jump and two are from races a few days away. The two markets that are quite far away basically have no trading activity while the one jumping soon is very active. When I chick the logging file only the very active market has check market book and process market book running. The two other markets don't have anything logged, but when that very active market went inplay and then afterwards  settled, that's when streaming time out seemed to start working for the two other markets and they started logging stuff every 5 seconds. How can I get all markets to process every 5 seconds? 



# Logging

```logging.basicConfig(filename = 'streaming_timeout.log', level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO), format='%(asctime)s:%(levelname)s:%(lineno)d:%(message)s')



class OverWatch3(BaseStrategy):

    def start(self) -&gt; None:

        print("starting strategy")



    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

        [http://logging.info|logging.info](http://logging.info|logging.info)(f"Running check_market_book for market.market_id: {market.market_id}")

        return True

        

    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:

        [http://logging.info|logging.info](http://logging.info|logging.info)(f"running process_market_book for market.market_id :{market.market_id}")



ow3 = OverWatch3(

    market_filter=streaming_market_filter(

        market_ids = ['1.215545086','1.215545081','1.215501829']

    ),

    streaming_timeout = 5,

)



framework.add_strategy(ow3)



framework.run()```

---

## 2023-06-26 10:14:09 - general channel

**Jorge**

I guess my model is too slow and when there are many live games it takes too long to run process_market_book. For sure increasing the number of CPUs and optimizing the model would help me. I'd just like to add another safety check in case this ever happens again

---

## 2023-06-26 09:24:50 - general channel

**Jorge**

Hi, I'm trying to understand how would my flumine Strategy work in case the latency suddenly is very high. I am placing an order using [https://github.com/betcode-org/flumine/blob/master/flumine/markets/market.py#L79|place_order](https://github.com/betcode-org/flumine/blob/master/flumine/markets/market.py#L79|place_order) and then checking the selection's exposure using [https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L185|market.blotter.get_exposures(self, lookup=selection_lookup)](https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L185|market.blotter.get_exposures(self, lookup=selection_lookup)). Could it happen that the order gets matched and goes to EXECUTION_COMPLETE, but being the latency very high, the selection's exposure doesn't consider this order? In this case, my strategy would think this order never existed and place it again

---

## 2023-06-24 08:20:28 - strategies channel

**thambie1**

Thanks for all the suggestions. The approach that that I'm experimenting with now is to use a fixed margin, then use kelly (ignoring existing positions) to determine the size given the margin, and finally use kelly (considering existing positions) to determine what price to offer given the size computed in the previous step. Theoretically I'm pretty comfortable with it :crossed_fingers:

---

## 2023-06-24 07:28:59 - general channel

**Trex44**

Morning all. How do you access the Runner name via a strategy when backtesting? I can see it in RunnerCatalogue but can't figure out how to get there. Market Catalogue is 'none'.

---

## 2023-06-24 03:00:33 - general channel

**Andy**

Anyone running their code in VSC getting these oom errors and VSC crashing periodically? The program doesn’t seem to be using large amounts of memory if I check task manager and the json files I’m reading and writing to aren’t more than a few mb in size. Have tried the google suggestions but hasn’t improved things - [https://stackoverflow.com/questions/71614897/vscode-crashed-reason-oom-code-536870904#:~:text=If%20you%20are%20using%20VSCode,Optimizations%22%20and%20mark%20the%20checkbox.&amp;text=It's%20easy%20than%20you%20think,will%20see%20that%20it%20works|https://stackoverflow.com/questions/71614897/vscode-crashed-reason-oom-code-536870904#:~:text=If%20you%20are%20using%20VSCode,Optimizations%22%20and%20mark%20the%20checkbox.&amp;text=It's%20easy%20than%20you%20think,will%20see%20that%20it%20works](https://stackoverflow.com/questions/71614897/vscode-crashed-reason-oom-code-536870904#:~:text=If%20you%20are%20using%20VSCode,Optimizations%22%20and%20mark%20the%20checkbox.&amp;text=It's%20easy%20than%20you%20think,will%20see%20that%20it%20works|https://stackoverflow.com/questions/71614897/vscode-crashed-reason-oom-code-536870904#:~:text=If%20you%20are%20using%20VSCode,Optimizations%22%20and%20mark%20the%20checkbox.&amp;text=It's%20easy%20than%20you%20think,will%20see%20that%20it%20works).

---

## 2023-06-23 16:10:44 - strategies channel

**George**

In my strategy i would like to ensure that `check_market_book` returns `False` up to 60 seconds after the market status changes from SUSPENDED to OPEN. However, when I implement this using `time.time()` , the simulation fails, because the `time.time()` counter is aligned with "real life" and not with the flumine simulation.

What have I done wrong?

---

## 2023-06-23 10:49:30 - strategies channel

**Peter**

However, why are you worried about streaming markets in which you're not interested? Just filter them out in your strategy's `check_market` method.

---

## 2023-06-23 10:45:17 - strategies channel

**James**

I want to run a strategy against a set of football markets based on competition (and maybe a few other params), but I don’t want to maintain the stream for every football market in a given country, but market filters can’t let me filter by competition.

Has anyone used a worker to push market_ids into a strategy’s market filter so I don’t have to manually input a set of market ids every few days? Or is there an easier way to do this that i’m missing..

---

## 2023-06-23 10:44:10 - strategies channel

**Peter**

[https://www.researchgate.net/publication/4748916_Probability_and_Statistical_Models_for_Racing|This paper might help you](https://www.researchgate.net/publication/4748916_Probability_and_Statistical_Models_for_Racing|This paper might help you) but as [@UBS7QANF3](@UBS7QANF3) implies, if these models gave you an edge, people would be very quick to exploit it and the edge would disappear. In the case of Harville, there's a clear bias in the results that it delivers towards shorter priced runners, making it a poor estimator for place odds.

---

## 2023-06-23 01:26:58 - strategies channel

**Tom**

I think about BSP something like this - odds chosen at random at 100% markets would eventually return 0 if you chose horses at random.

From there, there is information implied in decision-making that maximises value, shaping models of probabilistic outcomes.

So (optimised) decisions assert information or that other decisions do not assert information.

---

## 2023-06-22 06:39:36 - general channel

**Peter**

Flumine has an `order.replace` replace method, but it only allows you to change the price, not the size, as that's all that Betfair allows on an existing order. You will of course also lose your place in the matching queue, re-entering at the back of your new price's queue. Because it's limited, I suspect that most people simply do an `order.cancel` and then place a new bet with the adjusted price and size. Using that approach though, you need to be aware that there may be a delay before your cancelation is executed, and indeed it can still be matched in the small window between you requesting the cancellation and it taking effect, so it's prudent to verify the cancellation before placing the adjusted bet.



The blotter is certainly very useful, I'd say equally with the orders object received by a strategy's `process_orders` method. Note an important difference is that the blotter has all orders for the current market, but the `process_orders` method receives only the orders for the current strategy.



Yes, existing orders will be retrieved and added to the blotter if you restart your strategy, but there may be a small delay as those with execution complete status won't come through the order stream, so instead Flumine makes an API call to Betfair to get them and add them to the blotter. Better practise though is to design your strategies to run continuously (whilst acknowledging that during development that may not be feasible or desirable).

---

## 2023-06-22 03:02:19 - general channel

**Tom**

Hey guys, what is the best way to amend orders in Flumine? Is there any dummy code for this available? It's just checking price and size and re-establishing the order to new market conditions. I've got to get my head around this blotter as well - is that how most of you are managing your orders? Will it retrieve all existing orders if you re-start your strategy?

---

## 2023-06-21 09:58:37 - strategies channel

**Mo**

So if Kelly tells you 0 stake, increase margin and try again?

---

## 2023-06-21 09:57:38 - strategies channel

**thambie1**

Doesn't account for existing positions. Kelly will eventually say to stop offering at the price if you build up a large enough position, where what you would really like to do is offer a worse price

---

## 2023-06-21 09:56:19 - strategies channel

**Mo**

How about Kelly with fixed margin?

---

## 2023-06-21 09:40:38 - strategies channel

**thambie1**

If the question was in regard to market making, like I mentioned in the question kelly can't provide both the price and size at the same time, but only one given the other.

---

## 2023-06-21 09:31:13 - strategies channel

**thambie1**

Yeah, I have taking strategies that incorporate kelly, they work well

---

## 2023-06-21 09:30:55 - strategies channel

**liam**

Have you experimented with taking advantage of this along the lines of kelly?

---

## 2023-06-21 09:28:44 - strategies channel

**liam**

I assume your model gives you a signal?

---

## 2023-06-21 09:19:46 - strategies channel

**liam**

[@U01DCR5PXDY](@U01DCR5PXDY) does your model return higher ROI (real) based on your signal?

---

## 2023-06-21 09:13:06 - general channel

**liam**

Or



```def incognito_worker(context: dict, flumine) -&gt; None:

    for strategy in flumine.strategies:

        print(strategy.context)```

---

## 2023-06-21 08:31:40 - random channel

**Jorge**

Makes sense, does it work in flumine as `strategy = BacktestBaseStrategy(market_filter={"markets": market_file_paths})` ?

---

## 2023-06-20 23:36:14 - general channel

**Alex**

Any reason why line 191 in markets.blotter reads `for order in self.strategy_selection_orders(strategy, *lookup[1:])` ? Why is disregarding the first element in lookup? I suspect this is a bug because strategy_selection_orders would normally take strategy, selection_id, and handicap as parameters. In the above it would just get strategy and selection_id=handicap and handicap defaulting to 0. [https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L191](https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L191)

---

## 2023-06-20 21:46:42 - strategies channel

**Mo**

I don’t think it’s been said BSP is more accurate. BSP is very accurate for the amount of work you have to put into making the prediction i.e. zero. It is entirely possible to have a model that is better than BSP

---

## 2023-06-20 21:44:05 - strategies channel

**AndyL**

So if you come up with the best "model" you can for fair prices... it's been said that Betfair BSP is always going to be more accurate. But am I right in thinking that's an obvious statement, because BSP is simply the "starting price" once everyone and his dog has decided on their own fair price and bet in the market, so of course BSP is going to be the "best" as it's an average of everyone's views.....?

The key is coming up with a decent estimate of BSP, before it happens ?

---

## 2023-06-20 17:38:40 - strategies channel

**thambie1**

Anyone have suggestions for how to approach pricing/sizing for market making using a fundamental model? Ideally I'd like to combine something like the Avellaneda &amp; Stoikov paper with the kelly criterion. The issue being, the Avellaneda &amp; Stoikov approach is suitable to a single product, whereas on Betfair you are often market making several runners. Furthermore, the paper's concept of inventory management doesn't completely apply given that you don't need to sell back your positions in sports betting. The kelly criterion on the other hand is great, but it can only tell you the amount to offer given a price, or a price given the amount you want to offer, but not both at the same time.

---

## 2023-06-20 17:28:26 - issues channel

**John Foley**

related somewhat to above question:

i’d like for `strategy.process_closed_market` to report my p&amp;l back to the logs once the market has settled. is there a one liner for this? or need to use some combination of the exposure functions from the blotter? wincing at the thought of handling edge cases, dead heats etc but `blotter.process_closed_market` is giving me some hope that stuff may already be handled..

---

## 2023-06-20 13:47:51 - issues channel

**liam**

So if you are in a strategy it would be



```exposure = market.blotter.selection_exposure(self, lookup)```

---

## 2023-06-20 13:47:16 - issues channel

**Faye**

I'm using it inside the strategy if that's what you mean? I just put that in as that's what I thought I needed to do.

Ha 54years, I think slack is a little confused today!

---

## 2023-06-20 13:41:41 - issues channel

**liam**

More context needed, your strategy needs to be the object itself, is this how you are actually using it?

---

## 2023-06-20 13:40:41 - issues channel

**Faye**

Could someone tell me if I am using selection_exposure correctly please as it is just returning 0.0 but I know bets have been matched (backtesting)

```blotter = Blotter(market_id=market.market_id)

strategy = Strategy1

lookup = (runner.selection_id, runner.handicap)

exposure = blotter.selection_exposure(strategy, lookup)```



---

## 2023-06-20 12:09:52 - general channel

**George**

Is it a bad idea to put a 'slow' (maybe a few seconds) function call inside `process_market_book`?  I imagine that would cause a lot of problems when (potentially) betting on large numbers of markets?

---

## 2023-06-19 18:58:38 - general channel

**D C**

Yeah I guess - but it's just sales patter isn't it? [@UBS7QANF3](@UBS7QANF3) that model has been around for ages now hasn't it - do you know if they actively work on it to improve it? I enquired years ago about how much it was to subscribe to but was told it was available to bookies only - do many bookies actually use it?

---

## 2023-06-19 14:05:50 - strategies channel

**James**

Hey, everyone I’m new to Flumine,

I’ve been using an JS based closed source framework for a while doing mostly in play trading.

The framework I have been using  handles a few things flumine doesn’t seem to (Flumine handles a LOT that the js framework doesn’t).

I’m wondering if theres an easy way to get your current matched win/lose positions on a runner?

Also does any one have any nice util functions for hedging/ledging that they’d be willing to share?

---

## 2023-06-18 19:25:47 - strategies channel

**AndyL**

I understand the :face_vomiting: from [@U4H19D1D2](@U4H19D1D2) and I think for strategies that are showing 1-2% or more ROI, why would you bother adding 1000s of potentially -EV bets..? However, from recent experience in comparing a rather weak market-maker strategy I had, which was a mere 0.2% roi, I actually found that over the long run hedging vs not-hedging made the same amount of money, but the difference was the hedge method had a max drawdown of about -£50, whereas the non-hedge method a drawdown of -£2000 !!

---

## 2023-06-17 10:54:50 - general channel

**AI Trader**

Hi guys,

I am looking for a solution to test strategies with small amounts of money. I know I. can limit that through software and using the concept of strategies in the orders and etc, but I was wondering if there is any way to have anything similar to a sub-account (as in crypto exchanges), so regardless of software bugs, I can guarantee I will be using a limited amount of money for a strategy. Any ideas on this? [https://support.betfair.com/app/answers/detail/a_id/94|Betfair seems not to allow multiple accounts per client](https://support.betfair.com/app/answers/detail/a_id/94|Betfair seems not to allow multiple accounts per client)

---

## 2023-06-17 03:00:02 - issues channel

**Aaron Smith**

I see. How about:

```def cancel_all(strat: BaseStrategy, framework: Flumine) -&gt; None:

    """cancels all executable orders of strat and waits for confirmation"""

    num_cancel_attempts = 5

    for _ in range(num_cancel_attempts):

        for market in framework.markets:

            orders = market.blotter.strategy_orders(strategy=strat, order_status=[OrderStatus.EXECUTABLE])

            cancel_orders(market=market, orders=orders)

        [http://logging.info|logging.info](http://logging.info|logging.info)('Sleeping for 3s')

        time.sleep(3)  # waiting for orders to be cancelled in another thread



        e_orders = []

        for market in framework.markets:

            orders = market.blotter.strategy_orders(strategy=strat, order_status=[OrderStatus.EXECUTABLE])

            e_orders += orders

            [http://logger.info|logger.info](http://logger.info|logger.info)(f"{len(orders)} orders executable in market {market.market_id}")

        if not e_orders:

            break

    else:

        logger.warning(f"failed to cancel {len(e_orders)} orders")```

this function would be called in BaseStrategy.finish()

downsides:

• If order takes longer than 3s to cancel, we d send out multiple cancelations for the same order (but maximum 5 and with 3s delay between attempts, so i guess that should be fine?)

upsides:

• if an order slips through, we try to cancel again

• giving up instead of infinte while loop (maybe not perfect either, but the lesser evil?)

---

## 2023-06-16 18:02:49 - random channel

**R**

can confirm.  liquidity is really the issue when using kelly.  Assuming your model/pricing is not terrible.

---

## 2023-06-16 17:38:44 - random channel

**liam**

Yeah market capacity kills Kelly, Kelly bet sizing (per odds) is powerful though 

---

## 2023-06-16 17:36:15 - random channel

**Jonjonjon**

Has anyone managed to use Kelly successfully to compound big returns, or are there caveats that would prevent it working on Betfair? At present I just use  level bet sizes.

---

## 2023-06-16 16:27:57 - issues channel

**liam**

So I need to make changes to stop the streams correctly but I think you are better to place this code in the strategy itself, for example your worker:



```def terminate(context: dict, framework: Flumine) -&gt; None:

    # ... logic to terminate

    framework.handler_queue.put(TerminationEvent)```

This will trigger `BaseStrategy.finish` to be called which would contain



```    def finish(self, flumine) -&gt; None:

        # called before flumine ends

        for market in flumine.markets:

            for order in market.blotter.strategy_orders(self, order_status=[OrderStatus.EXECUTABLE]):

                market.cancel_order(order)



        while True:

            e_orders = []

            for market in flumine.markets:

                orders = market.blotter.strategy_orders(self, order_status=[OrderStatus.EXECUTABLE])

                e_orders += orders

                [http://logger.info|logger.info](http://logger.info|logger.info)(f"{len(orders)} orders executable in market {market.market_id}")

            if e_orders:

                [http://logger.info|logger.info](http://logger.info|logger.info)("Sleeping for 3s")

                time.sleep(3)

            else:

                break```

I just tested this and it works really well

---

## 2023-06-16 09:33:44 - issues channel

**Aaron Smith**

is there the possibility of me sending the cancel request for all orders and while waiting for its completion, my strategy placing new bets that then will still be left out there? So basically i d have to:

1. stop framework from placing any new orders

2. send cancel request for all orders

3. wait for confirmation

4. put terminationEvent

?

---

## 2023-06-16 09:21:33 - issues channel

**liam**

I think its best to solve the problem first, why no use of the strategy exposure / bets?

---

## 2023-06-16 09:20:45 - issues channel

**Aaron Smith**

[@U4H19D1D2](@U4H19D1D2) i can be rather careless, but thats also why i would never remove any controls :smile: But i think there is only so much flumine can do in this case. Its not like any individual order broke the order exposure, but i didnt set any strategy exposure or a maximum amount of bets it could place, so flumine has no reason to assume i didnt want to put my whole bank roll out in one go there.

---

## 2023-06-15 09:06:22 - random channel

**Tom**

Legend, cheers. I have a shitty logging control instance I copied from a walkthrough somewhere once but didn't do much (anything) to improve it.



Are these to hold custom data so I can put in my strategy-code and pull those out of the cleared orders file?

```    "market_note",

    "trade_notes",

    "order_notes",```



---

## 2023-06-14 12:51:51 - random channel

**Aaron Smith**

this may be an odd and unnecessarry Q, but anyways: In flumine.BaseStrategy.process_market_book we get a Market and a MarketBook object, however a Market already contains the MarketBook under Market.market_book. Is there any reason we are still getting them both separately? Can the MarketBook i am given ever differ from what i get in Market.market_book?

---

## 2023-06-14 05:33:57 - strategies channel

**liam**

As above but market filter also accepts a list so you can split but with a single strategy 

---

## 2023-06-13 18:21:28 - strategies channel

**George**

perfect thanks. so you are essentially able to run your strategy 24/7 without ever manually intervening?

---

## 2023-06-13 18:18:06 - strategies channel

**George**

Indeed - thanks for pointing out. I have set these limits and I am happy with them. However, I am more concerned around the fact that my supposedly fully-automated strategy might have terminated (either gracefully or not) due to a Betfair outage (or similar), and that - as a result - I will need to manually intervene in order to restart it.

Does anyone have any experience with needing to do that, and in what cases does it occur / how does Flumine respond?

---

## 2023-06-13 18:12:34 - strategies channel

**Jonjonjon**

Good question. when creating a Strategy you can limit your selection exposure, order exposure, number of live orders. I think it's in the BaseStrategy class

---

## 2023-06-13 17:57:08 - strategies channel

**AndyL**

Depends if you hedge or not... any win/losses average out over time... Last Sunday I lost -£120 on my hedging strategy :-)

---

## 2023-06-13 17:39:46 - betconnect channel

**Sam - DH**

Cheers for getting back to me Adam - I think maybe I've overlooked the necessity to officially create these strategy refs before assigned them to Bets. Thanks for pointing that section out in BC wrapper, I'll have a mess about with this from here and get back to you if I run into issues. Sam

---

## 2023-06-13 17:17:14 - strategies channel

**George**

If I was to develop a 24/7 fully automated market-making strategy, I imagine there are a number of things that could go wrong because of Betfair outages and similar things.

• Is anyone able to point me to the code where Flumine deals with these sorts of issues, so that I can be aware of what kinds of manual intervention might be required?

• I imagine several people in this slack are running strategies of this kind, do you have any kind of advice for someone starting out on this path?

---

## 2023-06-11 13:21:54 - general channel

**PeterLe**

Hi, sorry newbie question...can someone please explain this setting in simple terms :

```multi_order_trades: bool = False,```

If you were trading the same market, how would it work in conjunction with :

```max_live_trade_count: int = 15,```

Thanks in advance

---

## 2023-06-11 11:32:09 - random channel

**D C**

[https://www.amazon.co.uk/Betfair-Trading-Made-Simple-Ultimate/dp/1980887039/ref=sr_1_1?crid=3PIPU3F84WQ9X&amp;keywords=caan+berry+betfair&amp;qid=1686479509&amp;sprefix=caan+berry%2Caps%2C90&amp;sr=8-1|https://www.amazon.co.uk/Betfair-Trading-Made-Simple-Ultimate/dp/1980887039/ref=sr_1_[…]+betfair&amp;qid=1686479509&amp;sprefix=caan+berry%2Caps%2C90&amp;sr=8-1](https://www.amazon.co.uk/Betfair-Trading-Made-Simple-Ultimate/dp/1980887039/ref=sr_1_1?crid=3PIPU3F84WQ9X&amp;keywords=caan+berry+betfair&amp;qid=1686479509&amp;sprefix=caan+berry%2Caps%2C90&amp;sr=8-1|https://www.amazon.co.uk/Betfair-Trading-Made-Simple-Ultimate/dp/1980887039/ref=sr_1_[…]+betfair&amp;qid=1686479509&amp;sprefix=caan+berry%2Caps%2C90&amp;sr=8-1)

---

## 2023-06-11 09:56:09 - random channel

**foxwood**

That's true for traditional disk drives where lots of small files are sprinkled around the drive at random. The needed head movement and rotational latency wastes significant amounts of time. With ssds' that problem goes away. The remaining issue is that of finding the true file address which means searching directory sectors. While ssd's still have to do that, the time taken and access speed to the directory sectors is very fast. I organize my files in folders by event type and date (eg "HR230611" for today's horses) which helps minimize the search time when the strategy is given a long list of files to work through for backtest.

---

## 2023-06-10 10:51:02 - strategies channel

**liam**

Yeah that looks fine assuming live is the same, if you can get some strategy code that replicates the issue I can run on my recorded market.



Btw any reason you need 20s of pre play rather than filter just in play on the kwargs?

---

## 2023-06-10 10:47:31 - strategies channel

**AndyL**

```def run_process(markets):

    uid = str(os.getpid())



    client = clients.SimulatedClient()

    framework = FlumineSimulation(client=client)

    bsp_file = "hrbsp/hrbsp_"+uid

    strategy = UkHrBot(framework, bsp_file,

        market_filter={"markets": markets,

                   "listener_kwargs": {"seconds_to_start": 20}

                  },

        max_order_exposure=500,

        max_selection_exposure=500,

        max_live_trade_count=4

    )



    with mock_patch("builtins.open", smart_open.open):

        control = BacktestLoggingControl("results/hrorders_"+uid+".txt")

        framework.add_logging_control(control)

        framework.add_strategy(strategy)

        framework.run()```

---

## 2023-06-10 07:27:53 - strategies channel

**liam**

Any context to the strategy in terms of order type (passive)/ size/quantity? How off is it?



I find it accurate enough to trust simulations when used correctly, volatility certainly makes things tricky 

---

## 2023-06-08 16:47:34 - strategies channel

**Lee**

in the strategy you should be calling `market.cancel_order(order)`

---

## 2023-06-08 14:15:37 - strategies channel

**R**

n00b question here.



I've built and maintained my own backtesting / simulation framework but it's not as well refined as Flumine, so I'm in the process of figuring out how to work with flumine.



One thing I have is a bunch of historical market data (PRO data from betfair exchange).  I'm running the `SimulatedClient` along with the `FlumineSimulation` framework.  Things are going well except that I get `Market is not open` when running things.  Is there a flag to be set to ignore this and just run the strategy with simulated returns / execution or am I completely misunderstanding things?

---

## 2023-06-07 18:05:25 - random channel

**foxwood**

Bite the bullet and refactor into a GPSdata class. One data instance per event in a base market class shared and inherited by the sub-markets. If you've got proper stuff going in C++ I'd stick with that rather than switch to Python and it's own brand of weird. Having said that I started auto-converting flumine to C++ initially but abandoned that due to having to implement the lower level foibles and libraries of Python. Considered it more important to start recording data / betting / losing money than worry about the language.

---

## 2023-06-07 12:44:11 - strategies channel

**Aaron Smith**

[@UBS7QANF3](@UBS7QANF3) you are correct that assuming that there is no systematic bias in the bet selection of any strategy would be a questionable claim to make without any further proof given. However, i didnt claim this was true for any of my strategies. I merely constructed such a strategy for the purpose of showing an example of an EV calculation that may (for this particular strategy) be accurate in the sense that pnl/EV would eventually converge towards 1 over time, but would still be inaccurate in the sense that this could be a very slow process and there are obviously better ways to calculate an EV.

---

## 2023-06-07 12:30:27 - general channel

**C0rnyFlak3s**

Hello guys, it’s been a while since I was active in this slack, now I’m returning to the field in full steam. I was constructing an extensive odds feed database myself to validate my value models over the last couple months. So far so good, but now I want to backtest my models on my data feed. I have written a custom game matcher which matches games from different bookmakers, however what I am still struggling with is a good source for historical results data. Sure, I can extract many result stats from my data myself, but I would rather enjoy an API service that lets me pull results (including corners etc.  besides just goals).



So my question to you guys is, are you using 3rd party services to get results data on already finished games, and if you do, can you maybe point me to a place which offers a great sports/league coverage? It doesn’t need to be a free service, paid services are also welcome if they offer an API endpoint to pull historical results. Thanks.

---

## 2023-06-07 12:20:51 - strategies channel

**Mo**

I'm not (yet) convinced by your argument. You seem to be saying that provided there is no systematic bias in your probabilities compared to the market then you can use whatever probability you want for the EV calculation. It seems contrived to think there is no systematic bias in your probabilities compared to the market and, in fact, in all likelihood there must be some for you to identify a mispricing



Example situation where the EV could be misleading:



1. Your strategy backs long price horses

2. You calculate EV using market implied probabilities calculated from BSP using the standard overround removal method

3. Your overround removal method has failed to account for favourite longshot bias, the market implied probabilities are too high and your EV is an overestimate

---

## 2023-06-07 11:32:42 - issues channel

**Tom**

I'm having a nightmare of a time trying to use RaceCards; I want to call them to get results, bsp, market data e.t.c. - Wouldnt mind seeing the full functionality; there is something there that even has form related data (I presume it's not available for Australian horse racing?).



I've spun myself around enough times to not really know what to try next.



```def get_race_results(race_card: RaceCard, market_ids: List[str]):

    logging.debug(f"Getting race card for market_ids: {market_ids}")

    try:

        racecards = race_card.get_race_card(market_ids, data_entries="RACE")

        race_results = race_card.get_race_result(market_ids)

        print(f"race results are {race_results}")

        logging.debug(f"Received race card data: {racecards}")

    except Exception as e:

        logging.error(f"Failed to get race card data: {e}")

        return []



    result = []

    for race in racecards:

        logging.debug(f"Processing race: {race['raceName']}")

        for runner in race['runners']:

            runner_data = {

                "Market ID": race['marketId'],

                "Race Name": race['raceName'],

                "Race Time": race['raceTime'],

                "Runners": race['numberOfRunners'],

                "Distance": race['distance'],

                "Runner Name": runner['runnerName'],

                "Runner ID": runner['selectionId'],

                "Starting Price": runner['sp'],

                "Final Position": runner['finishingPosition'],

                "In-Play High Price": runner['inPlayHighPrice'],

                "BSP": runner['bsp'],

            }

            result.append(runner_data)

            logging.debug(f"Processing runner_data: {runner_data}")



    return result



def get_results(trading):

    date_str = datetime.date.today().strftime("%d-%m-%Y")

    file_path = f'data/market_trade_data/market_trade_data_{date_str}.pkl'

    market_trade_data = pd.read_pickle(file_path)

    logging.debug(f"Market trade data: {market_trade_data}")

    market_ids = refresh_market_ids(market_trade_data)



    race_card = trading.RaceCard.login()

    try:

        trading.race_card.login()

        print("Logged in successfully.")

    except Exception as e:

        print(f"Failed to log in: {e}")



    all_results = []

    for market_id in market_ids:

        logging.debug(f"Getting race results for market_id: {market_id}")

        all_results.extend(get_race_results(race_card, [market_id]))



    df_results = pd.DataFrame(all_results)

    df_results.to_csv(f"data/race_results/race_results_{date_str}.csv", index=False)

    logging.debug(f"Saved race results to 'data/race_results/race_results_{date_str}.csv'")```

---

## 2023-06-06 20:46:58 - random channel

**PeterLe**

In-play only UK/Ire Horses

I just tried running a strategy on the Dogs, 28472 Markets, took 9:17 (So not easy to compare)



```STRATEGY_KWARGS = {'inplay': False, 'seconds_to_start': 660} ```

---

## 2023-06-06 14:59:53 - strategies channel

**Aaron Smith**

nothing of the kind, its about discussing reasons for why pnl/EV (pnl divided by EV) may not converge to 1 (if that is possible), where pnl is regarding a strategy, not a single bet, and EV is calculated based on placed bets in the past by that same strategy and calculated by using final market prices

---

## 2023-06-06 13:58:00 - strategies channel

**Aaron Smith**

I think we maybe need to differentiate between 2 ways an EV can be inaccurate:

1. pnl/EV converges towards 1 over time, but slowly.

2. pnl/EV does not converge towards 1

For example, if i have a strategy that is equally likely to back or lay a runner, independent on the odds, then i could calculate an EV by just comparing the odds i took to 1/n (basically using 1/n where n = number of runners instead of some kind of final price). This EV would obviously be super inaccurate, but still correct in the sense that pnl/EV would over time still converge to 1, just super slowly.



I m more interested in case 2. Suppose we take final prices (at schedueled off) to calc our EV, can you come up with any reason pnl/EV would not converge towards 1 over time? Or have you had strategies that showed amazing EV (calculated from actual bets, not simulation), but you disregarded them based on actual pnl? If so, did you find any reason on how the EV came to be inflated?

---

## 2023-06-06 13:43:59 - strategies channel

**liam**

I have found a higher EV can equal higher ROI (as expected) but as you are implying only when the EV is accurate, it tends to highlight model inefficiencies as well

---

## 2023-06-05 23:16:51 - issues channel

**foxwood**

In `process_closed_market()` I walk the blotter and log all the bets marked as `EXECUTION_COMPLETE` For the first time today I found there were lots of unmatched lapsed bets that were not logged. From the live strategy log it seems that the market was closed and removed before `"Order status update: Execution complete"` was received for these bets ! Is this normal everyday stuff that I've not noticed before or was it just BF having a bad day ?



Edit: All the bets were `MARKET_ON_CLOSE` and less than £10 liability so guessing that's maybe what happens if not enough to make the SP draw. Wonder what the `OrderStatus` would be in that case ?

---

## 2023-06-05 22:56:17 - random channel

**foxwood**

That's all I've ever done - add a massive list of files to be processed as part of the strategy constructor

```market_filter={"markets": markets,

               "listener_kwargs": { ...```

If only called with one market then there would be a significant overhead of having to teardown / construct the strategy every time a file was to be processed. Or have I misunderstood the question or some subtle point ?

---

## 2023-06-04 09:41:32 - general channel

**Jonjonjon**

Must be some sort of super hft strategy if they want to remove the if statement. Reminds me of something I read about a guy who would parse order stream messages before they fully arrived (on an Asian financial exchange, not Betfair).

---

## 2023-06-03 03:18:06 - general channel

**thambie1**

Anyone know if it's possible to login using the API using a trading master account? Currently getting error "TRADING_MASTER" when I try.

---

## 2023-06-02 14:18:09 - random channel

**Peter**

You're right that there are different approaches to database replication. The [https://dev.mysql.com/doc/refman/8.0/en/replication-solutions.html|MySQL documentation explains many of them](https://dev.mysql.com/doc/refman/8.0/en/replication-solutions.html|MySQL documentation explains many of them). But it's a pretty technical area and I wouldn't try to set it up and manage it yourself unless you're an experienced DBA (i which case why ask the question?).



The right solution absolutely depends on why you need a replicated database, so how others do it is pretty irrelevant. but since you asked, it's a standard feature of most cloud database services including AWS's RDS, which is how I do it, allowing me to focus on my trading apps and not get bogged down with irrelevant database issues.

---

## 2023-06-02 09:40:38 - issues channel

**Andy**

def start_stream(bfl_trading, bfl_client, event_types=["horse", "greyhound"]):

    """Retrieves a json dictionary with the stream data from the specified event types."""

    for event in event_types:

        event_types[event_types.index(event)] = EVENT_TYPE_IDS[event]



    # create queue

    output_queue = queue.Queue()



    # create stream listener

    listener = betfairlightweight.StreamListener(output_queue=output_queue)



    # create stream

    streamH = bfl_trading.streaming.create_stream(listener=listener)

    streamG = bfl_trading.streaming.create_stream(listener=listener)



    # Create filters to get the events

    horse_market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["AU"],

        market_types=["WIN"]

    )

    greyhound_market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["4339"],

        country_codes=["AU"],

        market_types=["WIN"]

    )



    market_data_filter = filters.streaming_market_data_filter(

        fields=["EX_BEST_OFFERS", "EX_MARKET_DEF"], ladder_levels=3

    )





    # subscribe

    horse_streaming_unique_id = streamH.subscribe_to_markets(

        market_filter=horse_market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=5000,  # send update every 1000ms

    )



    greyhound_streaming_unique_id = streamG.subscribe_to_markets(

        market_filter=greyhound_market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=5000,  # send update every 1000ms

    )



    # start stream in a new thread (in production would need err handling)

    tH = threading.Thread(target=streamH.start, daemon=True)

    tH.start()

    tG = threading.Thread(target=streamG.start, daemon=True)

    tG.start()



    return streamH, output_queue

---

## 2023-06-01 22:34:54 - issues channel

**AI Trader**

I am placing my orders through threads concurrently.  I can see that when the strategy starts, the first orders are placed successfully.

Are you aware of any limitations imposed by Betfair? I've found [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Exceptions|here](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Exceptions|here) that:



[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/placeOrders|placeOrders](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/placeOrders|placeOrders), [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/cancelOrders|cancelOrders.](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/cancelOrders|cancelOrders.) [https://docs.developer.betfair.com/pages/viewpage.action?pageId=2621600|updateOrders](https://docs.developer.betfair.com/pages/viewpage.action?pageId=2621600|updateOrders), [https://docs.developer.betfair.com/pages/viewpage.action?pageId=2621599|replaceOrders](https://docs.developer.betfair.com/pages/viewpage.action?pageId=2621599|replaceOrders) if the number of transactions (instructions) submitted exceeds 1000 in a single second causes an error. This is by far not my case (I am sending less than 100 requests per second surely).

---

## 2023-06-01 21:51:52 - issues channel

**AI Trader**

I get this error every time I run the strategy. After a couple of minutes running the strategy, I get dozens of these messages in a couple of seconds (It's an HFT strategy), and from there no orders are placed anymore, only errors. Do you have any guesses on what could be happening?

---

## 2023-06-01 21:48:41 - issues channel

**AI Trader**

[@UBS7QANF3](@UBS7QANF3) I have. It's weird because I manage to login thorugh the betfairlightweight api and place orders successfuly. But whenever I run my strategy, some time after I get the error below



```2023-06-01 20:46:58,742 - ERROR - executor.replace - ERROR REPLACE: SportsAPING/v1.0/replaceOrders 

Params: {'marketId': '1.214777671', 'instructions': [{'betId': '309396638021', 'newPrice': 4.3}]} 

Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retries exceeded with url: /exchange/betting/json-rpc/v1 (Caused by SSLError(SSLZeroReturnError(6, 'TLS/SSL connection has been closed (EOF) (_ssl.c:997)')))```

---

## 2023-06-01 18:04:42 - betconnect channel

**Lee**

have you tried setting the locale in the way liam mentioned

```trading = betfairlightweight.APIClient(

        "username", 

        "password", 

        app_key="app_key", 

        locale="spain"

    )```

---

## 2023-05-30 21:51:46 - betconnect channel

**Alejandro Pablos Sánchez**

[Running] python -u "c:\Users\aleja\OneDrive\Escritorio\Tipster_Auto\src\login2.py"

Traceback (most recent call last):

  File "c:\Users\aleja\OneDrive\Escritorio\Tipster_Auto\src\login2.py", line 7, in &lt;module&gt;

    trading.login_interactive()

  File "C:\Users\aleja\AppData\Roaming\Python\Python38\site-packages\betfairlightweight\endpoints\logininteractive.py", line 30, in __call__

    (response, response_json, elapsed_time) = self.request(

  File "C:\Users\aleja\AppData\Roaming\Python\Python38\site-packages\betfairlightweight\endpoints\logininteractive.py", line 63, in request

    self._error_handler(response_json)

  File "C:\Users\aleja\AppData\Roaming\Python\Python38\site-packages\betfairlightweight\endpoints\logininteractive.py", line 70, in _error_handler

    raise self._error(response)

betfairlightweight.exceptions.LoginError: API login: AUTHORIZED_ONLY_FOR_DOMAIN_ES

---

## 2023-05-30 21:49:40 - betconnect channel

**Alejandro Pablos Sánchez**

`import betfairlightweight`



trading = betfairlightweight.APIClient('username', 'password', 'app_key')

trading.api_base = '[https://identitysso.betfair.es/api/login](https://identitysso.betfair.es/api/login)'

trading.locale = 'es'



trading.login_interactive()

---

## 2023-05-27 15:13:26 - issues channel

**Jeff Waters**

Thanks Derek. Does that delay even apply with simulated trading, using historical data?

---

## 2023-05-27 12:10:55 - issues channel

**Jeff Waters**

Hi



I'm doing back testing, and using market.cancel_order(order) to cancel orders, like so:



```def cancel_order(self, market: Market, order: BaseOrder):

    with market.transaction() as t:

        t.cancel_order(order)```

However, the logger shows that an exception was thrown:



  *File "C:\Users\User\Documents\New back test\venv\lib\site-packages\flumine\execution\transaction.py", line 101, in cancel_order*

    *order.cancel(size_reduction)*

  *File "C:\Users\User\Documents\New back test\venv\lib\site-packages\flumine\order\order.py", line 339, in cancel*

    *raise OrderUpdateError("Order does not currently have a betId")*

*flumine.exceptions.OrderUpdateError: Order does not currently have a betId*

*ERROR - FlumineException Order does not currently have a betId in process_market_book (1.145085632)*



I'm using the following code to create orders:



```order = OrderFactory().non_bsp_order(self, back_or_lay, target_price, stake, runner, market_book)

with market.transaction() as t:

    t.place_order(order)```

and this is what the OrderFactory method looks like:



```def non_bsp_order(self, strategy_object: BaseStrategy, back_or_lay: str, bet_price: float, stake_size: float,

                  runner: RunnerBook, market_book: MarketBook) -&gt; BetfairOrder:

    trade = Trade(

        market_book.market_id,

        runner.selection_id,

        runner.handicap,

        strategy_object,

    )

    return trade.create_order(

        side=back_or_lay, order_type=LimitOrder(price=bet_price, size=stake_size)

    )```

Where am I going wrong, please?

---

## 2023-05-26 22:28:58 - general channel

**Jonjonjon**

I'm not sure if this is correct or not, but will [https://github.com/betcode-org/betfair/blob/e4d58fd369312408c04519be1520e35b0dfc61dc/betfairlightweight/endpoints/betting.py#L241|list_market_book](https://github.com/betcode-org/betfair/blob/e4d58fd369312408c04519be1520e35b0dfc61dc/betfairlightweight/endpoints/betting.py#L241|list_market_book) do it? Disclaimer: I haven't tried it.

---

## 2023-05-25 19:54:46 - random channel

**mandelbot**

I'm nowhere near that but I just leave enough to cover my drawdown + some. Why should you leave money on there you don't use when you could buy bonds or shares etc intead? Not to mention risk a strategy going haywire and wiping you out

---

## 2023-05-25 19:43:01 - betconnect channel

**Adam O'Dwyer**

Hi Sam, from the BetConnect side - that field can be passed and stored from the Back and Lay perspective. With regards to it sticking, is their a particular endpoint or call that you expect to see it on? I see mention of it in the Betcode betconnect wrapper [https://github.com/betcode-org/betconnect/blob/683cbff1248106613c26038b9a84aecbb5036f1a/betconnect/resources/betting.py#L62|here](https://github.com/betcode-org/betconnect/blob/683cbff1248106613c26038b9a84aecbb5036f1a/betconnect/resources/betting.py#L62|here).

---

## 2023-05-25 16:01:53 - betconnect channel

**Sam - DH**

Afternoon team, could someone confirm for me please if the customer_strategy_ref is designed *only* to be used on the back side?

Searched far as I could before coming here, [https://developer.betconnect.com/](https://developer.betconnect.com/) suggests it's supported on both, and the bet_request_match and bet_request_match_and_more endpoints seem to accept my custom refs and lay my bets, but am having no luck getting them to actually stick to our lay bets. I did also note there's no mention of customer_strategy_ref in the python wrapper so, requesting backup. Cheers in advance for any help

---

## 2023-05-25 11:53:07 - random channel

**Jonjonjon**

Currently running 350-400 Flumine Strategy instances...

---

## 2023-05-25 11:34:17 - random channel

**Herugrim**

Yeah and because you pay commission per market per account you would generally end up paying more commission, especially if your accounts ran competing strategies. It’s painful to setup and even more painful to manage. 



IMO the only reason to need one is if you were deploying bots that have to potential to go rogue and drain your balance, but that comes back to improving your coding and best practices. It’s easier just to use strategy refs

---

## 2023-05-25 11:22:03 - random channel

**Mo**

Less reason to have them now we have order and strategy refs but they predated those 

---

## 2023-05-25 08:24:00 - general channel

**liam**

Not sure how keras/h5 works but to start with I imagine loading the model is slow and is shared so could be done in `Strategy.add`



```def add(self):

    self.model = tf.keras.models.load_model(ModelName) ```

---

## 2023-05-25 07:57:37 - general channel

**Andy B**

I think that I am accessing the keras model to make predictions too fast when back testing against the market stream:

2023-05-25 16:21:56,369:CRITICAL:Unknown error bad allocation in process_market_book (1.212040559)

Traceback (most recent call last):

  File "C:\Python\lib\site-packages\flumine\utils.py", line 239, in call_strategy_error_handling

    return func(market, market_book)

  File "C:\Python\Scripts\flumine\FlumineSims.py", line 228, in process_market_book

    ModelName = tf.keras.models.load_model(ModelName)

  File "C:\Python\lib\site-packages\keras\utils\traceback_utils.py", line 70, in error_handler

    raise e.with_traceback(filtered_tb) from None

  File "C:\Python\lib\site-packages\h5py\_hl\files.py", line 533, in __init__

    fid = make_fid(name, mode, userblock_size, fapl, fcpl, swmr=swmr)

  File "C:\Python\lib\site-packages\h5py\_hl\files.py", line 226, in make_fid

    fid = h5f.open(name, flags, fapl=fapl)

  File "h5py\_objects.pyx", line 54, in h5py._objects.with_phil.wrapper

  File "h5py\_objects.pyx", line 55, in h5py._objects.with_phil.wrapper

  File "h5py\h5f.pyx", line 106, in h5py.h5f.open

  File "h5py\h5fd.pyx", line 155, in h5py.h5fd.H5FD_fileobj_get_eof

  File "h5py\h5fd.pyx", line 155, in h5py.h5fd.H5FD_fileobj_get_eof

MemoryError: bad allocation



That makes sense if it is multi-processing and trying to open it n number of times I guess, but I am not sure if there is a way to do this without slowing down the stream.  Is there a better way to do this?

---

## 2023-05-25 06:00:28 - general channel

**Andy B**

Thanks Liam,

    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:



        if market.seconds_to_start &lt;= 5 and market_book.inplay == False:



            [http://logging.info|logging.info](http://logging.info|logging.info)(f"Inside the last 5 seconds for this market and race is not inplay")

            ThisMarket = TodaysRunners[TodaysRunners['MarketID'] == market_book.market_id]



            for runner in market_book.runners:

				if runner.status == "ACTIVE" and runner.ex.available_to_back:

					row_index = ThisMarket[(ThisMarket['MarketID'] == market_book.market_id) &amp; (ThisMarket['SelectionID'] == runner.selection_id)].index

					if len(row_index) &gt; 0:

						# Update the value in the BSP column for the matching row

						ThisMarket.loc[row_index, 'BSP'] = runner.ex.available_to_back[0]['price']



            RaceFull = ThisMarket[['TrackName','RaceNumber','Distance','HorseName','Num','MarketID','SelectionID']].copy()

            scaled_features = StandardScaler().fit_transform(Race.values)

            ModelName = 'HorseModel2M.h5'

            ModelName = tf.keras.models.load_model(ModelName)

            Predictions = ModelName.predict(scaled_features)

            RaceFull['Probability'] = Predictions

            RaceFull['Model'] = 'Model9'

            RaceFull = RaceFull.sort_values(by = 'Probability', ascending=False)

            RaceFull = RaceFull.fillna(0)

---

## 2023-05-24 09:01:13 - issues channel

**Jeff Waters**

Hi



I've amended the error handling method to print the details of the errors:



```def call_strategy_error_handling(

    func: Callable, market, market_book: MarketBook

) -&gt; Optional[bool]:

    try:

        return func(market, market_book)

    except FlumineException as e:

        logger.error(

            "FlumineException %s in %s (%s)" % (e, func.__name__, market.market_id),

            exc_info=True,

        )

        print(e)

    except Exception as e:

        logger.critical(

            "Unknown error %s in %s (%s)" % (e, func.__name__, market.market_id),

            exc_info=True,

        )

        print(e)

        if config.raise_errors:

            raise

    return False```

How do I get it to print a full stack trace, please? Currently, the output is just telling me 'list index out of range', but it would be helpful to know which bit of my code was responsible for that error.



GPT suggested adding:



traceback_str = traceback.format_exc()  # Get the formatted traceback as a string

print(traceback_str)  # Print the stack trace



However, that had no effect.



Thanks

---

## 2023-05-23 12:09:19 - strategies channel

**river_shah**

Sorry if this is a digression and over engineered for your use case but as you say "best", the answer is in mean variance optimization. The mathematically grounded way is that you come up with strategy expectations of returns and covariances and then blend all individual strategies into a meta strategy and trade that. The meta strategy assigns positions limits to ensure you don't blow through market capacity.

---

## 2023-05-22 12:25:15 - strategies channel

**James**

Is there a “best” way of mitigating risk when using highly correlated strategies, ie those whose selections overlap? Eg  80% of selections in strategy B are also selections in strategy A (albeit placed by auto instead of manually and at a difference time). Likewise 60% of selections in strategy C are also picked in strategy A. Capping the max exposure per selection to a fixed amount is one option but I wondered whether there is a better way. Thanks

---

## 2023-05-19 14:36:02 - general channel

**Unknown**

Good morning, everyone. Yesterday, while using _*betfairlightweight*_, I noticed that all soccer matches, once they appear as _*InPlay*_ on the Betfair website, take approximately 1 minute to show up for the first time in the API when you select to display `in_play_only=True` events. Additionally, it takes 2 minutes or more for them to stabilize and continuously appear without interruption.



```market_filter = betfairlightweight.filters.market_filter(

        event_type_ids=['1'],in_play_only=True

    )

    return trading.betting.list_events(filter=market_filter)```

Is this a normal occurrence when using the API with calls like the one above or similar to the test video I made using [https://docs.developer.betfair.com/visualisers/api-ng-sports-operations/](https://docs.developer.betfair.com/visualisers/api-ng-sports-operations/)?



Im asking because, for example, in _*Geeks Toy Software*_, once it shows as _*InPlay*_, it stays that way, and the same goes for the Betfair website. However, when using the API, this oscillating occurs.

---

## 2023-05-17 02:27:32 - strategies channel

**Alex**

It also depends on the number of bets placed, i.e. are you closing out bets half way through the race, then placing new bets? With 1000 datapoints your estimated strategy performance will have larger error than with 10000. Overfitting might be an issued based on how many parameters your model has (you'll likely be fine if you just have a few). You can try to bootstrap standard errors of your strategy to get an idea of how significant your results are.

---

## 2023-05-15 17:05:18 - strategies channel

**Paul**

However I might just be talking through my pocket - I’ve not got that much data yet, so that’s the reason my models aren’t profitable, it can’t be my fault, surely? :joy: 

---

## 2023-05-15 17:04:13 - strategies channel

**Paul**

I think if your models are focused on fundamentals, smaller with reference to BSP like Mo suggested is a great indicator and you can have strong confidence on a smaller sample size. If price action based, you might need 10k+ examples, but you could have tens or hundreds of examples per event. However, I think it’s worth pointing out that regardless there are not many 2yo 5f events, or 4m Hcap Chase events, or races with pre-off fav below 1.2 or higher than 7.0, and the fundamentals and price action - even pre-event - are going change over all the spaces in between. I think I’d want a large enough sample space across all those dimensions, and so you get closer to 10k events - about 2.5 years of racing.

---

## 2023-05-13 09:52:48 - general channel

**Dennis**

did something change in the list_cleared_orders endpoint? I have some code that was working fine for ages but then fell over a few months back, now it just times out with an error

```cleared_orders = trading.betting.list_cleared_orders(

                bet_status="SETTLED",

                record_count=10,

                from_record=0,

                settled_date_range=range_dates

            )```

and I get an 'UNEXPECTED_ERROR' after a long time

---

## 2023-05-13 07:44:19 - strategies channel

**river_shah**

This is very much dependent on what your strategy is doing and what your modelling process is. If you want your strategy to pick up on weak long shot signals, need to throw more data at the problem. 10K is a heuristic that is very feasible computationally even on a laptop with flumine

---

## 2023-05-13 07:31:20 - strategies channel

**river_shah**

Much more depending on what your strategy is doing. 10K races is a minimum to avoid all kinds of data and backtest snooping issues.

---

## 2023-05-12 14:59:00 - random channel

**ShaunW**

Only approx 58.6% of the time [@USWDY5P7G](@USWDY5P7G) . :wink:  The morality model certainly isn't short of inputs so any conclusion is a range at best.

---

## 2023-05-10 09:53:47 - random channel

**liam**

Just run it with a base strategy that does nothing and aim for that

---

## 2023-05-10 09:41:41 - random channel

**Newbie99**

Yeah I suspect almost all of it can go! I simply didn’t realise how much of an impact it was having until I started Backtesting a new strategy (it only comes up in certain situations as anything in-play for example would already bypass this logic so haven’t noticed for a while)!



Seeing the cprofile results was quite an eye opener, I think this particular strategy generated a lot more orders that triggered this logic so really highlighted the inefficiency!

---

## 2023-05-10 08:50:45 - random channel

**Newbie99**

Its funny, but I wrote these functions, probably 2, maybe 3 years ago now (albeit they have grown into very slow moving monsters over time)! Back then they seemed to make sense!!!



I think the bulk of the issue is the sheer inefficiency of these two, as they get called a lot as part of my order validation (or cancellation) process:



```def check_race_type_by_country(race_type, market_name, event_type_id, country_dict):



    race_type = return_race_type(race_type, market_name, event_type_id)



    maiden = True if 'Mdn' in market_name else False



    if country_dict != False and isinstance(country_dict, dict):

        price = False

        # If a dict is in the config, it will match by country and race type

        maiden_list = [v for k,v in country_dict.items() if race_type == k]

        if len(maiden_list) &gt; 0:

            if isinstance(maiden_list[0], list):

                for m in maiden_list[0]:

                    if 'Mdn' in m.keys() and maiden is True:

                        price = m['Mdn']

                    else:

                        if 'default' in m.keys():

                            price = m['default']

            else:

                price = maiden_list[0]



        else:

            if 'default' in country_dict.keys():

                if 'odds' not in country_dict.keys() and 'runners' not in country_dict.keys():

                    maiden_list = country_dict['default']

                    if isinstance(maiden_list, list):

                        for m in maiden_list:

                            if 'Mdn' in m.keys() and maiden is True:

                                price = m['Mdn']

                            else:

                                if 'default' in m.keys():

                                    price = m['default']

                    else:

                        price = maiden_list

                else:

                    price = country_dict

    else:

        # If a single price (rather than a dict) is in the config, then it will set this for all valid markets

        if isinstance(country_dict, float) or isinstance(country_dict, int):

            price = country_dict

        else:

            price = False

    return price



def true_or_false(setting, country_code=False, market_id=False, market_type=False):

    if not isinstance(setting, list):

        if setting == 'True':

            return True

        elif setting == 'False':

            return False

        else:

            return setting

    else:

        if country_code is False or country_code is None or country_code == 'False':

            if setting == 'True' or setting is True:

                return True

            elif setting == 'False' or setting is False:

                return False

            else:

                if market_id is False:

                    if isinstance(setting, list):

                        default = [s for s in setting if isinstance(s, dict) and 'default' in s.keys()]

                        if len(default) &gt; 0:

                            if market_type is False:

                                return default[0]['default']

                            else:

                                market_type_benchmark = [s for s in setting if isinstance(s, dict) and market_type in s.keys()]

                                if len(market_type_benchmark) &gt; 0:

                                    return market_type_benchmark[0][market_type]

                                else:

                                    return default[0]['default']

                        else:

                            return setting

                    else:

                        return setting

                else:

                    for s in setting:

                        if market_id in s.keys():

                            if s[market_id] == 'True':

                                return True

                            elif s[market_id] == 'False':

                                return False

                            else:

                                return s[market_id]

                        else:

                            default = [s for s in setting if 'default' in s.keys()]

                            if len(default) &gt; 0:

                                if market_type is False:

                                    return default[0]['default']

                                else:

                                    market_type_benchmark = [s for s in setting if

                                                             isinstance(s, dict) and market_type in s.keys()]

                                    if len(market_type_benchmark) &gt; 0:

                                        return market_type_benchmark[0][market_type]

                                    else:

                                        return default[0]['default']

                            else:

                                return False

                    else:

                        default = [s for s in setting if 'default' in s.keys()]

                        if len(default) &gt; 0:

                            if market_type is False:

                                return default[0]['default']

                            else:

                                market_type_benchmark = [s for s in setting if

                                                         isinstance(s, dict) and market_type in s.keys()]

                                if len(market_type_benchmark) &gt; 0:

                                    return market_type_benchmark[0][market_type]

                                else:

                                    return default[0]['default']

                        else:

                            return False

        else:

            for s in setting:

                if isinstance(s, dict):

                    if country_code in s.keys():

                        if s[country_code] == 'True':

                            return True

                        elif s[country_code] == 'False':

                            return False

                        else:

                            if isinstance(s[country_code], dict):

                                if market_type in s[country_code].keys():

                                    return s[country_code][market_type]

                                else:

                                    if 'default' in s[country_code].keys():

                                        return s[country_code]['default']

                                    else:

                                        return False

                            else:

                                return s[country_code]

                    else:

                        if market_id is False:

                            default = [s for s in setting if 'default' in s.keys()]

                            if len(default) &gt; 0:

                                if market_type is False:

                                    return default[0]['default']

                                else:

                                    market_type_benchmark = [s for s in setting if

                                                             isinstance(s, dict) and market_type in s.keys()]

                                    if len(market_type_benchmark) &gt; 0:

                                        return market_type_benchmark[0][market_type]

                                    else:

                                        return default[0]['default']

                            else:

                                return setting

                        else:

                            if market_id in s.keys():

                                if s[market_id] == 'True':

                                    return True

                                elif s[market_id] == 'False':

                                    return False

                                else:

                                    return s[market_id]

            else:

                default = [s for s in setting if isinstance(s, dict) and 'default' in s.keys()]

                if len(default) &gt; 0:

                    if market_type is False:

                        return default[0]['default']

                    else:

                        market_type_benchmark = [s for s in setting if

                                                 isinstance(s, dict) and market_type in s.keys()]

                        if len(market_type_benchmark) &gt; 0:

                            return market_type_benchmark[0][market_type]

                        else:

                            return default[0]['default']

                else:

                    if isinstance(setting, list):

                        return setting

                    else:

                        return False```

setting in the above refers to a dict, on startup I open a json file which contains various parameters.



An example would be something like this:



```    {

        "event_type_ids": [

            7

        ],

        "strategy_name": "strategy_xyz",

        "country_codes": false,

        "market_types": [

            "WIN"

        ],

        "execution_market_types": [

            "WIN"

        ],

        "pre_event_order_window": [

            {

                "GB": [

                    {

                        "start": 3600,

                        "duration": false

                    }

                ],

                "IE": [

                    {

                        "start": 3600,

                        "duration": false

                    }

                ],

                "US": [

                    {

                        "start": 3600,

                        "duration": false

                    }

                ],

                "FR": [

                    {

                        "start": 3600,

                        "duration": false

                    }

                ],

                "AU": [

                    {

                        "start": 3600,

                        "duration": false

                    }

                ]

            }

        ]}```



---

## 2023-05-10 07:45:06 - random channel

**Newbie99**

Cool thanks Liam, at a high level what is happening (I think), is my conditional cancel logic (for some pre race strategies I only cancel if the model believes fair value has changed, rather than every x seconds).



Then the other part is reading values from a deeply nested JSON file to get values and that involves multiple loops.



Will get the functions, there's nothing proprietary as such, just inefficient code I think!

---

## 2023-05-09 19:56:16 - random channel

**Newbie99**

```  ncalls  tottime  percall  cumtime  percall filename:lineno(function)

  2408686   18.768    0.000 1041.182    0.000 /python_files/market_making.py:36(place_passive_order)





Called By:



   Ordered by: cumulative time

   List reduced from 9630 to 1 due to restriction &lt;'place_passive_order'&gt;



Function                                                                       was called by...

                                                                                   ncalls  tottime  cumtime

/python_files/market_making.py:36(place_passive_order)  &lt;- 1229074    9.614  554.391  /python_files/betting_strategy.py:53(process_market_book)

                                                                                  1179612    9.155  486.792  /python_files/betting_strategy.py:68(process_orders)





Called:



   Ordered by: cumulative time

   List reduced from 9630 to 1 due to restriction &lt;'place_passive_order'&gt;



Function                                                                       called...

                                                                                   ncalls  tottime  cumtime

/python_files/market_making.py:36(place_passive_order)  -&gt; 2408686    0.271    0.271  /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/strategy/strategy.py:249(name)

                                                                                 21826158   23.419   83.258  /python_files/market_making.py:6(create_runner_dict)

                                                                                 21826158   38.883  897.773  /python_files/place_order_functions.py:327(place_or_cancel)

                                                                                 21826158   25.190   40.984  /python_files/validation_functions.py:254(check_market)

                                                                                  2408686    0.128    0.128  {method 'keys' of 'dict' objects}```

---

## 2023-05-09 19:41:14 - random channel

**Newbie99**

```  ncalls  tottime  percall  cumtime  percall filename:lineno(function)

   288135    1.555    0.000  662.991    0.002 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/simulation/simulation.py:109(_process_market_books)

        4    0.000    0.000  467.806  116.951 /python_files/backtesting_functions.py:44(startup)

        4    0.232    0.058  467.637  116.909 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/simulation/simulation.py:29(run)

  1134046    8.263    0.000  459.433    0.000 /python_files/market_making.py:36(place_passive_order)

  9757016   17.160    0.000  396.170    0.000 /python_files/place_order_functions.py:327(place_or_cancel)

   1992/1    0.020    0.000  282.462  282.462 {built-in method builtins.exec}

        1    0.000    0.000  282.462  282.462 backtesting.py:1(&lt;module&gt;)

        1    0.000    0.000  280.392  280.392 backtesting.py:325(start_backtest_b)

  1151150    0.395    0.000  267.220    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/utils.py:235(call_strategy_error_handling)

   287798    0.840    0.000  243.036    0.001 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/simulation/simulation.py:154(_process_simulated_orders)

   574944    0.413    0.000  242.620    0.000 /python_files/betting_strategy.py:53(process_market_book)

   559802    0.202    0.000  241.037    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/utils.py:272(call_process_orders_error_handling)

   559802    0.632    0.000  240.835    0.000 /python_files/betting_strategy.py:68(process_orders)

  4342013   47.805    0.000  154.966    0.000 /python_files/place_order_functions.py:577(validate_new_order)

  1152415    0.544    0.000  150.247    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/utils.py:255(call_middleware_error_handling)

  4784556    3.025    0.000  102.676    0.000 /python_files/place_order_functions.py:310(cancel_orders_by_price)

   288103    1.304    0.000   78.054    0.000 /python_files/risk_worker.py:9(__call__)

121605882   50.622    0.000   73.601    0.000 /python_files/validation_functions.py:769(true_or_false)

 20833220   20.227    0.000   72.348    0.000 /python_files/place_order_functions.py:924(get_limit)

   576206   14.875    0.000   71.167    0.000 /python_files/risk_functions.py:31(calc_exposure_metrics)

   288104    0.207    0.000   62.674    0.000 /python_files/competition.py:121(__call__)

 14541572   31.843    0.000   61.683    0.000 /python_files/risk_functions.py:127(get_runner_exposure)

   287472    0.419    0.000   61.392    0.000 /python_files/competition.py:146(update_market)

   287472    0.980    0.000   60.909    0.000 /python_files/competition.py:187(update_modelled_price_list)

  4784556   11.933    0.000   60.852    0.000 /python_files/cancel_and_replace.py:12(cancel_orders)

 55674710   31.552    0.000   48.538    0.000 /python_files/validation_functions.py:725(check_race_type_by_country)

  1136008    3.174    0.000   45.434    0.000 /python_files/validation_functions.py:47(validate_market_book)

   287472    0.664    0.000   42.708    0.000 /python_files/competition.py:221(&lt;listcomp&gt;)

  2486230    2.362    0.000   42.045    0.000 /python_files/competition.py:234(update_runner_price)

  2486230    1.287    0.000   39.121    0.000 /python_files/competition.py:171(get_runner_name)

  2486230    4.873    0.000   37.716    0.000 /python_files/competition.py:172(&lt;listcomp&gt;)

  9757016   10.321    0.000   36.596    0.000 /python_files/market_making.py:6(create_runner_dict)

  1440123    3.603    0.000   35.733    0.000 /python_files/place_order_functions.py:228(construct_price)

 28978669   10.676    0.000   32.843    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/betfairlightweight/resources/bettingresources.py:8(__getitem__)

   576206    6.713    0.000   29.727    0.000 /python_files/risk_functions.py:46(&lt;listcomp&gt;)

  1134046    2.796    0.000   26.220    0.000 /python_files/validation_functions.py:163(validate_order_windows)

  5095443   10.677    0.000   25.777    0.000 /python_files/place_order_functions.py:138(get_benchmark_percentage_and_tolerance)

   576206    0.372    0.000   24.206    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/strategy/strategy.py:101(check_market)

   576206    0.590    0.000   23.735    0.000 /python_files/betting_strategy.py:37(check_market_book)

  9757016    4.906    0.000   22.284    0.000 /python_files/misc_functions.py:72(get_runner_info)

 43650454   10.245    0.000   21.749    0.000 /python_files/risk_functions.py:135(validate_order_has_risk)

   288166    0.864    0.000   21.579    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/streams/historicalstream.py:204(_read_loop)

 28978669    7.751    0.000   20.991    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/betfairlightweight/utils.py:69(to_snake_case)

 10891063   11.955    0.000   19.219    0.000 /python_files/validation_functions.py:254(check_market)

 14541572   18.712    0.000   18.712    0.000 /python_files/risk_functions.py:130(&lt;listcomp&gt;)

380141490   17.861    0.000   17.863    0.000 {built-in method builtins.isinstance}

  9757016   16.306    0.000   16.887    0.000 /python_files/misc_functions.py:73(&lt;listcomp&gt;)

   287472    2.668    0.000   16.183    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/shin/__init__.py:5(calculate_implied_probabilities)

  4342013    3.838    0.000   15.908    0.000 /python_files/place_order_functions.py:565(get_benchmark_value)

  1134046    1.803    0.000   15.850    0.000 /python_files/validation_functions.py:76(get_price_at_post_time)

   589543    0.445    0.000   15.093    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/streams/historicalstream.py:187(on_data)

 51813748    8.634    0.000   13.955    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/order/order.py:436(size_matched)

   589543    1.351    0.000   13.903    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/streams/historicalstream.py:30(_process)

 14497067    3.100    0.000   12.459    0.000 {built-in method builtins.sum}

   589543    1.884    0.000   12.020    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/betfairlightweight/streaming/cache.py:234(update_cache)

 28980260   11.731    0.000   11.731    0.000 {method 'sub' of 're.Pattern' objects}

  4342013   11.682    0.000   11.682    0.000 /python_files/place_order_functions.py:571(&lt;listcomp&gt;)

  1134046    1.977    0.000   11.560    0.000 /python_files/validation_functions.py:88(&lt;listcomp&gt;)

144563009   11.485    0.000   11.485    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/strategy/strategy.py:249(name)

  4342013   11.182    0.000   11.182    0.000 /python_files/misc_functions.py:148(create_ordered_dict)```

---

## 2023-05-09 19:06:36 - random channel

**Newbie99**

```ncalls  tottime  percall  cumtime  percall filename:lineno(function)

      113    0.002    0.000  585.570    5.182 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/concurrent/futures/_base.py:199(as_completed)

      114    0.001    0.000  585.563    5.137 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/threading.py:604(wait)

      114    0.003    0.000  585.562    5.137 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/threading.py:288(wait)

     2480  585.558    0.236  585.558    0.236 {method 'acquire' of '_thread.lock' objects}

   1998/1    0.019    0.000   10.578   10.578 {built-in method builtins.exec}

        1    0.000    0.000   10.578   10.578 backtesting.py:1(&lt;module&gt;)

        1    0.002    0.002    8.888    8.888 backtesting.py:288(start_backtest_a)

  1979/22    0.004    0.000    1.383    0.063 &lt;frozen importlib._bootstrap&gt;:1167(_find_and_load)

  1960/22    0.004    0.000    1.382    0.063 &lt;frozen importlib._bootstrap&gt;:1122(_find_and_load_unlocked)

  1874/23    0.003    0.000    1.379    0.060 &lt;frozen importlib._bootstrap&gt;:666(_load_unlocked)

  1630/23    0.002    0.000    1.379    0.060 &lt;frozen importlib._bootstrap_external&gt;:934(exec_module)

  4574/43    0.001    0.000    1.370    0.032 &lt;frozen importlib._bootstrap&gt;:233(_call_with_frames_removed)

  894/160    0.001    0.000    1.056    0.007 {built-in method builtins.__import__}

 2336/977    0.002    0.000    0.919    0.001 &lt;frozen importlib._bootstrap&gt;:1209(_handle_fromlist)

        1    0.000    0.000    0.688    0.688 /python_files/football_data.py:1(&lt;module&gt;)

4684/4545    0.045    0.000    0.350    0.000 {built-in method builtins.__build_class__}

        1    0.000    0.000    0.335    0.335 /python_files/validation_functions.py:1(&lt;module&gt;)

        1    0.000    0.000    0.334    0.334 /python_files/import_historic_horse_data.py:1(&lt;module&gt;)

     1630    0.005    0.000    0.325    0.000 &lt;frozen importlib._bootstrap_external&gt;:1007(get_code)

        1    0.000    0.000    0.309    0.309 backtesting.py:212(generate_event_groupings)

        1    0.000    0.000    0.297    0.297 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/statsmodels/tsa/holtwinters/__init__.py:1(&lt;module&gt;)

        1    0.000    0.000    0.297    0.297 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/statsmodels/tsa/holtwinters/model.py:1(&lt;module&gt;)

        1    0.000    0.000    0.249    0.249 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/pyplot.py:1(&lt;module&gt;)

        1    0.000    0.000    0.231    0.231 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/pandas/__init__.py:1(&lt;module&gt;)

        1    0.013    0.013    0.222    0.222 backtesting.py:270(&lt;listcomp&gt;)

    39431    0.214    0.000    0.214    0.000 {built-in method posix.stat}

     1630    0.002    0.000    0.214    0.000 &lt;frozen importlib._bootstrap_external&gt;:1127(get_data)

1874/1863    0.002    0.000    0.194    0.000 &lt;frozen importlib._bootstrap&gt;:566(module_from_spec)

        1    0.000    0.000    0.194    0.194 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/scipy/stats/__init__.py:1(&lt;module&gt;)

     1637    0.188    0.000    0.188    0.000 {method 'read' of '_io.BufferedReader' objects}

  234/229    0.000    0.000    0.173    0.001 &lt;frozen importlib._bootstrap_external&gt;:1231(create_module)

  234/229    0.170    0.001    0.172    0.001 {built-in method _imp.create_dynamic}

        1    0.000    0.000    0.172    0.172 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/scipy/stats/_stats_py.py:1(&lt;module&gt;)

      100    0.000    0.000    0.164    0.002 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/artist.py:159(_update_set_signature_and_docstring)

       99    0.000    0.000    0.161    0.002 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/artist.py:126(__init_subclass__)

       33    0.000    0.000    0.148    0.004 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/importlib/__init__.py:108(import_module)

       33    0.000    0.000    0.148    0.004 &lt;frozen importlib._bootstrap&gt;:1194(_gcd_import)

        1    0.000    0.000    0.140    0.140 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/scipy/stats/distributions.py:1(&lt;module&gt;)

        1    0.000    0.000    0.137    0.137 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/figure.py:1(&lt;module&gt;)

        1    0.000    0.000    0.129    0.129 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/projections/__init__.py:1(&lt;module&gt;)

      112    0.000    0.000    0.110    0.001 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/artist.py:1841(kwdoc)

     2025    0.039    0.000    0.103    0.000 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/concurrent/futures/process.py:762(submit)

        1    0.000    0.000    0.100    0.100 /python_files/misc_functions.py:1(&lt;module&gt;)

        1    0.024    0.024    0.099    0.099 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/scipy/stats/_continuous_distns.py:1(&lt;module&gt;)

  234/167    0.000    0.000    0.096    0.001 &lt;frozen importlib._bootstrap_external&gt;:1239(exec_module)

  234/167    0.017    0.000    0.096    0.001 {built-in method _imp.exec_dynamic}

        1    0.000    0.000    0.096    0.096 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/__init__.py:1(&lt;module&gt;)

        1    0.000    0.000    0.095    0.095 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/smart_open/__init__.py:1(&lt;module&gt;)

        1    0.000    0.000    0.095    0.095 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/flumine.py:1(&lt;module&gt;)

        1    0.000    0.000    0.094    0.094 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/smart_open/smart_open_lib.py:1(&lt;module&gt;)

        1    0.000    0.000    0.094    0.094 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/baseflumine.py:1(&lt;module&gt;)

      112    0.002    0.000    0.094    0.001 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/artist.py:1602(pprint_setters)

        1    0.000    0.000    0.093    0.093 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/smart_open/doctools.py:1(&lt;module&gt;)

        1    0.000    0.000    0.093    0.093 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/smart_open/transport.py:1(&lt;module&gt;)

        9    0.000    0.000    0.093    0.010 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/smart_open/transport.py:32(register_transport)

        1    0.000    0.000    0.093    0.093 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/pandas/core/api.py:1(&lt;module&gt;)

        1    0.000    0.000    0.092    0.092 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/colorbar.py:1(&lt;module&gt;)

        1    0.000    0.000    0.089    0.089 /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/flumine/strategy/strategy.py:1(&lt;module&gt;)

     1937    0.008    0.000    0.088    0.000 &lt;frozen importlib._bootstrap&gt;:1056(_find_spec)

     1630    0.002    0.000    0.086    0.000 &lt;frozen importlib._bootstrap_external&gt;:727(_compile_bytecode)```

---

## 2023-05-09 13:19:49 - random channel

**Newbie99**

I've recently switched to a new MacBook pro, from an old windows machine and as I knew performance was rubbish on that, I didn't worry too much, just left things processing overnight etc. However with an M2 Max I was expecting super fast backtesting, but compared to the results people post on here I seem to be way behind (e.g. 16k pre-race horse racing markets, 1 hour before the off takes circa 3 hours).



My code is as follows:

```def start_backtest_a(chunked_markets, max_workers, profit_sum, in_play, seconds_to_start, event_processing,

                    strategy_names, match_all, middleware):



    _process_jobs = []

    with futures.ProcessPoolExecutor(max_workers=max_workers) as p:

        for m in chunked_markets:

            _process_jobs.append(

                p.submit(startup,

                         profit_sum=profit_sum,

                         in_play=in_play,

                         seconds_to_start=seconds_to_start,

                         event_processing=event_processing,

                         markets=m,

                         strategy_names=strategy_names,

                         match_all=match_all,

                         middleware=middleware

                )

            )

        for i, job in enumerate(futures.as_completed(_process_jobs)):

            try:

                mini_output_list = job.result()  # wait for result

                output_list.extend(mini_output_list)

                progress = len(m) * i+1

                time_taken_seconds = (datetime.datetime.utcnow() - sim_start_time).total_seconds()

                time_taken_minutes = time_taken_seconds / 60

                percentage = progress / total_markets

                time_taken = time_taken_minutes if time_taken_minutes &gt; 2 else time_taken_seconds

                time_remaining = (time_taken / percentage) - time_taken

                time_measure = 'minutes' if time_taken_minutes &gt; 2 else 'seconds'

                print(f'Currently on market {progress} / {percentage*100:.2f}% of {total_markets}, '

                      f'time taken so far is {time_taken:.2f} {time_measure}, estimated time remaining is {time_remaining:.2f} {time_measure}, ')

            except Exception as e:

                print(f'Exception {e}.')

        return output_list```

With startup being as follows:



```def startup(markets, profit_sum, in_play, seconds_to_start, event_processing, strategy_names, match_all, middleware=False):

    logger = logging.getLogger()



    custom_format = "%(asctime) %(levelname) %(message)"

    log_handler = logging.StreamHandler()

    formatter = jsonlogger.JsonFormatter(custom_format)

    formatter.converter = time.gmtime

    log_handler.setFormatter(formatter)

    logger.addHandler(log_handler)

    logger.setLevel(logging.CRITICAL)  # Set to logging.CRITICAL to speed up simulation



    start_time = get_utc_time()



    # Gets a list of strategy settings

    settings = [setting for setting in rc if setting['on'] is True and setting['strategy_name'] in strategy_names]



    client = clients.SimulatedClient(simulated_full_match=match_all)



    framework = FlumineSimulation(client=client)



    # with mock_patch("builtins.open", smart_open.open): # Commented out as files will be unzipped prior to running

    for s in settings:

        max_selection_exposure = s['max_selection_exposure'] if true_or_false(s['max_selection_exposure']) != False else None

        include_virtual_prices = "EX_BEST_OFFERS_DISP" if true_or_false(

            s['include_virtual_prices']) is not False else "EX_ALL_OFFERS"

        if s['strategy_type'] == 'simple':



            strategy = betting_strategy(start_time=start_time, settings=s, paper=client.paper_trade,

                                        market_filter=create_market_filter(markets, in_play, seconds_to_start, event_processing),

            market_data_filter=streaming_market_data_filter(

            fields=[

                include_virtual_prices,

                "EX_TRADED",

                "EX_TRADED_VOL",

                "EX_LTP",

                "EX_MARKET_DEF",

                "SP_TRADED",

                "SP_PROJECTED",

            ]

            ),

            streaming_timeout=2,

            max_selection_exposure=max_selection_exposure,

            max_order_exposure=s['max_order_exposure'],

            conflate_ms=s['conflate'],

            name=s['strategy_name'],



            )



            framework.add_strategy(strategy)



    ''' Add in Middleware to get Market Catalogue '''

    framework.add_market_middleware(MarketCatalogueMiddleware())



    if middleware is not False:

        framework.add_market_middleware(middleware)



    framework.add_market_middleware(RiskMiddleware(framework))



    framework.run()```

I presume that calling the middleware could be an issue and also potentially my structure is wrong (i.e. in terms of trying to multiprocess at the wrong point).



I did try to get chatGPT to re-write things and it tried to use:



_with mp.get_context('spawn').Pool(max_workers) as pool:_ 



However I couldn't get it working (i.e. it never actually ran the framework, so I couldn't work out how to proceed).



Appreciate this is a bit of a '_how long is a piece of string_' situation, but is there a fairly generic approach to using multi processing with middleware that perhaps I could use as a template?

---

## 2023-05-09 01:45:45 - general channel

**Jose Maquia**

Hello! I'm using the following filters to place bets but want the bet to be placed normally and if partially filled I want it to automatically cancel after 5 seconds, what filters should I change. I tried FILL_OR_KILL but that doesn't work for me as I want it to stay for a few seconds instead of instantly cancel. I'm passing the constant CANCELLATION_TIME to the function but I'm unsure if it's actually doing anything.



# Define a limit order filter with time_in_force and min_fill_size

        limit_order_filter = betfairlightweight.filters.limit_order(

            size=order_size,

            price=order_price,

            persistence_type='LAPSE'

        )



        # Define an instructions filter

        instructions_filter = betfairlightweight.filters.place_instruction(

            selection_id=str(bet_object.selection_id),

            order_type="LIMIT",

            side="BACK",

            limit_order=limit_order_filter

        )



     bet_thread = threading.Thread(

            target= bfl_trading.betting.place_orders,

            args=(

                str(bet_object.match.market_id),

                [instructions_filter],

                CANCELLATION_TIME,

            ),

        )

        # Start the bet placement thread

        bet_thread.start()

---

## 2023-05-08 19:11:42 - general channel

**Beeblebrox**

I've seen strange things happen with strategy_selection_orders() not returning orders. I posted about it a month ago, but no one replied so I assumed it was just me ([https://betcode-org.slack.com/archives/C4H05ML2E/p1679771428625779](https://betcode-org.slack.com/archives/C4H05ML2E/p1679771428625779))

---

## 2023-05-08 13:10:31 - general channel

**liam**

Workers suit polling / long running process where as a moving average would need every MarketBook so suits being processed in a strategy and then stores in market context 

---

## 2023-05-08 12:25:18 - general channel

**Trex44**

Yes. Thanks very much, its buried in there. Is there a way to call this data inside a Flumine strategy? I can't find it in the market object or subclasses of the market class.

---

## 2023-05-08 11:50:10 - general channel

**Jorge**

Hey guys. Using flumine my Strategy behaves strangely when Latency is high. Could it happen that my [https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L118|market.blotter.live_orders](https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L118|market.blotter.live_orders) gets updated but my [https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L74|market.blotter.strategy_selection_orders](https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L74|market.blotter.strategy_selection_orders) does not get updated? For example, in the event of an order filled, I'm thinking [https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L118|market.blotter.live_orders](https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L118|market.blotter.live_orders) could change but [https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L74|market.blotter.strategy_selection_orders](https://github.com/betcode-org/flumine/blob/master/flumine/markets/blotter.py#L74|market.blotter.strategy_selection_orders) doesn't and therefore my exposure calculation is wrong.

---

## 2023-05-08 10:06:53 - general channel

**liam**

Too many variables, best practice is to compare your simulations to the real world for each strategy/marketType/time of day etc, you will find it will be very consistent over the long run in terms of if it will under/over state matching/pnl

---

## 2023-05-08 08:20:42 - general channel

**Nick**

Hi All - A couple of questions for those using Flumine for running backtests on their strategies and their automation needs:

1. How close do your backtests compare with reality once you go live on a strategy?

2. What are some of the factors that influence differences between backtests and live results?

3. Any experiences / comparisons people want to share?

---

## 2023-05-04 08:49:48 - issues channel

**liam**

Almost, does this make sense:



```class FootballFavBacker(BaseStrategy):



    def check_market_book(self, market, market_book):

        if "fav_selection_id" not in market.context:

            if market_book.status == "OPEN" and market.seconds_to_start &lt; 60:

                # store favourite's starting price

                runners = sorted(

                    market_book.runners, key=lambda r: get_price(r.ex.available_to_back, 0) or 1001

                )

                if runners:

                    fav = runners[0]

                    market.context["fav_selection_id"] = fav.selection_id

                    market.context["fav_starting_price"] = get_price(fav.ex.available_to_back, 0)

                    market.context["market_start_time"] = market_book.market_definition.market_time

                    print("Updated context:", market.context["fav_starting_price"], market.context["market_start_time"])



        # process when market open and inplay

        if market_book.status == "OPEN" and market_book.inplay:

            return True



    def process_market_book(self, market, market_book):

        fav_selection_id = market.context.get("fav_selection_id")

        if fav_selection_id:

            # get favourite

            runners = {r.selection_id: r for r in market_book.runners}

            if runners:

                fav = runners[fav_selection_id]

                # get favourite's odds from context

                fav_current_price = get_price(fav.ex.available_to_back, 0)

                fav_starting_price = market.context["fav_starting_price"]



                if fav_current_price &gt; fav_starting_price * 1.2:

                    # place BACK bet on the favourite

                    runner_context = self.get_runner_context(

                        market.market_id, fav.selection_id, fav.handicap

                    )

                    if runner_context.trade_count == 0:

                        trade = Trade(

                            market.market_id, fav.selection_id, fav.handicap, self

                        )

                        order = trade.create_order(

                            side="BACK",

                            order_type=LimitOrder(

                                get_price(fav.ex.available_to_back, 0),

                                size=5,

                            ),

                        )

                        market.place_order(order)```

---

## 2023-05-03 20:06:01 - general channel

**Trex44**

Thanks Mo. I went over the maths of it and yea I see that actually even in the scenario I posed you can't actually turn the strategy into a losing one because of the coms like you said. That wasn't immediately apparent to me.



Tried another scenario where I made the hit rate 50% too with a loss in one week and a win the next. Even though the coms weren't at X% the PC applied to the winning bet still left the strategy in profit. So I guess the maths behind PC was designed with all this in mind.

---

## 2023-05-03 11:32:48 - general channel

**Trex44**

Thanks Mo. I know its on the aggregate weekly winnings but assume these consist solely of the winning bet and nothing else. Then it effectively increases the coms you pay on the winnings of that bet without taking into account that bet was the only 1 in 10 you won, and assume the 9 losses were the previous week/s. As you are now netting less on your winning bets than you were before PC was applied your strategy may now be a losing strategy as the winners don't cover the losses.



I can see how this may still be a strategy that you may want to run, if running other profitable high hit rate strategies that don't generate much coms,  as it generates coms that compensate for those strategies. But still there is the possibility that if you had _*only*_ that one strategy, as described above ,you could find it becomes unprofitable once you hit PC. Unless I have misunderstood something.



I am no where near the lifetime allowence yet. I will have a deficit to work through too. I am just planning ahead and trying to figure out what to concentrate on next.

---

## 2023-05-03 08:55:21 - general channel

**Trex44**

Thanks Mo, yes that would be my definition of profitable. I thought though that if my lifetime comms generated weren't X% of my lifetime profits (X being 20% or 40% depending on the band) I would incur PC on winnings each week until they hit that band.



I can see a scenario there where say you win 1 in 10 bets but are below the life time comms level you are then charged PC on the winning bet which effectively brings your commission paid on that bet to well over 5%.  If the net gain from winning bets as part of a strategy is much lower but you are still losing the same amount on the losing bets in the sequence then it can turn a strategy unprofitable no?

---

## 2023-04-25 16:42:02 - general channel

**Peter**

It can indeed get complicated quickly. But Flumine has features that help keep this to a manageable level.



In case it helps, my feedback and end-of-day processes lean heavily on logging controls. I have a version that writes all orders to a database and updates those entries with the result when markets are complete. This keeps the monitoring logic completely separate from strategy execution (except arguably for the single `add_logging_control()` statement), but makes the data I need available for daily reconciliation scripts and ad hoc analyses.

---

## 2023-04-25 12:09:03 - random channel

**Unknown**

Not sure if anyone also does crypto trading but I've been collaborating with a crypto data provider ([http://CCData.io|CCData.io](http://CCData.io|CCData.io)) as a software dev. Got you a free data bundle to play with, usually sold for ~$1k.



Data is in CSV format containing all trades (spot + futures) and order book changes (spot only) for Binance BTC-USDT for 1-31 March 2023. See the attached PDF for data format info and instructions on how to re-play the order book.



[https://bit.ly/march2023-trades](https://bit.ly/march2023-trades) (~7GB compressed)

[https://bit.ly/march2023-obsnapshots](https://bit.ly/march2023-obsnapshots) (~20GB compressed)

[https://bit.ly/march2023-obupdates](https://bit.ly/march2023-obupdates) (~27GB compressed)

---

## 2023-04-23 16:53:18 - general channel

**Peter**

Hi [@U042NB80A1X](@U042NB80A1X) It feels to me as though you're overthinking this. I recommend taking a step backwards and looking at how it's done in the examples provided in the repo (especially lowest layer).



Think in terms of triggers and actions. Something is going to trigger a desire to place an order which you'll most likely detect in your strategy's `process_market()` method, so just use `market.place_order()` to execute the trade there. Other actions, such as replace or cancel, may be triggered by analysis of your order book so are done in your strategy's `process_orders()` method, or could be in response to changes in the market and so again done in  `process_market()` and it really doesn't need to get complicated.

---

## 2023-04-23 13:21:41 - general channel

**Unknown**

Hi, here is the log:



2023-04-22 08:26:33 |  Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failed: live_trade_count (1) &gt;= max_live_trade_count (1)



I manually/visually checked the market (on betfair website). There were no orders from this strategy (as they all had been cancelled by the code).

---

## 2023-04-23 11:32:24 - issues channel

**Dave**

[@U04NWADNCFR](@U04NWADNCFR) / [@URMM9463X](@URMM9463X) - presumably the override is only applicable if you run 1 strategy per flumine instance?

---

## 2023-04-23 10:30:45 - issues channel

**Andy B**

I take it that the idea is to retrieve your historical results via flumine in that case?  Under BFLW I would always pass a customer_strategy_ref value and retrieve it either via the API or the website, so it looks like I need to change my approach now.

---

## 2023-04-23 10:26:33 - issues channel

**Derek C**

you can also do this:

```flumine.config.customer_strategy_ref = 'strategy_code'```



---

## 2023-04-23 10:04:31 - general channel

**John**

Hi all and [@U4H19D1D2](@U4H19D1D2), I was trying to use `max_live_trade_count` (=1). I notice that even the existing orders have been cancelled by the code in `process_orders()` after 2 seconds for all runners, my code still thinks there are live orders executable for all runners (so below line is true):



[https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/flumine/strategy/strategy.py#L199](https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/flumine/strategy/strategy.py#L199)



hence my code doesn't place any new bets, though I'd expect the code to start placing new bets or those runners when their bets had been cancelled. Please could anyone give me a pointer if I am missing something very obvious?



Many thanks!

---

## 2023-04-23 09:38:22 - general channel

**river_shah**

Depends on context but I am not sure such a great idea. I would suggest do computation inside your strategy, building transaction and fire hedges yourself.



For larger exposure relative to market size, inbuilt cash out can be very inefficient

---

## 2023-04-23 06:24:39 - issues channel

**Dave**

customer_strategy_ref has always been set to the hostname and is not set anywhere else ([https://github.com/betcode-org/flumine/blob/9307dd5a0084c3583207921a521a1c39e430220f/flumine/config.py](https://github.com/betcode-org/flumine/blob/9307dd5a0084c3583207921a521a1c39e430220f/flumine/config.py) ). What I do is add a strategy identifier to order.notes, dump these orders (with notes) when market closes using the logging control.

---

## 2023-04-23 03:47:08 - issues channel

**Andy B**

Hi All, I am clearly missing something here as I am not gettting the strategy name passed through in my flumine strategies.  I thought that it used the name value e.g.

loc_strategy = FlatLOCModel(

    market_filter=streaming_market_filter(

        event_type_ids=["4339"], # Greyhound Racing

        country_codes=["AU"], # Australian Markets

        market_types=["WIN"], # Win Markets

    ),

    name = "LOC_1.07_3_3.80",

    max_order_exposure= 50, # Max bet sizes of $50

    max_trade_count=1, # Max of trade/bet attempt per selection

    max_live_trade_count=1, # Max of 1 unmatched Bet per selection

)



However, this just passes my machine name as the customer_strategy_ref.  Where should I be adding the customer_strategy_ref so that I can use it to filter my results?

---

## 2023-04-21 07:32:29 - general channel

**EJono**

the rest of the arguments passed to the strategy class look like the following:



```strategy_one = StrategyOne(

    max_order_exposure=30,

    max_live_trade_count=20,

    max_selection_exposure=30,

    market_filter=streaming_market_filter(

        event_type_ids=["1"],

        country_codes=country_codes,

        market_types=["MATCH_ODDS"],

    ),

    name='instance_1',

    context={

        "event_type_ids": ["1"],

        "market_types": "MATCH_ODDS",

        'number_of_markets_for_placement': eval(number_of_markets_to_place_on),

        "cancel_all_bets": eval(cancel_all_bets),

        'lower_limit': 0.0,

        'upper_limit': 0.33333333,

        'max_liability': 11,

        'strategy_type': 'first_to_score',

        'market_ids_for_placement': []

    }

)```

Strategy 2 and 3 are exactly the same apart from variations in "name", "lower_limit", and "upper_limit"

---

## 2023-04-20 20:17:57 - general channel

**liam**

Not really however I would look at an active flag in the strategy context which you update using a worker / text file. Adding strategies is a limitation of flumines design however maybe there is scope to make this possible 

---

## 2023-04-20 19:40:21 - general channel

**Andrey Luiz Malheiros**

Yes, I agree that using strategies with different instances of Flumine is not ideal, but is there a way to add or remove strategies from Flumine after running `flumine.run()`?

To explain further why I want this, let's say I have 4 strategies running, and one of them is performing VERY poorly, and I want to pause only that specific strategy to prevent further losses.

Now, in another scenario, let's say I have 4 strategies running, and I want to start an additional strategy.

In both of these scenarios, it would be very helpful to have a way to add or remove strategies from Flumine after the instance has already been initiated. Do you know if there is a way to do this?

---

## 2023-04-20 16:37:25 - general channel

**EJono**

Can more than one flumine strategy access the same market stream on a single account simultaneously?



Ive spun up three flumine strategies for testing which all want to be accesing and running on the same sorts of football markets.

Thus the streaming market filter and class set up looks like the following:



```SMF = streaming_market_filter(

        event_type_ids=event_type_ids,

        country_codes=country_codes,

        market_types=["MATCH_ODDS"]

)



strategy_one = StrategyOne(market_filter=SMF, ... )

strategy_two = StrategyTwo(market_filter=SMF, ... )

strategy_three = StrategyThree(market_filter=SMF, ... )```

I have noticed that sometimes a market will drop from the logs of one strategy and start up on another. Im slightly confused and wondering if there is somehting fundamental im missing such as "a market can only be streamed by one strategy at a time".

Any help greatly appreciated

---

## 2023-04-20 14:01:15 - general channel

**Peter**

Flumine maintains a list of market objects that you could iterate over to find the one with the smallest seconds_to_start attribute.



But that's not how I'd do it personally. Cleaner would be to treat each market separately and within the strategy do this processing when each market's seconds_to_start &lt;= 600 (you could set a flag in market.context to ensure that it's only done once).



Even cleaner would be to put this test and associated processing into the call() method in a custom middleware class.



However, if your external site is slow to respond you may need to push this out to another process to avoid holding up stream processing.



Yet another approach would be to make the external calls in a worker function, in which case rather than trying to infer the next race from the stream, I'd recommend making a single call at the beginning of the day using betfairlightweight to load all the catalogues and save a local list of the day's start times and then work through that to trigger your calls to the external site.

---

## 2023-04-19 22:09:45 - general channel

**Andy B**

Hi All, What's the best way of getting the next event start time from the stream?  I am doing Aus greyhounds and I have found a scenario where I need to periodically update data from an external site to use in my strategy.  My though is to insert this at a point where I have 5 minutes or more until the next race, but I'm not sure how to tell that from within the stream.

---

## 2023-04-19 18:18:28 - general channel

**Andrey Luiz Malheiros**

I was reading in the documentation about workers, and this really seems to be the ideal way to update the context according to data in my database. Thank you for your help, Liam. Regarding the situation of adding and renewing a strategy, is it possible to use any approach with workers and CustomEvent to add or remove strategies? I ask this because of the following situation: let's suppose I have 12 strategies for 4 different sports being executed. If I use one instance of Flumine for each strategy, I will end up with 12 different clients. Would this pose any issues with the connection limit allowed by Betfair, for example? Another option would be to run all the strategies in the same instance of Flumine. However, if I wanted to stop running only one of these strategies, it wouldn't be possible. I would have to remove all of them and then restart Flumine. Is there any solution to address this?

---

## 2023-04-19 05:32:00 - general channel

**liam**

Ok, best practice would be to have a single instance / strategy which reads your predictions either from a text file or an API. You can use a worker for this that polls every x seconds and updates your context.

---

## 2023-04-18 02:12:47 - general channel

**Andrey Luiz Malheiros**

Hey guys, my name is Andrey and I'm starting to use Flumine.

I want to run my strategies on a Django server and be able to activate and deactivate them using Flumine's API.

Currently, I'm using Django and Celery to start an asynchronous task when I call an API. Once this task initializes, Flumine starts running for a strategy that is passed in the body of the API request. However, the issue with this approach is that every time I call the API to start a strategy, I need to run another Flumine instance. I'm not sure if this is the best approach for my situation. Does anyone have a similar infrastructure or any ideas on how I can handle running my strategies on a server?

---

## 2023-04-17 10:51:33 - general channel

**Jorge**

Hi guys, I'm having an issue with my flumine Strategy. I save the details of every order I place, after it goes to EXECUTION_COMPLETE status, using:

```def save_completed_bets_data(self, market, selection_id):

    """

    Saves data from bets after an order in EXECUTION_COMPLETE.

    Note that an order can be partially matched many times before going to EXECUTION_COMPLETE status.



    """

    for order in market.blotter._orders.values():

        if order.size_matched &gt; 0:

            if order.status == OrderStatus.EXECUTION_COMPLETE:

                if order.selection_id == selection_id:

                    if order.date_time_execution_complete:

                        if order.bet_id not in self.completed_bets_dict:

                            self.completed_bets_dict[order.bet_id] = {

                                'market_id': market.market_id,

                                'selection_id': selection_id,

                                'side': order.side,

                                'average_price_matched': order.average_price_matched,

                                'size_matched': order.size_matched,

                                'execution_complete_ts': order.date_time_execution_complete,

                            }



                            df = pd.DataFrame.from_dict(self.completed_bets_dict, orient="index")

                            df.to_csv(self.completed_bets_csv_path)```

My issue is that for some orders (5% of them) the size_matched does not match the stake I get quering `list_cleared_orders`. Moreover, the stake from `list_cleared_orders` is always bigger than the one I recorded. Anyone has any clue why this would happen?

---

## 2023-04-16 17:05:27 - issues channel

**foxwood**

App key error as it says on the box. [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Exceptions](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Exceptions)



Do you have a valid App key ? [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Application+Keys](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Application+Keys)

---

## 2023-04-16 11:24:22 - general channel

**Trex44**

Footy always the most engaging, best sport in the world. Need data to build the models though, always been the issue. Glad to hear that pro is doable without horses though.

---

## 2023-04-16 10:42:19 - issues channel

**alan fisher**

Hi there. I'm a newbie trying to use Betfairlightweight python examples for the first time. I've  succeeded  in getting passed the trading.login which generates a session token but then anything I then try with the Trading object results in this error



Error: {'code': -32099, 'message': 'ANGX-0007', 'data': {'APINGException': {'requestUUID': 'ie2-ang08a-prd-03211101-003751a790', 'errorCode': 'INVALID_APP_KEY', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0007', 'data': {'APINGException': {'requestUUID': 'ie2-ang08a-prd-03211101-003751a790', 'errorCode': 'INVALID_APP_KEY', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}



Can anyone give me any pointers?

---

## 2023-04-16 00:01:49 - general channel

**Trex44**

Thanks guys. What would you recommend as the best sport to trade? I like football a lot but have struggled to get the data I felt I needed for models.

---

## 2023-04-11 14:34:50 - general channel

**Graham**

the documentation and technology is nice. The bottom line is that to exist as a p2p exchange with the sole USP being crypto-based deposits just sends the value to near-zero. For no other reason that you appear to want to operate in legal-waters. In the anecdotal venn-diagram of bettors, those who want a viable exchange are betting where liquidity is greatest; Betfair. Those who want to use crypto don't want any KYC.



I'm not sure the middle-ground, being a licenced operator (and therefore lawfully compliant to enforce KYC) is sufficient enough to mimic the massive success of [http://stake.com|stake.com](http://stake.com|stake.com)



Whomever successfully turns their back on the regulator and adopts a fair and honest -- but crucially close-to-anonymous exchange gets all the sweets.

---

## 2023-04-11 12:22:35 - general channel

**D C**

[@UPMUFSGCR](@UPMUFSGCR) It is a question that currently has no answer - bookies are not legally obliged to check source of funds at all. I am hoping that you are right though about it being depositors only that get checked. If not, my account will be gone as my non-betfair income per year is £0. This is the frustrating thing though because any legislation will be implemented by people who probably know jack shit about betting and will fail to see the subtle differences between exchange and bookmaker business models. I do worry what will happen if no distinction is made between casino/sports bettinge/exchange betting but we will soon see

---

## 2023-04-11 12:12:44 - general channel

**D C**

Oh right - you know that there is a government white paper coming out on UK gambling soon? There is talk of employing a single customer view for betting accounts. You must be aware of all the talk of people having to provide proof of income documentation that has been happening? Seems its mostly happening to losing accounts and bookmakers rather than the exchanges, but if this stuff becomes law then dumb money will evaporate very quickly

---

## 2023-04-11 10:55:12 - general channel

**ShaunW**

I agree about the crypto Peter. I don't actually know anyone who uses it for day to day transactions and if anything I just hear idioligical opposition and mistrust.  



The tech isn't the difficult part of setting up an exchange it's understanding how you'll become the name people think of when they want to place a bet. Taking a leaf from the bingo playbook, betting needs a compelling reason to "play" because the over complicated exchange model offering value nobody cares about is unlikely to take much business from tradional operators.  



I'm genuinely trying to be constructive and not just critical, I just feel without a novel and compelling customer offering that sells itself, the advertising budget alone to gain traction will be an obstacle.

---

## 2023-04-10 11:04:00 - issues channel

**Unknown**

This issue occurred again over the weekend. Everything had been running fine for over a week and then on Saturday strategy_selection_orders() stopped returning any orders again. I stopped and restarted the flumine instance and it started working again. [@U4H19D1D2](@U4H19D1D2) any idea what could be going on here? I'm on holiday at the moment so can't really debug it or look at the logs, but will take a look again when I get back.

---

## 2023-04-09 15:14:11 - general channel

**Aravind**

Hey guys - my name is Aravind and I am the founder of [https://www.dev.goated.com/](https://www.dev.goated.com/) - a sports trading exchange that is launching soon. Our api docs are here: [https://api.dev.goated.com/swagger-ui/](https://api.dev.goated.com/swagger-ui/) and we have built an sdk here: [https://docs.goated.com](https://docs.goated.com).



I love what the community have done here with *betfairlightweight* and would love to get a similar high quality sdk for Goated so that existing betfair traders can also connect to Goated easily. Are there people here who might be exited in working with me on this?

---

## 2023-04-07 11:52:21 - general channel

**Trex44**

Hey guys, what's the correct way to print the results of a strategy to a log (e.g. a text file). Is this available in the blotter somewhere?

---

## 2023-04-07 08:46:20 - general channel

**Tom**

I had to make a list and put market_ids=market_ids into the filter.



But clunky but at least it works



I already process the data that gives me the list of Market ID's I want in the BaseStrategy class init, so might just have to recreate it until I get the live access

---

## 2023-04-07 03:59:56 - general channel

**Tom**

Just looking for a bit of help with this error.



I was using the broad market filter

#     market_filter = streaming_market_filter(

#         event_type_ids=['7'],

#         country_codes=['AU'],

#         market_types=['WIN']

# ),



Then thought I would try to limit it to the number of markets I am interacting with in testing (a single event, all markets). I'm loading them in _init_ and attempting to loop through that list in the market filter with a lambda function (is that the problem?)



This is the error. It could also be because I am not logging out properly?- I have 2 files I am running, one is collecting data and the other is running strategy in flumine; I haven't figured out how to run both at the same time yet, but the idea is that the first one would manage data (inc. which markets to stream/process for bets).



betfairlightweight.exceptions.ListenerError: connection_id: 206-070423024222-349976, data: {"op":"status","id":3002,"statusCode":"FAILURE","errorCode":"MAX_CONNECTION_LIMIT_EXCEEDED","errorMessage":"You have exceeded your max connection limit which is: 2 connection(s).You currently have: 3 active connection(s).","connectionClosed":true,"connectionId":"206-070423024222-349976"}

---

## 2023-04-03 21:34:47 - issues channel

**Andy B**

I have had my first flumine strategy up and running for about a week and it seems to work well apart from one issue that happens inconsistently.  I'm not sure if it is relevant or not, but the strategy fires when the there is less than 5 seconds to start time and the event has not gone inplay.  I keep getting batches of the following somewhat generic error filling my log file, and I am wondering if this is a common issue that I should be handling in the code with try\catch.  I'd like to know why it happens though, rather than just ignoring it:

2023-04-03 22:02:21,329:CRITICAL:Unknown error '1.212248357' in process_market_book (1.212248357)

Traceback (most recent call last):

  File "C:\Python\lib\site-packages\pandas\core\indexes\base.py", line 3803, in get_loc

    return self._engine.get_loc(casted_key)

  File "pandas\_libs\index.pyx", line 138, in pandas._libs.index.IndexEngine.get_loc

  File "pandas\_libs\index.pyx", line 165, in pandas._libs.index.IndexEngine.get_loc

  File "pandas\_libs\hashtable_class_helper.pxi", line 5745, in pandas._libs.hashtable.PyObjectHashTable.get_item

  File "pandas\_libs\hashtable_class_helper.pxi", line 5753, in pandas._libs.hashtable.PyObjectHashTable.get_item

KeyError: '1.212248357'



The above exception was the direct cause of the following exception:



Traceback (most recent call last):

  File "C:\Python\lib\site-packages\flumine\utils.py", line 239, in call_strategy_error_handling

    return func(market, market_book)

  File "c:\Users\elmob\OneDrive\Punting\Scripts\Betfair\FluStrat.py", line 231, in process_market_book

    ratio_price = iggy_df.loc[market_book.market_id].loc[runner.selection_id].item() / runner.ex.available_to_back[0]['price']

  File "C:\Python\lib\site-packages\pandas\core\indexing.py", line 1073, in __getitem__

    return self._getitem_axis(maybe_callable, axis=axis)

  File "C:\Python\lib\site-packages\pandas\core\indexing.py", line 1312, in _getitem_axis

    return self._get_label(key, axis=axis)

  File "C:\Python\lib\site-packages\pandas\core\indexing.py", line 1260, in _get_label

    return self.obj.xs(label, axis=axis)

  File "C:\Python\lib\site-packages\pandas\core\generic.py", line 4049, in xs

    loc, new_index = index._get_loc_level(key, level=0)

  File "C:\Python\lib\site-packages\pandas\core\indexes\multi.py", line 3160, in _get_loc_level

    indexer = self._get_level_indexer(key, level=level)

  File "C:\Python\lib\site-packages\pandas\core\indexes\multi.py", line 3263, in _get_level_indexer

    idx = self._get_loc_single_level_index(level_index, key)

  File "C:\Python\lib\site-packages\pandas\core\indexes\multi.py", line 2849, in _get_loc_single_level_index

    return level_index.get_loc(key)

  File "C:\Python\lib\site-packages\pandas\core\indexes\base.py", line 3805, in get_loc

    raise KeyError(key) from err

KeyError: '1.212248357'

---

## 2023-04-02 09:29:08 - random channel

**Paul**

The article itself states that most experts reckon that the models out there can break even at the track (i.e. they break even at 120%), and the CAW players make their profits on that 10% rebate.

---

## 2023-03-31 08:35:15 - general channel

**Jorge**

Hi guys, I am trying to access `market.event_name` in [https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L109|check_market_book](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L109|check_market_book) but it is equal to None. Any way I could access it?

---

## 2023-03-31 07:10:45 - general channel

**Trex44**

Hey I was looking to do this to but was implementing the computation in the strategy class. What are the benefits/reasons for implementing it in the middleware ?

---

## 2023-03-30 23:23:22 - general channel

**Trex44**

```{"asctime": "2023-03-30 22:09:29,717", "levelname": "INFO", "message": "Client added", "username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": null, "transaction_count_total": null, "trading_controls": [], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-03-30 22:09:29,717", "levelname": "INFO", "message": "Adding market middleware &lt;flumine.markets.middleware.SimulatedMiddleware object at 0x7f68114aa380&gt;"}

{"asctime": "2023-03-30 22:09:29,718", "levelname": "INFO", "message": "Adding client control MAX_TRANSACTION_COUNT"}

{"asctime": "2023-03-30 22:09:29,718", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2023-03-30 22:09:29,718", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2023-03-30 22:09:29,718", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2023-03-30 22:09:29,718", "levelname": "INFO", "message": "Adding strategy LowestLayer"}

{"asctime": "2023-03-30 22:09:29,719", "levelname": "INFO", "message": "Creating new HistoricalStream (1000) for strategy LowestLayer", "strategy": "LowestLayer", "stream_id": 1000, "market_filter": "/home/ubuntu/Python_projects/tmp/races/1.161864856", "event_id": "29441541", "event_processing": false}

{"asctime": "2023-03-30 22:09:29,719", "levelname": "INFO", "message": "Starting flumine", "clients": {"Betfair": {}, "Simulated": {"6bb3cddd": {"username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 0, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140085059739648)&gt;"]}

{"asctime": "2023-03-30 22:09:29,719", "levelname": "INFO", "message": "Client login", "username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-03-30 22:09:29,720", "levelname": "INFO", "message": "Client update account details", "username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-03-30 22:09:29,720", "levelname": "INFO", "message": "Starting historical market '/home/ubuntu/Python_projects/tmp/races/1.161864856'", "market": "/home/ubuntu/Python_projects/tmp/races/1.161864856"}

{"asctime": "2023-03-30 22:09:29,720", "levelname": "INFO", "message": "[Register: 1000]: marketSubscription"}

{"asctime": "2023-03-30 22:09:29,720", "levelname": "INFO", "message": "[MarketStream: 1000]: \"MarketStream\" created"}

{"asctime": "2023-03-30 22:09:29,720", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,722", "levelname": "INFO", "message": "Adding: 1.161864856 to markets"}

{"asctime": "2023-03-30 22:09:29,728", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,731", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,732", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,733", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,734", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,735", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,736", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,754", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,759", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,785", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,822", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,917", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:29,952", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:30,040", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:30,083", "levelname": "WARNING", "message": "Runner 12077917 (13.81) removed from market 1.161864856"}

{"asctime": "2023-03-30 22:09:30,154", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:30,480", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:30,529", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

{"asctime": "2023-03-30 22:09:30,648", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.161864856 added, 1 markets in cache"}

----------------------------------------------

Seconds to start = 0.176

market_book.total matched = 0

[r.total_matched for r in market_book.runners] = [24835.62, 3965.73, 2802.5, 593.19, 29.79, 153.78, 0]

sum([r.total_matched for r in market_book.runners]) = 32380.609999999997

----------------------------------------------

Seconds to start = 0.063

market_book.total matched = 0

[r.total_matched for r in market_book.runners] = [24835.62, 4521.7, 2802.5, 593.19, 29.79, 153.78, 0]

sum([r.total_matched for r in market_book.runners]) = 32936.579999999994

----------------------------------------------

Seconds to start = 0.003

market_book.total matched = 0

[r.total_matched for r in market_book.runners] = [24835.62, 4521.7, 2802.5, 593.19, 29.79, 45.97, 0]

sum([r.total_matched for r in market_book.runners]) = 32828.77

{"asctime": "2023-03-30 22:09:33,018", "levelname": "INFO", "message": "Market 1.161864856 closed", "market_id": "1.161864856", "event_id": "29441541", "event_type_id": "7", "event_name": "Sedge 29th Aug", "market_type": "WIN", "market_start_datetime": "2019-08-29 18:20:00", "country_code": "GB", "venue": "Sedgefield", "race_type": null, "orders_cleared": [], "market_cleared": [], "closed": true}

{"asctime": "2023-03-30 22:09:33,019", "levelname": "INFO", "message": "Market cleared", "market_id": "1.161864856", "order_count": 0, "clients": {"Betfair": {}, "Simulated": {"6bb3cddd": {"username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140085059739648)&gt;"]}

{"asctime": "2023-03-30 22:09:33,019", "levelname": "INFO", "message": "Market level cleared", "market_id": "1.161864856", "profit": 0, "bet_count": 0}

{"asctime": "2023-03-30 22:09:33,019", "levelname": "INFO", "message": "Market closed", "market_id": "1.161864856", "clients": {"Betfair": {}, "Simulated": {"6bb3cddd": {"username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140085059739648)&gt;"]}

{"asctime": "2023-03-30 22:09:33,020", "levelname": "INFO", "message": "Removing market 1.161864856", "clients": {"Betfair": {}, "Simulated": {"6bb3cddd": {"username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140085059739648)&gt;"]}

{"asctime": "2023-03-30 22:09:33,020", "levelname": "INFO", "message": "Completed historical market '/home/ubuntu/Python_projects/tmp/races/1.161864856'"}

{"asctime": "2023-03-30 22:09:33,020", "levelname": "INFO", "message": "Simulation complete"}

{"asctime": "2023-03-30 22:09:33,020", "levelname": "INFO", "message": "Shutting down Execution (SimulatedExecution)"}

{"asctime": "2023-03-30 22:09:33,020", "levelname": "INFO", "message": "Shutting down Execution (BetfairExecution)"}

{"asctime": "2023-03-30 22:09:33,020", "levelname": "INFO", "message": "Client logout", "username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-03-30 22:09:33,021", "levelname": "INFO", "message": "Exiting flumine", "clients": {"Betfair": {}, "Simulated": {"6bb3cddd": {"username": "6bb3cddd", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f68114aa590&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140085059739648)&gt;"]}

time in mins = 0.05507066069791714

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

Profit: 0.00

total = 0 

 max = 0 

 min = 0```

---

## 2023-03-30 23:22:48 - general channel

**Trex44**

```from collections import OrderedDict

from flumine import BaseStrategy

from flumine.order.trade import Trade

from flumine.order.order import OrderStatus

from flumine.order.ordertype import LimitOrder

from flumine.utils import get_price

import numpy as np





class LowestLayer(BaseStrategy):

 

    def check_market_book(self, market, market_book):

        if market_book.status == "OPEN" and not market_book.inplay and 0 &lt; market.seconds_to_start &lt; 0.2:

            print('----------------------------------------------')

            print(f'Seconds to start = {market.seconds_to_start}')

            print(f'market_book.total matched = {market_book.total_matched}')

            print(f'[r.total_matched for r in market_book.runners] = {[r.total_matched for r in market_book.runners]}')

            print(

                f'sum([r.total_matched for r in market_book.runners]) = {sum([r.total_matched for r in market_book.runners])}')

            return True```

---

## 2023-03-28 08:37:37 - general channel

**RDr**

Hi Liam, thanks for your response. I did start running the sample codes in [https://betcode-org.github.io/flumine/quickstart/](https://betcode-org.github.io/flumine/quickstart/) and then kept waiting for framework.run() to show something after the initial msg 'starting strategy 'ExampleStrategy'.  So most likely me not starting with and running the right example (and knowing what I am doing yet).

---

## 2023-03-28 00:25:19 - general channel

**RDr**

Hi, I am only getting started and found some codes to get stream racing data using befairlightweight.

It sounds like Flumine could facilitate the process and run different market_ids streams in parallel/concurrently and sequentially.

Could someone assist and let me know what the Flumine codes would be to run and get/save different streaming data in parallel (different venues) and also in sequence (same venue for different races once the previous race market closes) ?

Thanks!



#===================================================

# Sample section of codes for betfairlightweight version (only 1 stream worked for me, not sure how to adapt the codes or use existing Flumine functions to record multiple markets in  parallel or sequentially)



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)



# create stream

stream = trading.streaming.create_stream(listener=listener)



# create filters (AU WIN racing)

# market_filter = streaming_market_filter(

#    event_type_ids=["7"], country_codes=["AU"], market_types=["WIN"],

# )

my_market_ids = [..., ...., ...]

market_filter = filters.market_filter(market_ids=my_market_ids)



market_data_filter = streaming_market_data_filter(

    fields=["EX_MARKET_DEF", "EX_LTP", "EX_BEST_OFFERS", "EX_TRADED", "EX_TRADED_VOL", "SP_TRADED", "SP_PROJECTED"], ladder_levels=3

)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



# start stream in a new thread (in production would need err handling)

t = threading.Thread(target=stream.start, daemon=True)

t.start()



# Open a file for the market stream data

filename = f"{market_id}.txt"

filepath = os.path.join("data", filename)

with open(filepath, "w") as f:



    # check for updates in output queue

    while True:

        market_books = output_queue.get()

        print(market_books)



        for market_book in market_books:

            # print(

            #     market_book,

            #     market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

            #     market_book.streaming_update,  # json update received

            #     market_book.market_definition,  # streaming definition, similar to catalogue request

            #     market_book.publish_time,  # betfair publish time of update

            # )



            # write data to file

            f.write(str(market_book.streaming_unique_id) + '\n')

            f.write(str(market_book.streaming_update) + '\n')

            f.write(str(market_book.market_definition) + '\n')

            f.write(str(market_book.publish_time) + '\n')

---

## 2023-03-27 19:35:40 - strategies channel

**birchy**

Thanks for your help [@U04AD6RAGGH](@U04AD6RAGGH), it's very much appreciated. I had a quick play with CalibratedClassifierCV but it seems to produce very similar results to my basic LogisticRegression. Is that to be expected? My implementation is:



`#model = LogisticRegression()

model = CalibratedClassifierCV(

    estimator=LogisticRegression(),

    method='sigmoid'

#    method='isotonic'

)`

I believe it to be correct? At this stage, I'm starting to steer towards one of the auto ml libraries rather than manually trying the infinite number of combinations.

---

## 2023-03-27 17:50:27 - general channel

**Peter**

When you setup a strategy to subscribe to a market, you can set the streaming_timeout (seconds) parameter. That will force the a snapshot to be taken and evaluated at that frequency if no market updates have been received. [https://betcode-org.github.io/flumine/strategies/#parameters](https://betcode-org.github.io/flumine/strategies/#parameters)

---

## 2023-03-27 17:45:28 - general channel

**Thomas JAMET**

To compute time-based analytics?

If there are no market-book updates, the middleware won't get called and the analytics won't get updated and become stale.

If there are no market-book updates (and no strategy order), the strategy won't get evaluated either I believe, but that's another question.

Is there a Flumine facility to have a timer-based callback?

I am now leaning towards creating a separate BackgroundWorker for this. Any suggestion?

---

## 2023-03-27 17:37:50 - general channel

**Peter**

Creating a middleware child class with a  `___call___()` method is exactly how I would do it. You can write the results to the market.context dictionary and they'll be available to every strategy that consumes that market.



Not sure why you would want a timer-based callback in this context.

---

## 2023-03-27 17:22:21 - strategies channel

**birchy**

[@U04AD6RAGGH](@U04AD6RAGGH) good point on the IDs, I overlooked that. As for the signals, they're calculated on every market update and in the above example, only saved to the CSV for analysis &amp; modelling. As such, the "bets" are only placed to populate the CSV. I have a handful of signals at present and trying various combinations to see which ones are good/bad. This seems like a sensible approach with my current understanding?



Will look at validation and calibration.

---

## 2023-03-27 15:54:50 - strategies channel

**R**

Per [@U9JHLMZB4](@U9JHLMZB4)’s comment above, your accuracy can be high when predicting every runner will lose.  In a 10 runner race, you'd have 90% accuracy!  So we have to take a deeper look at things.  Usually you can start at precision and recall:



Precision is related to False Positives

Recall is related to False Negatives



In this case, False Positives can lose you money while False Negatives will miss trades.  So:



low Recall = Lots of missed trades

low Precision = lots of bad trades



From your numbers, you are missing more trades than you are losing; which is better than the other way around.



Not surprised that those ID features don't work, they are not "numbers" in the sense that a logistic model can deal with them.  They are more like categorical variables.  It's like trying to numerically model a word, it can be done, but needs some preprocessing.



I'm curious: is there one trade per event you are looking for or multiple signals simultaneously?  Trying to understand if you have a class imbalance problem.



Also, use cross-validation and calibration : [https://scikit-learn.org/stable/modules/generated/sklearn.calibration.CalibratedClassifierCV.html](https://scikit-learn.org/stable/modules/generated/sklearn.calibration.CalibratedClassifierCV.html)

---

## 2023-03-27 13:03:31 - strategies channel

**birchy**

I now have some quick n dirty signals as a proof of concept and running against a complete dataset generated by Flumine simulation where the strategy backs every runner for £1 at LTP on every update. Results appear to be more realistic, particularly the recall stat [@U9JHLMZB4](@U9JHLMZB4) mentioned:



`Accuracy: 0.8649507394792786

Precision: 0.6514084507042254

Recall: 0.34230002846569885

F1-score: 0.4487777570442247

MSE: 0.13504926052072141

LogLoss: 4.867668736665466`



Using irrelevant features such as market_id and selection_id give poor results as expected. Surprised that the Accuracy is still quite high though. Thoughts?

---

## 2023-03-26 21:06:45 - strategies channel

**R**

So feature scaling applies to logistic regression only when you are interested in regularizing the model somehow (i.e. L1 and L2 terms are non-zero).  In most cases we want to regularize to improve generalization (reduce overfitting).



I would try to just convert everything to implied probabilities and that will act as a scaling transform.  If there are features that you can't do this to (like volume perhaps) then standardize them or play around with some scaling methods to see what works best (e.g. normalization and minmax scaling can also work)



quick and dirty method is to minmax scale things and go from there.

---

## 2023-03-26 19:41:37 - strategies channel

**R**

also yes, hyperparameter optimization and cross-validate the shit out of everything.

---

## 2023-03-26 19:34:25 - strategies channel

**ShaunW**

Your understanding is correct. The implied probability of the matched prices in your dataset is approximately 0.84, which means that, on average, the market believes there is an 84% chance of the runner winning. To beat the market, your model's accuracy should be higher than this implied probability.

In your case, the accuracy of the LogisticRegression model is 0.8346, which is close to the market's implied probability but not quite above it. This means that, although your model appears to be performing reasonably well, it is not yet outperforming the market.

To improve your model's performance, you can try several approaches:

1. Feature Engineering: Create new features or transform existing features to better capture the underlying patterns in the data.

2. Feature Selection: Remove irrelevant or noisy features to reduce overfitting and improve model generalization.

3. Hyperparameter Tuning: Optimize the hyperparameters of your Logistic Regression model, such as regularization strength (C) or using different solvers.

4. Ensemble Methods: Combine multiple models, like decision trees or other classifiers, to improve overall performance.

5. Experiment with different algorithms: Try other machine learning algorithms that might better capture the patterns in your dataset.

Remember to also take into account the Precision, Recall, and F1-score of your model, as they provide additional insights into its performance. For instance, your model's high Recall (0.9988) and lower Precision (0.8354) indicate that it is good at identifying winning bets but may also produce many false positives, which can lead to losses. Balancing these metrics can help you create a more effective betting strategy.

---

## 2023-03-26 19:17:50 - strategies channel

**birchy**

Going back to my opening post, the model I was using:



`from sklearn.model_selection import train_test_split

from sklearn.linear_model import LogisticRegression

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, mean_squared_error`



`# Convert the target variable to binary (0 for lose, 1 for win)

df['winner'] = df['profit'].apply(lambda x: 1 if x &gt; 0 else 0)`



`# Split data into training and test sets

features = ['sig1', 'sig2', 'sig3']`

`X_train, X_test, y_train, y_test = train_test_split(df[features], df['winner'], test_size=0.2)`



`# Instantiate a logistic regression model

model = LogisticRegression()`



`# Fit the model to the training data

model.fit(X_train, y_train)`



`# Use the model to make predictions on the test data

y_pred = model.predict(X_test)`



`# Evaluate the model's performance using appropriate metrics

accuracy = accuracy_score(y_test, y_pred)

precision = precision_score(y_test, y_pred)

recall = recall_score(y_test, y_pred)

f1 = f1_score(y_test, y_pred)

mse = mean_squared_error(y_test, y_pred)

print(f"Accuracy: {accuracy}")

print(f"Precision: {precision}")

print(f"Recall: {recall}")

print(f"F1-score: {f1}")

print(f"MSE: {mse}")`



Bearing in mind that the dataset is a bet history (BACK bets only) where all unmatched bets have been removed and 'profit' is a real-world number, would this not achieve the same result as calculating EV for training? My gut feeling is that the model is shyte, or at least the data I'm using is too optimised due to being pre-filtered by the strategy that generated it. Thoughts?

---

## 2023-03-26 17:57:37 - strategies channel

**Peter**

[@U016TGY3676](@U016TGY3676) We need to be a bit careful about looking for expected or "normal" values in the stats. They will depend a lot on how noisy the data is. Moreover, they're just one part of some subtle evaluations.



To illustrate, imagine a UK greyhound model that predicts that every dog in a six dog race will lose (there are some poor tutorials out there that actually build models that do this!). the model is pants, but it's also accurate 83.33% of the time. On the other hand a model with some genuine predictive power may have an accuracy down in the 70s but yield better results when used to place actual bets. So I agree with [@U04AD6RAGGH](@U04AD6RAGGH) that calculating expected returns can be a useful metric for deciding whether you have a viable model.

---

## 2023-03-26 17:46:52 - strategies channel

**birchy**

Just for fun, chat GPT came up with this:

`import pandas as pd

from hmmlearn import hmm



# Load data into pandas dataframe

df = pd.read_csv("market_data.csv")



# Define the state space

states = ["increase", "decrease", "same"]



# Define the observation space

observations = df[["bid_price", "ask_price"]].values



# Define the transition probabilities

trans_mat = [[0.7, 0.2, 0.1],

             [0.3, 0.5, 0.2],

             [0.2, 0.3, 0.5]]



# Define the emission probabilities

emissionprob_mat = [[0.2, 0.4, 0.4],

                    [0.4, 0.3, 0.3],

                    [0.3, 0.3, 0.4],

                    [0.4, 0.4, 0.2]]



# Create the HMM model

model = hmm.MultinomialHMM(n_components=3)

model.startprob_ = [0.3, 0.4, 0.3]

model.transmat_ = trans_mat

model.emissionprob_ = emissionprob_mat



# Fit the model to the data

model.fit(observations)



# Make predictions

prediction = model.predict(df[["bid_price", "ask_price"]].values)

predicted_states = [states[state] for state in prediction]

df["predicted_states"] = predicted_states



# Print the predictions

print(df["predicted_states"])`



---

## 2023-03-26 17:43:47 - strategies channel

**R**

One thing though, aside from all of these metrics: [http://nicolas.kruchten.com/content/2016/01/ml-meets-economics/](http://nicolas.kruchten.com/content/2016/01/ml-meets-economics/)



Pay attention to your metrics, but also pay attention to what constitutes "good".  Above is a great article on when a higher number isn't always best.



This is why measuring the Expected Value of your model is crucial.  Accuracy is great, Value is better :slightly_smiling_face:

---

## 2023-03-26 17:40:24 - strategies channel

**R**

as a quick way to get started, try something like PyCaret

 [https://pycaret.readthedocs.io/en/stable/index.html](https://pycaret.readthedocs.io/en/stable/index.html)



It'll give you exposure to a lot of different models, preprocessing steps, and visualizations like confusion matrices.  Great for quick model experimentation

---

## 2023-03-26 16:48:22 - strategies channel

**Peter**

I'm rather worried by your recall stat. It implies that you have have hardly any false negatives, which isn't really realistic with the sort of data we work with. I'm wondering whether you have an imbalanced class issue. Have you built a [https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html|confusion matrix](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html|confusion matrix) for your model's predictions?

---

## 2023-03-26 16:09:23 - strategies channel

**birchy**

Thanks [@U04AD6RAGGH](@U04AD6RAGGH). So my features are signals generated from changes in price, volume, etc. The strategy is inplay horses, so my main concern is that it may be identifying that 1.01=winner, even though that's not always the case...

Will look at SGD. I also have plans to use a similar model for predicting price movement, i.e. the binary target being `price_now &lt; price_previously`. Any advice on that?

---

## 2023-03-26 14:51:43 - strategies channel

**R**

also, in case you didn't spot it there is a class called SGDClassifier ([https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDClassifier.html))



This is a nice gradient based method for various things, logistic regression being one of them.  Allows incremental learning too.



I've found it to be a bit better than the LogisticRegression class (faster too IMO)

---

## 2023-03-26 14:25:44 - strategies channel

**birchy**

As a complete noob to ML, etc, I'm playing around with sklearn and LogisticRegression with a target variable of runner win/lose based on market data generated signals. I'm trying to understand the metrics, which are as follows:

`Accuracy: 0.8346274074821014

Precision: 0.8353535353535354

Recall: 0.998792270531401

F1-score: 0.9097909790979097

MSE: 0.16537259251789857`



On paper, it looks like a reasonable model, however the implied probability of my matched prices in the dataset is `~0.84`. If I understand correctly, I would need to get to an `accuracy` score &gt; matched implied probability?

Edit: to add some further context, my dataset is a betting history with ~50K bets on 1000 markets and i'm using an 80/20 split.

---

## 2023-03-26 05:13:42 - issues channel

**Andy B**

I have my first flumine strategy running and I was going to test with small stakes, but I am getting the error "Order has violated: ORDER_VALIDATION Error: Order price is not valid for CLASSIC ladder".  I am only guessing that it has something to do with the stake size, which works quite fine in bflw, but I'm not 100% sure, so just wondering if this rings a bell with anyone else?

---

## 2023-03-25 19:21:58 - strategies channel

**R**

The general idea behind Benter's work still stands today.  Financial (quant) literature talks of two types of probabilities: P &amp; Q.



P is generated from fundamental models (e.g. logit models based on data)

Q is generated from market information (e.g. implied probabilities)



In general, a final probability is generated as a weighted combination of P&amp;Q.



Benter implemented this and attached it to a kelly system.   It worked.  Very effectively.



The beauty of this approach is that it rests on one single question: how well can you model the price of a horse?



If you can do that well, kelly is your man.  Otherwise you better figure out something else.

---

## 2023-03-25 19:10:28 - issues channel

**Beeblebrox**

I'm having an issue with the blotter function strategy_selection_orders() sometimes not returning any orders even though there have definitely been some orders placed by a strategy on the market. The majority of the time it works, but sometimes it just stops working and I can't work out why. Has anyone else had similar issues? For a bit of context I'm using it for a strategy that places bets on football markets from 12 hours before kick off up to kick off.

---

## 2023-03-25 10:53:04 - issues channel

**Andy B**

Hi All,

I have just created my first flumine strategy after a couple of years of hacking together bflw and my own custom code.  I copied the code from [https://betfair-datascientists.github.io/api/How_to_Automate_3/?h=iggy#scrape-todays-model-ratings](https://betfair-datascientists.github.io/api/How_to_Automate_3/?h=iggy#scrape-todays-model-ratings) and then modified it with my own strategy, which I think has worked successfully, but I have just noticed a lot of errors containing the following:



betfairlightweight.exceptions.ListenerError: connection_id: 102-250323104256-6797689, data: {"op":"status","id":2007,"statusCode":"FAILURE","errorCode":"MAX_CONNECTION_LIMIT_EXCEEDED","errorMessage":"You have exceeded your max connection limit which is: 2 connection(s).You currently have: 3 active connection(s).","connectionClosed":true,"connectionId":"102-250323104256-6797689"}



This is followed by a number of:



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "C:\Python\lib\site-packages\flumine\streams\orderstream.py", line 51, in run

    self._stream.start()

  File "C:\Python\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 67, in start

    self._read_loop()

  File "C:\Python\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 226, in _read_loop

    received_data_raw = self._receive_all()

  File "C:\Python\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 248, in _receive_all

    raise SocketError("[Connect: %s]: Socket %s" % (self._unique_id, e))

betfairlightweight.exceptions.SocketError: [Connect: 1007]: Socket [WinError 10054] An existing connection was forcibly closed by the remote host

2023-03-25 21:13:30,779:INFO:Starting MarketStream 2006

2023-03-25 21:13:30,779:INFO:[Register: 2007]: Unique id updated on listener and stream

2023-03-25 21:13:31,771:INFO:[MarketStream: 2007]: connection_id: 108-250323104330-6863571

2023-03-25 21:13:32,096:ERROR:MarketStream 2007 run error

Traceback (most recent call last):

  File "C:\Python\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 244, in _receive_all

    part = self._socket.recv(self.buffer_size)

  File "C:\Python\lib\ssl.py", line 1226, in recv

    return self.read(buflen)

  File "C:\Python\lib\ssl.py", line 1101, in read

    return self._sslobj.read(len)

ConnectionResetError: [WinError 10054] An existing connection was forcibly closed by the remote host



I only have one instance running, so I am not sure what is generating these errors.  Just wondering if anyone else has experienced this or has some thoughts on what may cause it?

---

## 2023-03-24 13:26:10 - general channel

**Tom**

Yeah I don't know how to think about it - on the one hand you'd think that there is some threshold of betting activity towards full book optimisation if you have too much going on in a single, closed event; but then it might detract from the risk/reward profile of each individual decision.

---

## 2023-03-24 13:01:25 - general channel

**liam**

Thats a very wide reaching question and ultimately boils down to market capacity. I personally run multiple strategies with similar models but different executions (the important part) however I know some centralise to try and have more control over execution / double taking etc

---

## 2023-03-24 01:23:50 - general channel

**Tom**

I'm still waiting on Betfair to allow my API to stream Delayed Data; it looks like they might have even completely restricted my connection to the Betfair API to make calls.



I am testing code with it, although had throttled it to a single (horseracing) event and the markets within it; but was calling odds every minute to get market percentage - which I presume is why because it's streaming type behaviour.



I've emailed them 3 times about the delayed app key, so it's a bit tricky to get the strategy going; I'm working on other bits and pieces in the meantime but it's tricky to see how flumine works without the streaming.

---

## 2023-03-24 00:55:42 - issues channel

**Lee**

Put the filter in the BookmakerStrategy brackets

---

## 2023-03-24 00:18:53 - issues channel

**Greg**

Added this but same error :

```strategy = BookmakerStrategy()

market_filter=streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["AU"],

        market_types=["WIN"],

    )

framework.add_strategy(strategy)```



---

## 2023-03-24 00:07:30 - issues channel

**Lee**

Your market filter needs to be in the strategy instantiation 

---

## 2023-03-24 00:00:34 - issues channel

**Greg**

Hi All.been away for a while.Hope you are all well. I have ben using a certain Ai engine to help teach me some python and seem to get the odd thing running. I am getting a subscription exceed error :"ERROR", "message": "[MarketStream: 2001]: SUBSCRIPTION_LIMIT_EXCEEDED: trying to subscribe to 19639 markets whereas max allowed number was: 1000"} though, which I have noted has occurred once on this forum in the past I can find and that was referred to BF bdp. They have increases my allowed threshold to 1000 markets but have suggested I limit the market monitoring and/or increase connection threads. Here is the code snippet that looks relevant

```class BookmakerStrategy(BaseStrategy):

    market_filter = streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GBR", "IRE", "AUS"],

        market_types=["WIN"],

    )



    def check_market_book(self, market, market_book):

        if self.seconds_to_start &gt; 600:  # 10 minutes

            return False

        if market_book.status not in ["CLOSED", "SUSPENDED"]:

            return False



    def __init__(self, market_filter=None):

        super().__init__(market_filter)

        self.race_time = 0

        self.race_started = False```

Any advice appreciated.Cheers

---

## 2023-03-23 22:11:46 - general channel

**Jesus Perdomo**

Hey guys, so glad I found this library, very cool!



Just trying to figure out what would be best practice for my use (I read the official betfair stuff but doesn't really answer the question).

My understanding is that there is a limit to how many login requests the API can receive before soft-banning. The 'best practices' page states that a single login session can carry out multiple API calls as long as it's alive. I'm trying to make an app that gets some information from the API, hopefully in the future extend it to allow betting through the app as well. The app will make some requests to find out if a particular markets exists (by searching for a team name), and what the odds are at the time of request. The app will be using non-interactive logon as it is hands-off



Would best practice be as follows? Logon --&gt; Get Data --&gt; Logout?

Or should I just keep the connection open for the next API call? - I'd say the time in-between calls can be variable, sometimes in quick succession (seconds to minutes), but most of the time it would be in the minutes to hours range.



If the best thing to do is to keep the connection open, does the API send an exception code or some other response if a session is already open?

I'm just trying to figure out how to code the logic: If already logged-in, send call, otherwise, attempt login and get a session id

---

## 2023-03-23 08:40:28 - random channel

**Peter**

Bard's no better. "The Betfairlightweight Python library was written by oksidisko. It is a lightweight, super fast wrapper for Betfair API-NG (with streaming) that allows all betting operations (including market and order streaming) and most account operations."

---

## 2023-03-22 05:54:09 - general channel

**Mo**

If you have a clear idea of your strategy then suggest you start with the flumine examples - [https://github.com/betcode-org/flumine/tree/master/examples/strategies](https://github.com/betcode-org/flumine/tree/master/examples/strategies) - and adapt for your needs

---

## 2023-03-22 05:51:56 - general channel

**Mo**

1. Prices files could be self recorded or purchased from Betfair. The format is the same

2. It's not entirely clear what you mean by market books being "betfair objects" but the answer is probably yes. The Betfair API defines what a MarketBook object is [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-MarketBook](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-MarketBook)

3. betfairutil has a calculate_book_percentage function [https://github.com/mberk/betfairutil/blob/525dc4dc9d87bc9438e72c24fd024d9bcab29b6c/betfairutil/__init__.py#L1518-L1540](https://github.com/mberk/betfairutil/blob/525dc4dc9d87bc9438e72c24fd024d9bcab29b6c/betfairutil/__init__.py#L1518-L1540)

---

## 2023-03-22 02:52:17 - general channel

**Tom**

What's the best way to familiarise oneself with all the different functionalities and options? I'm looking on GitHub and the docs but I'm running myself in circles - I'm sure that a lot of what I want to do are the classic problems that have been overcome in the libraries - but where do you find and understand all the functionality?



getting market_percentage for example, I'm trying to use betfairutil (and I'm sure this is straightforward), but I'm having trouble going from the dataframe I've created to what's needed



```market_books = betfairutil.read_prices_file(path_to_prices_file)```

are prices_files standardised outputs from betfair?



I thought market_books themselves were betfair objects?



I seem to be confusing myself chasing different ideas of how it works without really sitting down and trying to understand the libraries first - I have a clear idea of the strategy e.t.c. but in terms of structuring software it's tricky because I can't conceptualise the end result (which parts to make modular, how to structure the different working bits and pieces etc)

---

## 2023-03-21 19:12:16 - strategies channel

**George**

that's easy as I don't have any alpha to leak yet :smile: just some ideas!

i'm going to see if I can get a skeleton strategy coded up this week and play around with flumine to see if it has what I am looking for. if I can't find it probably someone helpful will point me in the right direction. what a great group!

---

## 2023-03-21 18:41:29 - strategies channel

**Paul**

You’ll need to build a market making model. Just constantly adding to either side of the book without considering how a limit order book works, could land you in some hot water. At the last meetup, Matthew Trenhaile suggested market making on BF meant you were in a constant losing battle to 2-3 people who know more than you, but I’m not sure that’s true.

---

## 2023-03-21 10:33:41 - general channel

**Peter**

Flumine wraps around Betfairlightweight. It provides a trading framework with BFLW providing the connection to Betfair in the background. So the the best way to combine them is simply to work in Flumine.

---

## 2023-03-21 10:11:03 - general channel

**Tom**

Hey guys, I was around about 6 months ago looking at a betfair bot. Since then have done CS50, CS50p, some data-science, maths and half a dozen udemy courses and am now building the bot.  Between betfairlightweight and flumine it just blows my mind how this stuff is out there (not to mention the type of statistical libraries and things that are out there).  Can already see a use for betfairutil as well so cheers [@UBS7QANF3](@UBS7QANF3) and [@U4H19D1D2](@U4H19D1D2).



 It seems like flumine is the quickest way to login to the API and start streaming, although I'd done it all in betfairlight in the past. Is there any wisdom on the best way to use combinations of these to get what you want from it? I'd say my strategy is most like market-making (in horseraces) in terms of how it executes

---

## 2023-03-20 18:21:29 - strategies channel

**George**

do you find that there is enough in flumine for a market making strategy that relies a lot on tracking existing orders and liabilities, both live and executed? or did you have to add to flumine to get what you needed in that respect?

---

## 2023-03-19 17:27:46 - random channel

**Michael**

Generally, it gets code right but the issue is more the model being natural language and therefore ambiguity, so it is right but might not do 100% what you meant it to. I saw someone suggest you could let it access your shell and then use it to iterate your code as it runs and runs into errors, very interesting use case but it would probably get itself stuck in circles at some point

---

## 2023-03-18 13:09:53 - random channel

**PeterLe**

In response to the question : summarise the key points from the book - efficiency of racetrack betting markets by william T Ziemba and which is the most optimal strategy:



"Efficiency of Racetrack Betting Markets" is a book by William T. Ziemba and Donald B. Hausch that provides a comprehensive analysis of the betting markets in horse racing. The book examines the efficiency of these markets and explores various strategies for betting on horse races. Here are the key points from the book:

1. Market efficiency: The authors argue that racetrack betting markets are relatively efficient, meaning that odds generally reflect the true probability of outcomes. However, they also point out that there are inefficiencies that can be exploited by astute bettors.

2. The favorite-longshot bias: The book discusses the well-known favorite-longshot bias, which is the tendency for bettors to overbet longshots and underbet favorites. This bias can lead to consistent losses for bettors who consistently back longshots.

3. The importance of data: The authors emphasize the importance of using data to make informed betting decisions. This includes historical data on horse performances, track conditions, and other relevant factors.

4. Handicapping: Ziemba and Hausch provide a detailed overview of various handicapping methods, such as speed ratings, pace analysis, and form analysis. They argue that successful handicapping is essential for consistently identifying value bets.

5. Optimal betting strategies: The book examines several betting strategies and their potential profitability, such as the Kelly Criterion, proportional betting, and fixed fractional betting.

6. Market efficiency and arbitrage opportunities: The authors explore the existence of arbitrage opportunities in racetrack betting markets, where bettors can lock in a profit regardless of race outcomes.

7. Risk management: The book emphasizes the importance of managing risk in betting, highlighting that the optimal betting strategy should take into account the bettor's risk tolerance and bankroll size.

The most optimal strategy, according to the authors, is using the Kelly Criterion. This betting strategy involves adjusting bet sizes based on the perceived edge and the bettor's bankroll. The Kelly Criterion is known for maximizing long-term growth while also managing risk. However, it's important to note that the success of this strategy depends on the bettor's ability to accurately estimate the true probabilities of race outcomes and identify value bets.

---

## 2023-03-18 11:48:29 - random channel

**river_shah**

Sometimes I like to bet the farm. Is that a good strategy?





Betting the farm, or wagering your entire bankroll on a single bet, is generally considered a high-risk strategy and is not advisable for most bettors. Here are several reasons why betting the farm is not a good strategy:

1. Risk of ruin: Betting your entire bankroll on a single bet exposes you to a significant risk of losing everything if the bet does not go in your favor. This can be emotionally and financially devastating, especially if you've spent a considerable amount of time building your bankroll.

2. No room for recovery: When you bet the farm, you leave no room for recovery if the bet goes against you. A more prudent approach would involve placing smaller, calculated bets that allow you to recover from losses and maintain a more consistent betting strategy.

3. Inefficient capital allocation: Betting the farm usually implies that you are overconfident about a particular outcome. However, even in situations where you have a strong edge, it is more efficient to allocate your capital across multiple bets to maximize the long-term growth of your bankroll.

4. Encourages emotional decision-making: Betting the farm can lead to emotional decision-making, as you are likely to be more concerned about the immediate outcome rather than focusing on the long-term growth of your bankroll. Emotional decisions often lead to poor results, as they are not based on a sound analysis of probabilities and odds.

A more sensible approach to betting involves using a disciplined bankroll management strategy, such as the Kelly Criterion, fixed percentage betting, or fixed-unit betting. These strategies aim to balance risk and reward, maximizing the long-term growth of your bankroll while minimizing the risk of ruin. By following a disciplined approach, you can enjoy betting while protecting yourself from significant financial losses.

---

## 2023-03-18 11:47:00 - random channel

**river_shah**

Why is Kelly a good bank roll management scheme?





The Kelly Criterion, developed by John Larry Kelly Jr., is a bankroll management strategy that aims to maximize the expected growth of your bankroll over time. It determines the optimal fraction of your bankroll to bet on each opportunity, based on the estimated probability of winning and the odds offered. The Kelly Criterion is considered a good bankroll management scheme for several reasons:

1. Maximizes expected growth: The Kelly Criterion is designed to maximize the expected growth of your bankroll by considering both the probability of winning and the payoff of the bet. This ensures that you are investing the optimal amount for each bet, maximizing your potential returns over time.

2. Minimizes risk of ruin: By betting a proportion of your bankroll, the Kelly Criterion helps you avoid the risk of losing your entire bankroll in a short period. The risk of ruin decreases as you use a smaller fraction of the optimal Kelly bet, providing a balance between risk and potential returns.

3. Adjusts for varying bet sizes: The Kelly Criterion dynamically adjusts the bet size based on your current bankroll and the odds of each opportunity. This means that as your bankroll grows, your bet sizes will also increase, enabling you to capitalize on your success. Conversely, when your bankroll decreases, your bet sizes will decrease, protecting you from further losses.

4. Takes probability and odds into account: Unlike other bankroll management strategies, the Kelly Criterion considers both the probability of winning and the odds offered by the bet. This allows you to make more informed decisions and better manage your risk, as you are not only considering the size of your bankroll but also the potential returns and the likelihood of success.

5. Encourages disciplined betting: The Kelly Criterion promotes disciplined betting by requiring you to carefully estimate the probability of winning and compare it to the odds offered. This approach encourages a more analytical and systematic approach to betting, which can lead to better long-term results.

However, it's worth noting that the Kelly Criterion has some limitations:

• It requires accurate estimation of the probability of winning, which can be challenging in practice.

• It can lead to relatively large bet sizes if the perceived edge is significant, increasing the risk of large losses.

• It may not be suitable for risk-averse bettors, as it focuses on maximizing expected growth rather than minimizing risk.

Despite these limitations, the Kelly Criterion remains a popular and effective bankroll management strategy due to its ability to maximize expected growth while minimizing the risk of ruin.

---

## 2023-03-18 11:45:55 - random channel

**river_shah**

If I know favourites are over bet in signifiant horse races, what should I do?





If you believe that favorites are overbet in significant horse races, it means that the public is putting too much money on the favorite horses, causing their odds to be lower than their true probabilities of winning. In this case, you can consider the following strategies to potentially take advantage of this market inefficiency:

1. Bet on non-favorites: Focus on betting on non-favorite horses that may have higher odds than their true probabilities of winning. These horses may be undervalued due to the overbetting on the favorites, which can create potential value bets.

2. Look for value in exotic bets: Exotic bets, such as exactas, trifectas, or superfectas, involve predicting the order of finish for multiple horses in a race. Since most bettors tend to focus on favorites, there may be value in including non-favorite horses in your exotic bets.

3. Bet on races with less public attention: Large races tend to attract more casual bettors who tend to overbet favorites. By focusing on races with less public attention, you may find more accurately priced odds, allowing you to identify value bets more easily.

4. Utilize a data-driven approach: Collect and analyze historical data on horses, jockeys, trainers, and race conditions to build a predictive model. This can help you identify undervalued horses and make more informed betting decisions.

5. Implement a disciplined bankroll management strategy: To minimize your risk, use a disciplined bankroll management strategy, such as betting a fixed percentage of your bankroll on each race. This can help protect your bankroll from significant losses due to unexpected race outcomes.

6. Monitor the odds movement: Keep an eye on the odds as they change leading up to the race. You may find value bets if you can identify and capitalize on any discrepancies between the odds and your assessment of each horse's true probability of winning.

Remember, betting on horse races always involves a level of risk. While you may be able to identify value bets by exploiting the overbetting on favorites, it's essential to have a disciplined approach to bankroll management and be prepared for potential losses.

---

## 2023-03-18 11:41:13 - random channel

**river_shah**

```As a trading system, I have many decision rules and thresholds. How should I optimize and combine the thresholds and rules?



Optimizing and combining decision rules and thresholds in a trading system involves selecting the best set of rules and parameter values that maximize your trading strategy's performance, given your objectives and constraints. Here's a step-by-step guide to help you:

Define objectives and constraints: Clearly state your objectives, such as maximizing returns, minimizing risk, or achieving a specific risk-return profile. Also, consider constraints like trading costs, capital requirements, and any regulatory restrictions.

Pre-process data: Clean, preprocess, and organize historical market data to use in your analysis. This data will be used to backtest and optimize your trading strategy.

Create a set of candidate rules: Develop a diverse set of trading rules based on technical indicators, fundamental analysis, or other signals. Make sure these rules are modular and can be combined or adjusted easily.

Split data into training, validation, and testing sets: Divide your historical data into separate sets to prevent overfitting and to ensure that your strategy performs well on unseen data.

Develop a performance metric: Choose an appropriate performance metric (e.g., Sharpe ratio, Sortino ratio, or information ratio) to evaluate your trading strategy. This metric should align with your objectives and constraints.

Optimize decision rules and thresholds: Using the training data, perform optimization to find the best combination of rules and thresholds. There are various optimization methods, such as:

Grid search: Systematically test various combinations of rules and thresholds within a predefined range.

Random search: Test random combinations of rules and thresholds within a predefined range.

Genetic algorithms: Apply evolutionary algorithms to find the optimal combination of rules and thresholds.

Bayesian optimization: Use probabilistic models to optimize the selection of rules and thresholds.

Validate the optimized strategy: Apply the optimized strategy to the validation dataset to assess its performance. If it does not meet your objectives, consider refining the rules, thresholds, or optimization method and repeat the process.

Backtest on out-of-sample data: Once you have validated your optimized strategy, backtest it on the testing dataset to evaluate its performance on unseen data. This step helps ensure the robustness of your strategy.

Monitor and update: Regularly monitor your trading strategy's performance and update the rules and thresholds as needed. Markets evolve over time, and your strategy may need to adapt to changing conditions.

Remember, optimizing and combining trading rules and thresholds is an iterative process that requires continuous monitoring and adjustments. A successful trading system should balance the need for robustness, simplicity, and adaptability to market conditions.```

A more concrete code example useful for trading:



```What is mean variance optimization? Implement MVO using numpy, ensure positivity constraint, shrink covariance matrix to make sparse portfolios. use L-BFGS-B as optimizer





Mean Variance Optimization (MVO) is a portfolio optimization technique developed by Harry Markowitz in his Modern Portfolio Theory. The goal of MVO is to find the optimal allocation of assets in a portfolio that maximizes the expected return while minimizing portfolio risk, as measured by portfolio variance.

Here's an example of MVO implementation in Python using NumPy, SciPy, and a shrinkage method to obtain a sparse portfolio with positivity constraints:

python```



```import numpy as np

import pandas as pd

from scipy.optimize import minimize



def mean_variance_optimization(returns, cov_matrix, target_return, shrinkage_factor=0.5):

    num_assets = len(returns)

    

    # Objective function: Portfolio variance

    def portfolio_variance(weights, cov_matrix):

        return weights.T @ cov_matrix @ weights

    

    # Shrink covariance matrix

    avg_variance = np.mean(np.diag(cov_matrix))

    shrunk_cov_matrix = (1 - shrinkage_factor) * cov_matrix + shrinkage_factor * avg_variance * np.identity(num_assets)

    

    # Constraints

    constraints = (

        {"type": "eq", "fun": lambda w: np.sum(w) - 1},  # Sum of weights equal to 1

        {"type": "eq", "fun": lambda w: np.dot(returns, w) - target_return},  # Target return

    )

    

    # Bounds: positivity constraint

    bounds = [(0, 1) for _ in range(num_assets)]

    

    # Initial weights

    initial_weights = np.ones(num_assets) / num_assets

    

    # Minimization using L-BFGS-B

    result = minimize(portfolio_variance, initial_weights, args=(shrunk_cov_matrix), method="L-BFGS-B", bounds=bounds, constraints=constraints)

    

    return result.x



# Example usage

if __name__ == "__main__":

    asset_returns = np.array([0.05, 0.1, 0.12])

    covariance_matrix = np.array([

        [0.1, 0.05, 0.01],

        [0.05, 0.2, 0.02],

        [0.01, 0.02, 0.3],

    ])

    

    target_return = 0.1

    shrinkage_factor = 0.5

    

    optimal_weights = mean_variance_optimization(asset_returns, covariance_matrix, target_return, shrinkage_factor)

    print("Optimal Weights:", optimal_weights)```

---

## 2023-03-17 11:09:52 - issues channel

**Andrew**

Yea I'm using the examples-single.py



Is it this line:



trading = betfairlightweight.APIClient("username")



?

---

## 2023-03-17 11:06:50 - issues channel

**Andrew**

Connected to pydev debugger (build 191.7479.30)

{"asctime": "2023-03-17 10:56:16,147", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2023-03-17 10:56:16,147", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2023-03-17 10:56:16,148", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2023-03-17 10:56:16,148", "levelname": "INFO", "message": "Adding strategy back_strat_42"}

{"asctime": "2023-03-17 10:56:16,148", "levelname": "INFO", "message": "Creating new &lt;class 'flumine.streams.marketstream.MarketStream'&gt; (2000) for strategy back_strat_42"}

{"asctime": "2023-03-17 10:56:16,148", "levelname": "INFO", "message": "Starting flumine", "clients": {"username": "", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": null, "transaction_count_total": null, "trading_controls": [], "order_stream": true, "best_price_execution": true, "paper_trade": false}, "markets": {"market_count": 0, "open_market_count": 0}, "streams": ["&lt;OrderStream(OrderStream, initial daemon)&gt;", "&lt;MarketStream(MarketStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 18028)&gt;", "&lt;WriterThread(pydevd.Writer, started daemon 11888)&gt;", "&lt;ReaderThread(pydevd.Reader, started daemon 14476)&gt;", "&lt;PyDBCommandThread(pydevd.CommandThread, started daemon 8612)&gt;"]}

{"asctime": "2023-03-17 10:56:16,293", "levelname": "ERROR", "message": "BetfairClient `login` error", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\clients\\betfairclient.py\", line 29, in login\n    return self.betting_client.login()\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\betfairlightweight\\endpoints\\login.py\", line 31, in __call__\n    self.url, session=session\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\betfairlightweight\\endpoints\\login.py\", line 57, in request\n    check_status_code(response)\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\betfairlightweight\\utils.py\", line 34, in check_status_code\n    raise StatusCodeError(response.status_code)\nbetfairlightweight.exceptions.StatusCodeError: Status code error: 500", "client": "APIClient", "trading_function": "login", "response": "Status code error: 500"}

{"asctime": "2023-03-17 10:56:16,509", "levelname": "INFO", "message": "Adding worker keep_alive"}

{"asctime": "2023-03-17 10:56:16,509", "levelname": "INFO", "message": "Adding worker poll_market_catalogue"}

{"asctime": "2023-03-17 10:56:16,510", "levelname": "INFO", "message": "Adding worker poll_account_balance"}

{"asctime": "2023-03-17 10:56:16,510", "levelname": "INFO", "message": "Adding worker poll_market_closure"}

{"asctime": "2023-03-17 10:56:16,512", "levelname": "INFO", "message": "BackgroundWorker keep_alive starting", "worker_name": "keep_alive", "function": "&lt;function keep_alive at 0x000001823546B268&gt;", "context": {}, "start_delay": 0, "interval": 1200, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-03-17 10:56:16,513", "levelname": "ERROR", "message": "Error in BackgroundWorker keep_alive: 'Flumine' object has no attribute 'clients'", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 65, in run\n    self.context, self.flumine, *self.func_args, **self.func_kwargs\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 97, in keep_alive\n    for client in flumine.clients:\nAttributeError: 'Flumine' object has no attribute 'clients'", "worker_name": "keep_alive", "function": "&lt;function keep_alive at 0x000001823546B268&gt;", "context": {}}

{"asctime": "2023-03-17 10:56:16,514", "levelname": "INFO", "message": "BackgroundWorker poll_market_catalogue starting", "worker_name": "poll_market_catalogue", "function": "&lt;function poll_market_catalogue at 0x000001823546B378&gt;", "context": {}, "start_delay": 10, "interval": 60, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-03-17 10:56:16,516", "levelname": "INFO", "message": "BackgroundWorker poll_account_balance starting", "worker_name": "poll_account_balance", "function": "&lt;function poll_account_balance at 0x000001823546B400&gt;", "context": {}, "start_delay": 10, "interval": 120, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-03-17 10:56:16,518", "levelname": "INFO", "message": "BackgroundWorker poll_market_closure starting", "worker_name": "poll_market_closure", "function": "&lt;function poll_market_closure at 0x000001823546B488&gt;", "context": {}, "start_delay": 10, "interval": 60, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-03-17 10:56:16,520", "levelname": "INFO", "message": "Starting streams.."}

{"asctime": "2023-03-17 10:56:16,521", "levelname": "INFO", "message": "Starting OrderStream 1000", "stream_id": 1000, "customer_strategy_refs": "LAPTOP-SDCL040E", "conflate_ms": null, "streaming_timeout": 0.25, "client_username": ""}

{"asctime": "2023-03-17 10:56:16,522", "levelname": "INFO", "message": "Starting output_thread (OrderStream 1000)"}

{"asctime": "2023-03-17 10:56:16,523", "levelname": "INFO", "message": "[Register: 1001]: orderSubscription"}

{"asctime": "2023-03-17 10:56:16,524", "levelname": "INFO", "message": "[OrderStream: 1001]: \"OrderStream\" created"}

{"asctime": "2023-03-17 10:56:16,590", "levelname": "INFO", "message": "[OrderStream: 1001]: connection_id: 209-170323105616-5848216"}

{"asctime": "2023-03-17 10:56:16,622", "levelname": "INFO", "message": "[OrderStream: 1002]: SUCCESS (1 connections available)"}

{"asctime": "2023-03-17 10:56:16,626", "levelname": "INFO", "message": "[OrderStream: 1001]: SUCCESS (1 connections available)"}

{"asctime": "2023-03-17 10:56:16,658", "levelname": "INFO", "message": "[OrderStream: 1001]: 0 oc added"}

{"asctime": "2023-03-17 10:56:16,780", "levelname": "INFO", "message": "Starting MarketStream 2000", "stream_id": 2000, "market_filter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"], "countryCodes": ["GB", "IE"]}, "market_data_filter": {"fields": ["EX_BEST_OFFERS", "EX_LTP", "EX_MARKET_DEF"], "ladderLevels": 1}, "conflate_ms": 1000, "streaming_timeout": null}

{"asctime": "2023-03-17 10:56:16,781", "levelname": "INFO", "message": "Starting output_thread (MarketStream 2000)"}

{"asctime": "2023-03-17 10:56:18,785", "levelname": "INFO", "message": "Starting MarketStream 2000", "stream_id": 2000, "market_filter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"], "countryCodes": ["GB", "IE"]}, "market_data_filter": {"fields": ["EX_BEST_OFFERS", "EX_LTP", "EX_MARKET_DEF"], "ladderLevels": 1}, "conflate_ms": 1000, "streaming_timeout": null}

{"asctime": "2023-03-17 10:56:20,794", "levelname": "INFO", "message": "Starting MarketStream 2000", "stream_id": 2000, "market_filter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"], "countryCodes": ["GB", "IE"]}, "market_data_filter": {"fields": ["EX_BEST_OFFERS", "EX_LTP", "EX_MARKET_DEF"], "ladderLevels": 1}, "conflate_ms": 1000, "streaming_timeout": null}

{"asctime": "2023-03-17 10:56:24,811", "levelname": "INFO", "message": "Starting MarketStream 2000", "stream_id": 2000, "market_filter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"], "countryCodes": ["GB", "IE"]}, "market_data_filter": {"fields": ["EX_BEST_OFFERS", "EX_LTP", "EX_MARKET_DEF"], "ladderLevels": 1}, "conflate_ms": 1000, "streaming_timeout": null}

{"asctime": "2023-03-17 10:56:26,530", "levelname": "ERROR", "message": "Error in BackgroundWorker poll_market_catalogue: 'Flumine' object has no attribute 'clients'", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 65, in run\n    self.context, self.flumine, *self.func_args, **self.func_kwargs\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 113, in poll_market_catalogue\n    client = flumine.clients.get_betfair_default()\nAttributeError: 'Flumine' object has no attribute 'clients'", "worker_name": "poll_market_catalogue", "function": "&lt;function poll_market_catalogue at 0x000001823546B378&gt;", "context": {}}

{"asctime": "2023-03-17 10:56:26,531", "levelname": "ERROR", "message": "Error in BackgroundWorker poll_account_balance: 'Flumine' object has no attribute 'clients'", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 65, in run\n    self.context, self.flumine, *self.func_args, **self.func_kwargs\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 155, in poll_account_balance\n    for client in flumine.clients:\nAttributeError: 'Flumine' object has no attribute 'clients'", "worker_name": "poll_account_balance", "function": "&lt;function poll_account_balance at 0x000001823546B400&gt;", "context": {}}

{"asctime": "2023-03-17 10:56:26,532", "levelname": "ERROR", "message": "Error in BackgroundWorker poll_market_closure: 'Flumine' object has no attribute 'clients'", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 65, in run\n    self.context, self.flumine, *self.func_args, **self.func_kwargs\n  File \"C:\\Users\\andre\\AppData\\Local\\Continuum\\anaconda3\\lib\\site-packages\\flumine\\worker.py\", line 166, in poll_market_closure\n    for client in flumine.clients:\nAttributeError: 'Flumine' object has no attribute 'clients'", "worker_name": "poll_market_closure", "function": "&lt;function poll_market_closure at 0x000001823546B488&gt;", "context": {}}

{"asctime": "2023-03-17 10:56:32,822", "levelname": "INFO", "message": "Starting MarketStream 2000", "stream_id": 2000, "market_filter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"], "countryCodes": ["GB", "IE"]}, "market_data_filter": {"fields": ["EX_BEST_OFFERS", "EX_LTP", "EX_MARKET_DEF"], "ladderLevels": 1}, "conflate_ms": 1000, "streaming_timeout": null}

{"asctime": "2023-03-17 10:56:48,827", "levelname": "INFO", "message": "Starting MarketStream 2000", "stream_id": 2000, "market_filter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"], "countryCodes": ["GB", "IE"]}, "market_data_filter": {"fields": ["EX_BEST_OFFERS", "EX_LTP", "EX_MARKET_DEF"], "ladderLevels": 1}, "conflate_ms": 1000, "streaming_timeout": null}

---

## 2023-03-17 10:38:38 - issues channel

**Andrew**

Hi, I'm just trying to get started and I've been trying to get the ExampleStrategy on the flumine documentation to work



It seems to be getting to the start bit, but then gets stuck creating the streams (gets stuck on line 427 of baseflumine.py)



self.streams.start()



I thought it was because I had a delayed API key which didn't have streaming permissions, but betfair get me permissions, but it still isn't working



Does anyone know what might be the issue?



Thanks

---

## 2023-03-16 14:59:06 - random channel

**river_shah**

My model is to blindly back anything ridden by Rachel Blackmore....[https://www.youtube.com/watch?v=neQwFEzUmiE|60% of the time, it works every time](https://www.youtube.com/watch?v=neQwFEzUmiE|60% of the time, it works every time).

---

## 2023-03-16 13:24:13 - strategies channel

**birchy**

So that's one market stream per framework? If we want to add more event types (e.g. greyhounds), I presume it's preferable to set `event_type_ids=['7', '4339']` and then filter at strategy level? Also is it best practice to reuse a filter instance? e.g:



 `mf=filters.streaming_market_filter(

    event_type_ids=['7', '4339'],

    market_types=['WIN'],

    country_codes=['GB', 'IE'],

)`

`strategy1 = Horses1(market_filter=mf)

strategy2 = Horses2(market_filter=mf)`

---

## 2023-03-16 09:44:11 - general channel

**rob smith**

Hi, can anyone see what the issue is with my place bet order? I am trying to place a lay at BSP but just get a failure response. Thanks

```limit_order = filters.limit_order(size=10, price=1.01)

instruction = filters.place_instruction(order_type="LIMIT_ON_CLOSE", selection_id=runner.selection_id, side="LAY", limit_order=limit_order)

place_orders = trading.betting.place_orders(market_id=market_book.market_id, instructions=[instruction], customer_strategy_ref="Lay")```



---

## 2023-03-16 08:54:41 - strategies channel

**Andrew**

A somewhat related question. Is market context shared between strategies? I can see from the code that strategy context is unique per strategy. Is the same market instance passed to both strategies in the above example?

---

## 2023-03-16 07:48:08 - strategies channel

**birchy**

Just to clarify I'm using this correctly, does the following create a new market stream for each strategy or does/can it share one stream because the filters are the same?

`strategy1 = Horses1(`

    `market_filter=filters.streaming_market_filter(

        event_type_ids=['7'],

        market_types=['WIN'],

        country_codes=['GB', 'IE'],

    ),

)

framework.add_strategy(strategy1)`



`strategy2 = Horses2(

    market_filter=filters.streaming_market_filter(

        event_type_ids=['7'],

        market_types=['WIN'],

        country_codes=['GB', 'IE'],

    ),

)

framework.add_strategy(strategy2)`

---

## 2023-03-13 11:16:00 - issues channel

**Sunken**

Still having issues. Putting in some of the code I used to test the difference

```test_file_path=F'{start_path}PRO_2020_Apr_10_29766007_1.170279955.txt'

data_dump=open(test_file_path,"r")

json_dump=data_dump.readlines()



listener = betfairlightweight.StreamListener(max_latency=None,calculate_market_tv=True,cumulative_runner_tv=True)



stream = trading.streaming.create_historical_generator_stream(

    file_path=test_file_path,

    listener=listener,

)



gen =stream.get_generator()

market_booksList=list(gen())



total_traded=0



for i,update in enumerate(json_dump):

    if i == 0: # No price info

        continue

    betfair_dataDict=json.loads(update)

    trade_changeList=betfair_dataDict['mc'][0]['rc']



    for changeDict in trade_changeList:

            if 'trd' in changeDict:

                total_traded += changeDict['tv']

    total_traded_blw=market_booksList[i][0].total_matched

    if abs(total_traded - total_traded_blw) &gt;0.1:

         print(total_traded, "basic")

         print(total_traded_blw, "blw")

         print(i)```

---

## 2023-03-12 12:50:18 - issues channel

**foxwood**

Done that thanks - seems to happen most days on uk dogs if the connection is lost or start a new strategy running around 19:30 - 20:00 ish. So many markets open at the same time.

---

## 2023-03-10 14:26:29 - general channel

**liam**

You can just copy the original code



```with mock_patch("builtins.open", smart_open.open):

    for path in glob.iglob(file_path + "**/**/*.bz2", recursive=True):

        # create generator

        stream = trading.streaming.create_historical_generator_stream(

            file_path=path,

            listener=listener,

        )

        ...```

One thing to note is that this will write the data once complete so if there is an error it won't have recorded anything, you might want to refactor to write to file after each market

---

## 2023-03-10 10:06:35 - general channel

**liam**

Here is a hopefully an easier to understand script and considerably faster, few caveats:



• Half time isn't possible without some assumptions and/or other data

• All odds movements would be a massive list, is that what you actually want?

```import logging

import csv

import smart_open

from unittest.mock import patch as mock_patch

import betfairlightweight



COLUMNS = [

    "market_id",

    "event_date",

    "event_name",

    "country",

    "market_name",

    "selection_id",

    "selection_name",

    "result",

    "actual_sp",

    "pp_min",

    "pp_max",

    "pp_wap",

    "pp_ltp",

    "pp_volume",

    "ip_min",

    "ip_max",

    "ip_wap",

    "ip_ltp",

    "ip_volume"

]



file_path = "/Users/liampauling/Documents/tmp/marketdata/1.177242007.gz"



# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



# create trading instance (don't need username/password)

trading = betfairlightweight.APIClient("username", "password", "appKey")



# create listener

listener = betfairlightweight.StreamListener(

    max_latency=None,  # ignore latency errors

    output_queue=None,  # use generator rather than a queue (faster)

    lightweight=True,  # lightweight mode is faster

    update_clk=False,  # do not update clk on updates (not required when backtesting)

    cumulative_runner_tv=True,

    calculate_market_tv=True,

)



with mock_patch("builtins.open", smart_open.open):

    # create generator

    stream = trading.streaming.create_historical_generator_stream(

        file_path=file_path,

        listener=listener,

    )

    market_data = {}  # store all data



    # loop all markets

    for i in stream.get_generator()():

        for market_book in i:

            market_id = market_book["marketId"]

            if market_id not in market_data:

                market_data[market_id] = {

                    "market_definition": market_book["marketDefinition"],

                    "selections": {

                        i["id"]: {

                            "id": i["id"],

                            "name": i.get("name"),

                            "pp_min": None,

                            "pp_max": None,

                            "pp_ltp": None,

                            "pp_volume": None,

                            "ip_min": None,

                            "ip_max": None,

                            "ip_ltp": None,

                            "ip_volume": None,

                        } for i in market_book["marketDefinition"]["runners"]

                    },

                    "inplay": False,

                    "final_market_book": None,

                }

            market = market_data[market_id]



            # update selection values when prePlay

            if market_book["status"] == "OPEN" and not market_book["inplay"]:

                for selection in market_book["runners"]:

                    selection_data = market["selections"][selection["selectionId"]]

                    if selection_data["pp_min"] is None:

                        selection_data["pp_min"] = selection["lastPriceTraded"]

                        selection_data["pp_max"] = selection["lastPriceTraded"]

                        selection_data["pp_ltp"] = selection["lastPriceTraded"]

                        selection_data["pp_volume"] = selection["totalMatched"]

                    else:

                        selection_data["pp_min"] = min(selection_data["pp_min"], selection["lastPriceTraded"])

                        selection_data["pp_max"] = max(selection_data["pp_max"], selection["lastPriceTraded"])

                        selection_data["pp_ltp"] = selection["lastPriceTraded"]

                        selection_data["pp_volume"] = selection["totalMatched"]



            # update selection values when inPlay

            if market_book["status"] == "OPEN" and market_book["inplay"]:

                for selection in market_book["runners"]:

                    selection_data = market["selections"][selection["selectionId"]]

                    if selection_data["ip_min"] is None:

                        selection_data["ip_min"] = selection["lastPriceTraded"]

                        selection_data["ip_max"] = selection["lastPriceTraded"]

                        selection_data["ip_ltp"] = selection["lastPriceTraded"]

                        selection_data["ip_volume"] = selection["totalMatched"]

                    else:

                        selection_data["ip_min"] = min(selection_data["ip_min"], selection["lastPriceTraded"])

                        selection_data["ip_max"] = max(selection_data["ip_max"], selection["lastPriceTraded"])

                        selection_data["ip_ltp"] = selection["lastPriceTraded"]

                        selection_data["ip_volume"] = selection["totalMatched"]

                        selection_data["actual_sp"] = selection["sp"]["actualSP"]



            # final book

            market["final_market_book"] = market_book



# write data to csv

with open("output_bflw_new.csv", "w") as f:

    writer = csv.DictWriter(f, fieldnames=COLUMNS)

    writer.writeheader()

    for market_id, market in market_data.items():

        market_definition = market["market_definition"]

        selection_lookup = {i["selectionId"]: i for i in market["final_market_book"]["runners"]}

        for selection in market["selections"].values():

            writer.writerow(

                {

                    # market level data

                    'market_id': market_id,

                    'event_date': market_definition["marketTime"],

                    'event_name': market_definition.get("eventName"),

                    'country': market_definition["countryCode"],

                    'market_name': market_definition.get("name"),

                    # selection level data

                    'selection_id': selection["id"],

                    'selection_name': selection["name"],

                    'result': selection_lookup[selection["id"]]["status"],

                    'actual_sp': selection["actual_sp"],

                    "pp_min": selection["pp_min"],

                    "pp_max": selection["pp_max"],

                    # "pp_wap",

                    "pp_ltp": selection["pp_ltp"],

                    "pp_volume": selection["pp_volume"],

                    "ip_min": selection["ip_min"],

                    "ip_max": selection["ip_max"],

                    # "ip_wap",

                    "ip_ltp": selection["ip_ltp"],

                    "ip_volume": selection["ip_volume"],

                }

            )```

---

## 2023-03-08 19:55:57 - strategies channel

**Dave**

I wish I had a model for racing instead and just said "always trade at my modeled price + some markup", which is way easier to manage. But alas, my triggers are just based on observed values in market data for now + some hypothesis as to how the impact future price.

---

## 2023-03-08 19:54:16 - strategies channel

**Dave**

Sure, and tbh I have experienced just that. For racing, my initial thresholds were picked from backtest but I've had to tune down the aggressiveness based on real trading. I was concerned if the tuning based on real trades was me adapting to seasonality (and therefore might have to tune again in a month or two to pick up spring racing etc) OR just me adapting to the differences in simulation Vs reality (and therefore I've now hit my stable state which shouldn't go stale). For football on the other hand, for years I've kept my execution the same (minus some moderate tweaking), but my black-box models get retrained every few months to pick up changes in league stage etc.

---

## 2023-03-08 19:48:42 - strategies channel

**liam**

I think it’s more important to try and understand what impacts a strategy pnl.



I find that optimising model variables / thresholds in an ideal world to be be the easy part, the problem is the market is not ideal. You can see this by comparing a model with 100% matching vs real world, the optimum will be different. 



To answer your question I think it can certainly vary per market type, racing is a nightmare as you have the slow decay mixed with the change in ‘seasons’. I don’t think I have ever had a strategy increase it’s profit/ROI without an iterative AvB type development to see where the limits are. You can’t do this purely through simulation, sometimes involves bleeding some cash. I have mentioned this before and I think there was a poll but I spend 80% of my time on execution/matching (which feeds into threshold and model optimization) 

---

## 2023-03-08 10:22:14 - strategies channel

**birchy**

[@U0128E7BEHW](@U0128E7BEHW) I use market data only which is essentially based on "abnormal" activity, so other than occasionally rechecking what a "normal" market is, I don't change parameters/signals/etc. In fact, I have one particular strategy that has been ticking along for 10+ years and every time I've attempted to optimise it has a detrimental effect. :grinning:

---

## 2023-03-06 15:29:51 - random channel

**Luke Stevens-Cox**

Hi guys, new to this slack and sports modelling has anyone done any golf modelling and have any resources they'd be willing to share around where they started or anything they found useful? Thanks

---

## 2023-03-06 14:38:07 - random channel

**PeterLe**

TPD were scheduled to do a workshop  today at Wolvs :

-------  TPD Wrote : --------------

Good Morning, in case you are not aware we are running a Workshop at Wolverhampton racecourse on Monday 6th March. The broad agenda being; arrive late afternoon, meet the TPD team, a few presentations re various elements of the service.



The first race is at 5:30pm and the final race at 8:30pm. We plan to do some live betting in the races.



This is a totally free event, there are a limited number of places remaining, if you would like a place reserving please drop an email to [mailto:support@tpd.zone|support@tpd.zone](mailto:support@tpd.zone|support@tpd.zone).

--------------------

There is an email address there DC if it helps?

---

## 2023-03-06 06:37:41 - issues channel

**jp**

A few times every week I have gotten the following exception when calling Betfair API lately:



The SSL connection could not be established, see inner exception.

 ---&gt; System.Security.Authentication.AuthenticationException: Authentication failed because the remote party sent a TLS alert: 'DecryptError'.

 ---&gt; System.ComponentModel.Win32Exception (0x80090326): The message received was unexpected or badly formatted.



I am not using Flumine/Betcode, but my own C# code. This happens when calling placeOrders or cancelOrders (and maybe others). I could send thousands of working requests before and after this, and ignoring it seems to work out ok. But it would be nice to understand what it is about. Anyone else seen it?

---

## 2023-03-05 15:44:38 - strategies channel

**Dave**

Question regarding strategy calibration: how often do you tend to recalibrate your strategy parameters, e.g. refresh the thresholds of your triggers etc? For my football betting I have always been able to keep my thresholds the same, but retrain my ML models periodically, for a few years now. Never really been an issue. For racing (which I've only been doing at scale since last Nov), I have no model, just reacting to observations in market data (so the model ends up being a bunch of handcrafted thresholds). I have no sense yet as to how quickly my calibrated values may become too stale. Does anyone do anything as basic as this, and if so, how do you keep your thresholds/parameters up to date? Run some periodic optimization over a grid of possible thresholds?

---

## 2023-03-01 18:03:33 - random channel

**Paul**

This free event is happening in my office in April and might touch on subjects of interest here. I know one of the organisers works with some bookmaker trading desks and I’m hoping to get him or his customers to leak some alpha in a nearby bar afterwards. [https://awsdeepdivesdays.splashthat.com|https://awsdeepdivesdays.splashthat.com](https://awsdeepdivesdays.splashthat.com|https://awsdeepdivesdays.splashthat.com)

---

## 2023-02-24 09:29:24 - issues channel

**Mo**

Use the `read_timeout` attribute of `betting`: [https://github.com/betcode-org/betfair/blob/00e9abb2b4d228408eea1620cbeb55cbaed0e0c6/betfairlightweight/endpoints/baseendpoint.py#L15](https://github.com/betcode-org/betfair/blob/00e9abb2b4d228408eea1620cbeb55cbaed0e0c6/betfairlightweight/endpoints/baseendpoint.py#L15)

---

## 2023-02-24 09:17:55 - issues channel

**EJono**

I have a function set up to pull through cleared orders from record that started to fail on the 15th. Nothing has changed about the function which executes 3 times a day, depsite it working for weeks prior. This code executes in a loop with "iteration" being incremented from 0, 1, 2, 3, ... while the returned moreAvailable firled is True.



bet_status = 'SETTLED'

group_by = 'BET'

from_record = iteration *100

record_count = (iteration+1) *100



orders = trading.betting.list_cleared_orders(

            group_by=group_by,

            bet_status=bet_status,

            from_record=from_record,

            record_count=record_count,

            lightweight=True,



        )



The full exception is quite long but the final traceback handled states the following:



Traceback (most recent call last):

  File "/mnt/syndicate_middleware/adjustFunctions/betfairLadderOperations.py", line 1290, in getFilteredClearedOrders

    orders = trading.betting.list_cleared_orders(

             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "/usr/local/lib/python3.11/site-packages/betfairlightweight/endpoints/betting.py", line 434, in list_cleared_orders

    (response, response_json, elapsed_time) = self.request(method, params, session)

                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "/usr/local/lib/python3.11/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 45, in request

    raise APIError(None, method, params, e)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders

Params: {'betStatus': 'SETTLED', 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'BET', 'fromRecord': '0', 'recordCount': '100'}

Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=16)



Ive tried messing with the parameters  ie reducing volume records requested in each call but nothing seems to be solving this issue. From docemunetation you should be able to retrieve up to 1000 records at a time. Current order requests still work fine. Anything obvious im missing for succesfully retrieving the cleared orders from record?

---

## 2023-02-21 22:22:26 - issues channel

**Lee**

How are you equating no data? Do you receive the snapshot or just no updates? Are you assigning both filters to a strategy? Greyhound markets hours before are thin, there can be a big gaps between updates

---

## 2023-02-21 11:40:58 - general channel

**Ke**

Does anyone use 3rd party api to incorporate live score in the strategy? Any recommendations?

---

## 2023-02-20 21:19:00 - general channel

**AI Trader**

*Conflate logic*

Another question guys,

For the Flumine simulation, I am trying to check wether the conflate_ms is working or not, and it seems to me that it is not.

I have added a print of the timestamps (market_book.publish_timestemp_epoch) in the *process_market_book* , and no matter what conflate_ms I use (here I am using 10_000 ms), it always receives the same updates (which seems to be the most granular possible).

Is there anything extra required to make conflate_ms work in simulation mode?



Below is how I am instantiating the FlumineStrategy.

```flumine_strategy = FlumineStrategy(

    strategy = strategy,

    client=client,

    name="bt",

    market_filter={"markets": [market_file]},

    conflate_ms=10_000,

    max_live_trade_count=1000,

    max_selection_exposure=1000,

    max_order_exposure=1000

)```



---

## 2023-02-20 20:07:41 - strategies channel

**birchy**

I've found the same as [@UQL0QDEKA](@UQL0QDEKA) and no longer bin strategies that are only slightly +EV in simulation. [@U4H19D1D2](@U4H19D1D2) I've had quite a few similar graphs where I've analysed bet logs and then trimmed out some "poor" bets which simulation shows an improvement but real-world shows a downturn. My conclusions are:

1. The strategy is already optimal for the available £

2. I've inadvertently overfitted

---

## 2023-02-19 09:10:54 - general channel

**Peter**

You can't directly. Betfair's order processing is the same for all orders so doesn't care what the event type is and therefore doesn't include it in the response. Three possible ways around this, each with pros and cons would be:

• a lookup on the market_id (yes they are unique)

• put the event type ID or name in the customer strategy reference so that it is returned with the orders response

• keep a record your end of the orders that you've placed against which you can lookup the responses

---

## 2023-02-18 22:07:05 - general channel

**AI Trader**

Hi guys,

How can I reconstruct the betfair URL (eg

[https://www.betfair.com/exchange/plus/football/market/1.208541766](https://www.betfair.com/exchange/plus/football/market/1.208541766))  from information available in the placed orders (fetched from betfairlightweight.betting.list_current_orders) ?

I need both the event type (eg footbal) and the market_id. The response from betfairlightweight.betting.list_current_orders only includes the market_id. Any advices?



Also, could anyone confirm that market_id is unique across all event types as well?

---

## 2023-02-18 16:02:11 - general channel

**SrFabio**

Hey guys what live data feed would you guys recommend for football games? I'm developing an hybrid trading approach with some automated components and it's very sensitive to delay, I'm not sure if you guys have tried anything I just need to know the events (goals, fouls, corners etc..) as they happen with the least delay possible

---

## 2023-02-17 03:47:32 - general channel

**AI Trader**

Hi [@U4H19D1D2](@U4H19D1D2),

I found a solution for the issue, but I would still like to figure out what was going wrong if you could help.

I solved it by replacing the JupyterLoggingControl in the examples by the BacktestLoggingControl.



To be more precise, it was getting stuck at c.join() in BaseFlumine ([https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/baseflumine.py#L445](https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/baseflumine.py#L445))



`Solution`

```framework.add_strategy(flumine_strategy)

# framework.add_logging_control(JupyterLoggingControl(directory=backtester_orders_path, file_name=f"{market_id}.json"))

framework.add_logging_control(BacktestLoggingControl())

framework.run()```



---

## 2023-02-16 02:53:16 - general channel

**AI Trader**

I think I might have narrowed down the error.



To be more precise, when debugging, the code stops at line 34 (in FlumineSimulation.run() on `with self:`) [https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/simulation/simulation.py#L34](https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/simulation/simulation.py#L34), with no errors, but never ends.



I think the reason for the error is that I have created a Child class of Flumine BaseStrategy, and thus I am not reaching BaseFlumine.__exit__.



Will try to produce a minimal example tomorrow

---

## 2023-02-13 00:31:20 - general channel

**Andrew**

Borrowed from elsewhere, and modified for my use. Can't recall where from.



`market_files = [f'{MARKET_FILES_PATH}/{path}' for path in os.listdir(MARKET_FILES_PATH,)]`



`def run_process(market_files):`

    `price_recorder = PriceRecorder(`

        `market_filter=`

        `{`

            `'markets': market_files,`

            `'event_type_ids': ['4339'],`

            `'country_codes': ['AU'],`

            `'market_types':['WIN'],`

            `'listener_kwargs': {'inplay': False},`  

        `},`

    `)`



    `framework = FlumineSimulation(clients.SimulatedClient())`

    `framework.add_strategy(price_recorder)`

    `framework.run()`



`def main():`

    `_start = time.time()`



    `processes = os.cpu_count()  # Returns the number of CPUs in the system.`

    `markets_per_process = 8   # 8 is optimal as it prevents data leakage.`



    `_process_jobs = []`

    `with futures.ProcessPoolExecutor(max_workers=processes) as p:`

        `# Number of chunks to split the process into depends on the number of markets we want to process and number of CPUs we have.`

        `chunk_size = min(`

            `markets_per_process, math.ceil(len(market_files) / processes)`

        `)`

        `# Split all the markets we want to process into chunks to run on separate CPUs and then run them on the separate CPUs`

        `for markets in (utils.chunks(market_files, chunk_size)):`

            `_process_jobs.append(`

                `p.submit(`

                    `run_process,`

                    `market_files=markets,`

                `)`

            `)`

        `for job in [http://futures.as|futures.as](http://futures.as|futures.as)_completed(_process_jobs):`

            `job.result()  # wait for result`



    `print(f'Total execution time: {(time.time() - _start):.2f} secs')`



`if __name__ == "__main__":`

    `main()`

---

## 2023-02-12 22:53:21 - general channel

**Andrew**

Taking such an approach means you can’t have bank management across markets. Which market runs first? But to simulate strategy on markets in parallel to collect results I’ve used ProcessPoolExecutor in Python concurrent.futures.

---

## 2023-02-12 16:59:16 - general channel

**AI Trader**

Hi [@U4H19D1D2](@U4H19D1D2), thanks a lot!



I am backtesting the strategy using the Flumine Backtester (along with data collected from Flumine data recorder).

My my market_catalogue is never available (market.market_catalogue is always None).



I know it stores data in two different folders:

• marketCatalogue/

• streaming/

I am only giving passing to the backtester the path to the streaming file (in the market_filter argument, see code below).  My understanding is that the streaming data also contains market_catalogue messages from the exchange, so that shouldn't be a problem. Am I missing something? Any help will be appreciated.



```strategy = MakerStrategy(

    client=client,

    name="bt",

    market_filter={"markets": [path_to_streaming_file]},

    conflate_ms=100,

    max_live_trade_count=1000,

    max_selection_exposure=1000,

    max_order_exposure=1000

)```

---

## 2023-02-12 06:52:29 - general channel

**liam**

It filters per strategy but if you look at the code you can create your own version if required 



[https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/markets/blotter.py#L74|https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/markets/blotter.py#L74](https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/markets/blotter.py#L74|https://github.com/betcode-org/flumine/blob/aaf2e1a027a19e1bb2209a77015e16eb8c689040/flumine/markets/blotter.py#L74)

---

## 2023-02-12 06:48:55 - issues channel

**Andy B**

Thanks Liam, I knew that I needed to get across to Flumine at some point and this might be the clincher.  I have always prioritised worki g on building profitable models, but I do need to take a step back and take a more holistic view of my environment.

I do catch errors for most of my code, but I hadn't wrapped anything around this.  I think i'll do that as the first step while I look at how I migrate my code across to flumine and whatever changes that requires within my code.

---

## 2023-02-12 06:47:55 - general channel

**liam**

`strategy_selection_orders()`

---

## 2023-02-12 00:47:07 - issues channel

**Andy B**

Hi All,



I am trying to get to the bottom of Betfair connection issues which have cropped up in the last week.  I have a feeling it is because of the way I have implemented by strategies, because I am running 6 separate scripts which all do repeated logins to Betfair.  The error that has been randomly appearing this week is:



Traceback (most recent call last):

  File "C:\Python\lib\site-packages\urllib3\connectionpool.py", line 386, in _make_request

    self._validate_conn(conn)

  File "C:\Python\lib\site-packages\urllib3\connectionpool.py", line 1042, in _validate_conn

    conn.connect()

  File "C:\Python\lib\site-packages\urllib3\connection.py", line 414, in connect

    self.sock = ssl_wrap_socket(

  File "C:\Python\lib\site-packages\urllib3\util\ssl_.py", line 449, in ssl_wrap_socket

    ssl_sock = _ssl_wrap_socket_impl(

  File "C:\Python\lib\site-packages\urllib3\util\ssl_.py", line 493, in _ssl_wrap_socket_impl

    return ssl_context.wrap_socket(sock, server_hostname=server_hostname)

  File "C:\Python\lib\ssl.py", line 500, in wrap_socket

    return self.sslsocket_class._create(

  File "C:\Python\lib\ssl.py", line 1040, in _create

    self.do_handshake()

  File "C:\Python\lib\ssl.py", line 1309, in do_handshake

    self._sslobj.do_handshake()

socket.timeout: _ssl.c:1105: The handshake operation timed out



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "C:\Python\lib\site-packages\requests\adapters.py", line 489, in send

    resp = conn.urlopen(

  File "C:\Python\lib\site-packages\urllib3\connectionpool.py", line 787, in urlopen

    retries = retries.increment(

  File "C:\Python\lib\site-packages\urllib3\util\retry.py", line 550, in increment

    raise six.reraise(type(error), error, _stacktrace)

  File "C:\Python\lib\site-packages\urllib3\packages\six.py", line 770, in reraise

    raise value

  File "C:\Python\lib\site-packages\urllib3\connectionpool.py", line 703, in urlopen

    httplib_response = self._make_request(

  File "C:\Python\lib\site-packages\urllib3\connectionpool.py", line 389, in _make_request

    self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)

  File "C:\Python\lib\site-packages\urllib3\connectionpool.py", line 340, in _raise_timeout

    raise ReadTimeoutError(

urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "C:\Python\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 36, in request

    response = [http://session.post|session.post](http://session.post|session.post)(

  File "C:\Python\lib\site-packages\requests\api.py", line 115, in post

    return request("post", url, data=data, json=json, **kwargs)

  File "C:\Python\lib\site-packages\requests\api.py", line 59, in request

    return session.request(method=method, url=url, **kwargs)

  File "C:\Python\lib\site-packages\requests\sessions.py", line 587, in request

    resp = self.send(prep, **send_kwargs)

  File "C:\Python\lib\site-packages\requests\sessions.py", line 701, in send

    r = adapter.send(request, **kwargs)

  File "C:\Python\lib\site-packages\requests\adapters.py", line 578, in send

    raise ReadTimeout(e, request=request)

requests.exceptions.ReadTimeout: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "C:\Users\elmob\OneDrive\Punting\Scripts\Betfair\Model6.py", line 649, in &lt;module&gt;

    GetBFRunners()

  File "C:\Users\elmob\OneDrive\Punting\Scripts\Betfair\Model6.py", line 164, in GetBFRunners

    greyhounds_events = trading.betting.list_events(

  File "C:\Python\lib\site-packages\betfairlightweight\endpoints\betting.py", line 123, in list_events

    (response, response_json, elapsed_time) = self.request(method, params, session)

  File "C:\Python\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 45, in request

    raise APIError(None, method, params, e)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listEvents

Params: {'filter': {'eventTypeIds': [4339], 'marketCountries': ['AU', 'NZ'], 'marketStartTime': {'to': '2023-02-14T00:24:32Z'}}}

Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)



To clarify how my scripts run, they all begin by creating the betfair login using:

trading = betfairlightweight.APIClient(username=my_username,

                                    password=my_password,

                                    app_key=my_app_key,

                                    certs=certs_path)



trading.login()



I then get my list of races and runners from Betfair using a custom function, and I suspect this is where it is falling over every time.  I've got a hunch that when I call the BFLW functions within betting.py, the fact that I am calling the same methods multiple times across the 6 scripts is causing it to timeout because it is too many attempts or too much data requested from Betfair.



Does this sound logical or is there something else in the error code that points to the issue?  If it is the problem, what is the best method of implementing my code to manage multiple different strategies with their own independent methods in my code?



Cheers

---

## 2023-02-11 19:18:02 - issues channel

**Mikkel**

Thanks Foxwood. I have read the BF docs and recovered the password, multiple times... still same issues.



Liam,



I am trying to login using the following:



username = "[mailto:mikkelwr@icloud.com|m](mailto:mikkelwr@icloud.com|m)y email address"



password = "***"



app_key = "***"









trading = betfairlightweight.APIClient(username = "username" , password = "password", app_key = "app_key", certs='/Applications/xca')



resp = [http://trading.session.post|trading.session.post](http://trading.session.post|trading.session.post)(

    url=trading.login_interactive.url,

    data={

        "username": trading.username,

        "password": trading.password,

        "redirectMethod": "POST",

        "product": trading.app_key,

        "url": "[https://www.betfair.com](https://www.betfair.com)",

        "submitForm": True,

    }

)



session_token = "****"















print(trading.betting.list_event_types())

---

## 2023-02-08 23:32:23 - general channel

**Unknown**

```import math

from collections import OrderedDict

from flumine import BaseStrategy

from flumine.order.trade import Trade

from flumine.order.order import OrderStatus

from flumine.order.ordertype import LimitOrder

from flumine.utils import get_price

import numpy as np





class LowestLayer(BaseStrategy):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

        self.max_order_exposure = 100



    def check_market_book(self, market, market_book):

        if market_book.status == "OPEN" and not market_book.inplay:

            return True



    def process_market_book(self, market, market_book):



        # count market matched trades

        market_matched_trades_count = sum(

            [self.get_runner_context(market.market_id, r.selection_id, r.handicap).trade_count -

             self.get_runner_context(market.market_id, r.selection_id, r.handicap).live_trade_count for r

             in market_book.runners])



        # get lowest/highest priced runner (depends on sort settings)

        prices = [

            (r.selection_id, get_price(r.ex.available_to_back, 0))

            for r in market_book.runners if r.status == "ACTIVE"



        ]



        if not prices:

            return



        if market.seconds_to_start &gt; 250:

            return



        prices.sort(key=lambda tup: tup[1], reverse=False)

        selection_id = prices[0][0]



        if prices[0][1] &gt; 12:

            return



        # calculate market under/over round for later analysis

        underround = _calculate_underround(market_book.runners)



        for runner in market_book.runners:



            runner_context = self.get_runner_context(

                market.market_id, runner.selection_id, runner.handicap

            )



            if runner.selection_id == selection_id:



                '''Place initial bet'''

                if market_matched_trades_count == 0 and runner_context.live_trade_count == 0 and 250 &gt; market.seconds_to_start &gt; 0:

                    self.create_trade_create_order(market, market_book, runner, underround, self.context['stake'],

                                                   back_lay='LAY', market_depth=0)

                    print('Entry Bet')



                '''Code only here for investigations'''

                if market.seconds_to_start in [104.043, 103.929]:

                    print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;')

                    print(f'SECONDS TO START = {market.seconds_to_start}')

                    print(f'strategy_selection_orders{market.blotter.strategy_selection_orders(self, selection_id, runner.handicap)}')

                    print(f'market.blotter.orders = {[o for o in market.blotter]}')

                    print(f'market status = {market.status}')

                    print(f'runner status = {runner.status}')

                    print( f'selection exposure = {market.blotter.selection_exposure(strategy=self, lookup=(runner.handicap, runner.selection_id))}')

                    print(f'stats = {market.blotter.get_exposures(strategy=self, lookup=(runner.handicap, runner.selection_id))}')

                    print(f'number of active runners = {len([r for r in market_book.runners if runner.status == "ACTIVE"])}')



                '''Try to green up on runner - limit order'''

                if runner_context.trade_count == 1 and runner_context.live_trade_count == 0 \

                        and 30 &lt; market.seconds_to_start &lt;= 60:

                    stake, price, backorlay = self.green_all(market, runner, market_depth=0)

                    self.create_trade_create_order(market, market_book, runner, underround,

                                                   stake=stake, back_lay=backorlay, set_price=price)



                '''If green up was unsuccessful then cancel bets'''

                if runner_context.trade_count &gt;= 1 and runner_context.live_trade_count &gt; 0 and market.seconds_to_start &lt; 30:

                    executable_orders = [o for o in

                                         market.blotter.strategy_selection_orders(

                                             self, selection_id, runner.handicap) if o.status.value == 'Executable']



                    if len(executable_orders) &gt; 0:

                        for order in executable_orders:

                            market.cancel_order(order)

                            print(executable_orders)



                '''Place green up at market price

                Will do this only if matched profit if lose &gt; £1 difference that matched profit if win'''

                if market.seconds_to_start &lt; 25:

                    exposures = market.blotter.get_exposures(strategy=self,

                                                             lookup=(runner.handicap, runner.selection_id))



                    matched_profit_if_win = math.sqrt(exposures['matched_profit_if_win'] ** 2)

                    matched_profit_if_lose = math.sqrt(exposures['matched_profit_if_lose'] ** 2)

                    if math.sqrt((matched_profit_if_win - matched_profit_if_lose) ** 2) &gt; 1:

                        stake, price, backorlay = self.green_all(market, runner, dump_position=True)

                        self.create_trade_create_order(market, market_book, runner, underround,

                                                       stake=stake, set_price=price, back_lay=backorlay)



     



    def process_orders(self, market, orders):

        # kill order if unmatched in market for greater than X seconds

        for order in orders:

            if order.status == OrderStatus.EXECUTABLE:

                if order.elapsed_seconds and order.elapsed_seconds &gt; 100:

                    market.cancel_order(order)



    def create_trade_create_order(self, market, market_book, runner, underround, stake,

                                  back_lay: str, market_depth: int = 1, set_price: float = 0.0):



        stake = float((np.round(stake, 2)))

        '''If market_order = True then a higher market_depth results 

        in a worst price. If it is False the reverse is true'''



        if set_price != 0.0:

            bet_template = [back_lay, set_price]

        elif back_lay == 'BACK':

            bet_template = ['BACK', get_price(runner.ex.available_to_lay, market_depth)]

        else:

            bet_template = ['LAY', get_price(runner.ex.available_to_back, market_depth)]



        # create trade

        trade = Trade(

            market_book.market_id,

            runner.selection_id,

            runner.handicap,

            self,

        )

        # create order

        order = trade.create_order(

            side=bet_template[0],

            order_type=LimitOrder(bet_template[1], np.round(stake, 2)),

            notes=OrderedDict(underround=round(underround, 4)),

        )

        # place order for execution

        market.place_order(order)



    def green_all(self, market, runner, market_depth: int = 0, dump_position: bool = False):

        facts = market.blotter.get_exposures(strategy=self, lookup=(runner.handicap, runner.selection_id))



        selection_exposure = market.blotter.selection_exposure(strategy=self,

                                                               lookup=(runner.handicap, runner.selection_id))

        matched_profit_if_win = facts['matched_profit_if_win']

        matched_profit_if_lose = facts['matched_profit_if_lose']

        print('green all called')

        print(matched_profit_if_win)

        print(matched_profit_if_lose)



        if matched_profit_if_win &gt; 0:

            avg_odds = (matched_profit_if_win + selection_exposure) / selection_exposure

            if dump_position is False:

                return self.calc_green(avg_odds,

                                       current_price_of_runner=get_price(runner.ex.available_to_back, market_depth),

                                       total_staked=selection_exposure) + ('LAY',)

            else:

                return self.calc_green(avg_odds,

                                       current_price_of_runner=get_price(runner.ex.available_to_lay, 0),

                                       total_staked=selection_exposure) + ('LAY',)



        if matched_profit_if_win &lt; 0:

            avg_odds = (matched_profit_if_lose + selection_exposure) / matched_profit_if_lose

            if dump_position is False:

                return self.calc_green(avg_odds,

                                       current_price_of_runner=get_price(runner.ex.available_to_lay, market_depth),

                                       total_staked=matched_profit_if_lose) + ('BACK',)

            else:

                return self.calc_green(avg_odds,

                                       current_price_of_runner=get_price(runner.ex.available_to_back, 0),

                                       total_staked=matched_profit_if_lose) + ('BACK',)



    def calc_green(self, avg_odds, current_price_of_runner, total_staked):

        green_all_stake = avg_odds / current_price_of_runner * total_staked

        return green_all_stake, current_price_of_runner





def _calculate_underround(runners: list) -&gt; float:

    return sum(

        [

            1 / get_price(r.ex.available_to_lay, 0)

            for r in runners

            if r.ex.available_to_lay

        ]

    )```

---

## 2023-02-08 17:56:57 - strategies channel

**Peter**

Oops [@UQL0QDEKA](@UQL0QDEKA). Just spotted that you have the parameters in the wrong place. They're parameters for the strategy rather than the market_filter, so your code should be:



```strategy = Sub6(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"], # was 7 for horses, 4339 for greyhounds, 15 = todays card greyhounds

        country_codes=["GB","IE"],

        market_types=["WIN"],

    ),

    max_order_exposure=5,

    max_selection_exposure=20,

    max_trade_count=5,

    max_live_trade_count=1

)```

Apologies for not picking this up first time around.

---

## 2023-02-08 12:27:51 - strategies channel

**PeterLe**

Thanks for the reply Peter. My strategies are standalone ie not inside strategy.py (where BaseStrategy is defined). OK I think I understand what you are saying here. Thanks for clarifying that.

Just as a belt/braces approach, Ive also set the individual betfair account exposures via the master account too, just to be on the safe side. Appreciate the reply thanks

---

## 2023-02-08 10:04:14 - strategies channel

**Peter**

A little confused by the question. Is your strategy not inside your Strategy.py file, or were you referring to the Fumine strategy.py file where BaseStrategy is defined (and which you shouldn't touch). Either way, what you're doing is the right way to go about it.



It's worth playing about a little with these parameters to get a feel for how they work, individually and together, It's super easy to nix a strategy by accidentally setting them too tight, especially when laying. E.g. after recognised prices have been set and stakes have been rounded to 2 decimal places, is there any risk of the actual order exposure could be 5.01?

---

## 2023-02-08 09:32:06 - strategies channel

**PeterLe**

Morning. If you have a number of strategies running on the same system and the same betfair account...How do you set the exposures for each strategy independently.

I currently have this code in a single strategy:

```strategy = Sub6(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"], # was 7 for horses, 4339 for greyhounds, 15 = todays card greyhounds

        country_codes=["GB","IE"],

        market_types=["WIN"],

    ),```

Would I change it to something like this:

```strategy = Sub6(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"], # was 7 for horses, 4339 for greyhounds, 15 = todays card greyhounds

        country_codes=["GB","IE"],

        market_types=["WIN"],

        max_order_exposure=5,

        max_selection_exposure=20,

        max_trade_count=5,

        max_live_trade_count=1

    ),```

So can the exposures be set in the strategy itself rather than in Strategy.py Sorry only basic python skills so i might be talking $%^&amp; Thanks :grinning:

---

## 2023-02-07 21:39:43 - general channel

**Trex44**

```{"asctime": "2023-02-07 21:17:57,216", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.138465931", "selection_id": 10200239, "handicap": 0, "id": "138950974772156791", "customer_order_ref": "4d8a4a5a825e8-138950974772156791", "bet_id": null, "date_time_created": "2018-01-01 13:05:50.071000", "publish_time": "2018-01-01 13:05:50.071000", "market_version": null, "async": false, "trade": {"id": "e47d1976-a72c-11ed-93b3-3fe541d536d4", "strategy": "LowestLayer", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138950974772156791"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 3.7, "size": 5.0, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null, "price_ladder_definition": "CLASSIC"}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 5.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Pending", "status_log": "Pending", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "0.9912", "market_notes": null, "client": "72f36d32"}

{"asctime": "2023-02-07 21:17:57,216", "levelname": "INFO", "message": "1 order packages executed in transaction", "market_id": "1.138465931", "order_packages": [{"id": "e47d1978-a72c-11ed-93b3-3fe541d536d4", "client": "&lt;flumine.clients.simulatedclient.SimulatedClient object at 0x7f61a3560250&gt;", "market_id": "1.138465931", "orders": ["138950974772156791"], "order_count": 1, "package_type": "Place", "customer_strategy_ref": "ip-172-31-38-7", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}], "transaction_id": 1, "client_username": "72f36d32"}

Entry Bet

{"asctime": "2023-02-07 21:17:57,217", "levelname": "INFO", "message": "Trade status update: Pending", "id": "e47d1976-a72c-11ed-93b3-3fe541d536d4", "strategy": "LowestLayer", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138950974772156791"], "offset_orders": [], "notes": "", "market_notes": "3.7,3.8,3.7", "status": "Pending", "status_log": "Pending"}

{"asctime": "2023-02-07 21:17:57,218", "levelname": "INFO", "message": "Order Place: SUCCESS", "bet_id": null, "order_id": "138950974772156791", "status": "SUCCESS", "error_code": null}

{"asctime": "2023-02-07 21:17:57,218", "levelname": "INFO", "message": "Order status update: Executable", "market_id": "1.138465931", "selection_id": 10200239, "handicap": 0, "id": "138950974772156791", "customer_order_ref": "4d8a4a5a825e8-138950974772156791", "bet_id": "100000000001", "date_time_created": "2018-01-01 13:05:50.071000", "publish_time": "2018-01-01 13:05:50.071000", "market_version": null, "async": false, "trade": {"id": "e47d1976-a72c-11ed-93b3-3fe541d536d4", "strategy": "LowestLayer", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138950974772156791"], "offset_orders": [], "notes": "", "market_notes": "3.7,3.8,3.7", "status": "Pending", "status_log": "Pending"}, "order_type": {"order_type": "Limit", "price": 3.7, "size": 5.0, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null, "price_ladder_definition": "CLASSIC"}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 5.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2018-01-01 13:05:50.294000", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Executable", "status_log": "Pending, Executable", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 25.65, "matched": []}, "notes": "0.9912", "market_notes": "3.7,3.8,3.7", "client": "72f36d32"}

{"asctime": "2023-02-07 21:17:57,218", "levelname": "INFO", "message": "Trade status update: Live", "id": "e47d1976-a72c-11ed-93b3-3fe541d536d4", "strategy": "LowestLayer", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138950974772156791"], "offset_orders": [], "notes": "", "market_notes": "3.7,3.8,3.7", "status": "Live", "status_log": "Pending, Live"}

{"asctime": "2023-02-07 21:17:57,220", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.138465931", "selection_id": 10200239, "handicap": 0, "id": "138950974772156791", "customer_order_ref": "4d8a4a5a825e8-138950974772156791", "bet_id": "100000000001", "date_time_created": "2018-01-01 13:05:50.071000", "publish_time": "2018-01-01 13:05:50.071000", "market_version": null, "async": false, "trade": {"id": "e47d1976-a72c-11ed-93b3-3fe541d536d4", "strategy": "LowestLayer", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138950974772156791"], "offset_orders": [], "notes": "", "market_notes": "3.7,3.8,3.7", "status": "Live", "status_log": "Pending, Live"}, "order_type": {"order_type": "Limit", "price": 3.7, "size": 5.0, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null, "price_ladder_definition": "CLASSIC"}, "info": {"side": "LAY", "size_matched": 5.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 3.7}, "responses": {"date_time_placed": "2018-01-01 13:05:50.294000", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Execution complete", "status_log": "Pending, Executable, Execution complete", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0, "matched": [[1514811950696, 3.7, 5.0]]}, "notes": "0.9912", "market_notes": "3.7,3.8,3.7", "client": "72f36d32"}

{"asctime": "2023-02-07 21:17:57,220", "levelname": "INFO", "message": "Trade status update: Complete", "id": "e47d1976-a72c-11ed-93b3-3fe541d536d4", "strategy": "LowestLayer", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138950974772156791"], "offset_orders": [], "notes": "", "market_notes": "3.7,3.8,3.7", "status": "Complete", "status_log": "Pending, Live, Complete"}

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

SECONDS TO START = 104.043

strategy_selection_orders[Order 100000000001: Execution complete]

market.blotter.orders = [Order 100000000001: Execution complete]

market status = OPEN

runner status = ACTIVE

selection exposure = 13.5

stats = {'matched_profit_if_win': -13.5, 'matched_profit_if_lose': 5.0, 'worst_potential_unmatched_profit_if_win': 0.0, 'worst_potential_unmatched_profit_if_lose': 0.0, 'worst_possible_profit_on_win': -13.5, 'worst_possible_profit_on_lose': 5.0}

number of active runners = 8

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

SECONDS TO START = 103.929

strategy_selection_orders[]

market.blotter.orders = [Order 100000000001: Execution complete]

market status = OPEN

runner status = ACTIVE

selection exposure = -0.0

stats = {'matched_profit_if_win': 0.0, 'matched_profit_if_lose': 0.0, 'worst_potential_unmatched_profit_if_win': 0.0, 'worst_potential_unmatched_profit_if_lose': 0.0, 'worst_possible_profit_on_win': 0.0, 'worst_possible_profit_on_lose': 0.0}

number of active runners = 8

{"asctime": "2023-02-07 21:17:58,369", "levelname": "INFO", "message": "Market 1.138465931 closed", "market_id": "1.138465931", "event_id": "28531405", "event_type_id": "7", "event_name": "Sthl 1st Jan", "market_type": "WIN", "market_start_datetime": "2018-01-01 13:10:00", "country_code": "GB", "venue": "Southwell", "race_type": null, "orders_cleared": [], "market_cleared": [], "closed": true}

{"asctime": "2023-02-07 21:17:58,370", "levelname": "INFO", "message": "Market cleared", "market_id": "1.138465931", "order_count": 1, "clients": {"Betfair": {}, "Simulated": {"72f36d32": {"username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 1, "transaction_count_total": 1, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140057390804992)&gt;"]}

{"asctime": "2023-02-07 21:17:58,370", "levelname": "INFO", "message": "Market level cleared", "market_id": "1.138465931", "profit": 5.0, "bet_count": 1}

{"asctime": "2023-02-07 21:17:58,371", "levelname": "INFO", "message": "Market closed", "market_id": "1.138465931", "clients": {"Betfair": {}, "Simulated": {"72f36d32": {"username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 1, "transaction_count_total": 1, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140057390804992)&gt;"]}

{"asctime": "2023-02-07 21:17:58,371", "levelname": "INFO", "message": "Removing market 1.138465931", "clients": {"Betfair": {}, "Simulated": {"72f36d32": {"username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 1, "transaction_count_total": 1, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140057390804992)&gt;"]}

{"asctime": "2023-02-07 21:17:58,371", "levelname": "INFO", "message": "Completed historical market '/home/ubuntu/Python_projects/tmp/races/1.138465931'"}

{"asctime": "2023-02-07 21:17:58,371", "levelname": "INFO", "message": "Simulation complete"}

{"asctime": "2023-02-07 21:17:58,371", "levelname": "INFO", "message": "Shutting down Execution (SimulatedExecution)"}

{"asctime": "2023-02-07 21:17:58,372", "levelname": "INFO", "message": "Shutting down Execution (BetfairExecution)"}

{"asctime": "2023-02-07 21:17:58,372", "levelname": "INFO", "message": "Client logout", "username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 1, "transaction_count_total": 1, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-02-07 21:17:58,372", "levelname": "INFO", "message": "Exiting flumine", "clients": {"Betfair": {}, "Simulated": {"72f36d32": {"username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 1, "transaction_count_total": 1, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140057390804992)&gt;"]}

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

Profit: 5.00

10200239 2018-01-01 13:05:50.294000 OrderStatus.EXECUTION_COMPLETE 3.7 3.7 5.0 5.0```

---

## 2023-02-07 21:39:35 - general channel

**Trex44**

```{"asctime": "2023-02-07 21:17:54,969", "levelname": "INFO", "message": "Client added", "username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": null, "transaction_count_total": null, "trading_controls": [], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-02-07 21:17:54,969", "levelname": "INFO", "message": "Adding market middleware &lt;flumine.markets.middleware.SimulatedMiddleware object at 0x7f61a0256740&gt;"}

{"asctime": "2023-02-07 21:17:54,969", "levelname": "INFO", "message": "Adding client control MAX_TRANSACTION_COUNT"}

{"asctime": "2023-02-07 21:17:54,970", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2023-02-07 21:17:54,970", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2023-02-07 21:17:54,970", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2023-02-07 21:17:54,970", "levelname": "INFO", "message": "Adding strategy LowestLayer"}

{"asctime": "2023-02-07 21:17:54,971", "levelname": "INFO", "message": "Creating new HistoricalStream (1000) for strategy LowestLayer", "strategy": "LowestLayer", "stream_id": 1000, "market_filter": "/home/ubuntu/Python_projects/tmp/races/1.138465931", "event_id": "28531405", "event_processing": false}

{"asctime": "2023-02-07 21:17:54,971", "levelname": "INFO", "message": "Starting flumine", "clients": {"Betfair": {}, "Simulated": {"72f36d32": {"username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "BetConnect": {}}, "markets": {"market_count": 0, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140057390804992)&gt;"]}

{"asctime": "2023-02-07 21:17:54,971", "levelname": "INFO", "message": "Client login", "username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-02-07 21:17:54,971", "levelname": "INFO", "message": "Client update account details", "username": "72f36d32", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7f61a0256950&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-02-07 21:17:54,972", "levelname": "INFO", "message": "Starting historical market '/home/ubuntu/Python_projects/tmp/races/1.138465931'", "market": "/home/ubuntu/Python_projects/tmp/races/1.138465931"}

{"asctime": "2023-02-07 21:17:54,972", "levelname": "INFO", "message": "[Register: 1000]: marketSubscription"}

{"asctime": "2023-02-07 21:17:54,972", "levelname": "INFO", "message": "[MarketStream: 1000]: \"MarketStream\" created"}

{"asctime": "2023-02-07 21:17:54,972", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:54,974", "levelname": "INFO", "message": "Adding: 1.138465931 to markets"}

{"asctime": "2023-02-07 21:17:54,982", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:54,982", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:54,984", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,000", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,003", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,007", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,014", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,045", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,062", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,070", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,097", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,197", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,229", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,234", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,310", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,391", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}

{"asctime": "2023-02-07 21:17:55,409", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.138465931 added, 1 markets in cache"}```

---

## 2023-02-07 21:38:33 - general channel

**Trex44**

Evening all.  Was wondering if anyone can help me solve an issue with back testing a strat. The strat places a bet on a single runner before the race starts then is supposed to place a second bet at 60 seconds to the off if market.blotter.strategy_selection_order has a count greater than one. Which it should do as the first bet was placed successfully and shows as Execution complete. Bizarrely though the market.blotter.strategy_selection_order list turns to an empty list between 104-103 seconds to the off even though the market.blotter.orders list continues to contain the order. See logs attached. I have backtested this strat on 4 markets, 3 it works fine on. Its only this one market that I have seen this behaviour on.

---

## 2023-02-07 09:52:04 - issues channel

**Paras Stefanopoulos**

my devised strategy isn’t time bound so just trying to keep it simple to do some testing

---

## 2023-02-07 09:49:15 - general channel

**Andrew**

Sorry a bit late back to this thread. Here's a rough outline of my approach. I make use of market context to cache values from previous check. FYI, I initialise this in middleware



Here's actual code snippet - any IP removed :slightly_smiling_face:



This bit goes in _process_market_book_, _pr is new price



if _pr != market.context['order_price'][runner.selection_id]: # market.context['order_price'][runner.selection_id] is existing target price for runner

                        _sz = &lt;calculate new size based on _pr&gt; # there was some IP here!

                        if _sz &gt; 0:

                            market.context['order_price'][runner.selection_id] = _pr

                            market.context['order_size'][runner.selection_id] = _sz

                            market.context['create_order'][runner.selection_id] = True # This is a flag to help control cancel before create new order



A bit later on in _process_market_book_



for runner in market_book.runners:

            rc = self.get_runner_context(market.market_id, runner.selection_id, runner.handicap)

            if market.context['create_order'][runner.selection_id] and not rc.executable_orders:

                # flagged for create, no executable order

                trade = Trade(market.market_id, runner.selection_id, handicap = runner.handicap, strategy = self)

                order = trade.create_order(

                    side = "LAY",

                    order_type = LimitOrder(

                        price = market.context['order_price'][runner.selection_id],

                        size = market.context['order_size'][runner.selection_id],

                        )

                    )

                market.place_order(order)

                market.context['create_order'][runner.selection_id] = False



And here's the magic in _process_orders_ I figured to handle state and wait for cancel



def process_orders(self, market, orders):

        for order in orders:

            rc = self.get_runner_context(market.market_id, order.selection_id, order.handicap)

            if market.context['create_order'][order.selection_id] and rc.executable_orders:

                # flagged for create, so need to cancel current before create new

                if order.status == OrderStatus.EXECUTION_COMPLETE:

                    market.context['create_order'][order.selection_id] = False

                elif order.status == OrderStatus.EXECUTABLE:

                    market.cancel_order(order)

---

## 2023-02-07 09:46:15 - issues channel

**liam**

How do you normally access the API? From memory you are blocked from automating the actual login so you would have to:



```trading = betfairlightweight.APIClient("username", "password", app_key="appKey")



trading.set_session_token("SSOID")```

---

## 2023-02-07 09:08:58 - general channel

**Peter**

[@U04980ZT6UX](@U04980ZT6UX) Apologies. Missed your follow up questions when you originally posted them. In case they're still relevant ... market.blotter.live_orders() will give you an iterable of the live orders for that market only, or if ypu're working in your strategy's process_orders() method, the list of orders passed into it will be filtered by the strategy and market combination, but will be all such orders, though easily filtered by OrderStatus.EXECUTABLE.



[@U01D23DDMTQ](@U01D23DDMTQ) is right that to change price and size requires a cancel and new place as Betfair won't allow changing price and size in a replace. Personally I'd fire off the cancel as soon as I knew that I no longer wanted the bet and then watch the response (if working synchronously, or the order stream if working asynchronously) before placing the new order - which may be what he meant by implementing a wait queue.

---

## 2023-02-05 12:31:22 - general channel

**JamieK**

Thanks Trex. I'll try PyCharm also to compare, not sure if DataSpell is working as I expected.



TBH, I'm way off having very much of a clue what I'm doing yet. I'm watching some tuts and am aiming to understand how to utilise Flumine, backtest any simple strategy, and then develop my own to backtest. Just need to get my head round Python on the way!

---

## 2023-02-05 12:12:51 - general channel

**Trex44**

Hey Jamie, welcome.  I have never heard of DataSpell. I use PyCharm for building Flumine strategies and for remote deployment. I use Jupyter notebook for analysing data that I extract from market data using some custom scripts I built. Although I think you could probably just build a flumine strategy and use it in back test mode to extract the data, no need for a custom script.

---

## 2023-02-05 12:01:44 - general channel

**JamieK**

Hi all :slightly_smiling_face: This all looks very interesting, an opportunity to combine my coding skills with my love of betting. Hoping I can start a journey with this, learn and have some fun. I'm a python newbie, more used to building web apps with Typescript.



Anyone heard of, or use JetBrains DataSpell instead of Jupyter Notebooks (it's supposed to be an enhanced IDE wrapper around Jupyter Notebooks)? I think this IDE might be more appropriate than JetBrains PyCharm

---

## 2023-02-01 07:20:37 - general channel

**liam**

You want to take advantage of `strategy.conflate`

---

## 2023-01-31 19:13:42 - general channel

**Peter**

Broadly what [@UFTBRB3F1](@UFTBRB3F1) said, but with a couple of tweaks.



A minor point on football markets: handicaps will be non-zero for most runners in the Asian Handicap market type, and zero for other markets.



I recommend against trying to filter data from the market recorder as you stream it. Better is to collect it raw (i.e. not just the best prices), compress it and save it, all of which the marketrecorder does by just setting the parameters. Then process the files offline to extract the data you want. The reason for this process is that as you gain more experience in this field, you will probably find that you need more extensive data from which to extract the features that you will use to derive your trading triggers. And while it's easy to filter out the data you're not yet interested in, it's impossible (or at least very expensive if you buy it from Betfair) to infill later the data you wished you'd collected.

---

## 2023-01-26 19:09:51 - general channel

**Unknown**

Ah, I see. But that still doesn't explain why you're getting what look to be authentication errors. Attached is an example 3, that first gets a list market IDs from the betting attribute, passes it to the race_cards endpoint and generates a new (filtered) list based on a condition found only there, and finally passes that into the Flumine strategy's market filter. The code works with no authentication issues, so you must be doing something subtly different.

---

## 2023-01-25 20:04:03 - general channel

**Trex44**

Unless I am mistaken though the examples filter based on data from the list_market_catalogue method called on the betting attribute of the trading object. This doesn't have the data I am after which is held in the race_card attribute of the same trading object. The attributes access two different API's. I was trying to

• call betting.list_market_catalogue and return all UK market ids 

• then send this list to the race_card attribute by calling the get_race_card method on it and filtering the list of market ids based on the track surface type (data held in the race_card API not the betting API). 

• Then pass this list of ids to the market filter that is passed to the Strategy object (strategy var) that is passed to framework.add_strategy.  

I can't simply call the race_card.get_race_card() method because it needs market ids as a parameter so I have to make the call on the betting attribute first.

---

## 2023-01-25 14:25:38 - random channel

**Paul**

I shall be converting that strategy to flumine tonight as it is otherwise profitable… :-)

---

## 2023-01-25 13:39:53 - random channel

**river_shah**

I don't know much about inplay horses so won't comment. I know for other bet sized constrained markets, multiple strategy replicates typically result in very bad performance for high stakes

---

## 2023-01-25 13:38:17 - random channel

**river_shah**

It will be very strategy and stake size dependent. Each of the replicated strats is essentially a competitor and what is worse, a competitor that knows your entire signals / strats. If staking big enough, market impact will shoot through the roof

---

## 2023-01-25 13:11:50 - random channel

**PeterLe**

:thinking_face: If you were to run the exact same strategy (inc stakes), on the same system, on multiple accounts, how close would you expect the end of month profits to be on each account?

---

## 2023-01-24 11:44:55 - general channel

**Unknown**

OK. Attached are two examples. Example1 is a working script doing what I think you may have been trying to do and creates a list of market IDs from the racecards and feeds that to Flumine. Example2 is how I would personally do it, which embeds the filter condition into the Flumine strategy's check_market_book method.



They both use the same fairly random filter criteria looking for Flat races under a mile - you can insert your own condition.



Points to note are:

• You may need to tweak how the Betfair credentials are passed to the trading object to reflect how you authenticate

• In example two there's no need for an explicit login or call to list_market_catalogues as Flumine takes care of those.

• The market filters have different parameters (because Betfair is inconsistent).

• Where you find the information for your conditions may be a bit different too (ditto).

• The market catalogue may not appear in example2 until several seconds after the market is added to the stream.

• I've turned the order stream off in both example, but you will probably want it on (by removing the parameter when the client is initiated).

---

## 2023-01-23 22:42:46 - random channel

**birchy**

I don't have the body or looks to apply for a modelling job.

---

## 2023-01-23 10:55:16 - issues channel

**foxwood**

Think it might have been a thread timing / sequence issue ? Did go through the blotter code (and checked latest version since am running 2.0.1 !). In `check_market_book` I walk the orders in `for order in market.blotter:` The order was in that set although the runner status was `REMOVED` Looking at the simulated packet time this situation arose on the first data packet milliseconds after the removal timestamp. My guess was that the order thread hadn't got round to dealing with this yet and that the strategy had got there first and saw this as a good order. Since [@U9JHLMZB4](@U9JHLMZB4) confirmed what should happen I put some defensive code `if not self.isActiveRunner(market_book, order.selection_id): continue` in the loop to check and this solved the issue.

---

## 2023-01-22 22:47:18 - general channel

**Peter**

The error message you're getting from Betfair is for an invalid session, so nothing to do with your filter or strategy. This feels more like an issue with how you're initiating your script.

---

## 2023-01-22 22:05:39 - general channel

**Trex44**

```  File "/home/ubuntu/Python_projects/initiate_strat.py", line 95, in &lt;module&gt;

    target_arr = get_filter_list()

  File "/home/ubuntu/Python_projects/initiate_strat.py", line 27, in get_filter_list

    results = trading.betting.list_market_catalogue(

  File "/home/ubuntu/.local/lib/python3.10/site-packages/betfairlightweight/endpoints/betting.py", line 233, in list_market_catalogue

    (response, response_json, elapsed_time) = self.request(method, params, session)

  File "/home/ubuntu/.local/lib/python3.10/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 55, in request

    self._error_handler(response_json, method, params)

  File "/home/ubuntu/.local/lib/python3.10/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 81, in _error_handler

    raise self._error(response, method, params)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketCatalogue 

Params: {'filter': {'eventTypeIds': [7], 'marketCountries': ['GB'], 'marketTypeCodes': ['WIN']}, 'marketProjection': ['RUNNER_DESCRIPTION', 'RUNNER_METADATA', 'COMPETITION', 'EVENT', 'EVENT_TYPE', 'MARKET_DESCRIPTION', 'MARKET_START_TIME'], 'maxResults': 100} 

Exception: None 

Error: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie2-ang05b-prd-01191051-000775c81b', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} 

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie2-ang05b-prd-01191051-000775c81b', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}```

---

## 2023-01-22 22:05:31 - general channel

**Trex44**

Wonder if anyone can help. I was trying to pass a list of market_ids as part of the market filter to a strategy. The id's are generated by filtering the markets based on information in the race_card. At the moment I am logging in using the market filter, getting all the market_ids for races then passing the market_ids to get_race_card. Then using ifnformation from the race_card I filter the market_ids and return a list of filtered market ids  to the strategy. But I get the following error . (see attached). Both the filter and strategy work fine when executed separate to one another.

---

## 2023-01-22 19:26:47 - issues channel

**foxwood**

Is the simulation supposed to delete completed bets when a non-runner / reserve is declared on uk dogs prior to the off ? Investigated a divide by zero bug of mine in a strategy which arose with a REMOVED runner that had an EXECUTION_COMPLETE order in market.blotter that predated the runner removal time - there were other runners bets also in the blotter from before the removal time. Confused about what should happen but current T&amp;Cs say "If a non-runner or reserve runner is declared, then all bets prior to the update of the market on Betfair will be void". Never checked what happens live !

---

## 2023-01-22 15:12:15 - general channel

**D C**

To be plain, I currently use an asynchronous TCP/IP socket component. As such, I use a single session token for my bet placements. I am considering moving to a blocking socket multi-threaded bet placement model. Now I might be able to share a single session token between any/all threads that I create or I might need a login per thread (doubtful but I just don't know). I suppose I a better question would be to ask those who use thread pools for bet placement if they share all threads across a single login session.

---

## 2023-01-21 14:36:09 - general channel

**Aaron Smith**

[https://betcode-org.github.io/flumine/](https://betcode-org.github.io/flumine/) has good info for getting started. In the flumine repo under examples, you ll find the S3Recorder, which can be used to safe streaming data in a s3-bucket. The s3 recorder can be set up just like any strategy (so you can follow the steps from the link)

---

## 2023-01-21 00:50:59 - general channel

**Andrew**

How does flumine handle abandoned markets? Call to remove_market of BaseStrategy? And possibly process_closed_market? My interest is how best for automation to handle delays, and long delays in start, and then distinguish between those markets and those that are abandoned or cancelled?

---

## 2023-01-20 18:32:58 - random channel

**Mick**

No worries. To be honest I thought my suggestion might have led to a discussion of where to find modelling jobs but seeing how quiet this thread is, perhaps it's not such a hot topic!

---

## 2023-01-20 18:03:07 - general channel

**Nicholas vizard**

Hey gents,

Hope everyone is doing well. Just looking for some help in analysis of Betfair's historical Bz2 stream files.

 *I was wondering if someone had a way to consistently identify the market book update that contains the latest possible snapshot of the trading data for a given market (i.e. last update on runner volumes,ltp, ladders etc.)?* 

I call this the last traded market book (LTMB). This is separate to the  last market update , as trading volumes are wiped before this final update.



It seems that in most markets, the LTMB can be identified as the third last market update in the bz2 file. However, there are some instances in which this is not the case.

Any help in establishing a consistent way to identify the LTMB would be much appreciated.



Best,

Nick

---

## 2023-01-20 13:54:41 - general channel

**Peter**

This is [@U4H19D1D2](@U4H19D1D2)’s logic so he may have a different take, but here's mine.



The order lookup is made up of market_id, selection_id and handicap. Although the handicap is 0 for most markets, for handicap markets specifically (e.g. asian line markets) it is needed to differentiate between multiple market lines for the same selection. It's also possible to have the same selection_id (and handicap = 0) in multiple markets at the same time (e.g. correct score in soccer). So to identify uniquely the market line to which an order applies for all market types, we need all three components.



However when the strategy_selection_orders method is invoked, it's done so in the context of the blotter for a specific market and loads the orders for that market only, which is why the market_id isn't needed and is sliced off the tuple, leaving just the selection_id and handicap.

---

## 2023-01-20 08:07:35 - random channel

**Mick**

For the record I'm certainly not promoting [http://freelancer.com|freelancer.com](http://freelancer.com|freelancer.com) (which has many flaws) - my suggestion for a jobs channel was in relation to modelling jobs from _any_ source.

---

## 2023-01-19 23:29:50 - general channel

**Trex44**

Thanks both. Just curious - why does the strategy_selection_orders method take a tuple as its second parameter but slice the tuple to remove index 0. Why doesn't it just accept runner_id?

---

## 2023-01-19 22:49:28 - general channel

**Peter**

It is indeed the strategy object itself, which as you'll usually call the method from within the strategy would generally just be `self`.

---

## 2023-01-19 21:19:40 - general channel

**liam**

Strategy object itself I think 

---

## 2023-01-19 21:16:09 - general channel

**Trex44**

Evening all, for the selection_exposure method of the blotter class what exactly is the strategy parameter that is supposed to be passed? Is it the name of the strat as a string?

---

## 2023-01-19 17:07:33 - random channel

**Unknown**

Following on from Jorge's post about freelancing platforms, I just saw this (below) - I can't enquire any further because I'm not a "Preferred freelancer". It got me thinking though, would it be an idea to add a "jobs" channel for when similar sports modelling jobs come up?

---

## 2023-01-19 14:25:05 - general channel

**birchy**

_You make the assumption that anyone who uses betcode libraries will make money, they are just tools._ 



I've heard this so many times over the years. Most newcomers are very naive and assume that bot == profit but we all know that automating a shit strategy is just a more efficient shit strategy.

---

## 2023-01-19 09:36:55 - general channel

**liam**

I have just pushed betcode/faq public :grinning:



[https://betcode-org.github.io/faq/](https://betcode-org.github.io/faq/)



This was created by [@U9JHLMZB4](@U9JHLMZB4) so I can't take ownership but going to look at expanding it to all common questions we get and then into more strategy development.

---

## 2023-01-18 13:33:43 - strategies channel

**D C**

It's a massive question and depends on what sport and whether it is inplay or not etc (although fundamentals will be similar). Also depends on what you know already. I'd echo what [@UFTBRB3F1](@UFTBRB3F1) says though - you'll learn nothing from 99.9% of youtube/social media and (possibly) a few useful bits and pieces from the other 0.1% but nothing game changing. Most online content is based around people selling something which will undoubtedly end up being (at best) so basic it is worthless or (at worst) so bad that you will lose money by trying to recreate it.

You'll find nothing better than this slack even if you have no desire to automate your betting.

---

## 2023-01-17 08:18:06 - general channel

**Jorge**

I'm working in a function to save the EV of my flumine orders, this function is part of the `BaseStrategy` class. Right now, I just call the function on every `process_market_book` iteration, and save the best back and lay prices for every order with EXECUTION_COMPLETE status.



I'm wondering if it is possible to improve it in order to save the partially matched orders as well.



```def register_ev_completed_orders(self, market, selection_id, best_back_price, best_lay_price):

    for order in market.blotter._orders.values():

        if order.status == OrderStatus.EXECUTION_COMPLETE:

            if order.selection_id == selection_id:

                if order.size_matched &gt; 0:

                    if order.date_time_execution_complete:

                        seconds_since_matched = (datetime.datetime.utcnow() - order.date_time_execution_complete).total_seconds()

                        if 10 &lt; seconds_since_matched &lt; 30:

                            if order.bet_id in self.completed_bets_dict:

                                self.completed_bets_dict[order.bet_id]['seconds_since_matched'].append(seconds_since_matched)

                                self.completed_bets_dict[order.bet_id]['ref_prices'].append((best_back_price, best_lay_price))

                            else:

                                self.completed_bets_dict[order.bet_id] = {

                                    'market_id': market.market_id,

                                    'selection_id': selection_id,

                                    'seconds_since_matched': [seconds_since_matched],

                                    'side': order.side,

                                    'ref_prices': [(best_back_price, best_lay_price)],

                                    'size_matched': order.size_matched,

                                    'average_price_matched': order.average_price_matched}```

---

## 2023-01-16 21:01:19 - general channel

**Trex44**

Ok thanks very much, I will go read the docs again and figure out what stream to pass to the Strategy instance.

---

## 2023-01-16 20:57:06 - general channel

**Trex44**

The above are the logs from adapting the strategy so that it will place a £2 back bet at the best available price on the first runner (as ranked by runner id). The market only has to be 'OPEN' not in play.  Its filtered for the [https://www.betfair.com/exchange/plus/horse-racing/market/1.208749303?nodeId=32033309|Wolves 15:15](https://www.betfair.com/exchange/plus/horse-racing/market/1.208749303?nodeId=32033309|Wolves 15:15) market on the 18th.

---

## 2023-01-16 20:56:59 - general channel

**Trex44**

```{"asctime": "2023-01-16 20:43:47,370", "levelname": "INFO", "message": "Client added", "username": "x", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": null, "transaction_count_total": null, "trading_controls": [], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-01-16 20:43:47,371", "levelname": "INFO", "message": "Adding client control MAX_TRANSACTION_COUNT"}

{"asctime": "2023-01-16 20:43:47,371", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2023-01-16 20:43:47,371", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2023-01-16 20:43:47,372", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2023-01-16 20:43:47,372", "levelname": "INFO", "message": "Adding strategy Lay_Fav_Strat"}

{"asctime": "2023-01-16 20:43:47,372", "levelname": "INFO", "message": "Creating new &lt;class 'flumine.streams.datastream.DataStream'&gt; (2000) for strategy Lay_Fav_Strat"}

{"asctime": "2023-01-16 20:43:47,372", "levelname": "INFO", "message": "Starting flumine", "clients": {"Betfair": {"x": {"username": "x", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fa89d18bac0&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}}, "Simulated": {}, "BetConnect": {}}, "markets": {"market_count": 0, "open_market_count": 0}, "streams": ["&lt;OrderStream(OrderStream, initial daemon)&gt;", "&lt;DataStream(DataStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140362210664448)&gt;"]}

{"asctime": "2023-01-16 20:43:47,598", "levelname": "INFO", "message": "Client login", "username": "x", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fa89d18bac0&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-01-16 20:43:47,881", "levelname": "INFO", "message": "Client update account details", "username": "x", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fa89d18bac0&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}

{"asctime": "2023-01-16 20:43:47,882", "levelname": "INFO", "message": "Adding worker keep_alive"}

{"asctime": "2023-01-16 20:43:47,882", "levelname": "INFO", "message": "Adding worker poll_market_catalogue"}

{"asctime": "2023-01-16 20:43:47,882", "levelname": "INFO", "message": "Adding worker poll_account_balance"}

{"asctime": "2023-01-16 20:43:47,882", "levelname": "INFO", "message": "Adding worker poll_market_closure"}

{"asctime": "2023-01-16 20:43:47,883", "levelname": "INFO", "message": "BackgroundWorker keep_alive starting", "worker_name": "keep_alive", "function": "&lt;function keep_alive at 0x7fa89d147c70&gt;", "context": {}, "start_delay": 0, "interval": 1200, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-01-16 20:43:47,883", "levelname": "INFO", "message": "BackgroundWorker poll_market_catalogue starting", "worker_name": "poll_market_catalogue", "function": "&lt;function poll_market_catalogue at 0x7fa89d1540d0&gt;", "context": {}, "start_delay": 10, "interval": 60, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-01-16 20:43:47,883", "levelname": "INFO", "message": "BackgroundWorker poll_account_balance starting", "worker_name": "poll_account_balance", "function": "&lt;function poll_account_balance at 0x7fa89d154160&gt;", "context": {}, "start_delay": 10, "interval": 120, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-01-16 20:43:47,884", "levelname": "INFO", "message": "BackgroundWorker poll_market_closure starting", "worker_name": "poll_market_closure", "function": "&lt;function poll_market_closure at 0x7fa89d1541f0&gt;", "context": {}, "start_delay": 10, "interval": 60, "func_args": [], "func_kwargs": {}}

{"asctime": "2023-01-16 20:43:47,884", "levelname": "INFO", "message": "Starting streams.."}

{"asctime": "2023-01-16 20:43:47,884", "levelname": "INFO", "message": "Starting OrderStream 1000", "stream_id": 1000, "customer_strategy_refs": "ip-172-31-38-7", "conflate_ms": null, "streaming_timeout": 0.25, "client_username": "x"}

{"asctime": "2023-01-16 20:43:47,884", "levelname": "INFO", "message": "Starting output_thread (OrderStream 1000)"}

{"asctime": "2023-01-16 20:43:47,885", "levelname": "INFO", "message": "[Register: 1001]: orderSubscription"}

{"asctime": "2023-01-16 20:43:47,885", "levelname": "INFO", "message": "[OrderStream: 1001]: \"OrderStream\" created"}

{"asctime": "2023-01-16 20:43:47,955", "levelname": "INFO", "message": "[OrderStream: 1001]: connection_id: 108-160123204347-4921521"}

{"asctime": "2023-01-16 20:43:47,984", "levelname": "INFO", "message": "[OrderStream: 1002]: SUCCESS (9 connections available)"}

{"asctime": "2023-01-16 20:43:47,985", "levelname": "INFO", "message": "[OrderStream: 1001]: SUCCESS (9 connections available)"}

{"asctime": "2023-01-16 20:43:48,001", "levelname": "INFO", "message": "[OrderStream: 1001]: 0 oc added"}

{"asctime": "2023-01-16 20:43:48,135", "levelname": "INFO", "message": "Starting DataStream 2000", "stream_id": 2000, "market_filter": {"marketIds": ["1.208749303"], "eventTypeIds": ["7"], "marketTypes": ["WIN"], "venues": ["Wolverhampton"], "countryCodes": ["GB"]}, "market_data_filter": {"fields": ["EX_ALL_OFFERS", "EX_TRADED", "EX_TRADED_VOL", "EX_LTP", "EX_MARKET_DEF", "SP_TRADED", "SP_PROJECTED"]}, "conflate_ms": null}

{"asctime": "2023-01-16 20:43:48,135", "levelname": "INFO", "message": "[Register: 2001]: marketSubscription"}

{"asctime": "2023-01-16 20:43:48,136", "levelname": "INFO", "message": "[FlumineStream: 2001]: \"FlumineStream\" created"}

{"asctime": "2023-01-16 20:43:48,212", "levelname": "INFO", "message": "[FlumineStream: 2001]: connection_id: 109-160123204348-5018646"}

{"asctime": "2023-01-16 20:43:48,241", "levelname": "INFO", "message": "[FlumineStream: 2002]: SUCCESS (8 connections available)"}

{"asctime": "2023-01-16 20:43:48,268", "levelname": "INFO", "message": "[FlumineStream: 2001]: SUCCESS (8 connections available)"}

{"asctime": "2023-01-16 20:43:48,285", "levelname": "INFO", "message": "[MarketStream: 2001] 1.208749303 added, 1 markets in cache"}

{"asctime": "2023-01-16 20:43:48,285", "levelname": "INFO", "message": "[FlumineStream: 2001]: 1 mc added"}

{"asctime": "2023-01-16 20:43:48,386", "levelname": "INFO", "message": "Adding: 1.208749303 to markets"}

{"asctime": "2023-01-16 20:43:58,116", "levelname": "INFO", "message": "Created marketCatalogue for 1.208749303", "market_id": "1.208749303", "event_id": "32033309", "event_type_id": "7", "event_name": "Wolverhampton 18th Jan", "market_type": "WIN", "market_start_datetime": "2023-01-18 15:15:00", "country_code": "GB", "venue": "Wolverhampton", "race_type": "Flat", "orders_cleared": [], "market_cleared": [], "closed": false}

{"asctime": "2023-01-16 20:43:58,286", "levelname": "INFO", "message": "Client update account details", "username": "x", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fa89d18bac0&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}```

---

## 2023-01-16 16:24:56 - general channel

**river_shah**

If a worker dies with outstanding positions, upon restart if `customer_strategy_ref` remains the same, does that ensure that `market.blotter` bootstraps all the orders for that market? If that is the case, can I please be pointed to the code how positions are bootstrapped

---

## 2023-01-16 15:40:20 - general channel

**Trex44**

But I get nothing at all regarding any attempt to move the files to S3 prior to deletion. Tried hard coding the file path into the relevant object too but that didn't work. I am calling the strategy from a strategies folder where it sits in its own script rather than adding it to the strategies script but I don't see why this would have an effect.

---

## 2023-01-16 12:01:47 - random channel

**D C**

Yeah I know what you mean. Mods can be tricky. I'm thinking of basic stuff though. Let's take a stupid example - backtesting a lay the field strategy inplay. You are parsing JSON time and time again but ultimately you are only interested in a handful of coefficients calculated from that entire data file. Its a poor example probably. OBviously it would only work for a very limited and targeted type of backtest/simulation - I was just wondering if anyone had tried this kind of thing.

---

## 2023-01-14 11:49:40 - strategies channel

**R**

Curve is pretty shallow imho.  Although I come from an AI background so maybe I'm biased!



Took me an hour or so to get a basic model running.

---

## 2023-01-13 18:49:48 - strategies channel

**Alessio**

Online is always non-better in a strict learning sense, because you see each item once, you cannot do multiple batch passes. What you get is the ability to react to something happening that changes what the model learnt so far. But the price you pay is that you cannot control if the model is royally screwed up (bad data, bad learning, etc..) manually, you get to do that with alerts and automation, which is where I see the overhead

---

## 2023-01-13 18:42:13 - strategies channel

**Alessio**

The main problem I see in online is understanding how to validate the model and see if it is drifting badly. It can end up with a lot of overhead.

---

## 2023-01-13 17:33:58 - strategies channel

**R**

For the modelling / ML people in the crowd: curious if you guys use online / incremental learning?  I've been toying around with River ML ([https://riverml.xyz/0.14.0/](https://riverml.xyz/0.14.0/)) and find it kind of fun to play with models in an online / streaming setting.



Current toy project is modeling expected value using an online ML.  Very basic, linear models kind of stuff but interested to see who else is out there!

---

## 2023-01-13 09:32:09 - issues channel

**Andy**

what's the best practice way of going about my use case -&gt;

For my strategy, I need to always have the marketID and selectionID readily available for all AU Horse Races. I see I can poll the API with a max of 100 results, which I have filtered by AU Horse Racing. This gets me the next 100 races in AU but it doesn't get me where I need to be.

Are Betfair marketIDs always sequential? Is it possible to use filters.market_filter() to return any marketID's &gt; the max(marketID) I polled? or

any better/working way to go about every so often retrieving the marketID's and selectionID's for any 'new' markets created

---

## 2023-01-12 17:18:41 - general channel

**R**

Doing some due diligence on a strategy at the moment and realized I have not been detecting some last-minute changes in races.



Does anyone know if the `status` field in a `Runnerbook` can be used to check if runners have been dropped out or am I mis-reading the docs?  Just wondering if anyone has experience here before I PR a filter that doesn't actually work!

---

## 2023-01-12 14:26:05 - random channel

**river_shah**

page 13 of pdf goes over this: [http://www.ams.org/notices/201405/201405FullIssue.pdf](http://www.ams.org/notices/201405/201405FullIssue.pdf) If your strategy sharpe ratio is very high just ignore this

---

## 2023-01-12 13:56:27 - random channel

**river_shah**

I am sure one can derive bounds on this but selection bias from backtests can be more pronounced when the strategy information ratio is low. If your strategy trades once a year (for example long only mutual fund) and then holds, with an information ratio of 1), running millions of backtests will induce massive bias in your portfolio selections. If on the other hand you are like [@U4H19D1D2](@U4H19D1D2) and trade a 100K times a day with effectively max IR (information ratio) you can rest assured that any backtest induced selection bias will be low.

---

## 2023-01-12 13:10:23 - strategies channel

**liam**

I have got to the point now that my GPS model can be used to calculate the accuracy / ev of my market based models

---

## 2023-01-12 10:49:02 - strategies channel

**D C**

I don't know how to test it but it feels like the GPS markets are a lot more "static" now - especially in the early race stages. I find it hard to believe that this is down to BA users via manual trading - it feels like someone has a half decent model for ALL stages of the race now which it never felt like before. I've stopped trying to refine my GPS stuff now really just try to be more selective on entry points.

---

## 2023-01-12 10:43:54 - strategies channel

**liam**

Yeah I was contemplating rerunning my model code to try and improve it but I doubt it will make a difference, just seems to come down to more competition / more efficient markets. I was 25% down in 2022 compared to 2021 and tbh I would be happy to match 2022 in 23 but its not going to be easy / not sure I can be bothered :joy:

---

## 2023-01-12 10:34:41 - strategies channel

**Unknown**

This doesn't look good, TPD has been a step change in making inplay more efficient..



To put in context the loss of 0.004 of ev results in a halving of profits for this particular strategy

---

## 2023-01-12 10:21:13 - random channel

**river_shah**

The problem Prado goes on and on about is maybe more appropriate for low frequency trading...

---

## 2023-01-12 08:35:26 - random channel

**Mo**

I use a very similar approach (not my own work) for financial markets but it's not immediately obvious to me how to apply this to the kind of betting strategies I run

---

## 2023-01-11 22:29:05 - issues channel

**JFP**

```    # Get betfair data files

    data_folder = 'C:/Data/Data/File'

    data_files = os.listdir(data_folder,)

    data_files = [f'{data_folder}/{path}' for path in data_files]



    strategy = BookLayOrders(

        # market_filter selects what portion of the historic data we simulate our strategy on

        # markets selects the list of betfair historic data files

        # market_types specifies the type of markets

        # listener_kwargs specifies the time period we simulate for each market

        market_filter={

            "markets": data_files,  

            'market_types':['WIN'],

            'country_codes':["GB"],

            "listener_kwargs": {"seconds_to_start": 190},  

            },

        max_order_exposure=10000,

        max_selection_exposure=10000,

        max_live_trade_count=10000,

        max_trade_count=10000,

        multi_order_trades = True,

    )

    # Run our strategy on the simulated market

    framework.add_strategy(strategy)

    framework.add_logging_control(

        BacktestLoggingControl()

    )



    framework.run()```

---

## 2023-01-11 14:30:24 - issues channel

**JFP**

horses Win market, &gt; $50000 matched, passive orders, one strategy, avg 80 orders per market

---

## 2023-01-11 14:15:15 - issues channel

**JFP**

Prob should clarify. I have a strategy that places bets live. Have been running this with profit. When I simulate this strat with historical data, I get negative results

---

## 2023-01-11 14:06:59 - issues channel

**JFP**

Thanks Liam. The strategy giving different results does not have any simulated middleware. Is there anyway smart matching could be causing these discrepancies or do you think it could be some update in between versions 1.19.14 and 1.21.0, I noticed a couple of speed improvements for backtesting between these versions?

---

## 2023-01-11 12:36:09 - issues channel

**JFP**

Just noticed a significant discrepancy when backtesting with different versions of Flumine.

Original backtesting completed back in Dec 2021 with Flumine 1.19.14 showed consistent profit for a strategy that places a lot of passive bets.

Have been running this strat live with success.

Just reran the same data with latest version of Flumine 2.3.1 which gave approx. break even. Ran backtest against periods when it was running live and it gave negative results when my live results were positive.

Reinstalled 1.19.14 and rerun Backtest, got original positive results and also got positive results that roughly match my actual results for live trading periods.

Installed Flumine 1.21.0 (when smart matching was implemented) and get the same negative results as per 2.3.1.

The docs for smart matching says, for backtesting, it removes double counting of size for passive orders. Just after some more clarification on this, is this to remove double counting when running multiple strategies (ie: simulated middleware with live strat)?

---

## 2023-01-10 11:20:52 - issues channel

**PeterLe**

Andy do you have two step?

If so you need to include that too

My Python knowledge is very basic (so this may not be the best way to do this...but it works :grinning:)

This is my code:



```myacc = str(input("please enter account name: "))

app_key = str(input("Please enter key: "))

mypass = str(input("Please enter Password and 2FA: "))

trading = betfairlightweight.APIClient(myacc,mypass, app_key, certs=r"C:\certs")```

so you just add your 2FA onto your password. As i say, there is prob a better way....good luck

---

## 2023-01-10 10:02:47 - issues channel

**Andy**

and ran, and get this error



Traceback (most recent call last):

  File "c:\Users\Documents\Python - Problem Solving and Programming\Betfairlightweight.py", line 17, in &lt;module&gt;

    event_types = trading.betting.list_event_types()

                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "C:\Users\Python\Python311\Lib\site-packages\betfairlightweight\endpoints\betting.py", line 37, in list_event_types

    (response, response_json, elapsed_time) = self.request(method, params, session)

                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  File "C:\Users\Python\Python311\Lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 55, in request

    self._error_handler(response_json, method, params)

  File "C:\Users\Python\Python311\Lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 81, in _error_handler

    raise self._error(response, method, params)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listEventTypes

Params: {'filter': {}}

Exception: None

Error: {'code': -32099, 'message': 'ANGX-0007', 'data': {'APINGException': {'requestUUID': 'ie2-ang22a-prd-01051046-0009aa71d1', 'errorCode': 'INVALID_APP_KEY', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0007', 'data': {'APINGException': {'requestUUID': 'ie2-ang22a-prd-01051046-0009aa71d1', 'errorCode': 'INVALID_APP_KEY', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}

---

## 2023-01-10 09:41:47 - issues channel

**Andy**

newbie question for login from the doc:



import betfairlightweight

trading = betfairlightweight.APIClient(

        "username", "password", app_key="app_key", certs="/certs"

    )

trading.login()



what should the app_key parameter be? Should I copy and paste out the 1592 character .pem file? (I've tried that and it doesn't seem to do anything)

---

## 2023-01-10 07:06:13 - issues channel

**Andrew**

I’m embarrassed to own up to my foolishness to open my report in Excel and it truncated trailing zeroes on order ids. But I do still note the code above where customer_order_ref has hash of strategy name prefixed to order I’d.



I’ve got my cancel and place working. Thinking of using async on that. Any experiences?

---

## 2023-01-09 11:02:19 - general channel

**Andrew**

How do I confirm an order has been cancelled after market.cancel_order(order)? I think I have a race condition trying the place an order before cancellation. On market that’s not a problem but my strategy requires single live order per runner at any moment, plus need to ensure order has cancelled and not executed (before cancel instruction received).

---

## 2023-01-09 10:47:22 - issues channel

**Andrew**

Doesn’t customer_order_ref have a hash of the strategy name as a prefix, so they aren’t equivalent?

---

## 2023-01-09 09:35:37 - general channel

**Andrew**

What’s the best way, with flumine, to handle this when both the price and size are to change? Clearly it’s cancel and then place. But if I’m updating too quickly (a feature of my strategy) how do I best avoid a “race” where the order to be cancelled isn’t yet executable (ie. cancellable)?

---

## 2023-01-07 15:55:49 - general channel

**Mo**

```cancel_instruction = betfairlightweight.filters.cancel_instruction(bet_id="292096868384")

cancel_execution_report = trading.betting.cancel_orders(instructions=[cancel_instruction])```

---

## 2023-01-07 13:02:00 - general channel

**Meow**

Hey anyone know how to cancel a particular betid? I have tried this



`cancel_order_filter = betfairlightweight.filters.cancel_instruction( bet_id = '292096868384')`

`cancel_order = trading.betting.cancel_orders(instructions = cancel_order_filter)`



This snippet of code errors out.

---

## 2023-01-03 23:31:05 - strategies channel

**birchy**

[@UQL0QDEKA](@UQL0QDEKA) Personally, I use the "full match" P&amp;L purely as an indicator of whether the strategy is sensible, i.e. the best possible outcome, which is not achievable in the real world. The more interesting number is the actual simulated match P&amp;L as it can highlight adverse selection. For example, we can set the cancellation time to a bigger number to increase the match rate but that may decrease P&amp;L due to adverse selection.

For reference, I've just looked at a recent simulation which shows a 58% match rate (passive bets) but actual "matched" profit is equal to 46% of the "full match" P&amp;L after commission at 2%.

---

## 2023-01-03 23:03:49 - general channel

**birchy**

[@U02RN7YDRQ9](@U02RN7YDRQ9) I'm fine with Pycharm on my development machine. My production stuff is on a headless Linux VPS. :+1: 

[@URMM9463X](@URMM9463X) I'm thinking more along the lines of automating the setup &amp; launch via a script. It seems like a common workflow for which management tools would already exist but Google has muddied the waters and/or I'm not using the correct terminology. My basic manual workflow would be something like:

1. login to remote server via SSH

2. create venv

3. activate venv &amp; install libraries (Flumine, etc)

4. git clone strategy code

5. launch python strategy

6. logout of SSH

---

## 2023-01-03 22:59:07 - strategies channel

**Alessio**

Why wouldn't the backtest also implicity get a 36%, hence giving you the correct number? Mostly a maker strategy?

---

## 2023-01-03 21:41:40 - issues channel

**Peter**

The [https://github.com/betcode-org/flumine/blob/master/flumine/markets/middleware.py|SimulatedSportsDataMiddleware](https://github.com/betcode-org/flumine/blob/master/flumine/markets/middleware.py|SimulatedSportsDataMiddleware) has a check that

`pt &gt; update.publish_time_epoch`

i.e. the market time is later than the timestamp for the sports data update. This means that, unless I’m misunderstanding something in the wider context, the strategy’s process_sports_data method assessments and trades are based on market data from the future.



If my reasoning is correct, is this a compromise necessary because when backtesting the sports stream is simulated by middleware that can only be triggered by the market update? Would this also mean that the comment in the [https://github.com/betcode-org/flumine/blob/master/examples/simulate-sportsdata.py|simulate-sportsdata.py](https://github.com/betcode-org/flumine/blob/master/examples/simulate-sportsdata.py|simulate-sportsdata.py) example’s process_sports_data() method that said method is “called on each update from sports-data-stream” is slightly off?

---

## 2023-01-03 21:09:33 - random channel

**Aaron Smith**

most successful bettors started with a negative pnl i would assume. The major difference between losing 1k and 50k is risk management. I think someone who lost 50k could still turn it around theoretically, but at the very least they should heavily rethink their approach to testing and scaling. Everybody writes a bad strategy sometimes, even the ones who selected &gt;300k, but they wouldnt lose 50k on it.

---

## 2023-01-02 15:44:16 - issues channel

**D**

Flumine question - creating a LAY order using trade.create_order()  with price=40.0, bet_target_type='PAYOUT', bet_target_size=40,



I get the following order violation message and the order isn't placed:



`"WARNING", "message": "Order has violated: STRATEGY_EXPOSURE Error: Order exposure (1560.0) is greater than strategy.max_order_exposure (400)"` 



Whereas I was expecting the exposure from this order to be counted as 40 and not 1,560 - is this correct?

---

## 2023-01-02 08:15:25 - random channel

**Jorge**

Happy New Year all! This year I finally have time to focus in the modelling part of the strategies, I will combine it with some freelancing developing projects, instead of the full time employment I had last years :slightly_smiling_face:

---

## 2023-01-01 21:30:56 - random channel

**AP**

My plan is to continue with in-play racing and also build some fundamental pre off models for UK and AUS racing. I have collected all the data so a matter of creating a good model and optimising execution.

---

## 2023-01-01 20:20:58 - random channel

**D C**

My plan is to model pre-race horses and dogs. I've been finding the GPS profits dipped off considerably and I've spent all year trying to force it but I feel for all the hours put in I've got nothnig from it. Going to try good old fashioned modelling and value betting. Basically 2023 I need to make every hour on this stuff useful rather than getting tunnel visioned on a single thing.

---

## 2023-01-01 20:09:06 - random channel

**Mo**

Happy new year all. My plan is to collaborate on some projects with some of you guys



Recently I have started doing some freelance work with a former colleague and it has made me realise how useful it is to work with someone who understands the modelling side of things. That’s something that my syndicate currently lacks 

---

## 2023-01-01 20:09:03 - random channel

**river_shah**

I started late 2020 on development and deployed early 2021. I work on sports betting on a few sprints a year, but it is fully automated and at a scale where it makes sense to make it grow and polish to see how much more I can squeeze out. Got a few things working well, others not so much. I have other tradfi trading models as well which take the bulk of my time

---

## 2022-12-30 10:54:32 - general channel

**Mo**

Possibly irrelevant as I don't use flumine and my architecture is quite different but I use m5.2xlarge for trading (multiple sports)

---

## 2022-12-27 20:40:55 - general channel

**liam**

Yes but it’s local paper trading, basically using the flumine simulation engine on live market data 

---

## 2022-12-24 11:48:34 - strategies channel

**Mo**

It’s not Betfair’s fault though is it? The Australian tax regime doesn’t understand the exchange model

---

## 2022-12-24 10:38:20 - strategies channel

**D C**

I don't pay PC as I spent years losing money but I guess this means that even just a break even strategy on AUS racing is very useful to reduce it for those who do pay as well as keeping it at bay for those that don't?

---

## 2022-12-23 11:52:48 - strategies channel

**Michael**

Whats the best strategy to use to be able to collect data without losing too much (lowest lay?)

---

## 2022-12-20 22:22:52 - general channel

**Mikkel**

Hi all,



Some time ago I made the research for a profitable system for French horse racing. I'm now looking to expand this to an auto system on Betfair on and on UK races. Does anyone know of a database of fundamental data for uk horse racing - would be nice if it was easy to access through an API. Or does any know of any written guides for automating betting on Betfair using Flumine, etc? :slightly_smiling_face:

---

## 2022-12-20 20:18:45 - random channel

**Jonjonjon**

Ah. That's a good point So he's hoping people think they can beat him at his game. Brave of him to share photos of his family on there as well though. If it was me, I'd hire a model to pretend to me be.

---

## 2022-12-20 12:38:41 - general channel

**Matthieu Labour**

In other words, is there a backpointer to flumine in the strategy?

---

## 2022-12-19 22:36:09 - general channel

**Matthieu Labour**

How can I access flumine from the Strategy? I want to do something like the following. Thank you!

```    def process_raw_data(

        self, clk: str, publish_time: int, datum: dict

    ) -&gt; None:

        flumine.handler_queue.put(CustomEvent...```

---

## 2022-12-17 19:03:40 - general channel

**Matthieu Labour**

Hi, when recording market data for 2 sports, do you recommend that I use one strategy for both sports or 2 strategies (one per sport)? In other words, would you create 2 instances of [https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py](https://github.com/betcode-org/flumine/blob/master/examples/strategies/marketrecorder.py). One per Sport or one only. Is there performance penalty in having multiples and specializing him.

---

## 2022-12-16 09:09:31 - strategies channel

**Unknown**

Day 7, graph showing the difference in ev based on the changes made, step change in the median ev I am now getting which is having a very positive impact on ROI/pnl.



Going back through git (pycharm makes this very easy) I can see that I did some AvB testing on adding the new strategies (now removed) and saw no impact, it seems the problem was that this was during the summer when liquidity was good.



Calculating the ev has seen me go full circle and started feeding it back into the model (ifs) that it uses that has opened up a few ideas...

---

## 2022-12-16 08:58:13 - random channel

**liam**

I have a SimpleStrategy which places a single order at 1.01 on a market/selection and then cancels, invaluable for validating changes/errors etc

---

## 2022-12-16 06:16:09 - random channel

**AP**

[https://www.kaggle.com/code/bkumagai/bayesian-velocity-models-for-horse-race-simulation/notebook|https://www.kaggle.com/code/bkumagai/bayesian-velocity-models-for-horse-race-simulation/notebook](https://www.kaggle.com/code/bkumagai/bayesian-velocity-models-for-horse-race-simulation/notebook|https://www.kaggle.com/code/bkumagai/bayesian-velocity-models-for-horse-race-simulation/notebook)

---

## 2022-12-16 02:17:43 - general channel

**AI Trader**

[@U4H19D1D2](@U4H19D1D2) There was a typo, yes. What I meant is that I want to cancel all pending/open orders before I *stop* trading a market.



In that case, should I do the following?



```def check_market_book(self, market, market_book):

    exit_market : boolean = check_exit_market()



    if not exit_market:

        if market_book.status == "OPEN":

            return True

    else:

        for runner in market_book.runners:

            open_orders = market.blotter.strategy_selection_orders(self, runner.selection_id, runner.handicap, order_status=[OrderStatus.EXECUTABLE, OrderStatus.PENDING])

            for order in open_orders:

                market.cancel_order(order)

        self.remove_market(market.market_id)```

---

## 2022-12-13 18:03:46 - issues channel

**Liam Querido**

Okay, that makes sense. But how do you install the package in editable model? Is it a similar idea to pip install?

---

## 2022-12-13 14:26:49 - random channel

**Jorge**

Hi, are there any other Sports betting exchanges that offer Websocket API? I'm looking to see if it is possible to scale a strategy using more exchanges...

---

## 2022-12-12 08:57:39 - general channel

**liam**

I don't understand the first sentence, is there a word missing?



As you can see `check_market_book` will only block `process_market_book` and `process_closed_market` will still call, `finish` will be [https://github.com/betcode-org/flumine/blob/04d607e1d749a2dbaa8297bbf74c062990867a6b/flumine/strategy/strategy.py#L151|called before flumine ends](https://github.com/betcode-org/flumine/blob/04d607e1d749a2dbaa8297bbf74c062990867a6b/flumine/strategy/strategy.py#L151|called before flumine ends)

---

## 2022-12-11 22:08:38 - general channel

**AI Trader**

*CANCEL ORDERS BEFORE STOPPING TRADING THE MARKET*

Hi guys,

I want to cancel all my orders before I start trading the market. Currently, the way I "stop" trading it is by placing conditions on `check_market_book`

I am not sure this is the right way though, as it seem that whenever `check_market_book` returns *False*, there is no call to any function like `process_closed_market`, `finish` (see code below from `baseflumine.BaseFlumine._process_market_books`.



Could someone advise:

1 - Where should I add my condition to check if I want to stop trading the market

2 - What is the right function to override in order to close all my orders before exiting the market?



Any help is hugely appreciated. Tks



```for strategy in self.strategies:

    if utils.call_strategy_error_handling(

        strategy.check_market, market, market_book

    ):

        utils.call_strategy_error_handling(

            strategy.process_market_book, market, market_book

        )```



---

## 2022-12-11 15:01:09 - strategies channel

**thambie1**

Both of the following options are strategy dependent. Won't always work.

1. Try to get actual results to line up with backtest results, then backtest on a larger sample.

2. Calculate EV in some manner. Based on bsp or closing odds.

---

## 2022-12-11 04:40:16 - general channel

**AI Trader**

Hi guys,

Could someone help me to understand how simulated__profit is computed in the SimulatedClient() ? I am using it to backtest a strategy that uses the stream. I guess my main questions are:

1 - Is the simulated__profit the profit of an order at the END of the match? Or is it when I have an order of the same amount and opposite side (eg first back 10 and then lay 10)?

2 - At what time could I consider to have realized the profit? I imagine it won't be in the placed_date field?



My goal is to reconstruct a pnl timeseries of unrealized pnl.

---

## 2022-12-10 14:36:11 - strategies channel

**river_shah**

[@U4H19D1D2](@U4H19D1D2) not directly related but when you calibrate / backtest with 100% simulated hit rates, do you get plausible / intuitive strategy parameters or does it tend to produce garbage?

---

## 2022-12-09 11:45:09 - strategies channel

**Unknown**

I was just looking at my results from a strategy, graph looks similar to the one you posted this morning (although I didn't trade Clon)

Anyway it will be interesting to see how you get on with this Liam, it gets the old grey matter working if nothing else :grinning:

---

## 2022-12-08 15:48:10 - general channel

**EJono**

Im trying to publish the standard output logs from flumine to azure for storage but cant seem to get any outputs. Is there any reason why the below wouldnt output anything.



```from .strategies import test_strategy

from .handlers import AzureLogHandler



logger = logging.getLogger()

logger.addHandler(AzureLogHandler)

logger.setLevel(logging.DEBUG)



framework.add_strategy(test_strategy)



framework.run()```

I can see log messages i set up from inside the "process_market_book" function of "test_strategy" so im sure the handler is working correctly but nothing other than these manual messages are appearing. Do i need to refer to a specifc logger name in the "getLogger(...)" method? Does this have to execute at the root level to work correctly, iniside "__main__"? or something else?

Feel like am im missing something fundamental about logging or otherwise simple.

Cheers!

---

## 2022-12-08 12:51:25 - strategies channel

**liam**

[@UUE6E1LA1](@UUE6E1LA1) blue line is both, not sure what you mean tbh? This strategy works purely off market data with no TPD info

---

## 2022-12-08 11:45:49 - strategies channel

**PeterLe**

Yes what I mean by the reference to betangel was that there would be a number of uses using it that needed to get up to speed so there may have been som easier profits available initially. I have the TPD feed via betfair (using c#) and i also tested using betangel. I got different results using the same strategy criteria using my own program and betangel. Your correct about the frequency of the updates by the way.

---

## 2022-12-08 09:58:37 - strategies channel

**liam**

Last year was insanely good, this year things have got tougher, feel free to start a new thread on this as I will continue my analysis on this strategy on this one and might get messy

---

## 2022-12-08 09:18:22 - strategies channel

**liam**

But what is the market implied probability?? (this strategy takes advantage of market volatility)

---

## 2022-12-08 09:17:12 - strategies channel

**Mo**

Yeah same with tennis. But I wonder if you have tried looking at the EV of these bets based on market implied probabilities? This is something I’m currently working on for something which is pretty similar which is trying to assess if a new strategy is long term profitable based on limited data

---

## 2022-12-04 17:11:54 - general channel

**AI Trader**

Thanks [@UFTBRB3F1](@UFTBRB3F1)!

Are you saying it is not possible to add and remove markets? Because there is the remove_market function from the BaseStrategy class.



Once I am running the strategy, is it possible to add and remove a market from the framework through Flumine? (I want to avoid restarting the framework).

---

## 2022-12-04 17:01:38 - general channel

**AI Trader**

Hi guys,

What is the correct way to dynamically add markets to my strategy? My criteria are not available through the filters (eg.: traded_amount), so I would like to check every once in a while if these conditions are met and add the market in case it does.



Subscribing to all markets and then checking the condition on `check_market_book` would not be efficient as I would be getting messages from thousands of markets.

My idea would be to have an asynchronous process running every hour populating a file with the markets I want to be trading. Then I would have to embed the logic to check this list in Flumine and remove and add the markets according to this list. What would be the right way to do so? For the Flumine part where I would be checking the list, I woulnd't mind if this was to be done on every book update, as it is a quick check, but I certainly want to avoid subscribing to 10k markets and performing the filter checks every time there's an update in one of these markets.

---

## 2022-12-04 06:46:37 - general channel

**Tony**

Hi, I am very impressed with this forum and I am interested in learning more about backtesting and strategy development. I am a university student and I am unable to afford the pro data, which is quite expensive. Is there an alternative to using pro data for beginners who are just starting out? It seems that some people have run into errors when using only the free data, and while there are a few months of free, full data available, I am not sure if this would be sufficient for testing the significance of a strategy. Thanks all for your help

---

## 2022-11-28 16:39:04 - general channel

**Jorge**

Hi, how can I check if my strategy has any executable or pending order in the market?



I thought `market.blotter.has_live_orders`  was good for this, it works in Simulation. But in live trading it is returning True also when there are orders with "Execution complete"... Could it be that it does not work for "FILL_OR_KILL" orders?

---

## 2022-11-27 12:17:27 - random channel

**Aaron Smith**

the strategy that on my end threw money around like a fresh lottery winner in a strip club was also relying on cancels. Sadly i m just to consumed with private life atm to really look into it, so i m just letting things run and hope for the best, but i ll be curious if you guys find anything intresting

---

## 2022-11-27 12:12:23 - random channel

**river_shah**

I had one of the worst days for a particular strategy (that is typically fairly consistent / low variance). Haven't looked at any logs yet. Most other strats (not using cancels) were fine.

---

## 2022-11-27 12:04:28 - random channel

**PeterLe**

I was having a think about this after Liam posted,...I wasn't at my desk for most of the day, but when i was,  I did notice that there were a t least a couple races where I had a large profit on selections which then traded very low in odds, which then went on to lose.

So it could easily have been a good day too. Easy enough to modify the strategy but it all equals out at the end of the month.

---

## 2022-11-27 10:00:28 - random channel

**Newbie99**

Well that opened my eyes to the concept of people 'making a living betting on reality tv'!!! I had no idea there were enough markets/volume for that (ignoring the difficulty of how to price anything)!

---

## 2022-11-26 18:08:34 - general channel

**AI Trader**

[@U4H19D1D2](@U4H19D1D2)

I tried to add a `betfairlightweight.filters.market_filter` filter so that I could also filter by market_start_time, but I am getting almost 10_000 markets, whereas I should be getting less than 300. Any ideas why?

I used the below filter as a *market_filter* for the BaseStrategy, which returns the below error:

```filter = betfairlightweight.filters.market_filter(event_type_ids=["1"], market_start_time={'from': '2022-11-26T23:31:33Z', 'to': '2022-11-28T17:31:33Z'})```

`{"asctime": "2022-11-26 17:52:58,912", "levelname": "ERROR", "message": "[FlumineStream: 2001]: SUBSCRIPTION_LIMIT_EXCEEDED: trying to subscribe to 9866 markets whereas max allowed number was: 200"}`



It says there are 9866 markets passing this filter, but if I manually check it through:

```all_event_ids = [event.event.id for event in self.trading.betting.list_events(filter=filter)]```

I get only 232 event ids (and there should be a single market_id per event ids as I am only fetching MATCH_ODDS., which is way smaller than the number of market_ids the BaseStrategy complains about (9866)



Below is the code Ive used for the BaseStrategy:

```framework = Flumine(client=client)

strategy = S3MarketRecorder(

    name="WIN",

    market_filter=filter,

    stream_class=DataStream,

    context={

        "local_dir": "./bet_data_temp",

        "force_update": False,

        "remove_file": True,

        "remove_gz_file": True,

        "bucket" : bucket,

    },

)```



---

## 2022-11-26 17:19:32 - general channel

**AI Trader**

Yes for the question where the markets gets updated automatically?



Is there a way to add additional filters to the streaming (for data its fine to get all the 500+ markets, but for trading I would like to limit by time to match for instance)

---

## 2022-11-26 17:12:35 - general channel

**AI Trader**

Hi gents,

Questions related to *BaseStrategy:*

Q1 : It receives  `market_filter` and `market_data_filter` as arguments. Does it automatically update the markets based on these filters? Eg.: If on day 24 Nov the Market M doesn't pass through the filters, but on day 25 Nov it does, will the strategy automatically include this market on Nov 25 without me restarting the code? If not, is there an alternative to restarting the code every X hours? As it would stop the strategy during the restart time, which is risky for trading and would make me loose data for data recording.



Q2: I am trying to find a way to filter markets for which I want to store data using the *MarketRecorder* strategy in the examples.

I want to fetch football matches, but if I filter by:

```market_filter=betfairlightweight.filters.streaming_market_filter(

    event_type_ids=["1"],

    market_types=["MATCH_ODDS"],

    betting_types=["ODDS"],

),```

 I get:

`{"asctime": "2022-11-26 16:40:19,795", "levelname": "ERROR", "message": "[FlumineStream: 2001]: SUBSCRIPTION_LIMIT_EXCEEDED: trying to subscribe to 505 markets whereas max allowed number was: 200"}`



I could obviously get a reduced number of  market_ids myself by doing:

```filter = betfairlightweight.filters.market_filter(event_type_ids=[1], market_start_time={'from': datetime_from, 'to': datetime_to})

self.trading.betting.list_events(filter=filter)```

But then I would have static ids and certainly would have to restart the program to fetch the new markets, which is a problem as described above.



What would be the recommended way to reduce the subset of markets while avoiding having static market_ids ?

---

## 2022-11-25 14:22:36 - issues channel

**EJono**

Question regarding rugby union "WINNING_MARGIN" market type. I was wondering if there was a way to intrinsically link the the selection ids provided in via the market_book object from the following call: market_books = trading.betting.list_market_book(WINNING_MARGIN_ID) , to the actual wining margin buckets listed in the ui:

home 1-12

home 13+

away 1-12

away 13+

draw

in other markets ie MATCH_ODDS, the market_catalogue would give a list of runners with both selection_id and team name leaving little ambiguity to exactly the selection that the an order is going down on. However the runner list inside the catalogue for the winning_margin is empty so im not sure what selection_id corresponds to which points bucket. Also i cant find a sort priority field. I thought the index of the runners inside the market_book might be the way to ultimately determine the corresponding points bucket but this doesnt seem particularly safe as i have seen instances in the past of runners indexing not matching up with traditoinal home, away, draw ordering. Two currently listed rugby games which have this empty market_catalogue runners include



Harlequins v Gloucester,  eventId: 31925868,  WM marketID: '1.206774481'

Newcastle v Exeter,  eventId: 31925869,  WM marketID: '1.206774284'



Is there anyway of identifying wich selection_id corresponds to which win margin bucket through the information available from market_book or market_catalogue that i am missing?

Cheers

---

## 2022-11-23 09:58:11 - random channel

**Nicholas vizard**

Thanks for your prompt response, Mo. It seems I may be misunderstanding how to calculate the net volume traded on a particular runner at a particular time point in the stream. My issues seem to arise when calculating the sp_traded_volume. For clarity, my strategy has been the following:



*1.      Let total traded volume for a particular runner,i, at time point t, equal the limit_traded_volume on that runner + the sp_traded _volume on that runner*



*2.      Calculate the limit traded volume as the sum of all volume values available on the limit traded volume ladder*

          _for example, with the limit traded volume ladder: {'p':[1.05,1.06,1.07],'v':[5,10,15]}_ 

          _I would return 30  as the limit traded volume at this time point (sum of the volume values)_ 



*3.       Calculate the sp_traded_volume as the minimum of either:*

           *a. the sum of the size objects on the sp_available_to_back_ladder or,*

           *b. he sum of the size objects on the sp_available_to_lay ladder divided by  (bsp -1)*



          _For example, with :      BSP = 2        sp_available_to_back_ladder: {'p':[1.05,1.06,1.07],'v':[100,20,20]}                sp_available_to lay ladder: {'p':[1.05,1.06,1.07],'v':[20,20,20]}_

          _I would return 60 as the sp traded volume at this time point (the sum of the sp_lay ladder (60) divided by the BSP -1 (1))._



It follows that my total traded volume would be 90 in this example (30 limit traded volume + 60 sp traded volume).



I  would be amazing If you could identify any problems with this strategy. Or alternatively, if you are able to point me to documentation that may facilitate my understanding of sp and sp traded volumes that would be much appreciated.

Thank you so much for your help Mo, it truly is appreciated!

---

## 2022-11-22 21:04:55 - random channel

**Nicholas vizard**

Hey guys,

I hope you are keeping well.



I just had a quick question regarding a particularity I have found in the SP matched volume figures that I have extracted from the historical PRO stream files.

*Is there a reason that the SP traded volume pool can decrease in subsequent time periods for a particular runner?* 



For example in [market id: 1.188384541, selection id: 28467067] I find that the SP lay pool available decreases from a total volume of 138.41  to 89.45 in two subsequent time periods. The particular time periods are the periods prior to and the period of bsp consolidation. I have included the raw sp lay ladders below for reference.



Many thanks for any help you can provide, I am conducting analyses involving trading volumes so identifying why there may be this discrepancy would be much appreciated.

Cheers!



*Period Prior to consolidation (sum of traded volume = 138.41):*

{'p':[1.2,1.15,1.13,1.12,1.11,1.1,1.09,1.08,1.07,1.06,1.05,1.04],'v':[16.05,2.67,2.67,5.35,5.35,16.05,15.36,29.44,2.67,16.05,16.05,10.7]}



*Period of consolidation (traded volume = 89.45):*

{'p':[1.1042944041670215],'v':[89.45]}

---

## 2022-11-22 17:58:17 - strategies channel

**Alessio**

I wonder if the right way to do this is to take a "good enough" model, start perturbing it, and then see which metrics are sensitive to it.

---

## 2022-11-22 03:31:32 - general channel

**AI Trader**

Thanks a lot [@U4H19D1D2](@U4H19D1D2), I'll try your solution.

I guess it would be enough to do the below in the script where I instantiate the strategy and add it to flumine?



```from flumine import config



config.customer_strategy_ref = "my_strat_ref"```



---

## 2022-11-21 16:50:24 - random channel

**Mo**

Here are the details for one of the upcoming webinars I referenced in my talk the other evening:



&gt; Hi,

&gt; 

&gt; Hopefully football fever is now sweeping the country and everyone is in the mood for a topical seminar. As such, the RSS Statistics in Sports section is hosting a webinar on Wednesday 30th November, at 2pm, when Professor Nial Friel will talk about 'Assessing competitive balance in the English first division / Premier league over 40 seasons using a stochastic block model'. For more details please visit: 

&gt; [https://eur03.safelinks.protection.outlook.com/?url=https%3A%2F%2Frss.org.uk%2Ftraining-events%2Fevents%2Fevents-2022%2Fassessing-competitive-balance-in-the-english-first%2F%23fulleventinfo&amp;data=05%7C01%7Cpeter.philipson1%40NEWCASTLE.AC.UK%7C95a31891ea134caf546408dacbd4d1cc%7C9c5012c9b61644c2a91766814fbe3e87%7C1%7C0%7C638046412149476075%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&amp;sdata=eE30uxdZWp%2FOwL6BqIWn%2BGTmLgZfLR9x1Z2wuNQx%2BR0%3D&amp;reserved=0](https://eur03.safelinks.protection.outlook.com/?url=https%3A%2F%2Frss.org.uk%2Ftraining-events%2Fevents%2Fevents-2022%2Fassessing-competitive-balance-in-the-english-first%2F%23fulleventinfo&amp;data=05%7C01%7Cpeter.philipson1%40NEWCASTLE.AC.UK%7C95a31891ea134caf546408dacbd4d1cc%7C9c5012c9b61644c2a91766814fbe3e87%7C1%7C0%7C638046412149476075%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&amp;sdata=eE30uxdZWp%2FOwL6BqIWn%2BGTmLgZfLR9x1Z2wuNQx%2BR0%3D&amp;reserved=0) 

&gt; 

&gt; Online access details will be circulated to those registered ahead of the event.

&gt; 

&gt; RSS Statistics in Sports Section

---

## 2022-11-21 16:46:16 - general channel

**AI Trader**

The customer_strategy_refs=[config.customer_strategy_ref], part  (that filters only orders coming from the hostname )

---

## 2022-11-21 15:53:52 - general channel

**AI Trader**

Thanks Liam! 



The hostname / customer_strategy_ref should only be used for filtering the orders on the below part of the code in the middleware , right ? I have removed that part l. My issue is that the order_strategy_ref is different depending on whether I place the orders locally or in the cloud. My understanding is that the first 13 characters of that field should only depend on the strategy name , and not on the hostname. Am I missing something ? 



```resp = client.betting_client.betting.list_current_orders(

                customer_strategy_refs=[config.customer_strategy_ref],

                order_projection="EXECUTION_COMPLETE",

            )```



---

## 2022-11-21 07:34:37 - general channel

**liam**

It will be because your hostname / customer_strategy_ref has changed, you can set it to a default value in the config. This is done so you can run multiple instances of flumine with separate orders 

---

## 2022-11-21 02:35:46 - general channel

**AI Trader**

Hi guys,

I'm running my flumine instance in the cloud with the Middleware available in the examples for retrieving EXECUTION_COMPLETE orders whenever the program restarts. When running the same code locally, the middleware fails to retrieve the orders that were placed by the program in the cloud due to the strategy_name_hash `(current_order.customer_order_ref[:STRATEGY_NAME_HASH_LENGTH])` being different (even though the strategy name is the same both locally and in the cloud). I need help figuring out why this is happening, as  `customer_order_ref` should only depend on the strategy name? Any hints would be hugely appreciated as I have spent a lot of time trying to debug this with no success. The fact that orders only store the hash of the strategy name makes it more difficult to figure out if for some undesired reason my code is changing the strategy name.

---

## 2022-11-20 23:11:33 - general channel

**mzaja**

Hi all,

I have a greyhound bot which I've been running for a few months using bflw and a self-made scheduler, which starts the bot 5 mins before each race. I would like to port the strategy to flumine. However, flumine expects me to initialise the strategy object with a coarse filter which would subscribe to all greyhound markets at once, but this gets me over the 200 markets per connection limit on most days. What is the best way to go about this? I am only interested in market updates 5 min before the off since there is virtually no activity beforehand, so it seems a waste of subscriptions to spend them on markets which are overwhelmingly inactive.

---

## 2022-11-20 15:28:36 - general channel

**AI Trader**

[@U4H19D1D2](@U4H19D1D2) Sorry, let me make it more clear:



When using the `_create_order_from_current()` (see in the middleware example [https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/examples/middleware/orders.py#L45](https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/examples/middleware/orders.py#L45)), I get None in `strategy = self.flumine.strategies.hashes.get(strategy_name_hash)`

This entails that none of my previous orders gets created when the program restarts, as I get the error :

{"asctime": "2022-11-20 15:23:35,051", "levelname": "WARNING", "message": "OrdersMiddleware: Strategy not available to create order 138876445504398400", "bet_id": "287696652099", "market_id": "1.197093506", "customer_strategy_ref": "menoci", "customer_order_ref": "5458cb00631fc-138876445504398400", "strategy_name": "None", "client_username": "[mailto:xxxxx@gmail.com|xxxxx@gmail.com](mailto:xxxxx@gmail.com|xxxxx@gmail.com)"}

---

## 2022-11-20 14:56:00 - strategies channel

**James**

@R your comment reminded me of a recent interview with Patrick Veitch. To paraphrase, his favourite strategy is TFW - Timeform Wrong 

---

## 2022-11-20 06:38:00 - strategies channel

**liam**

Probably `blotter.strategy_orders(matched_only=True)`

---

## 2022-11-20 05:15:55 - general channel

**Unknown**

Hi guys,

Any guesses why I am getting a strategy_name equal to None? The order has been submitted by a strategy with a name different from None, and when trying to fetch the executed orders through the middleware available in the flumine examples, I am getting None as a strategy name, which implies that the middleware is not adding any of the executed orders when it restarts. Are there any requirements for the strategy name? Eg. a max length ?

---

## 2022-11-19 20:44:01 - strategies channel

**Liam Querido**

So there is no set strategy for dealing with this problem? Perhaps just constrain all bets to at least 0 EV in case one bet is unmatched. Again, however, this will require calculation of a probability of success p.

---

## 2022-11-19 19:35:56 - strategies channel

**AP**

What's the most efficient way to retrieve matched orders on the market within the strategy class?

---

## 2022-11-19 13:34:46 - strategies channel

**river_shah**

If your missed bets are approx 0 EV then don't worry about it and just think of it as added variance / part of normal operation of strategy

---

## 2022-11-19 13:29:47 - strategies channel

**Liam Querido**

What is the best way to mitigate execution risk? I have an arbitrage trading strategy that places three bets anytime an arbitrage opportunity exists. The problem comes when one of the bets cannot be matched, but the other two can be.



I have considered using the MatchMe feature and setting a liquidity filter to ensure that all my bets are matched, but is there a better method?

---

## 2022-11-18 19:43:36 - random channel

**Newbie99**

My solution isn't perfect, but I calculate any exposure metrics in a worker and then save to market.context (creating a dict for each strategy).



I use middleware when backtesting for the same result.

---

## 2022-11-18 09:56:24 - strategies channel

**Craig Welch**

[@UPMUFSGCR](@UPMUFSGCR): “_One of them did a good presentation on Greyhound Modelling. It’s online somewhere_”



I’d be very interested to read that. Do you recall any clues that might help me find it ?



TIA

---

## 2022-11-17 09:23:23 - general channel

**Aaron Smith**

depends heavily on the strategy. From my experience, strategies where i am offering bets underperform in backtest compared to live and strategies that take bets are very comparable. i think i m actually still doing slightly better in live than in backtesting, unless i backtest a lot to get the perfect parameters, in which case you can assume that the parameter set that was performing best was probably also a little lucky in that particular run and live will be performing slightly worse.

---

## 2022-11-17 09:13:30 - general channel

**Jorge**

Does the backtest (simulation) match live trading for you guys? I'm testing and want to feel confident they match before running the Strategy live with higher stake and in more markets. But maybe this is too much to ask from the backtest?

---

## 2022-11-16 10:59:35 - issues channel

**Peter C**

I have an issue that sometimes appears after a `connection closed by server` error. When the flumine strategy reconnects, it can sometimes get stuck in a cancelling loop. My cancel logic checks whether an order has Executable status, and then cancels based on time executable. Sometimes after a reconnect the strategy attempts to cancel an order, and this transaction fails as `bet_taken_or_lapsed`. The strategy will continually try to cancel these orders, so I'm wondering what the best way to avoid this is.

---

## 2022-11-15 18:36:21 - random channel

**VT**

[@UUE6E1LA1](@UUE6E1LA1)  I could try to build a model, but it would certainly be less efficient than this one. There are factors that change the margins in each quote, the bias of the favorite in the long term, etc... As I said, it's a matter of Buchdahl, he was kind enough to answer an email about this topic. I intend to use this to 'price and project' the most accurate quote possible on lines that are not available in bookies sharps but exist elsewhere.

---

## 2022-11-15 14:36:25 - general channel

**Jorge**

I added this to my strategy to simulate FILL_OR_KILL orders, it is not perfect but works most of the time:

```def process_orders(self, market, orders):

    for order in orders:

        if order.status == OrderStatus.EXECUTABLE:

            market.cancel_order(order)```



---

## 2022-11-15 08:52:48 - general channel

**Jorge**

Other question:sweat_smile:, does the "FILL_OR_KILL" attribute work in Simulation? In live trading I find "Order status update: Execution complete" but I don't receive this in Simulation...

---

## 2022-11-15 08:26:16 - general channel

**Jorge**

When running a FlumineSimulation I see that orders placed have [https://github.com/betcode-org/flumine/blob/master/flumine/order/order.py#L287|order.publish_time](https://github.com/betcode-org/flumine/blob/master/flumine/order/order.py#L287|order.publish_time)  == [https://github.com/betcode-org/flumine/blob/master/flumine/order/order.py#L286|order.date_time_created](https://github.com/betcode-org/flumine/blob/master/flumine/order/order.py#L286|order.date_time_created). But this is not 100% realistic, is it possible to add a processing delay? Let's say my strategy takes 100 ms to decide if it places an order.

---

## 2022-11-15 08:14:02 - general channel

**Jorge**

that's awesome, it's a easy solution to my problem of triggering a `process_market_book` whenever my probabilities of fair_price change. at least I can simulate if it improves my strategy

---

## 2022-11-15 06:21:03 - general channel

**liam**

Set `streaming_timeout` to a value in the strategy, this causes snap to be called on the cache every x seconds, ie



```strategy = ExampleStrategy(

    market_filter=streaming_market_filter(market_ids=["1.205602407"]),

    streaming_timeout=1

)```



---

## 2022-11-14 16:12:29 - random channel

**D C**

Would it not be easier to try and generate your own model and generate probabilities from that? Even if you wanted to try something absolutely filthy like curve fitting and extrapolation from these prices you would need to guess how they have applied the margin to each outcome price and remove it. Buchdahl has stuff on margin removal I think although in truth his books are still gathering dust on my shelf. I'm curious as to what use these prices would be to you though even if you could generate them?

---

## 2022-11-14 15:22:17 - general channel

**Jorge**

Hi, I am debugging an inplay market where I run flumine. The live log indicates an order was placed but I cannot see this order anywhere in the betfair website or quering `trading.betting.list_cleared_orders`



```2022-11-13 14:53:25,981 | INFO | a | a | Order status update: Pending

2022-11-13 14:53:25,982 | INFO | a | a | Deleting requests.Session

2022-11-13 14:53:25,982 | INFO | a | a | New requests.Session created

2022-11-13 14:53:25,987 | INFO | a | a | Thread pool submit

2022-11-13 14:53:25,987 | INFO | a | a | 1 order packages executed in transaction

2022-11-13 14:53:31,266 | INFO | a | a | execute_place

2022-11-13 14:53:31,267 | INFO | a | a | Trade status update: Pending

2022-11-13 14:53:31,267 | INFO | a | a | Order Place: SUCCESS

2022-11-13 14:53:31,267 | INFO | a | a | Order status update: Executable

2022-11-13 14:53:31,267 | INFO | a | a | Trade status update: Live

2022-11-13 14:53:31,505 | INFO | a | a | Order status update: Execution complete

2022-11-13 14:53:31,505 | INFO | a | a | Trade status update: Complete```

Any idea what could have happened?

---

## 2022-11-14 14:15:40 - general channel

**Jorge**

Hey, any clean way of changing the customer_strategy_ref of a flumine Strategy? I'm currently overwriting the config variable, like:



```import flumine.config

flumine.config.customer_strategy_ref = "my_strategy_ref"```

---

## 2022-11-12 17:34:59 - general channel

**Carlos M**

Thanks Mo. So this means that if my strategy cannot react as fast as the market updates, there is a risk that I will place orders based on old (and wrong) prices on the orderbook?

---

## 2022-11-12 17:33:09 - general channel

**Carlos M**

I entirely agree! What I am trying to understand is the following: Assume that my strategy is fast, but there is a situation where there are so many market updates (assume 100 in 1ms, as an extreme case). Why would I want to react on the oldest update? Isn't that even dangerous to place orders based on old prices (the price might have changed between the 0th and the 100th market updates in the queue). I am by no means suggesting this is a wrong approach, just trying to understand the risks

---

## 2022-11-12 17:22:34 - general channel

**liam**

Let’s assume you are running a strategy inplay, things move fast so should your strategy, you wouldn’t want to miss an opportunity that presents itself (market based) 



If you don’t want all updates you can use the conflate variable 

---

## 2022-11-12 17:19:28 - general channel

**Carlos M**

Thank you so much [@U4H19D1D2](@U4H19D1D2)!



Could you explain to me what is the benefit of processing every single book update (other than reconstructing the orderbook through book differences, which is not the case of a strategy) ? An example would be extremely appreciated

---

## 2022-11-11 13:14:00 - general channel

**Jorge**

Hi guys, what is [https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L46|conflate_ms](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L46|conflate_ms) used for when creating a flumine Strategy?

---

## 2022-11-11 02:43:07 - general channel

**AI Trader**

*AVOID DUPLICATED ORDERS*

How does flumine deals with avoiding duplicated orders? Say that my strategy always keeps a single bid and lay on the best levels of the orderbook. If I implement this logic (target orders generation and placement) in `process_market_book` , what will happen if I get a new market_update before betfair sends a message with my open orders to the websocket acknowledging that the orders have been placed? Example: I place both back and lays at the top of the orderbook at time T0, I receive another book update at time T1 and at time T2 my open orders are updated once the websocket receives my orders from betfair. Is is possible that in between T1 and T2 I place duplicated orders? As in this interval (T1-T2) I will not have acknowledged the open orders that I submitted at T0 just yet? Any help is enormously appreciated.

---

## 2022-11-10 13:47:58 - strategies channel

**Jonjonjon**

One of them did a good presentation on Greyhound Modelling. It's online somewhere.

---

## 2022-11-10 13:13:56 - general channel

**liam**

in your case `process_orders` is the most logical and store any data in `Strategy.context` or `Market.context`

---

## 2022-11-10 13:09:31 - general channel

**Guy Incognito**

Hi guys, I'm trying to run a strategy where after an order is matched u would like to update a value e.g. if my back bet gets matched then update my probability. What's the best way to do this? I will have multiple limit orders at once so I just want a code of chunk to execute when one of the orders get matched I've been looking at

 `_process_market_orders`

But not sure if it's the right way to go

---

## 2022-11-10 10:33:19 - strategies channel

**R**

Thanks guys, for sure I can see that the majority is in the win/place.  I have found value in the sense of I can determine where to place bets; but yes now the issue is getting it (after commission!).



This might be a cheeky question, so feel free to slap me on the wrists.  I am torn between pure market based betting (i.e. just using price history) and fundamental handicapping.  The latter requires data, expensive data.  Any thoughts?

---

## 2022-11-09 17:56:06 - general channel

**foxwood**

Got autogluton going fairly quickly so will explore the models on that to start with. Not sure about the trend to try everything then just pick simple best accuracy - the quality of the ones it gets right is more important. I got better results with tf by sticking to one model at a time and playing with the data in terms of changing the feature set, nodes, depth etc. ONNX looks interesting and MS give it some support for Windows so will have a look at that as well. Thanks for suggestions.

---

## 2022-11-09 14:12:33 - general channel

**R**

Not sure on compatibility with flumine, but in general you have:



pytorch or JAX that are pretty efficient and python-friendly.



Using ML in practice often means converting your model to some lightweight format, check out ONNX for that.  I would be more than happy to discuss further!

---

## 2022-11-09 12:57:35 - general channel

**FT**

Hi guys, I've got a flumine specific question. I don't know if I misunderstand something in the way the blotter works. I'm simulating a simple strategy with historical data. In this particular case, at the end all the orders in the markets blotter show up as PENDING, which is very unlikely since there are a lot of them and I take very bad prices just to see if they ever get the status EXECUTION_COMPLETE.

I collect some of the orders information into a dataframe. This is one example row. Why do I have a `avg_price_matched` and `size_matched` and `profit`, when the order is still PENDING? By the way the placed_at and completed_at are seconds to start time.

```selection_id  placed_at  completed_at  status                price  side  avg_price_matched  size_matched  profit

28396755      -348.287   -348.287      OrderStatus.PENDING   1.81   BACK  1.91               2.0           1.82```

---

## 2022-11-09 12:33:07 - general channel

**James**

Hi all, I'm trying to build a simple dataframe containing basic details for the day's races. For some reason I can't get the off times for each race. This line `'Start Time': [market_cat_object.market_start_time for market_cat_object in market_catalogues]` just returns None. Can anyone see what the issue is? Thanks



```# Create event filter

event_filter = betfairlightweight.filters.market_filter(

    event_type_ids=[7],

    market_type_codes=["WIN"],

    market_countries=["GB", "IE"], 

    market_start_time={

        'to': (datetime.utcnow() + timedelta(hours=time_window)).strftime("%Y-%m-%dT%TZ")

    }

)



todays_races = trading.betting.list_events(

    filter=event_filter

)



races_today = pd.DataFrame({

    'Event Name': [event_object.event.name for event_object in todays_races],

    'Event ID': [event_object.event.id for event_object in todays_races],

})



print(races_today)



races_list = races_today['Event ID'].to_list()

print(races_list)



market_catalogue_filter = betfairlightweight.filters.market_filter(event_ids=races_list, market_type_codes=["WIN"])



market_catalogues = trading.betting.list_market_catalogue(

    filter=market_catalogue_filter,

    max_results='100',

    sort='FIRST_TO_START',

)



# Create a DataFrame for each market catalogue

races_df = pd.DataFrame({

    'Start Time': [market_cat_object.market_start_time for market_cat_object in market_catalogues],

    'Market Name': [market_cat_object.market_name for market_cat_object in market_catalogues],

    'Market ID': [market_cat_object.market_id for market_cat_object in market_catalogues],

    'Total Matched': [market_cat_object.total_matched for market_cat_object in market_catalogues],

})```



---

## 2022-11-08 14:57:28 - general channel

**Jorge**

I can create it if I solve it for my strategy first

---

## 2022-11-08 13:34:17 - general channel

**Jorge**

Hi guys. Is there any way to get the current exposure from a market/strategy in flumine? Otherwise, I'd need to calculate it manually. For ex: If I placed a 3$ back order at 2.0 and a 2$ lay order at 2.0, the exposure would be 1$

---

## 2022-11-07 20:09:55 - betconnect channel

**Beeblebrox**

It's because the handicap field on the ActiveBet class is defined as a float, but what's being returned from the API is a string.



[https://github.com/betcode-org/betconnect/blob/6b901b04efc6a630537b12cebd3116d4268da4fd/betconnect/resources/betting.py#L590](https://github.com/betcode-org/betconnect/blob/6b901b04efc6a630537b12cebd3116d4268da4fd/betconnect/resources/betting.py#L590)

---

## 2022-11-07 12:56:53 - strategies channel

**AndyL**

Variance of no hedge can be very varied from strategy to strategy, the above is mild, and I've done some analysis with signal diversity and some no hedge  and am letting it run this month..

Other strategies/markets can be extreme variance with long period return to mean as it were.. these i think benefit from hedging more

---

## 2022-11-07 12:14:18 - strategies channel

**ShaunW**

It's pretty easy to figure out what difference hedging or not, at bsp, makes any difference to your specific strategy (size permitting). It's not always clearcut. Absolutely understand your position but my situation is that I gain from hedging so I don't like to be prescriptive, in fact when I don't hedge it turns into a loser.

---

## 2022-11-07 08:50:58 - general channel

**Newbie99**

For this to work, you essentially need to create a hash (import create_cheap_hash from flumine.utils) of your strategy name. Then you can assign the orders with a null customer_order_ref to that strategy and they will appear in the blotter.



```            if current_order.market_id in market_id_list:

                if current_order.side == 'BACK':

                    strategy_name_hash = create_cheap_hash(STRATEGY_NAME, STRATEGY_NAME_HASH_LENGTH)

                else:

                    strategy_name_hash = create_cheap_hash(STRATEGY_NAME, STRATEGY_NAME_HASH_LENGTH)

                order_id = current_order.bet_id

            else:

                strategy_name_hash = current_order.customer_order_ref[:STRATEGY_NAME_HASH_LENGTH]

                order_id = current_order.customer_order_ref[STRATEGY_NAME_HASH_LENGTH + 1:]```

---

## 2022-11-06 21:52:27 - general channel

**AI Trader**

Additional info: I've checked, and orders placed through manual UI cashout have *customer_strategy_ref = None*. The problem is that after fetching past orders through the middleware available in the [https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py|examples](https://github.com/betcode-org/flumine/blob/master/examples/middleware/orders.py|examples), the cashout orders don't appear even when *not* filtering orders by strategy, ie, *market.blotter.client_orders(client)* or in Blotter.strategy_orders(None).



I have also tried to modify the middleware example and remove line [https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/examples/middleware/orders.py#L24|24](https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/examples/middleware/orders.py#L24|24) :`(customer_strategy_refs=[config.customer_strategy_ref])`, but this causes an issue as in lines [https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/examples/middleware/orders.py#L49|46-49](https://github.com/betcode-org/flumine/blob/47af44b2173cf9d6b32fd9daef22dae510adea3f/examples/middleware/orders.py#L49|46-49) we try to access *customer_order_ref* and *customer_order_ref,* which are both `null` for orders placed by cashout (UI).



lines 46-49:

```strategy_name_hash = current_order.customer_order_ref[            :STRATEGY_NAME_HASH_LENGTH]

order_id = current_order.customer_order_ref[STRATEGY_NAME_HASH_LENGTH + 1 :]```

---

## 2022-11-06 21:51:31 - general channel

**AI Trader**

*INCLUSION OF MANUAL ORDERS (UI) IN BLOTTER.CLIENT_ORDERS()*

Hi guys,

Currently, I have a single strategy, and when using blotter functionalities such as market_exposure or selection_exposure I need to specify a strategy. The problem with that is that it does not include manual orders from the UI (such as manual cashout orders). Is there a way (without rewriting these functions) to get the market/selection exposure for all client orders (not only from a particular strategy), *including orders placed from the UI (cashout orders included*)?

---

## 2022-11-06 17:14:25 - random channel

**VT**

These guys move a lot of money in betting, it would be a real pleasure to spend some time with them helping out at work.

---

## 2022-11-06 15:47:06 - general channel

**AI Trader**

Hi guys,

I placed some orders using a Client/Strategy, and then restarted the program. After that, I cannot get anymore the matched orders using

• `makret.blotter.client_orders(client)` or

• `makret.blotter.client_orders(strategy_name)`

This worries me as if the code restarts for some reason (like crashing), I will basically loose all my matched orders and get a wrong `market_exposure`. Could someone provide some help to better understand if this is indeed an issue?



Is there any built-in mechanism to fetch the existing orders from the rest API when the program starts?

---

## 2022-11-06 14:01:15 - strategies channel

**Jonjonjon**

Or if you can find a way to diversify you strategy signal, you might not need to worry about the downside too much

---

## 2022-11-06 13:38:09 - general channel

**Peter**

Not sure what you mean by automatically, but most of what you need is already there and easy to implement. Take a look at this [https://github.com/betcode-org/flumine/blob/master/examples/example.py|example strategy](https://github.com/betcode-org/flumine/blob/master/examples/example.py|example strategy). In particular the process_orders method and the the pieces of code that are commented out.

---

## 2022-11-05 16:04:56 - general channel

**Nicholas vizard**

Hi everyone,

I hope you are all keeping well!

I just had a quick question related to understanding the MarketBook and MarketDefinition class in the betfairlightweight module. I am using the betfairlightweight module to parse the Historical Stream Data into a csv file. I am just starting out with object orientated programming, so any advice would be very much appreciated :blush::

*Why does the attribute _.market_definition_, when applied to a MarketBook object, return a MarketDefinition object, rather than kwargs.pop("market_definition", None)?*  

I suspect that:

 Applying the attribute market_definition to a marketbook object should return: kwargs.pop("market_definition", None) as that is wait is contained in the sourcecode for the MarketBook class (see: _betfairlightweight.resources.bettingresources.MarketBook')_

 However when I run: print(type(marketbookobject.market_definition),

I get: _*&lt; class, betfairlightweight.resources.streamingresources.MarketDefinition&gt;*_, which suggesting that I have generated a class by calling the market_definition attribute on a marketbook object.

Any help in clarifying why calling the market_definition attribute on a marketbook object generates a class would be much appreciated.



Thanks,

Nick

---

## 2022-11-05 13:42:59 - strategies channel

**Peter**

I agree with [@UBS7QANF3](@UBS7QANF3) that R^2 isn't worth much in this context. EV is useful and I'd also compare the Brier scores for your models to the one for BSP.

---

## 2022-11-05 12:46:57 - strategies channel

**Ralegh**

People experienced with modelling - what sort of R^2 values should I be looking for (versus bsp)? I have two models so far using separate data with R^2 0.3 and 0.15 (tiny p values), I'm going to play about with other methods but are those worth using (i.e. together ensembled somehow with other models) or not?

---

## 2022-11-04 08:45:00 - general channel

**Jorge**

Yes, this strategy relies solely in the sports_data. But I could place a bet if the marketBook changes in my favor, even if sports_data doesn't change

---

## 2022-11-04 08:15:35 - general channel

**Unknown**

Hi [@U4H19D1D2](@U4H19D1D2). This is the market and sports_data I'm using, both in marketSubscription format. And also the python code where I have the Strategy and Middleware

---

## 2022-11-03 16:48:40 - general channel

**Jorge**

This is my strategy class:

```class ExampleStrategy(BaseStrategy):

    def check_sports_data(self, market, sports_data) -&gt; bool:

        return True



    def process_sports_data(self, market, sports_data) -&gt; None:

        # called on each update from sports-data-stream

        fair_price = sports_data.runners[0].fair_price

        available_to_back = market.market_book.runners[0].ex.available_to_back[0]['price']

        if available_to_back &gt; fair_price:

            selection_id = market.market_book.runners[0].selection_id

            if self._invested and self._invested[(market.market_id, selection_id, 0)].executable_orders == True:

                return



            trade = Trade(

                market.market_id,

                selection_id,

                0,

                self,

            )

            order = trade.create_order(

                side="BACK",

                order_type=LimitOrder(available_to_back, 2, time_in_force="FILL_OR_KILL"),

            )

            market.place_order(order)```



---

## 2022-11-03 16:43:34 - general channel

**Jorge**

Exactly, so this is not possible with flumine, right? My use-case is an in-play football model that receives stats

---

## 2022-11-03 07:18:25 - general channel

**Mo**

Not sure if this will work as each process may need its own `trading` object but this is the basic pattern I follow for any parallelisation job in Python:



```import os

from concurrent import futures

from tqdm import tqdm



with futures.ProcessPoolExecutor(max_workers=os.cpu_count()) as pool:

    all_futures = [pool.submit(trading.historic.download_file, file_path=file) for file in file_list]

    for future in tqdm(futures.as_completed(all_futures), total=len(all_futures)):

        future.result()```

---

## 2022-11-03 03:21:01 - general channel

**Guy Incognito**

Is there anyway to run the loop at the end of [https://github.com/betcode-org/betfair/blob/master/examples/examplehistoricdata.py|https://github.com/betcode-org/betfair/blob/master/examples/examplehistoricdata.py](https://github.com/betcode-org/betfair/blob/master/examples/examplehistoricdata.py|https://github.com/betcode-org/betfair/blob/master/examples/examplehistoricdata.py) in parallel to speed up download. I tried using joblib but there isn't much difference.



The original loop looks like this:

```for file in file_list:

    print(file)

    download = trading.historic.download_file(file_path=path)

    print(download)```

---

## 2022-11-02 13:22:28 - general channel

**liam**

just an example but the idea would be the same, use middleware that gets called on each `marketBook` update to pull in the data that you need and then store in `market.context` for strategy processing

---

## 2022-11-02 13:14:42 - general channel

**Jorge**

Hi, is it possible to use flumine to simulate a strategy that uses data which is not recorded in the market files?

---

## 2022-11-02 11:13:53 - issues channel

**river_shah**

[@U4H19D1D2](@U4H19D1D2) this was asked a while ago but sorry I can't find answer in search. How do I force process termination if I hit something like this please?

```CRITICAL[flumine.utils:call_strategy_error_handling:246] Unknown error xxx```

---

## 2022-11-01 13:21:20 - issues channel

**Liam Querido**

Where would I call the prices_file_to_csv_file function in the below code?



client = clients.BetfairClient(trading)



framework = Flumine(client=client)



strategy = MarketRecorder(

    market_filter=betfairlightweight.filters.streaming_market_filter(

        market_ids=[MarketID],

    ),

    stream_class=DataStream,

    context={"local_dir": r"C:\tmp", "force_update": False, "remove_file": True,},

)



framework.add_strategy(strategy)

framework.run()

---

## 2022-11-01 11:54:07 - issues channel

**Guy Incognito**

if runner.status == "ACTIVE":

                        back_price = 5

                        back_size = 5



                        trade = Trade(

                            market_id=market_book.market_id,

                            selection_id=runner.selection_id,

                            handicap=runner.selection_id,

                            strategy=self

                        )



                        order = trade.create_order(

                            side="BACK",

                            order_type=LimitOrder(price=back_price, size=back_size)

                        )



                        market.place_order(order)

---

## 2022-11-01 11:47:51 - issues channel

**liam**

can you share the strategy code where you call place?

---

## 2022-11-01 07:19:31 - issues channel

**Liam Querido**

Is the MarketRecorder under Flumine the best way to stream? I have seen lots of different modules and many different approaches to streaming - some use MarketRecorder, others don't. What do you suggest (and is there a specific streaming example you could refer me to)?



So far, I am able to obtain the market data I want, but not via streaming (just PIT query). Below is my code. What is the best way to adapt this for streaming?



Thanks in advance! This forum has already been extremely helpful!





def GetEventIDs():

    event_types = trading.betting.list_event_types()

    Result = pd.DataFrame({

        'Sport': [event_type_object.event_type.name for event_type_object in event_types],

        'ID': [event_type_object.event_type.id for event_type_object in event_types]

    }).set_index('Sport').sort_index()

    return Result



GetEventIDs()





def FilterMarkets(EventTypeID,MarketCountry,DaysUntilMarketStart):

    sport_event_filter = betfairlightweight.filters.market_filter(

        event_type_ids    =[EventTypeID],

        market_countries  =[MarketCountry],

        market_start_time ={

            'to': (datetime.datetime.utcnow() + datetime.timedelta(days=DaysUntilMarketStart)).strftime("%Y-%m-%dT%TZ")

        }

    )

    country_sport_events = trading.betting.list_events(

        filter=sport_event_filter

    )

    Result = pd.DataFrame({

        'Event Name': [event_object.event.name for event_object in country_sport_events],

        'Event ID': [event_object.event.id for event_object in country_sport_events],

        'Event Venue': [event_object.event.venue for event_object in country_sport_events],

        'Country Code': [event_object.event.country_code for event_object in country_sport_events],

        'Time Zone': [event_object.event.time_zone for event_object in country_sport_events],

        'Open Date': [event_object.event.open_date for event_object in country_sport_events],

        'Market Count': [event_object.market_count for event_object in country_sport_events]

    })

    return Result





def process_runner_books(runner_books,market_catalogues):

    '''

    This function processes the runner books and returns a DataFrame with the best back/lay prices + vol for each runner

    :param runner_books:

    :return:

    '''

    best_back_prices = [runner_book.ex.available_to_back[0]['price']

        if runner_book.ex.available_to_back

        else np.nan

        for runner_book

        in runner_books]

    best_back_sizes = [runner_book.ex.available_to_back[0]['size']

        if runner_book.ex.available_to_back

        else np.nan

        for runner_book

        in runner_books]



    best_lay_prices = [runner_book.ex.available_to_lay[0]['price']

        if runner_book.ex.available_to_lay

        else np.nan

        for runner_book

        in runner_books]

    best_lay_sizes = [runner_book.ex.available_to_lay[0]['size']

        if runner_book.ex.available_to_lay

        else np.nan

        for runner_book

        in runner_books]



    selection_ids = [runner_book.selection_id for runner_book in runner_books]

    statuses      = [runner_book.status for runner_book in runner_books]

    runners       = [market_catalogue.runner_name for market_catalogue in market_catalogues.runners]



    df = pd.DataFrame({

        'Runners': runners,

        'Selection ID': selection_ids,

        'Best Back Price': best_back_prices,

        'Best Back Size': best_back_sizes,

        'Best Lay Price': best_lay_prices,

        'Best Lay Size': best_lay_sizes,

        'Status': statuses,

    })

    return df





def GetMarketBook(MarketID,MarketCatalogue):

    price_filter = betfairlightweight.filters.price_projection(price_data=['EX_BEST_OFFERS'])

    # Request market books

    market_books = trading.betting.list_market_book(

    market_ids=[MarketID],

    price_projection=price_filter

    )

    # Grab the first market book from the returned list

    market_book = market_books[0]

    Result = process_runner_books(market_book.runners, MarketCatalogue)

    return Result

---

## 2022-11-01 06:28:49 - issues channel

**Muhammad Adeel Zahid**

Ok, when I try to run the following code

```trading = betfairlightweight.APIClient(username = my_username, password = my_password, app_key = my_app_key, certs=certs_path)

trading.login()

market_id = "1.199777126"

selection_id = 31484513

resources = trading.race_card.get_race_card(market_ids=[market_id])

print(resources)```

I get the exception

`Traceback (most recent call last):`

  `File "E:\Git\betfair\dailyracevenuedatagrabber.py", line 37, in &lt;module&gt;`

    `resources = trading.race_card.get_race_card(market_ids=[market_id])`

  `File "E:\Git\betfair\venv\lib\site-packages\betfairlightweight\endpoints\racecard.py", line 59, in get_race_card`

    `raise RaceCardError(`

`betfairlightweight.exceptions.RaceCardError: You need to login before requesting a race_card`

`APIClient.race_card.login()`

when I change `trading.login()` to `trading.race_card.login()`

I get the following exception

`Traceback (most recent call last):`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\connectionpool.py", line 703, in urlopen`

    `httplib_response = self._make_request(`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\connectionpool.py", line 386, in _make_request`

    `self._validate_conn(conn)`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\connectionpool.py", line 1040, in _validate_conn`

    `conn.connect()`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\connection.py", line 414, in connect`

    `self.sock = ssl_wrap_socket(`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\util\ssl_.py", line 449, in ssl_wrap_socket`

    `ssl_sock = _ssl_wrap_socket_impl(`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\util\ssl_.py", line 493, in _ssl_wrap_socket_impl`

    `return ssl_context.wrap_socket(sock, server_hostname=server_hostname)`

  `File "C:\Users\adeel\AppData\Local\Programs\Python\Python310\lib\ssl.py", line 512, in wrap_socket`

    `return self.sslsocket_class._create(`

  `File "C:\Users\adeel\AppData\Local\Programs\Python\Python310\lib\ssl.py", line 1070, in _create`

    `self.do_handshake()`

  `File "C:\Users\adeel\AppData\Local\Programs\Python\Python310\lib\ssl.py", line 1341, in do_handshake`

    `self._sslobj.do_handshake()`

`ssl.SSLError: [SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:997)`



`During handling of the above exception, another exception occurred:`



`Traceback (most recent call last):`

  `File "E:\Git\betfair\venv\lib\site-packages\requests\adapters.py", line 440, in send`

    `resp = conn.urlopen(`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\connectionpool.py", line 785, in urlopen`

    `retries = retries.increment(`

  `File "E:\Git\betfair\venv\lib\site-packages\urllib3\util\retry.py", line 592, in increment`

    `raise MaxRetryError(_pool, url, error or ResponseError(cause))`

`urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='[http://www.betfair.com|www.betfair.com](http://www.betfair.com|www.betfair.com)', port=443): Max retries exceeded with url: /exchange/plus/ (Caused by SSLError(SSLError(1, '[SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:997)')))`



`During handling of the above exception, another exception occurred:`



`Traceback (most recent call last):`

  `File "E:\Git\betfair\venv\lib\site-packages\betfairlightweight\endpoints\racecard.py", line 28, in login`

    `response = session.get(self.login_url)`

  `File "E:\Git\betfair\venv\lib\site-packages\requests\api.py", line 75, in get`

    `return request('get', url, params=params, **kwargs)`

  `File "E:\Git\betfair\venv\lib\site-packages\requests\api.py", line 61, in request`

    `return session.request(method=method, url=url, **kwargs)`

  `File "E:\Git\betfair\venv\lib\site-packages\requests\sessions.py", line 529, in request`

    `resp = self.send(prep, **send_kwargs)`

  `File "E:\Git\betfair\venv\lib\site-packages\requests\sessions.py", line 645, in send`

    `r = adapter.send(request, **kwargs)`

  `File "E:\Git\betfair\venv\lib\site-packages\requests\adapters.py", line 517, in send`

    `raise SSLError(e, request=request)`

`requests.exceptions.SSLError: HTTPSConnectionPool(host='[http://www.betfair.com|www.betfair.com](http://www.betfair.com|www.betfair.com)', port=443): Max retries exceeded with url: /exchange/plus/ (Caused by SSLError(SSLError(1, '[SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:997)')))`



`During handling of the above exception, another exception occurred:`



`Traceback (most recent call last):`

  `File "E:\Git\betfair\dailyracevenuedatagrabber.py", line 34, in &lt;module&gt;`

    `trading.race_card.login()`

  `File "E:\Git\betfair\venv\lib\site-packages\betfairlightweight\endpoints\racecard.py", line 30, in login`

    `raise APIError(None, self.login_url, None, e)`

`betfairlightweight.exceptions.APIError: [https://www.betfair.com/exchange/plus/](https://www.betfair.com/exchange/plus/)` 

`Params: None` 

`Exception: HTTPSConnectionPool(host='[http://www.betfair.com|www.betfair.com](http://www.betfair.com|www.betfair.com)', port=443): Max retries exceeded with url: /exchange/plus/ (Caused by SSLError(SSLError(1, '[SSL: WRONG_VERSION_NUMBER] wrong version number (_ssl.c:997)')))`

Please note that my certificate setup and credentials are correct as I am able to use other API methods like `trading.betting.list_market_catalogue` . What could be the reason of this exception for this particular endpoint?

---

## 2022-10-30 08:21:30 - general channel

**Meow**

cat_filter = betfairlightweight.filters.market_filter(

    market_ids = [‘1.205704199’])



# Request market cat

market_cat = trading.betting.list_market_catalogue(filter = cat_filter)



[x.runner_name for x in market_cat[0].runners]

---

## 2022-10-29 14:04:40 - betconnect channel

**Liam Querido**

Hi there. I'm trying to use Flumine to stream the Market Book, using the code under the Stream Class subheading from the following link.

[https://betcode-org.github.io/flumine/quickstart/#event-processing](https://betcode-org.github.io/flumine/quickstart/#event-processing)

Nothing is returned when running the code - I'm wondering you could help me understand what's happening here. Note that I also changed the "flumine.add_strategy(strategy)" line to "framework.add_strategy(strategy)."



The code that I am running is below. Please let me know if logging would be useful. Thanks in advance!



from flumine import BaseStrategy

from flumine.streams.datastream import DataStream





class ExampleDataStrategy(BaseStrategy):

    def process_raw_data(self, publish_time, data):

        print(publish_time, data)



strategy = ExampleDataStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB"],

        market_types=["WIN"],

    ),

    stream_class=DataStream

)



flumine.add_strategy(strategy)

---

## 2022-10-27 11:13:56 - issues channel

**Beeblebrox**

Yeah saw that, thanks. Just need to update to the latest version now, I think I'm still on 1.20.1 :joy:.  I've just realised the other control that needs updating to deal with the LINE_RANGE ladder type is the strategy and selection exposure checks. It's using the points line as the price, rather than 2.0, e.g. a £10 bet on over 231.0 gives a liability of £2300.

---

## 2022-10-26 17:20:35 - general channel

**Peter**

You will have to calculate it yourself, as Betfair calculates it only at market level and has no interest in the strategies you used under the hood.



From earlier conversations here though I suspect that most people would calculate the commission for strategy A as 0.65 and record the other 0.59 as bonus profit from running the two strategies together rather than implicitly adding it into the profit for strategy A.

---

## 2022-10-26 16:20:06 - general channel

**Jorge**

For example, in the same market:

• Calling `list_cleared_orders`  with strategy A gives profit=32.35, commission=0.06

• Calling `list_cleared_orders`  with strategy B gives profit=-29.46, commission=0.06. But here commission should be equal to 0?

Is there any way of separating them or do I have to calculate the commission myself?

---

## 2022-10-26 15:59:43 - general channel

**Jorge**

Hi all. I'm trying to separate results from 2 strategies that bet in the same markets. How do you deal with commission?



I find that when calling `list_cleared_orders` with different `customer_strategy_refs`, the `profit` column is correct but the `commission` column considers commission taking into account bets placed by other strategy_refs.

---

## 2022-10-26 11:46:31 - strategies channel

**Mo**

Not sure [@UUE6E1LA1](@UUE6E1LA1). I guess that technically goodness of fit is another way of scoring a model

---

## 2022-10-25 22:24:21 - strategies channel

**D C**

Ah ok I see. So is it based on results or validation as opposed to model goodness of fit stuff like reduction in deviance on nested linear models for example?

---

## 2022-10-25 21:53:49 - strategies channel

**Mo**

Literally assign a model a score so you can eg rank different ones and decide which is “better”. For example log loss, Brier score, Ranked Probability Score

---

## 2022-10-25 21:47:01 - strategies channel

**D C**

Dumb question no doubt, but what exactly do you mean by "scoring" a model?

---

## 2022-10-25 18:06:22 - strategies channel

**Alessio**

For the second one, i focus on what matters for me, exactly. The X seconds is to account for the fact that you want to see how much your model can see into the future. If the market has already moved and I check if I agree with the market _in that moment_ I look less at my predictive power.

---

## 2022-10-25 18:00:47 - strategies channel

**Mo**

Let me see if I understand correctly



For the first method, you make e.g. approximately 10 predictions for a football match spread throughout the match then score them as you would any other predictions? So it's essentially subsampling to reduce but not remove this issue of repeated predictions with the same outcome



For the second method the subsampling is achieved by focusing only on situations where either the odds or model predictions have changed but then with some additional random subsampling. Not sure about the X seconds before part?

---

## 2022-10-25 17:48:52 - strategies channel

**Alessio**

Very interesting question. I don't have a good answer for you but the way I do it is that I do two scorings. The first one is by chopping the time of the event in 5-10 mins intervals, and looking at only the ones at the beginning of the window. This is to kind of evaluate the 'baseline' model. The second one, is that i look for changes in the odds OR the model (derivatives) and evaluate a random subset of fixed size per event. For each of these changes, I look X seconds before.

---

## 2022-10-25 17:12:14 - strategies channel

**Mo**

For those of you who do in play, how do you score your models?



Using standard scoring rules has never quite sat right with me given you may be making hundreds (or theoretically infinite numbers) of predictions repeatedly on the same outcome



Backtests is another option but realised profit is slow to converge and all the other things that go into them such as choice of staking make it hard to focus on predictive accuracy of the model

---

## 2022-10-24 19:59:59 - issues channel

**Beeblebrox**

I'm paper trading a strat on a TOTAL_POINTS_LINE market, but I'm getting an ORDER_VALIDATION error:



```{"asctime": "2022-10-24 18:48:19,823", "name": "flumine.controls", "levelname": "WARNING", "message": "Order has violated: ORDER_VALIDATION Error: Order price is not valid", "control": "ORDER_VALIDATION", "error": "Order price is not valid", "order": {"market_id": "1.205496414", "selection_id": 105545, "handicap": 0, "id": "138859300988413659", "customer_order_ref": "354b9995c9ce8-138859300988413659", "bet_id": null, "date_time_created": "2022-10-24 18:48:18.842366", "publish_time": null, "market_version": null, "async": null, "trade": {"id": "6be453dd-53cc-11ed-a6ba-001b213a8a25", "strategy": "NBABackOvers", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138859300988413659"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 233.0, "size": 10, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 10.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": "Order has violated: ORDER_VALIDATION Error: Order price is not valid", "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "", "market_notes": null}}```

In these markets the back prices are the unders value and the lay prices are the overs value. The actual price is always 2.0.  So for the example above, I tried to place a bet on the overs at 233.0, but this trips up the order validation stuff here: [https://github.com/betcode-org/flumine/blob/b59a077e5e3d09e5042de5438677782e4be330f8/flumine/controls/tradingcontrols.py#L53](https://github.com/betcode-org/flumine/blob/b59a077e5e3d09e5042de5438677782e4be330f8/flumine/controls/tradingcontrols.py#L53)

---

## 2022-10-21 15:06:40 - betfair-news channel

**Neil T (Betfair)**

Hi [@U4H19D1D2](@U4H19D1D2) [@U02K1MG7YCA](@U02K1MG7YCA) - Exchange plans over the next 6-8 months are focused on rebuilding the mobile experience.  This project is already well down the line for the Betfair Sportsbook the focus will be on the Exchange mobile product from early 2023.  See [https://betting.betfair.com/betfair-announcements/whats-new-on-betfair/help-shape-the-new-betfair-get-a-first-look-at-our-new-mobile-experience-220221-204.html|https://betting.betfair.com/betfair-announcements/whats-new-on-betfair/help-shape-the-[…]t-a-first-look-at-our-new-mobile-experience-220221-204.html](https://betting.betfair.com/betfair-announcements/whats-new-on-betfair/help-shape-the-new-betfair-get-a-first-look-at-our-new-mobile-experience-220221-204.html|https://betting.betfair.com/betfair-announcements/whats-new-on-betfair/help-shape-the-[…]t-a-first-look-at-our-new-mobile-experience-220221-204.html) for more details,

---

## 2022-10-21 11:31:25 - random channel

**Unknown**

Openly discussing pre-event strategy development for which of the following sports would be stepping on your toes?

---

## 2022-10-21 11:17:40 - issues channel

**EJono**

I am encountering an error every hour or so which I cant seem to repeat, stemming from a list_market_book request. The strategy runs every 2 minutes or so across ~100 markets. The traceback of the error appears to be timeout related but im not sure how to tackle whatever is causing it.



`market_books = trading.betting.list_market_book(`

  `File "/usr/local/lib/python3.10/site-packages/betfairlightweight/endpoints/betting.py", line 283, in list_market_book`

    `(response, response_json, elapsed_time) = self.request(method, params, session)`

  `File "/usr/local/lib/python3.10/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 45, in request`

    `raise APIError(None, method, params, e)`

`betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketBook` 

`Params: {'marketIds': ['1.205155225'], 'priceProjection': {'priceData': ['EX_ALL_OFFERS'], 'exBestOffersOverrides': {}, 'virtualise': True, 'rolloverStakes': False}}` 

`Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)`



 `SportsAPING/v1.0/listMarketBook` 

`Params: {'marketIds': ['1.205155225'], 'priceProjection': {'priceData': ['EX_ALL_OFFERS'], 'exBestOffersOverrides': {}, 'virtualise': True, 'rolloverStakes': False}}` 

`Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)`



On follow up runs  on the same market 2 mins later the issue no longer occurs. Anyone familiar with this problem or have encountered it before and know how to addres it? Cheers

---

## 2022-10-20 22:10:54 - betfair-news channel

**Dave**

One thing I would love to have is some understanding of where my betting activity lies amongst the activity of other participants. E.g. a weekly email that includes stuff like ranking by total volume (percentile is fine), total time that you had the best back/lay in the market, a distribution of your market share etc. Perhaps in the form of a weekly personalized email. I'd love to understand how my volume / liquidity compares. I think this kind of thing could help drive up engagement too - any thoughts on whether it is something you could offer? The premium charges section could be a decent place for this kind of thing too.

---

## 2022-10-19 13:14:36 - issues channel

**D C**

inplay and pre-event. If you have a strategy only wanting to analyse inplay money traded and you use API-NG you have to poll with listMarketBook. You often get really short suspension period so you'll get one call that is when the market is inplay, and the one before is not. You also get 2 full market traded volume arrays - you have to manually calculate the delta, but because of the uncertainty between when the market was precisely turned inplay, you won't know exactly what money traded PE and what traded IP. Obviously this uncertainty gets worse as your polling frequency gets lower. It is a small thing and perhaps a trivial example

---

## 2022-10-13 13:04:33 - issues channel

**Aaron Smith**

yea i have to admit i never did profiling before :sweat_smile: so maybe i ll have to look into that. But all the calculations are the same, its the same strategy only using a new way of placing orders..

---

## 2022-10-13 13:03:18 - issues channel

**liam**

the log with "High latency between current time and MarketBook publish time" normally points to something bad within a strategy, profiling will tell you straight away

---

## 2022-10-13 13:00:21 - issues channel

**Aaron Smith**

Hi people

I switched from using `market.place_order(order)`  to using

```with market.transaction() as t:

    for order in orders:

        t.place_order(order)```

This was done to chunk up orders and with that make for a smoother execution.

However sadly this has had the opposite effect. Since the change i m getting flooded with all possible latency warnings and higher delay than i ve ever seen before (60seconds+), so i assume i must ve messed up somewhere.

example warnings (just imagine an army of these):

```{"asctime": "2022-10-13 11:00:58,015", "levelname": "WARNING", "message": "[OrderStream: 1001]: Latency high: 62.55000066757202"}



{"asctime": "2022-10-13 10:59:20,992", "levelname": "WARNING", "message": "High latency between current time and MarketBook publish time", "market_id": "1.204868412", "latency": 26.081366777420044, "pt": "2022-10-13T10:58:54.911000"}



{"asctime": "2022-10-13 10:59:20,987", "levelname": "WARNING", "message": "[MarketStream: 2001]: Latency high: 26.017338514328003"}```

The basic structure i use goes as follows:

All this happens within the strategy method `process_market_book` .

I create a bunch of orders for different runners using `trade.create_order` .

I collect these orders in a list. Then i call

```

    @staticmethod

    def place_orders(orders: list[BetfairOrder], market: Market):

        with market.transaction() as t:

            for order in orders:

                t.place_order(order)





    @staticmethod

    def cancel_orders(market: Market, orders: list[BetfairOrder]):

        with market.transaction() as t:

            for order in orders:

                if order.status == OrderStatus.EXECUTABLE:

                    t.cancel_order(order)```

to place and cancel orders.



Anyone having an idea whats going on here?

If no orders are collected for placing/cancelling, these 2 functions are still called with an empty list, can this cause any issues?



Thanks a lot to anyone taking the time :slightly_smiling_face:

---

## 2022-10-13 01:12:35 - issues channel

**Liam Querido**

Hi there. I am trying to stream market data using the code below; however, I am getting an error when I run the subscribe_to_markets function. The error reads as follows: "TypeError: Object of type bytes is not JSON serializable."



I don't quite understand this error, as the market_filter and market_data_filters variables are dictionaries (not byte objects), so this error doesn't make sense to me intuitively.



Any help with resolving this issue would be much appreciated. Thanks in advance!



```from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter,

)



betfair_socket = trading.streaming.create_stream()



market_filter = streaming_market_filter(

    event_type_ids=['7'],

    country_codes=['IE'],

    market_types=['WIN'],

)

market_data_filter = streaming_market_data_filter(

    fields=['EX_ALL_OFFERS', 'EX_MARKET_DEF'],

    ladder_levels=3

)



betfair_socket.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

)



betfair_socket.start()  # blocking```

---

## 2022-10-11 15:13:11 - general channel

**Tom**

Cheers - is the scheduled start then considered the best possible odds as a model for the real probabilities?



I know it's a false abstraction and why we can bet successfully e.t.c. e.t.c.

---

## 2022-10-11 10:59:53 - strategies channel

**thambie1**

Depending on your strategy you could also use indicators like beating opening line, or beating BSP to get an indication of profitability with less data.

---

## 2022-10-11 09:20:07 - general channel

**Peter**

[@U03TJKFLE8K](@U03TJKFLE8K) My path was comparable to yours. I wrote the (still) most widely used PHP package for consuming the Betfair API. But it became clear that PHP was a severely limiting factor. All the best tooling for analysis, testing and trading in this space is in Python (i.e. Betfairlightweight, Flumine, Pandas and Jupyter Notebooks).



So I went all in, learnt the language and now work almost exclusively in it (with a bit of Rust thrown in when I need compiled execution speeds). So my recommendation would be the familiarise with the tools that best fit the job rather than trying to bend your process to fit what you currently know. Though that is said without knowing what your processes are, e.g. if you are placing your bets manually at the bookmakers from data summarised via web pages you’ve constructed with Node, there may be a case for not re-inventing the wheel, just the engine :slightly_smiling_face:

---

## 2022-10-11 06:07:56 - general channel

**Ivan Zhou**

you can't pip install the fasttrack library. You can get it from here [https://github.com/betfair-down-under/autoHubTutorials/tree/master/FastTrack](https://github.com/betfair-down-under/autoHubTutorials/tree/master/FastTrack).



There is a tutorial on how to use fasttrack here [https://betfair-datascientists.github.io/modelling/fasttrackTutorial/](https://betfair-datascientists.github.io/modelling/fasttrackTutorial/)

---

## 2022-10-11 05:29:45 - general channel

**Tom**

Hey guys, there is some information that would be pretty handy to start with - and it's not the end of the world to figure out how to do it myself because I want to develop those skills anyway - but those skills can also be developed on other steps - so has anybody done work on which odds to use as the 'real' odds for a race? Is it on Jump? a minute out? time-weighted? value-weighted? Is it possible to model this, or does it change significantly in the reality?

---

## 2022-10-07 23:13:52 - general channel

**birchy**

[@U042PP6NAHM](@U042PP6NAHM) I'm going to assume you're using Flumine...what I would do is use the `market.context` dict to save the price of each runner on each update while inplay=False, then retrieve those prices in `process_closed_market()`



`class ClosingPriceStrategy(BaseStrategy):



    def check_market_book(self, market, market_book):

        if market_book.inplay: return

        return True



    def process_market_book(self, market, market_book):

        market.context['closing_prices'] = {

            r.selection_id: r.last_price_traded

            for r in market_book.runners

            if r.last_price_traded

        }



    def process_closed_market(self, market, market_book):

        # save to csv or whatever...

        for k, v in market.context['closing_prices'].items():

            print(k, v)`



This can be used for either backtesting or live

---

## 2022-10-06 16:05:09 - betconnect channel

**Jeffrey Been**

I think so: I want to see what prices were available before the event goes into play. The scenario I want to simulate is: what odds are available pre-play, so I can compute the profit/loss for a certain strategy say: only backing the favourite

---

## 2022-10-05 22:20:44 - betconnect channel

**Unknown**

Hi Everyone, i was invited by paulliam. My name is Jeffrey and I want to backtest some betting strategies on betfair historic data, and while doing so i stumbled accross the betfairleightweight code. Using the Betfair historic Data Processor, I do get a nice and tidy dataset. However this is a manual excersise and since I will have to do this for 10k+ matches it is not feasible to do it manually. I did some research and it seems to me i need 2 steps in which i am stuck:



1. get the json file into a nice and tidy format (csv), using `json.normalize` it does not achieve the desired result i get this (first image) while im looking for (second image, used by json converter) :

2. Still this is not a nice data set, when i go to [https://www.betfairhistoricdata.co.uk/](https://www.betfairhistoricdata.co.uk/)  I can put in my bz2 file and get a nice output (but this is all manual). 

I was wondering if it was possible to automate this process for a batch of bz2/tar files, so that I can rapidly process &gt;1k matches (files). I cannot find it in the python code of the the betfairleightweight package though. Can somebody help me out please, or point me to the code which does the conversion from json to the nice tidy dataset i get from the betfair processor.



Much appreciated, cheers Jeff

---

## 2022-10-04 19:27:37 - strategies channel

**Jonjonjon**

I found the answer to my question. A Strategy instance contains a client object that has the information that I'm after.

---

## 2022-10-04 14:57:21 - strategies channel

**Jonjonjon**

I want my strategy to refrain from placing orders if the 5k transaction limit has been reached. What's the recommended way to do that?

---

## 2022-09-29 09:31:15 - strategies channel

**Jonjonjon**

Suppose I wanted to backtest a strategy that needs to consume data from 2 streaming files, where the strategy needs to consider data from both files, and the two markets are trading at the same time... Is there an example that shows me how to do that? I recall reading about it but Google is not being my friend this morning.:disappointed:

---

## 2022-09-28 22:56:09 - random channel

**foxwood**

I think [@UBS7QANF3](@UBS7QANF3) is the resident wizard on this stuff - he posted a link recently to a free pdf of a textbook well worth reading - worth searching for. Think whether all the features are useful - if they are not really relevant to the prediction then leave them out since it can mislead the training. Categories can help things along if they represent very different things eg NH racing versus flat. Beware of including any data that would be unknown to your program at the time of running it live eg don't include BSP if it is a pre-race model. Maybe try a binary classification model if you just want yes/no. Worst thing I ever did was leave the result in the data set - training was superb at over 95% :rolling_on_the_floor_laughing:. Correlation matrix might throw some light on meaningful relationships in the data. No easy fixes that I know of unfortunately - just have to  keep at it refining and thinking - rinse and repeat.

---

## 2022-09-28 20:16:01 - random channel

**Jonjonjon**

Suppose it turns out that my model has been over fitted. What steps would you suggest I take, in order to improve it?

---

## 2022-09-28 20:02:33 - random channel

**foxwood**

Randomly split your data into at least 2 sets. Train the model on the first set then see what the built model achieves on the unseen second set. Great result on training and worse performance on validation is overfitting. Lots of articles out there on ways to loosen it up.

---

## 2022-09-28 19:31:17 - random channel

**Jonjonjon**

I am fitting a logistic regression.



It has 20 features that have been standardised to be roughly normal.



Sample size is 20k.



60% of target values are false. 40% are true.



The score (from sklearn) is 0.5.



What should I do to test whether or not my model has been over fitted?

---

## 2022-09-26 09:46:31 - general channel

**Mick**

I only need to see the first three rungs on the price ladder but I've just noticed that my request for prices is returning many more than that. The code I'm using to scoop the prices for a single race is as follows



```	price_filter = betfairlightweight.filters.price_projection(price_data=['EX_ALL_OFFERS','SP_AVAILABLE'])

	market_books = bfex_trading.betting.list_market_book(market_ids=[mk_id],price_projection=price_filter)

	market_book = market_books[0]```

I read somewhere that if you didn't specify how many rungs you wanted then the default returned would be three. What have I misunderstood?

---

## 2022-09-25 12:10:06 - betfair-news channel

**Mick**

I got blocked once before for reading too much data whilst making too few bets and it was a painful and slow process getting unblocked so now I'm paranoid about getting blocked again. My data use/bet size ratio has improved very dramatically so that's not an issue anymore but there's a couple of things I've been doing recently that I wanted to check on. Firstly - I'm wanting to leave my trading unattended for hours and just for safety I'd like to take all but the bare minimum required cash in my account each day and put more back in the following day - we're talking a few hundred pounds. Would that cause a problem? Secondly, I've been trying a strategy of putting in a bet request above the market price and then gradually lowering it as race time approaches. But for programming simplicity it's actually easier to cancel and then make a new request (not sure if the API lets you change your requested odds anyway). So for any one horse I might make of the order of a dozen bets that get requested and cancelled before an order is accepted. The duration of any single requests is at least ten seconds. Might this cause me any trouble?

---

## 2022-09-24 16:40:16 - issues channel

**Newbie99**

I'm sure this will be something incredibly dumb, but why would the market recorder not always produce a .gz file when the market closes?



Here is my code:



```import time

import logging

import betfairlightweight

from pythonjsonlogger import jsonlogger

import account_info as ai

from flumine import Flumine, clients

from flumine.streams.datastream import DataStream

from marketrecorder import MarketRecorder

from flumine.worker import BackgroundWorker

from recorded_files_worker import sort_recorded_files

from flumine.streams.datastream import RaceDataStream



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = betfairlightweight.APIClient(ai.accname, ai.accpass, ai.acckey, certs=ai.path)

client = clients.BetfairClient(trading, interactive_login=False)



framework = Flumine(client=client)



strategy = MarketRecorder(

    name="horse_racing",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE", "US", "AU", "FR"],

        market_types=["WIN", "PLACE", "EACH_WAY", "OTHER_PLACE"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": ai.market_recorder_path,

        "force_update": False,

        "remove_file": True,

        "remove_gz_file": False,

    },

)



framework.add_strategy(strategy)



strategy = MarketRecorder(

    name="football",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["1"],

        market_types=["OVER_UNDER_05", "OVER_UNDER_15", "OVER_UNDER_25", "OVER_UNDER_35", "OVER_UNDER_45", "CLEAN_SHEET", "MATCH_ODDS", "MATCH_ODDS_AND_BTTS", "BOTH_TEAMS_TO_SCORE", "HALF_TIME",

                      "HALF_TIME_SCORE", "FIRST_HALF_GOALS_05", "FIRST_HALF_GOALS_15", "FIRST_HALF_GOALS_25", "CORRECT_SCORE", "DOUBLE_CHANCE", "DRAW_NO_BET"]

    ),

    stream_class=DataStream,

    context={

        "local_dir": ai.market_recorder_path,

        "force_update": False,

        "remove_file": True,

        "remove_gz_file": False,

    },

)



framework.add_strategy(strategy)

framework.run()```

The strange thing is, for horse racing, it creates a .gz file, but for football it just leaves the file unzipped (it records it correctly, just leaves it as the market name in the folder), why would this be?



Even more weirdly, it appears to correctly create the .gz files for the first x markets after startup, then stops...again just for football, which makes zero sense to me!

---

## 2022-09-20 08:41:13 - issues channel

**Mo**

[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Exceptions](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Exceptions)



&gt; -32602	

&gt; 

&gt; Problem parsing the parameters, or a mandatory parameter was not found

---

## 2022-09-20 02:22:51 - general channel

**Tom**

```market_types_filter = [betfairlightweight.filters.market_filter(event_ids=[event_ids]) for event_ids in aus_thoroughbred_events_today['Event ID']]

market_types = [trading.betting.list_market_types(filter=market_types_filter) for market_types_filter in market_types_filter]

aus_thoroughbred_events_today['Market Types'] = market_types```

I've got another one there - a lot of this code is just copied from the intro tutorial - I am going to run other peoples codes (with some adjustments) that perform similar functions to what I eventually need to build to just get things working and getting used to stepping outside of that structured learning environment I have been in without going all the way to the deep end.



I have a DataFrame called aus_thoroughbred_events_today, and I wanted to add market_types to that DataFrame (but not market_types objects, the actual information of which market types are available) I've only managed to attach the objects to the aus_thoroughbred_events_today DataFrame.



Besides this, I need to test whether the market-types I am calling match up with the existing sequence of events (that they actually represent the event they are supposed to) - and I will do the same thing with market_catalogues (I think the actual code should be similar enough).



I think that a lot of this is learning how to think about the problem rather than solving the specific problem and I'll be in learning phase for some time, but I am planning on doing 4+ hours a day on this 5 days a week and hope to have a very basic first iteration of a functional bot by 2023 - happy to take any advice on any of this process!

---

## 2022-09-19 11:02:03 - general channel

**Peter**

However, the code could be dangerous depending on the context in which it's executed.



If it's being used as part of a Flumine strategy you should be OK as IIRK Flumine will ensure that you have an available_to_back attribute on your runner_book.ex object.



But as your code refers to "runner_books", rather than just "runners", this suggests to me that you might be using Betfairlightweight, which doesn't offer the same safety, so your runner_book.ex object could be None. In which case your code would fall over with a missing attribute error.



So for safety, you might want to make that condition:

 `if runner_book.ex and runner_book.ex.available_to_back`

---

## 2022-09-18 20:21:10 - random channel

**Peter**

Same response. If your strategy requires you to access data from multiple markets on the same event, they all have to be accessed by the same instance of Flumine, i.e. the same market connection. So if the number of markets (or the processing time) requires splitting them, country codes would be a better splitter than market type.

---

## 2022-09-18 10:36:26 - random channel

**Peter**

Bringing this back to basic principles, workers are executed on a schedule / frequency that you determine and (normally) in a different thread hopefully on a different processor so have minimal impact on your strategy's processing time. Whereas middleware will be triggered with each market update and will delay / extend your strategy's processing.



So which is appropriate is going to depend on the CPU resources needed for your processing and the criticality of having it done for every market update, and oftentimes there won't be a clear answer.



To put this into context with your examples, for a) if your processing is quick and needs updating every time the prices move, you probably want middleware (though you may also want to cache the prices and check that the update has moved the ones you're interested in before executing the bulk of your processing). For b) if you're ingesting and processing a lot of data from an API and/or dealing with its latency and/or are not allowed to make up to 20 calls to it per second, then a worker is likely to be a better solution.

---

## 2022-09-17 20:52:03 - random channel

**Newbie99**

Sorry to dwell on this, but looking at: [https://betcode-org.github.io/flumine/markets/#middleware](https://betcode-org.github.io/flumine/markets/#middleware)



I tried the following:



```from flumine.markets.middleware import Middleware



class FootballMiddleware(Middleware):

    def __call__(self, market) -&gt; None:

        if market.event_type_id in ['1', 1] and market.market_catalogue is not None \

            and market.market_book is not None and market.seconds_to_start &lt;= 7200 \

            and market.market_book.status not in ['CLOSED', 'SUSPENDED'] \

            and market.market_type not in ['HALF_TIME_SCORE']:

            update_market(market)```

Adding to the framework as follows:



```framework.add_logging_control(FootballMiddleware())```

But I get the following:



```concurrent.futures.process._RemoteTraceback: 

"""

Traceback (most recent call last):

  File "D:\Python38\lib\concurrent\futures\process.py", line 239, in _process_worker

    r = call_item.fn(*call_item.args, **call_item.kwargs)

  File "D:\Python37\webpages\backtesting.py", line 170, in startup

    framework.add_logging_control(FootballMiddleware())

  File "D:\Python38\lib\site-packages\flumine\baseflumine.py", line 124, in add_logging_control

    [http://logger.info|logger.info](http://logger.info|logger.info)("Adding logging control {0}".format(logging_control.NAME))

AttributeError: 'FootballMiddleware' object has no attribute 'NAME'

"""



The above exception was the direct cause of the following exception:



Traceback (most recent call last):

  File "D:/Python37/webpages/backtesting.py", line 445, in &lt;module&gt;

    output_list = start_backtest_a(chunked_markets, CPUs, snapshot, strategy_names, event_list)

  File "D:/Python37/webpages/backtesting.py", line 365, in start_backtest_a

    mini_output_list = job.result()  # wait for result

  File "D:\Python38\lib\concurrent\futures\_base.py", line 432, in result

    return self.__get_result()

  File "D:\Python38\lib\concurrent\futures\_base.py", line 388, in __get_result

    raise self._exception

AttributeError: 'FootballMiddleware' object has no attribute 'NAME'```

I assumed it would be a simple change:



```class FootballMiddleware(Middleware):

    def __call__(self, market) -&gt; None:

        self.NAME = 'Football_Logging_Control'

        if market.event_type_id in ['1', 1] and market.market_catalogue is not None \

            and market.market_book is not None and market.seconds_to_start &lt;= 7200 \

            and market.market_book.status not in ['CLOSED', 'SUSPENDED'] \

            and market.market_type not in ['HALF_TIME_SCORE']:

            update_market(market)```



But the error still persists, so I'm clearly mis-understanding this. Do you have any suggestions by chance?

---

## 2022-09-17 16:10:47 - random channel

**Newbie99**

This is following on from the earlier conversation about backtesting with multi-proc (but isn't specific to chunking and event_processing, or at least I don't think it is...that said who knows).



So, I pass a list of markets to this function called startup, which runs as expected, in this instance it calls a worker, which doesn't run as expected.



Here is the startup function (this appears to run correctly, i.e. I can see the markets are loaded, market catalogues added and profit / orders always show as 0, but at least that confirms the script is working):



```def startup(markets, snapshot={}, strategy_names=strategy_names, event_list=False):

    logger = logging.getLogger()



    custom_format = "%(asctime) %(levelname) %(message)"

    log_handler = logging.StreamHandler()

    formatter = jsonlogger.JsonFormatter(custom_format)

    formatter.converter = time.gmtime

    log_handler.setFormatter(formatter)

    logger.addHandler(log_handler)

    logger.setLevel(logging.CRITICAL)  # Set to logging.CRITICAL to speed up simulation



    start_time = get_utc_time()



    settings = [setting for setting in rc if setting['on'] is True and setting['strategy_name'] in strategy_names]



    client = clients.SimulatedClient(simulated_full_match=False)



    framework = FlumineSimulation(client=client)



    print('Start of chunk', '-' * 150)

    for market in markets:

        print(check_event_id(market))



    with mock_patch("builtins.open", smart_open.open):

        for s in settings:

            max_selection_exposure = s['max_selection_exposure'] if true_or_false(s['max_selection_exposure']) != False else None

            if s['strategy_type'] == 'simple':



                ### ---- Remember to change listener kwargs , "listener_kwargs": {"seconds_to_start": 7200, "inplay":False}



                strategy = betting_strategy(start_time=start_time, settings=s, paper=client.paper_trade,

                                            market_filter={"markets": markets, "listener_kwargs": {"seconds_to_start": 7200, "inplay":False}, "event_processing": True},

                market_data_filter=streaming_market_data_filter(

                fields=[

                    "EX_ALL_OFFERS",

                    "EX_TRADED",

                    "EX_TRADED_VOL",

                    "EX_LTP",

                    "EX_MARKET_DEF",

                    "SP_TRADED",

                    "SP_PROJECTED",

                ]

                ),

                streaming_timeout=2,

                max_selection_exposure=max_selection_exposure,

                max_order_exposure=s['max_order_exposure'],

                conflate_ms=s['conflate'],

                name=s['strategy_name'],



                )



                framework.add_strategy(strategy)





        worker_settings_list = [

            {'function_name': 'get_in_play_football_data', 'function': get_in_play_football_data, 'func_kwargs': None ,'interval': 15, 'start_delay': 0}

        ]



        for f in get_worker_functions(settings):

            function_setting = [ws for ws in worker_settings_list if str(ws['function_name']) == f['function_name']]

            if len(function_setting) &gt; 0:

                function_setting = function_setting[0]



                framework.add_worker((BackgroundWorker(

                            framework,

                            function_setting['function'],

                            func_kwargs=function_setting['func_kwargs'],

                            interval=function_setting['interval'],

                            start_delay=function_setting['start_delay']

                        )))



        ''' Always add Risk Calc worker '''

        framework.add_worker(

            BackgroundWorker(

                framework,

                calc_risk,

                func_kwargs=None,

                interval=0.5,

                start_delay=5

            ))



        ''' Add in Middleware to get Market Catalogue '''

        framework.add_market_middleware(MarketCatalogueMiddleware())



        framework.run()



    for market in framework.markets:

        print("Order Count: {0}".format(len([o for o in market.blotter])))

        print("Profit: {0:.2f}".format(sum([o.profit for o in market.blotter])))



    if strategy_names[0] == 'market_data_extract':

        return write_market_context_to_json(framework)

    else:

        return write_pl_to_json(framework,group_by_market=False)```

Now, when I noticed the worker wasn't producing anything I did a quick test as follows:



```def get_in_play_football_data(context: dict, flumine) -&gt; None:

    print('ABCD')

    s = [m for m in flumine.markets]

    print(s)```

On screen I see the following:



```1.202093022 added

ABCD

[]

Order Count: 0

Profit: 0.00```

So the worker is running as we can see the printout, but how can s be an empty list?

---

## 2022-09-17 13:44:57 - random channel

**Newbie99**

I tried an alternative approach too, but this doesn't work (i.e. it runs, but the same issue arises in that it seems to split up the markets, even though they are grouped), so I think I'm using this incorrectly:



```def start_backtest_b(chunked_markets, max_workers, snapshot, strategy_names, event_list):



    with ProcessPoolExecutor(max_workers=max_workers) as executor:

        futures = [executor.submit(startup, chunk, snapshot, strategy_names, event_list) for chunk in chunked_markets]```

---

## 2022-09-17 13:40:23 - random channel

**Newbie99**

Just to come back to this again, I'm having trouble passing parameters, my data is as follows (should it be a list of tuples instead or does it not matter), which are all grouped by event_id):



```[['Y:/betcode/unzipped_files\\1.201875723', 'Y:/betcode/unzipped_files\\1.202058901', 'Y:/betcode/unzipped_files\\1.202058903', 'Y:/betcode/unzipped_files\\1.202058896', 'Y:/betcode/unzipped_files\\1.202058942', 'Y:/betcode/unzipped_files\\1.202020603', 'Y:/betcode/unzipped_files\\1.202020594', 'Y:/betcode/unzipped_files\\1.202020596', 'Y:/betcode/unzipped_files\\1.202020589'], ['Y:/betcode/unzipped_files\\1.202347516', 'Y:/betcode/unzipped_files\\1.202108260', 'Y:/betcode/unzipped_files\\1.202108265', 'Y:/betcode/unzipped_files\\1.202108267', 'Y:/betcode/unzipped_files\\1.202108306', 'Y:/betcode/unzipped_files\\1.202228381', 'Y:/betcode/unzipped_files\\1.202228342', 'Y:/betcode/unzipped_files\\1.202228335'], ['Y:/betcode/unzipped_files\\1.202261399', 'Y:/betcode/unzipped_files\\1.202261353', 'Y:/betcode/unzipped_files\\1.202261358', 'Y:/betcode/unzipped_files\\1.202261360', 'Y:/betcode/unzipped_files\\1.202277070', 'Y:/betcode/unzipped_files\\1.202277031', 'Y:/betcode/unzipped_files\\1.202277029', 'Y:/betcode/unzipped_files\\1.202277024'], ['Y:/betcode/unzipped_files\\1.202093071', 'Y:/betcode/unzipped_files\\1.202084753', 'Y:/betcode/unzipped_files\\1.202084748', 'Y:/betcode/unzipped_files\\1.202084755', 'Y:/betcode/unzipped_files\\1.202084762', 'Y:/betcode/unzipped_files\\1.202346073', 'Y:/betcode/unzipped_files\\1.202346071']]```

My function is as follows:



```def start_backtest_a(chunked_markets, max_workers, snapshot, strategy_names, event_list):



    with ProcessPoolExecutor(max_workers=max_workers) as executor:

        futures = executor.map(startup, chunked_markets, snapshot, strategy_names, event_list)```

Where startup is essentially this (from Liam's example in the docs):



```def run_process(markets):

    client = clients.SimulatedClient()

    framework = FlumineSimulation(client=client)

    strategy = LowestLayer(

        market_filter={"markets": markets},

        context={"stake": 2},

    )

    with mock_patch("builtins.open", smart_open.open):

        framework.add_strategy(strategy)

        framework.run()```

But it needs some parameters, which are causing the issue.



snapshot is a static dict (e.g. {'a': 1})

strategy_names is a list of strategy names (e.g. ['strat_a', 'strat_b'])

event_list is either a list of historic data (e.g. scores data to map against a betfair event) or a bool, so in this instance False as I'm not passing any historic data.



However it appears to be expecting an iterable for each parameter.



```Traceback (most recent call last):

  File "D:/Python37/webpages/backtesting.py", line 484, in &lt;module&gt;

    output_list = start_backtest_a(chunked_markets, CPUs, snapshot, strategy_names, event_list)

  File "D:/Python37/webpages/backtesting.py", line 346, in start_backtest_a

    futures = executor.map(startup, chunked_markets, snapshot, strategy_names, event_list)

  File "D:\Python38\lib\concurrent\futures\process.py", line 674, in map

    results = super().map(partial(_process_chunk, fn),

  File "D:\Python38\lib\concurrent\futures\_base.py", line 600, in map

    fs = [self.submit(fn, *args) for args in zip(*iterables)]

  File "D:\Python38\lib\concurrent\futures\_base.py", line 600, in &lt;listcomp&gt;

    fs = [self.submit(fn, *args) for args in zip(*iterables)]

  File "D:\Python38\lib\concurrent\futures\process.py", line 182, in _get_chunks

    it = zip(*iterables)

TypeError: 'bool' object is not iterable```

---

## 2022-09-16 15:29:27 - general channel

**EJono**

Is there a problem with calling "trading.keep_alive()" too frequently? Would doing so too many times in a given minute cause betfair to suspend or restrict an account?

---

## 2022-09-15 19:49:11 - general channel

**Peter**

Putting those snippets together works, i.e. this works:

```start_time = "17 September 2022 11:00"

game_time = datetime.strptime(start_time, "%d %B %Y %H:%M")

game_filter = betfairlightweight.filters.market_filter(

    event_type_ids=[1],

    market_start_time={

        'from': (game_time - timedelta(hours=2)).strftime("%Y-%m-%dT%TZ"),

        'to': (game_time + timedelta(hours=2)).strftime("%Y-%m-%dT%TZ")

    },

)

games = trading.betting.list_events(

    filter=game_filter

)```

returning (currently) a list of 57 EventResult objects.



Looking at the specific error you're getting though, it's telling you that your request is missing a mandatory parameter. Since listEvents only has one mandatory parameter, the filter. This means that you're either not actually attaching it, or that the market filter method is returning None, so it's still feeling like we're not quite seeing the actual code that you're using.

---

## 2022-09-15 09:56:11 - issues channel

**Aaron Smith**

mh, difficult. Those two are the only thing that changed and beside that its all strategy/figuring out which orders i want to place. Given its my most profitable strat i d rather not put that here :smile:

---

## 2022-09-15 09:45:00 - issues channel

**Aaron Smith**

which part of the code? its a strategy and then put into flumine simulation

---

## 2022-09-15 09:42:00 - issues channel

**Aaron Smith**

Hey ppl,

I am currently implementing the transaction class for placing orders (instead of market.place_order).

After the change, during simulation i get a lot of these errors:

`"Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failed: reset_elapsed_seconds (-0.188) &lt; reset_seconds (0.0)"`

Anyone have a clue on how that negative number comes to be?

---

## 2022-09-14 09:41:14 - random channel

**liam**

pandas is crap for trading live

---

## 2022-09-14 09:26:07 - random channel

**Jorge**

Hi, I'm facing this problem: I need to load 600 files in live-trading, each of them contains a row of a DF, and concat them into a Pandas DataFrame for analysis. Anyone knows what would be a fast file format to do this? I've tried with .parquet which takes 0.03 secs/file but I need something faster...

---

## 2022-09-13 07:56:59 - random channel

**Unknown**

You got me thinking so I did some tests yesterday on an instance I have running with 6 strategies that I know are slow at processing, here is the following at order creation:



```latency = (trade.date_time_created - market_book._datetime_created).total_seconds()```

Very strategy dependant but has the potential for the order to make a big difference in pnl / matching

---

## 2022-09-12 21:16:02 - general channel

**liam**

The processing cost of an under25 market is so small you would struggle to register it. If you want the market available either ignore it or just create a dummy strategy that does nothing but subscribes 

---

## 2022-09-12 08:41:12 - betfair-news channel

**Mo**

Internally you correctly have 2 teams, Guadalajara (MEX) and Guadalajara (ESP) with internal IDs X and Y. Both of these have selection ID 230909 in their lists of Betfair selection IDs (maybe Betfair uses others for these teams, I don't know)



As far as modelling is concerned, I don't think this needs to involve Betfair selection IDs at all



As far as reporting - yes you will need to account for this situation in your code if you want to do breakdowns by your internal team IDs. For example, do the breakdown by team and league



By all means this can be reported to Betfair but:



1. I wouldn't hold out hope that anything will be actioned

2. It doesn't change anything retrospectively

So IMHO the correct thing to do is still to be robust to Betfair's data issues

---

## 2022-09-11 23:22:24 - random channel

**Jonjonjon**

I am running almost 200 strategy instances under a single Flumine instance on a single script.



I'm concerned that it might cause performance issues, due to the multiple calls to `check_market_book`

What is the recommended way to check whether or not I am likely to be experiencing latency issues?



Looking though the logs, I have this from the trade log:



`"date_time_created": "2022-09-11 22:03:05.967328", "publish_time": "2022-09-11 22:03:05.914000"`



I believe "publish_time" is the time that comes from the streaming market book update, and "date_time_created" is the time, which is around 53 ms. But assumes that my clock is aligned with the Betfair clock.



How would other users measure this?

---

## 2022-09-09 10:31:34 - issues channel

**rob smith**

Hi guys, I am trying to get Asian Handicap lines for specific events. I'm in the midst of newborn sleep deprivation but swear this filter was working a couple of weeks ago. Now it doesn't return a catalogue. Any help would be appreciated. Thanks

```# Get AH markets

market_catalogue_filter = betfairlightweight.filters.market_filter(event_ids=[31728932], market_type_codes=['ASIAN_HANDICAP_DOUBLE_LINE'])

print(market_catalogue_filter)



market_catalogues = trading.betting.list_market_catalogue(

    filter=market_catalogue_filter,

    max_results='100',

    sort='FIRST_TO_START',

    market_projection=["RUNNER_DESCRIPTION"]

)

print(market_catalogues)```



---

## 2022-09-08 16:43:34 - issues channel

**Aaron Smith**

checking through my latency warnings i see that 98% of them are this version:

```"WARNING", "message": "High latency between current time and OrderPackage creation time, it is likely that the thread pool is currently exhausted", "trading_function": "cancel", "session": "&lt;requests.sessions.Session object at 0x7f02236a0b20&gt;", "latency": 0.102, "order_package": {"id": "3f6818d6-2f8b-11ed-969e-257a4444e788", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f028fd7ba30&gt;", "market_id": "1.203111349", "orders": ["138819438430078669"], "order_count": 1, "package_type": "Cancel", "customer_strategy_ref": "prod_GH", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}, "thread_pool": {"num_threads": 25, "work_queue_size": 2}```

I get these on cancel and place. `work_queue_size` can be higher (last one it was at 19, this time 2 was highest for this chunk of latency errors (they generally come in chunks). What i m surprised by is `"num_threads": 25` , i can not really see why i would have 25 threads running?

---

## 2022-09-07 15:28:05 - general channel

**foxwood**

[@U4H19D1D2](@U4H19D1D2) my base strategy has params like these which are checked for each packet in check_market_book() so can dip in quickly (eg) 5 hours before, place any bets and then ignore all data until market complete. But, since simulation has to check matching the only chance to skip to end would be once all bets were matched - all a bit too complex to bother with I now think.

```startAtSeconds = 18000    # seconds before official start to begin strategy

stopAtSeconds = 17995     # when to stop strategy ie start time - this : set -ve to carry on beyond official start```



---

## 2022-09-07 13:45:19 - general channel

**foxwood**

I'm meaning that the strategy PL for the market is not known until you get to the final packet and process_closed_market is called - then the runner book has a status of winner/loser. So if you only put bets in say the morning market it's a lot of data to chunder through to get the final outcome. Having made me think about that though, the matching has got to be simulated and MOC catered for etc so I'm not sure the suggestion had any merit now :joy:

---

## 2022-09-06 12:18:00 - general channel

**Jimmy**

will try - question - given this is in the strategy, does it matter for live?

---

## 2022-09-06 11:41:09 - general channel

**Jimmy**

Hello! sorry in advance for what is I suspect a daft question. I’m trying to backtest a football strategy which has the criteria of waiting for a market to reform (60 seconds or X) after a suspension. However, trapping that time in a backtest is proving tricky - it never seems to go above a 1s or so. What am I missing?

---

## 2022-09-06 08:32:00 - general channel

**liam**

AUS automation team have just released these, should be helpful for those that are just starting out and want to learn how to use flumine, I would have killed to have something like this when I first started (note that I haven't reviewed)



[https://betfair-datascientists.github.io/api/How_to_Automate_1/|How to Automate I: Understanding Flumine](https://betfair-datascientists.github.io/api/How_to_Automate_1/|How to Automate I: Understanding Flumine)



[https://betfair-datascientists.github.io/api/How_to_Automate_2/|How to Automate II: Backing or laying the 1st/2nd/.../nth favourite shot](https://betfair-datascientists.github.io/api/How_to_Automate_2/|How to Automate II: Backing or laying the 1st/2nd/.../nth favourite shot)



[https://betfair-datascientists.github.io/api/How_to_Automate_3/|How to Automate III: Betfair Data Scientists Models](https://betfair-datascientists.github.io/api/How_to_Automate_3/|How to Automate III: Betfair Data Scientists Models)



[https://betfair-datascientists.github.io/api/How_to_Automate_4/|How to Automate IV: Automate your own Model](https://betfair-datascientists.github.io/api/How_to_Automate_4/|How to Automate IV: Automate your own Model)



[https://betfair-datascientists.github.io/api/How_to_Automate_5/|How to Automate 5](https://betfair-datascientists.github.io/api/How_to_Automate_5/|How to Automate 5)

---

## 2022-09-05 09:18:34 - issues channel

**sartux**

from the documentation on betfair you can retrieve up to 90 days previous, instead by launching

```account_statement = trading.account.get_account_statement(lightweight=True)```



I get at most up to 2 previous days, how come?

---

## 2022-09-04 07:54:03 - issues channel

**sartux**

Good morning guys,

to make the account report I have always used the "get_account_statement" method and it has always worked.



```

dateStart = datetime.datetime(2022, 8,30,0,0)

acct_statement_date_filter = betfairlightweight.filters.time_range(from_=dateStart)



account_statement = trading.account.get_account_statement(item_date_range=acct_statement_date_filter)```

Since this morning instead I get this error



```TypeError: __init__() missing 1 required positional argument: 'fullMarketName'



   raise InvalidResponse(response=result)

betfairlightweight.exceptions.InvalidResponse: Invalid response received: {'accountStatement': [{'refId': '51365225816', 'itemD... ```

the script was working for 7 days without any problem

---

## 2022-09-03 10:05:22 - strategies channel

**Mo**

Wasn't referring to the strategy per se. I mean you're asking for an API that:



1. Is hooked into tennis feeds

2. Can alert on a very specific trigger

3. Is hooked into Discord

Maybe I'm just ignorant but would be surprised if there's something off the shelf that does all of that

---

## 2022-09-03 10:03:36 - strategies channel

**MA**

Read about in other forums so not a “new secretive” strategy unveiled just curious if anyone was kind to share the code (Discord alert can be ignored)

---

## 2022-09-01 13:15:07 - issues channel

**AP**

where can I add it in the strategy? Also, the problem is that the None shouldn't be present, as it is raised because the SUSPENDED status of the market was detected, or am I wrong?

---

## 2022-09-01 11:34:28 - issues channel

**AP**

Hi! I created an example strategy just to test some features of flumine but I'm struggling with a problem

```class ExampleStrategy(BaseStrategy):

    def start(self) -&gt; None:

        print("starting strategy 'ExampleStrategy'")



    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

        return (market_book.status == "OPEN") and (not market_book.inplay)



    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:

        for i in range(len(market_book.runners)):

            runner = market_book.runners[i]



            LPT = runner.last_price_traded



            if runner.status == "ACTIVE" and (LPT is not None):

                if LPT &lt; 2:

                    trade = Trade(

                        market_id=market_book.market_id,

                        selection_id=runner.selection_id,

                        handicap=runner.handicap,

                        strategy=self

                    )

                    order = trade.create_order(

                        side="BACK",

                        order_type=LimitOrder(price=LPT, size=2.00)

                    )



                    res = market.place_order(order)



                    if res:

                        print("Order placed: ", market_book.market_id, runner.selection_id, LPT)



    def process_orders(self, market: Market, orders: list) -&gt; None:

        if not((market.market_book.status == "OPEN") and (not market.market_book.inplay)):

            return



        for order in orders:

            if order.status == OrderStatus.EXECUTABLE:

                if order.size_remaining == 2.00:

                    market.cancel_order(order, 0.02)  # reduce size to 1.98



                if order.order_type.persistence_type == "LAPSE":

                    market.update_order(order, "PERSIST")



                if order.size_remaining &gt; 0:

                    market.replace_order(order, new_price=1.02)```

I had run this strategy on a specific market, but then the following error was raised:

```Traceback (most recent call last):

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/simulation/simulation.py", line 97, in run

    self._process_market_books(

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/simulation/simulation.py", line 117, in _process_market_books

    self._check_pending_packages(market_id)

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/simulation/simulation.py", line 189, in _check_pending_packages

    order_package.client.execution.handler(order_package)

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/execution/simulatedexecution.py", line 31, in handler

    func(order_package, http_session=None)

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/execution/simulatedexecution.py", line 142, in execute_replace

    place_instruction_report = replacement_order.simulated.place(

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/simulation/simulatedorder.py", line 70, in place

    return self._create_place_response(

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/simulation/simulatedorder.py", line 181, in _create_place_response

    if self.size_remaining == 0:

  File "/home/alessandro/venv/lib/python3.8/site-packages/flumine/simulation/simulatedorder.py", line 395, in size_remaining

    size

TypeError: unsupported operand type(s) for -: 'NoneType' and 'int'```

It seems that the execution is broken while the framework is trying to replace an order: first it tries to cancel the order, but then it discovers that the market.status is not OPEN and raise the error with

```return SimulatedCancelResponse(

                status="FAILURE",

                error_code="ERROR_IN_ORDER",

            )```

in flumine/simulation/simulatedorder.py, line 194. I don't understand why it is happening, because the check_market_book functions should already have checked that the market is OPEN. Also, in this specific case, the market is SUSPENDED before the race, Idk if it is an useful information. Can somebody help me with it?

---

## 2022-08-31 12:56:10 - strategies channel

**Ruben**

does it make sense to try football fundamental modelling for pre-off betting if I can't spend thousands of dollars on data feeds?

---

## 2022-08-30 21:17:18 - issues channel

**Evaldas**

[https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L154](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py#L154)

Is this some new way to format string in Python? :)

---

## 2022-08-30 09:48:42 - general channel

**Newbie99**

I second that, having played around with it this week, its great as it allows you to highlight where its execution that's letting you down, rather than the underlying strategy logic.

---

## 2022-08-30 09:43:33 - general channel

**Unknown**

Thought Id check a current strategy (although stakes a bit higher)..Shows the importance of matching rates.

I never really concentrated on matching rates much before the Slack group, but it has my attention now (red line profit) :grinning:

Thanks for pointing this feature out by the way, got me thinking...

---

## 2022-08-27 21:12:12 - general channel

**Johnny Boston**

I own a couple of horses lol and if I lay them on betfair with my bots I will get in trouble. So I  filter them out at the strategy level, but would be good to just not have them at the strategy level. In case I forget to add the filter on a new strategy one day.

---

## 2022-08-27 21:10:01 - general channel

**liam**

Don’t ask for it from betfair? No easier way than filtering at the strategy tbh, what’s the need?

---

## 2022-08-27 13:34:10 - random channel

**Newbie99**

When backtesting, I'm getting some unexpected behaviour using market.event.get.



Just using a simple worker as follows (purely to see whats coming through for now, obviously this doesn't actually do anything as such):



```def each_way_and_place(context: dict, flumine) -&gt; None:

    for market in [m for m in flumine.markets if m.event_type_id == '7' and m.market_catalogue is not None and m.market_book.status not in ['CLOSED', 'SUSPENDED']]:

        check_market_type(market)



def check_market_type(market):



    if market.market_type == 'WIN':

        place_market = market.event.get("PLACE")

        if place_market is not None:

            print({'main_market_id': market.market_id,

                   'main_market_type':market.market_type,

                   'main_market_status': market.market_book.status,

                   'get_market_id': place_market[0].market_id,

                   'get_market_type': place_market[0].market_type,

                   'get_market_status': place_market[0].market_book.status})

        else:

            print({'main_market_id': market.market_id,

                   'main_market_type':market.market_type,

                   'main_market_status': market.market_book.status})

    elif market.market_type in ['PLACE', 'OTHER_PLACE']:

        win_market = market.event.get("WIN")

        print({'main_market_id': market.market_id,

            'main_market_type':market.market_type,

               'main_market_status': market.market_book.status,

               'get_market_id': win_market[0].market_id,

               'get_market_type': win_market[0].market_type,

               'get_market_status': win_market[0].market_book.status})```

I just get the following:



```1.200622960 added

1.200652220 added

1.200652755 added

1.200622608 added

1.200626498 added

1.200622877 added

1.200652046 added

1.200652131 added

1.200652756 added

1.200652047 added

1.200622609 added

{'main_market_id': '1.200652756', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652755', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652047', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652046', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652756', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652755', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200622609', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622608', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

1.200652133 added

{'main_market_id': '1.200652047', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652046', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652756', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652755', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200622609', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622608', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652047', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652046', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

1.200652135 added

1.200622880 added

1.200622965 added

1.200652050 added

{'main_market_id': '1.200652756', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652755', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200622609', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622608', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

1.200626500 added

1.200652225 added

{'main_market_id': '1.200652756', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652755', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200626500', 'main_market_type': 'WIN', 'main_market_status': 'OPEN'}

{'main_market_id': '1.200622609', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622608', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652225', 'main_market_type': 'WIN', 'main_market_status': 'OPEN'}

1.200626501 added

1.200622882 added

1.200652136 added

1.200652226 added

1.200652052 added

1.200622883 added

1.200622966 added

{'main_market_id': '1.200652756', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652755', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200626501', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200626500', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}{'main_market_id': '1.200622609', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622608', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}



{'main_market_id': '1.200652226', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652225', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200622883', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622882', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652052', 'main_market_type': 'WIN', 'main_market_status': 'OPEN'}

{'main_market_id': '1.200652136', 'main_market_type': 'WIN', 'main_market_status': 'OPEN'}

1.200652137 added

1.200652758 added

1.200652053 added

1.200622967 added

{'main_market_id': '1.200622609', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622608', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}{'main_market_id': '1.200626501', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200626500', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}



{'main_market_id': '1.200652226', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652225', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200622883', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622882', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652053', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652052', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652137', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652136', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200622967', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622966', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200626501', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200626500', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}{'main_market_id': '1.200622609', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622608', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}



{'main_market_id': '1.200652226', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652225', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200622883', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200622882', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652053', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652052', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}

{'main_market_id': '1.200652137', 'main_market_type': 'PLACE', 'main_market_status': 'OPEN', 'get_market_id': '1.200652136', 'get_market_type': 'WIN', 'get_market_status': 'CLOSED'}```

Which seems very odd (i.e. it always shows no PLACE market when checking from the WIN market and when checking from the PLACE market, the WIN market is always closed.



Interestingly, when paper trading this works as expected, i.e. the markets are all open etc.



I'm wondering therefore, has anyone else had issues using this functionality when backtesting (all self recorded files via Flumine, randomly selected dates in June, July and August, the above markets are all GB &amp; IE on 1st or 2nd of July)?

---

## 2022-08-26 11:21:01 - issues channel

**liam**

use strategy A market filter and add logic to `check_market_book` for strategy B, you can see in the logs if a new stream is created or not

---

## 2022-08-26 11:18:28 - issues channel

**Newbie99**

Actually this thread made me think, can I just check my understanding is correct?



Lets say I have 2 Horse Racing strategies strategy A &amp; Strategy B.



All streaming filters are identical, except as follows:



Strategy A:

countries ['GB', 'IE', 'AU', 'US']

market_types ['WIN', 'PLACE']



Strategy B:

countries ['GB', 'IE']

market_types ['PLACE']



Am I correct in saying, that although the markets are a subset of strategy A for strategy B this would create a new connection as the streaming filters are not a perfect match (I presume the logic looks at whether the exact filter is used again)?



So from a connection efficiency perspective, using the above example, the best course of action would be to use the streaming filters as per Strategy A and then filter within the strategy to only look at the relevant markets?

---

## 2022-08-26 09:18:20 - issues channel

**Johnny Boston**

Yeah, so it looks like I have open connections then. I found latency issues when I had multiple strategies (more than 5) in the same container.



I then split them up and that went away. The latency was mainly due to custom streams that were getting model odds on short intervals.

---

## 2022-08-26 09:14:50 - general channel

**liam**

Its a bit complicated, a strategy is subscribed to streams, you can see the ids with `Strategy.stream_ids` or the streams themselves with `Strategy.streams`



We add the `stream_id` to the `MarketBook` which you can see with `MarketBook.streaming_unique_id` however there isn't anything in the Market object telling you this as it can be shared with multiple streams. This relates to a current bug where two streams could be updating a single Market due to a crossover in the filters

---

## 2022-08-26 09:12:40 - issues channel

**Johnny Boston**

I have containers running on ECS. When I deploy a new strategy, I pull down the container and start a new one. That's what I call a deployment.

---

## 2022-08-25 23:44:17 - issues channel

**Johnny Boston**

Does Flumine instantiate a new connection per strategy or does it identify if multiple strategies have similar filters and only use one connection per Flumine instance?



I am reaching my max active connections even though I have only 4 instances of Flumine running...

---

## 2022-08-25 17:29:39 - general channel

**Aaron Smith**

what is the best way to get all markets a strategy has subscribed to in flumine? context: when starting flumine, i want the strategy to access the market.context for all its markets.

---

## 2022-08-24 21:24:31 - strategies channel

**Newbie99**

Its not the same thing though is it...no one on here for example (I assume) will stop when they hit a random p&amp;l figure, but bankroll management is a legitimate way to stay in business!



To take an extreme example, you could build the perfect model that always pinpoints maximum value and executes perfectly, but there's still no guarantee the runner will win, hence you need to live to fight another day.



The difference is that for the bigger players on here maximum market liquidity is reached well before any risk tolerance becomes a consideration.

---

## 2022-08-24 21:02:53 - strategies channel

**birchy**

I agree that limiting exposure is in the realms of "stop for the day at £N" but, as [@UFTBRB3F1](@UFTBRB3F1) has said, having a £2k exposure on one runner can be a bit daunting although it might also indicate a shit strategy. :joy:

---

## 2022-08-24 18:17:47 - strategies channel

**Newbie99**

My approach is probably a bit clunky, but I re-create the Betfair 'if-win' from the GUI, I store this figure in the market.context in a dict unique to each strategy. I can therefore share exposure between strategies (or not) as appropriate.



I set the max_selection_exposure to a really big number I don't expect to hit and then manage exposure separately by performing various validation checks (e.g. current exposure of runner and current worst exposure, so if I am at an exposure limit for runner x and backing runner y would add further exposure to runner x I don't place the order, or rather I have a setting which I can toggle between True or False, depending on whether I want to allow that behaviour on a strategy).

---

## 2022-08-24 11:43:01 - general channel

**Unknown**

:beach_with_umbrella::beach_with_umbrella::beach_with_umbrella::beach_with_umbrella::beach_with_umbrella::beach_with_umbrella:  [!here](!here) Hi guys, to celebrate our Matched Betting Pro soft launch, we're giving away these lovely pink beach balls!!



We want to share our balls with the BetCode community, so just send me a DM with your address and we'll send some balls your way!! :incoming_envelope:



Also, if you want to test the Matched Betting platform yourself to see what the fuss is about, make sure to join our waiting list here --&gt; [https://www.betconnect.com/matchedbettingpro](https://www.betconnect.com/matchedbettingpro)



Drop us any questions and comments you might have about Matched Betting Pro here in this chat, we'll be happy to answer all of them! :rocket:

---

## 2022-08-24 00:32:22 - strategies channel

**Johnny Boston**

don't you set exposure at the strategy level through `max_selection_exposure` ?

---

## 2022-08-23 14:01:21 - strategies channel

**birchy**

To the Flumine users: how do you manage exposure at strategy level? I'm aware of the functions in the `blotter` but am likely not using them efficiently. In particular, `blotter.selection_exposure` is useful but accumulates the total exposure per side, which is great if you're both backing and laying a selection (#nevergreen) but not so good if you have a pure laying strategy that lays multiple runners as it hits my hard coded exposure limit and then stops betting on that particular runner, despite having layed other runners that potentially reduce the exposure on that runner. So I guess my questions are:

1. Do you "balance" exposures across multiple runners?

2. Is there a way to reset the exposures?

3. Should we be using a dynamic exposure limit, i.e. increase it when other runners have been layed, perhaps in conjunction with `blotter.market_exposure`?

4. Or should we loop through the blotter orders and self manage?

This is more of a "best practice" question than anything else...

---

## 2022-08-23 10:17:38 - random channel

**PeterLe**

Well as you know I'm still learning how to use Python. From knowing nothing, it wasn't as bad as i thought to get the recorder and a few strategies running (the latter with help from others on here and your examples).

I've now started to build out from those initial strategies and 'bolt stuff' on. Its a really good way of learning by the way, by using the simulator to test code (if anyone else is a beginner)

I've also learned Numpy; Pandas, Jupyter and a bit of C# too. I know have my recorders/strategies running on Ubuntu, which was easy to implement and virtually maintenance free....phey!

However, the more I learn about Python, the more I realise there's a lot more to learn, so this takes time and is part of the process. So in answer to your question, there is no one part as such, its a combination of everything

For me though, i just think of the whole thing as another tool/mentality/approach. It wont replace my preferred method of strategy development implementation, which i mentioned in the opening post, I see it more of a tool to enhance that.

I can see that there are some very technically competent folk on here who maybe not making a profit, I think that is because of the path you get led down and how your thought processes develop/channeled if you use this as your sole MO.

Either way, I'm not in any rush and the money is still rolling in, so just enjoying the trip!

---

## 2022-08-23 08:16:45 - random channel

**liam**

My general approach for new strategy development:



• Record raw data (s3)

• Process data to create signals etc. into csv's as and when, I use Strategy classes rather than loggingcontrols (quicker / more data available) through slimmed down flumine simulation (multiprocessing / [speed])

• Load into jupyter using pandas

• Join / process / create more signals if required

• Analyse / model / backtest theoretical pnl / lots of graphs

• Create real strategy / simulate / optimise stake / triggers for market capacity

• Go live

Start to finish is normally a few hours before I get bored :joy:

---

## 2022-08-22 18:01:06 - random channel

**PeterLe**

So a question to the pro’s please

So once you have your data (in sample and out of sample etc)..its useful to tweak existing strategies etc I’ve used this lately with some good success (even found a brand new strategy too)



Question is: What is the next step in using the recorded data, do you collect additional data via logging controls and analyse with pandas/db etc

I just wondered what steps you would take from recording the data through to going live with a new strategy (just bullet points and a few pointers would be great for someone new to this approach)

(By the way; I read an entry by [@UGV299K6H](@UGV299K6H) a week or so ago about testing a well thought out hypothesis live and seeing how it plays out. it really struck a chord with me. This tends to be my approach too. Ill still continue with this but looking at alternative approaches too)

Many thanks

---

## 2022-08-22 09:03:07 - issues channel

**mandelbot**

Sure, I'm mostly just following the examples

```import os

import math

import smart_open

from smart_open import open as so

from concurrent import futures

from unittest.mock import patch as mock_patch

from flumine import FlumineSimulation, clients, utils

from flumine.examples.lowestlayer import LowestLayer



markets = []



path = "/Volumes/BF/Befairlightweight Data/test"





for r, d, f in os.walk(path):

    for file in f:

        markets.append(os.path.join(r, file))





def run_process(markets):

    client = clients.SimulatedClient()

    framework = FlumineSimulation(client=client)

    strategy = LowestLayer(

        market_filter={"markets": markets},

        context={"stake": 2},

    )

    with mock_patch("builtins.open", smart_open.open):

        framework.add_strategy(strategy)

        framework.run()





if __name__ == "__main__":

    all_markets = [...]

    processes = os.cpu_count()

    markets_per_process = 8  # optimal



    _process_jobs = []

    with futures.ProcessPoolExecutor(max_workers=processes) as p:

        chunk = min(

            markets_per_process, math.ceil(len(all_markets) / processes)

        )

        for m in (utils.chunks(all_markets, chunk)):

            _process_jobs.append(

                p.submit(

                    run_process,

                    markets=m,

                )

            )

        for job in futures.as_completed(_process_jobs):

            job.result()  # wait for result```

---

## 2022-08-22 08:57:55 - issues channel

**mandelbot**

I'm trying to run multiprocessing on backtests for the first time (I know right?) and i keep getting the following error:



```TypeError: don't know how to handle uri Ellipsis```



```concurrent.futures.process._RemoteTraceback: 

"""

Traceback (most recent call last):

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/concurrent/futures/process.py", line 246, in _process_worker

    r = call_item.fn(*call_item.args, **call_item.kwargs)

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/flumine/strategy/testmulti.py", line 41, in run_process

    framework.add_strategy(strategy)

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/flumine/baseflumine.py", line 101, in add_strategy

    self.streams(strategy)  # create required streams

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/flumine/streams/streams.py", line 46, in __call__

    market_type = get_file_md(market, "marketType")

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/flumine/utils.py", line 66, in get_file_md

    with open(file_dir, "r") as f:

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/smart_open/smart_open_lib.py", line 224, in open

    binary = _open_binary_stream(uri, binary_mode, transport_params)

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/smart_open/smart_open_lib.py", line 396, in _open_binary_stream

    raise TypeError("don't know how to handle uri %s" % repr(uri))

TypeError: don't know how to handle uri Ellipsis

"""



The above exception was the direct cause of the following exception:



Traceback (most recent call last):

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/flumine/strategy/testmulti.py", line 63, in &lt;module&gt;

    job.result()  # wait for result

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py", line 439, in result

    return self.__get_result()

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/concurrent/futures/_base.py", line 391, in __get_result

    raise self._exception

TypeError: don't know how to handle uri Ellipsis```

Can't figure it out, anyone have any ideas?

---

## 2022-08-21 18:13:37 - strategies channel

**birchy**

I have a similar graph for a live dogs strategy that goes up steeply, then goes flat for a few weeks and then goes up again. So I'd say it _might_ be a goer but you'll need a bigger sample size (i.e. 6+ months).

Just noticed your graph covers 4 months, so I'd say that 2200 bets in that time period is nowhere near enough.

---

## 2022-08-21 16:12:36 - strategies channel

**MacrcoPolo**

Another thing to look at here from the 'are the prices I'm taking any good?' line is to check the average size of the levels you're trying to take liquidity from on back vs lay in your model. Need to be careful to to compare in the same price buckets since shown sizes vary so much with the price, but worth looking at

---

## 2022-08-21 09:39:48 - strategies channel

**Mo**

To be clear I am live trading the strategy just backing



Whether to just move on is an interesting question of how to prioritise the infinite possibilities of what to work on. And perhaps more importantly, whether trying to solve the mystery of the poor laying performance is mainly just an intellectual exercise rather than a profitable one

---

## 2022-08-21 08:36:50 - strategies channel

**Mo**

But it's very good practice to always look at the cumulative return plot as it gives you a much more nuanced feel for the strategy than headline numbers

---

## 2022-08-21 08:33:38 - strategies channel

**Mo**

This will depend on number of events, average odds, staking, etc. etc. but speaking very generally, it's entirely feasible for a strategy to be flat for a quarter

---

## 2022-08-21 08:24:16 - strategies channel

**Unknown**

Good morning everyone, I am backtesting a strategy and obtained this profit plot. Do you think this indicates the value opportunity was there but it disappeared when profit goes "flat"? This is ~900 markets, ~2200 orders

---

## 2022-08-21 07:20:39 - strategies channel

**Mo**

[@U01C12ZEADQ](@U01C12ZEADQ) I'm not sure what question you're referring to as "very stupid" :sweat_smile: my current line of investigation is indeed that the model needs one or more additional features and/or a structural change

---

## 2022-08-20 12:25:11 - random channel

**Jonjonjon**

When you add a strategy to a Flumine instance, for backtesting, it calls that func a few times to get the market definition from the historical file. If you have patched open with smart_open, or done something similar to let it work with compressed files, it both takes a lot of time and heats up the disk.

---

## 2022-08-19 16:10:16 - issues channel

**EJono**

im not sure why but for some reason im no longer seeing any markets in flumine.markets when i execute framework.run() anymore. This is the strategy set up i have been using that has been bringing through football succesfuly for the past few months now. Any idea why all of a sudden no markets are coming through on the stream? Last time i succesfully saw things working as they should be was wednesday last week.

```strategy = Strategy(

    max_order_exposure=5,

    max_live_trade_count=5,

    max_selection_exposure=5,

    market_filter=streaming_market_filter(

        event_type_ids=["1"],

        country_codes=country_codes,

        market_types=["MATCH_ODDS"],

    ),

    name=STRAT_NAME,

    context={

        'max_liability': LIABILITY

    }

)```

Im using

```flumine==2.2.3

betfairlightweight==2.16.6```



---

## 2022-08-18 10:24:12 - strategies channel

**Alessio**

Very stupid question, now that i think about it. Let me assume for a second that you lay because the model underpredicts w.r.t. odds. Is it possible it underpredicts because you have a missing feature? This would not affect 'backs' too much because without the faeature it would not be able to overpredict w.r.t. odds.

---

## 2022-08-18 09:38:59 - strategies channel

**liam**

Reading between the lines I do things very differently when it comes to model/pricing, on average I will place 60ish bets per second at key times which is where matching/spread/price comes crucial but at 1 selection / side this mean reverts out to leave just the model.



Is it a market based or fundamental?

---

## 2022-08-18 09:21:13 - strategies channel

**Mo**

Same picture at 100% match rate: backs do very well, lays do very badly. So doesn't seem to be execution or price movement related. Hence the focus on the model

---

## 2022-08-18 09:06:24 - random channel

**liam**

This is one of the negatives of flumines simplicity, in a more complex trading system you would separate the different components to allow strategy/framework/execution/price code to be updated without downtime.



My understanding is that [@UBS7QANF3](@UBS7QANF3) system allows this but it obviously comes at a complication/setup cost

---

## 2022-08-18 06:08:04 - strategies channel

**Mo**

I've looked at spread and over/underround - no relationship with quality of bets. Ditto distance run/remaining in the race



Everything is pointing to the model is just failing to identify value bets on the lay side. I still can't reconcile how it can do so on the back but not lay side but for now I'm focusing on improving the predictions

---

## 2022-08-17 11:40:35 - random channel

**Michael**

It's really interesting to see different people's attitudes to how to use the community and what their strategy is to get the best from it.

---

## 2022-08-16 15:04:56 - issues channel

**Ruben**

when backtesting a strategy and then printing orders placed, I am seeing orders with values of `elapsed_seconds_executable`  on the order of 10, 20, 30 and higher. However in the strategy I have the following code for `process_orders`, that shouldnt allow orders to exist for more than 2 seconds, what am I missing?

```    def process_orders(self, market, orders):

        for order in orders:

            if order.status == OrderStatus.EXECUTABLE:

                if order.elapsed_seconds and order.elapsed_seconds &gt; 2:

                    market.cancel_order(order)```

---

## 2022-08-15 20:52:54 - strategies channel

**Ruben**

is a 2% margin on backtest too low to consider a strategy?

---

## 2022-08-15 16:31:33 - general channel

**PeterLe**

OK, first few lines look like the below text..So i can see that it contains all the market information...but is something I dont need to run backtests on..if Flumine is recording it, I guess that it should be retained then :grinning:



{"marketId": "1.201121593", "marketName": "6f Hcap", "marketStartTime": "2022-07-18T15:10:00.000Z", "description": {"persistenceEnabled": true, "bspMarket": true, "marketTime": "2022-07-18T15:10:00.000Z", "suspendTime": "2022-07-18T15:10:00.000Z", "bettingType": "ODDS", "turnInPlayEnabled": true, "marketType": "WIN", "regulator": "GIBRALTAR REGULATOR", "marketBaseRate": 5.0, "discountAllowed": true, "wallet": "UK wallet", "rules": "&lt;br&gt;&lt;a href=\"[https://www.timeform.com/horse-racing/](https://www.timeform.com/horse-racing/)\" target=\"_blank\"&gt;&lt;img src=\" [http://content-cache.betfair.com/images/en_GB/mr_fr.gif](http://content-cache.betfair.com/images/en_GB/mr_fr.gif)\" title=\u201dForm/ Results\u201d border=\"0\"&gt;&lt;/a&gt;\n&lt;br&gt;&lt;br&gt;&lt;b&gt;MARKET INFORMATION&lt;/b&gt;&lt;br&gt;&lt;br&gt;This market information applies to Exchange Singles bets only. Please

---

## 2022-08-15 09:21:21 - strategies channel

**Mo**

I have a price taking strategy that produces good backtest results when backing (ROI 9% over approximately 20000 events) and bad results when laying (ROI -11% over the same events). I'm a bit perplexed why this is - my only theory is that the predictions are in some way biased towards 1 but in such a way that doesn't destroy all value when backing. This doesn't seem very convincing. Anyone experienced anything similar and were you able to resolve it? Any suggestions for where to start working out what's going on?

---

## 2022-08-15 09:13:28 - general channel

**Andy Bason**

I select the event ID then filter using

`markCatFilt = betfairlightweight.filters.market_filter(event_ids=[event_id])`

`markCats = trading.betting.list_market_catalogue(filter=markCatFilt, max_results='100', sort='FIRST_TO_START')`

And this is where I get stuck

---

## 2022-08-15 08:58:30 - general channel

**Andy Bason**

Hi Mo, I can filter events to find matches with AH markets using `matFilter = betfairlightweight.filters.market_filter(event_type_ids=[1], market_start_time={'to': (datetime.utcnow() + timedelta(hours=1)).strftime("%Y-%m-%dT%TZ")}, market_betting_types=["ASIAN_HANDICAP_DOUBLE_LINE"])` but then I'm not able to get the prices/lines for a specific event.

---

## 2022-08-13 19:06:49 - strategies channel

**Peter**

Flumine is designed to handle multiple strategies and if they're targeting the same markets it normally makes sense to run them on a single process.



When it won't usually make sense is when the markets are different, e.g. don't mix football and horse racing, or if you have a strategy that is very CPU intensive and may slow up the responsiveness of other strategies.



I think it's pretty normal also to keep data collection separate.

---

## 2022-08-13 17:23:24 - strategies channel

**Ruben**

is the general consensus in favour of grouping strategies under the same flumine instance, or running each strategy in a separate flumine process?

---

## 2022-08-13 10:21:43 - betfair-news channel

**Mo**

The second package you linked to for example says



&gt; Note: Current version does not support refreshing authentication tokens. This will need to be handled manually.

This is pretty basic functionality



It seems clear there is not a big community of javascript Betfair API users but there is a big community of Python users (you're in it)



We're not dogmatic about what language you code in - there are people on here that use C/C++, C# and other languages - but there is a huge amount of value to leverage in the off the shelf Python packages:



1. [https://github.com/betcode-org/betfair|betfairlightweight](https://github.com/betcode-org/betfair|betfairlightweight), the most cutting edge Betfair API implementation across all languages

2. [https://github.com/betcode-org/flumine|flumine](https://github.com/betcode-org/flumine|flumine), a fully featured trading platform built on top of betfairlightweight

and the community expertise you have access to if you're using something everyone is familiar with

---

## 2022-08-12 10:04:18 - strategies channel

**liam**

I guess it depends on what you constitute a change to be, I find that changes to test matching rates take just a few days to become obvious (80% of my testing) whilst triggers/strategy ifs can take months.



I try and isolate the other factors and just focus on the change and if it has been positive.



I think you are in the rare minority who is happy to go and do something else whilst you wait :wink:

---

## 2022-08-12 09:41:44 - strategies channel

**Michael**

I'm surprised that people find such frequent changes worthwhile, I think I would find them a problem as they really muddy the waters in terms of analysis. Even with frequent events like horse racing a few weeks of data is a trivial amount and easily affected by simple randomness.



Personally I find it very difficult to attribute success or failure to my own strategy changes rather than other factors with confidence.



These days I lean more towards establishing some kind of hypothesis and then setting up long running tests to confirm or refute it and I basically just ignore my betting whilst I'm waiting.

---

## 2022-08-12 05:08:19 - issues channel

**Johnny Boston**

Hey - I am trying to record the `last price traded` for a runner before the market goes in play.



The way I am doing this is by recording all the Market iterations to a csv and then when *`process_closed_market`* is called in my recording strategy, I find the last publish time from the csv. Problem is this is showing some very strange figures, with `last price traded` wildly different to `bsp`  so I am definitely doing something wrong.



Is there an easier way to do this after a market has closed? to find the `last_traded_price` before market goes in play? or do I just need to find a better solution to my problem ?

---

## 2022-08-11 20:39:25 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) do you make adjustments manually, or do you have some automation that evolves with the markets? I did a very rough version of the latter many years ago that basically started off betting "randomly", then checked the P&amp;L every 1000 bets, adjusted the signals and ran for another 1000 bets. Can't remember what the outcome was, but assume it was shit because I don't do that anymore. :grinning: 

Of course, now we can simulate with Flumine instead.

---

## 2022-08-11 19:17:56 - strategies channel

**Dario Scardina**

```trading = betfairlightweight.APIClient(username=my_username,

                                           password=my_password,

                                           app_key=app_key,

                                           cert_files=(cert, key),

                                           locale="italy",

                                           lightweight=False

                                           )



trading.login()



competitions = trading.betting.list_competitions(

    filter=betfairlightweight.filters.market_filter(

    event_type_ids=[1],  # Soccer's event type id is 1

    in_play_only=True # In play only

    )

)



live_events = trading.betting.list_events(betfairlightweight.filters.market_filter(

    event_type_ids=[1],  # Soccer's event type id is 1

    in_play_only=True,  # in play

    competition_ids=[competition.competition.id for competition in competitions], # get events only for competitions selected

    ))



strategy = ExampleStrategy(

    name="BackUnderSH",

    market_filter=streaming_market_filter(

        event_type_ids=["1"],

        event_ids=[live_event.event.id for live_event in live_events],

        market_types=["OVER_UNDER_05", "OVER_UNDER_15", "OVER_UNDER_25", "OVER_UNDER_35", "OVER_UNDER_45",

                           "OVER_UNDER_55", "OVER_UNDER_65"],

    )

)```

[@U02QDLFCYHG](@U02QDLFCYHG) maybe that could help... Works for me to consider only live events for soccer competitions.

---

## 2022-08-11 19:03:48 - strategies channel

**birchy**

For those of you with profitable strategies, how often do you all have to carry out maintenance or "tweak" settings/signals/etc? Personally I have one particular strategy that was my first live one with Flumine that's been untouched for ~2 years now. It's nothing adventurous but has been slowly ticking along and in recent months has performed exceptionally well. No doubt there will be an equal downturn at some point....

---

## 2022-08-11 18:44:51 - strategies channel

**Dario Scardina**

[@U02QDLFCYHG](@U02QDLFCYHG) did you find an alternative? I think we would implement a similar strategy :D

---

## 2022-08-11 17:30:52 - general channel

**Dario Scardina**

Hello, how can I get the runner name of a selection in flumine? Let's say I want to place orders only to Under selections

```strategy = ExampleStrategy(

    name="BackUnderSH",

    market_filter=streaming_market_filter(

        event_type_ids=["1"],

        event_ids=["31653002"],

        market_types=["OVER_UNDER_05", "OVER_UNDER_15", "OVER_UNDER_25", "OVER_UNDER_35", "OVER_UNDER_45",

                           "OVER_UNDER_55", "OVER_UNDER_65"]

    )

)```

I was trying then to skip Over selections in

```def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:

    # process marketBook object

    for runner in market_book.runners:

        skip_runner = False

        for runner_info in market.market_catalogue.runners:

            logger.debug("process_cleared_markets: %s" % runner_info.runner_name)

            if runner.selection_id == runner_info.selection_id:

                if "Ov" in runner_info.runner_name:

                    skip_runner = True

...```

But I've found out that market.market_catalogue is None.



Did somebody faced this problem?

---

## 2022-08-11 10:17:49 - general channel

**James**

I am trying to create a dataframe containing Teams/Event Names, Event IDs, Competition Names and Competition IDs. I've managed to create one dataframe containing Teams/Event Names and Event IDs and another containing Competition Names and Competition IDs. How can I match up Competition Names/IDs with the Event IDs? Any help would be appreciated!

Here's the code:

```    # Create competition filter

    competition_filter = betfairlightweight.filters.market_filter(

        event_type_ids=[1],

        market_start_time={

            'to': (datetime.utcnow() + timedelta(days=7)).strftime("%Y-%m-%dT%TZ")

        })



    # Get a list of competitions

    competitions = trading.betting.list_competitions(

        filter=competition_filter

    )



    # Create competition dataframe

    competition_df = pd.DataFrame({

        'Competition': [competition_object.competition.name for competition_object in competitions],

        'ID': [competition_object.competition.id for competition_object in competitions]

    })

    print(competition_df)



    comp_id_list = competition_df['ID'].tolist()

    print(comp_id_list)



    # Create event filter

    event_filter = betfairlightweight.filters.market_filter(

        event_type_ids=[1],

        competition_ids=comp_id_list,

        market_start_time={

            'to': (datetime.utcnow() + timedelta(days=7)).strftime("%Y-%m-%dT%TZ")

        }

    )



    upcoming_events = trading.betting.list_events(

        filter=event_filter

    )



    # Create event dataframe

    events_df = pd.DataFrame({

        'Teams': [event_object.event.name for event_object in upcoming_events],

        'Event ID': [event_object.event.id for event_object in upcoming_events],

    })

    print(events_df)```

---

## 2022-08-11 07:50:15 - general channel

**liam**

set `streaming_timeout` to a value on the `Strategy` for example this would send a marketBook through to `process_market_book` every update and every 10s regardless of an update or not



```strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB"],

        market_types=["WIN"],

    ),

    streaming_timeout=10

)```

---

## 2022-08-10 09:35:23 - strategies channel

**George**

If I want to simulate an inplay strategy for Place markets, with TPD data, how should I set that up? The TPD files are named (by default) with the Market ID of the win-market, so it won't work without making some kind of intervention in the Flumine code itself, I think.

---

## 2022-08-09 11:11:16 - issues channel

**George**

if I wanted to simulate an inplay strategy on the place market, how would I do that, because the TPD files are named with the win-market's market ID...

---

## 2022-08-09 08:13:46 - general channel

**liam**

What is a while? Have you processed your code?



Flumine will not remove liquidity when taking prices but will you can prevent double counting of passive with this config [https://betcode-org.github.io/flumine/advanced/#simulated_strategy_isolation|setting](https://betcode-org.github.io/flumine/advanced/#simulated_strategy_isolation|setting). Default is True which is what you probably want.

---

## 2022-08-09 08:05:45 - general channel

**LM**

Does using the flumine backtest functionality remove simulate liquidity being removed by each strategy being run. The reason i ask is that backttesting in flumine generally takes a while (even when multiprocessing is utilized) and i generally use it to help estimate liquidity in the market for a particular strategy (I know this isn't perfect but is indicative). My approach is usually to run multiple backtests with the same strategy adjusting the stake. I'm wondering if instead I can run a backtest once using multiple different staking strategies and get the same results or if these strategies would compete for the available liquidity?

---

## 2022-08-08 17:45:29 - issues channel

**George**

Sorry [@U4H19D1D2](@U4H19D1D2) I'm having a lot more issues related to this. I would like to trigger off the TPD data and send an order.

To send the order at the right price and for the right size, I want to know what is the latest market book that the strategy has received.

I tried to set `process_market_book` to save the most recent market book as `self.current_market_book`, but it didn't work, because I'm seeing that the `self.current_market_book.market_id` is a different market ID to the `sports_data.market_id` .



I noticed that, in the cricket example in the repo, the strategy sends an order to BACK at 1.01 ...

---

## 2022-08-08 16:26:02 - random channel

**Jorge**

Hi, I'm starting with the Binance Python API. Is there any group similar to this Slack for Binance trading? The API docs are really bad [https://python-binance.readthedocs.io/en/latest/overview.html](https://python-binance.readthedocs.io/en/latest/overview.html)

---

## 2022-08-08 13:07:07 - strategies channel

**Alessio**

Thought so for (1)., thanks for confirming. For (2) vs (3) is more about the approach: what I consider (2) is to find specific moments where you see mispricing, recognize them and act on them (say, go for player injuries and see when they are not priced in;  you don't care too much about the actual correct odds, it's more a signal to tell the strategy to act, and a lot of the logic is hand-tuned in the strategy) while (3) is more like a fundamentals-first approach -- basically building your own odds, but then trusting them most of the time. I see your point about them being connected, it's more of classifying bad odds/good odds -- and probably going for more rare events --  vs trying to shave every single penny out of each mispricing.

---

## 2022-08-08 11:32:14 - strategies channel

**thambie1**

It's much easier to to grow an already working but small scale strategy than to start a new one. It really depends on what you're existing strategy is, and whether there's room for growth. Bet sizing, latency, and modifications to the strategy can all be potential options. That being said, if you do decide to go down a completely different rabbit hole, I would pursue option #2. It's still very hard, but easier than #3, and more likely to be a stable competitive advantage compared to #1.

---

## 2022-08-08 09:49:55 - issues channel

**George**

Maybe you don't. I'm not sure. What I am thinking is this.

Let's say the TPD data has just picked up that Horse 1 has started to accelerate. So we want to back him on both the Win and the Place. Maybe the most efficient way to do that is to use a strategy with event processing and send an order to both markets from the same strategy.

---

## 2022-08-07 13:07:13 - general channel

**PeterLe**

Im using an MP600 PCIe, eitherway Im happy with the backtest speed, 6 mins to test that many is superfast , In the time I can make a brew, i can discover another losing strategy :grinning:

---

## 2022-08-06 21:43:55 - random channel

**Mick**

I'd like to get the BETDAQ API but have just seen they have an intimidating looking questionnaire ([https://api.betdaq.com/v2.0/Docs/default.aspx](https://api.betdaq.com/v2.0/Docs/default.aspx)) I'm nervous of being rejected. Any tips on what they're looking for? And one more thing - I haven't bet anything with them for many years except for a few bets yesterday - any idea how much regular betting they're expecting to see?

---

## 2022-08-06 21:22:23 - general channel

**Jonjonjon**

Do you think they know the general gist of your strategy?

---

## 2022-08-06 15:45:03 - issues channel

**George**

Clearer formatted code:

```import smart_open

from mock import patch

from flumine import FlumineSimulation, clients, config

from flumine.markets.middleware import SimulatedSportsDataMiddleware

from flumine.strategy.strategy import BaseStrategy



if __name__ == '__main__':

	client = clients.SimulatedClient()

 	framework = FlumineSimulation(client=client)

	markets = ['/path/to/file/1.201463615.gz', '/path/to/file/1.201463621.gz']

	strategy = BaseStrategy(market_filter= {'markets': markets, 'listener_kwargs': {'seconds_to_start': 60, '    calculate_market_tv':False, 'cumulative_runner_tv':False}, 'event_processing': True})

	with patch('builtins.open', smart_open.open):

 		framework.add_market_middleware(SimulatedSportsDataMiddleware('raceSubscription', '/sports/data/path'))

 		framework.add_strategy(strategy)

 		with patch.object(config, 'raise_errors', True):

 			framework.run()```

---

## 2022-08-06 15:27:39 - issues channel

**George**

Hi [@U4H19D1D2](@U4H19D1D2) here is the code I'm using:

```import smart_open

from mock import patch

from flumine import FlumineSimulation, clients, config

from flumine.markets.middleware import SimulatedSportsDataMiddleware

from flumine.strategy.strategy import BaseStrategy



if __name__ == '__main__':

    client = clients.SimulatedClient()

    framework = FlumineSimulation(client=client)

    sports_data_path = '/sports/data/path/'

    markets = ['/path/to/file/1.201463615.gz', '/path/to/file/1.201463621.gz']

    strategy = BaseStrategy(market_filter= {'markets': markets, 'listener_kwargs': {'seconds_to_start': 60, '    calculate_market_tv':False, 'cumulative_runner_tv':False}, 'event_processing': True})

    with patch('builtins.open', smart_open.open):

        framework.add_market_middleware(SimulatedSportsDataMiddleware('raceSubscription', sports_data_path))

        framework.add_strategy(strategy)

        with patch.object(config, 'raise_errors', True):

            framework.run()```

---

## 2022-08-04 13:44:06 - general channel

**John Foley**

Been thinking about this as well recently - a half-baked idea I had was to try using [https://github.com/mlflow/mlflow|mlflow](https://github.com/mlflow/mlflow|mlflow). It's designed for a very similar situation where you’re training hundreds or thousands of ML models, all with different parameters, and need a flexible way to attach performance metrics to each run. Definitely might be overkill though.. 

---

## 2022-08-03 14:29:22 - betfair-news channel

**liam**

You tried setting it? Or do you need to modify the headers as well?



```trading = betfairlightweight.APIClient(username, password, appKey)



trading.set_session_token("asdfgh")



event_types = trading.betting.list_event_types()```

---

## 2022-08-03 14:27:01 - betfair-news channel

**Enodeg Enodoff**

Hi guys, I’m new here. Currently I try to use the python betfairlightweight library, and have a question.



Maybe someone knows how to use this library with session tokens.

I have a vendor app key and want to try to use this library to work with my user’s accounts. (Session token we got with Oauth)



For single user we use “trading” class, where we get access with username and pass, this is ok:

trading = betfairlightweight.APIClient(username, password, appKey)



But Can’t find where we can modify login endpoint, and headers for access only with users session token.



Anybody can help?



Thanks.

---

## 2022-08-03 14:00:22 - random channel

**Wayne**

I know of cases like this going back to 2017 - was originally worded as "credit" until it was clear offering loans would be problematic in terms of licensing and regulations. It was re-named trading capital then. Back then I think it was viewed as an incentive for profitable guys to scale up new/other ideas quicker

---

## 2022-08-03 09:55:26 - strategies channel

**Johnny Boston**

```    strategy = TradingFlucsRecorder(

        market_filter={

            "markets": markets,

            "market_types": ["WIN"],

            "listener_kwargs": {

                "inplay": False,

                "seconds_to_start": 600,

                "calculate_market_tv": True,

            },

        }

    )```

---

## 2022-08-03 09:53:02 - strategies channel

**Johnny Boston**

```    client = clients.SimulatedClient(min_bet_validation=False, transaction_limit=9999999999999)

    framework = FlumineSimulation(client=client)



    strategy = aus_flucs_recorder

    strategy.market_filter = {

        "markets": markets,

        "market_types": ["WIN"],

        "listener_kwargs": {

            "inplay": False,

            "seconds_to_start": 600,

            "calculate_market_tv": True,

        },

    }

    strategy.context = {"SIMULATED": True}



    logger.warning(f"Processing markets: {[m for m in markets]}")



    with mock.patch("builtins.open", smart_open.open):

        framework.add_strategy(strategy)

        framework.run()```

---

## 2022-08-03 09:51:58 - strategies channel

**liam**

Yes but that strategy is setup for live with the filters 

---

## 2022-08-03 09:50:03 - strategies channel

**Johnny Boston**

Yeah, but can't you put a recorder strategy through a simulation to record back data?

---

## 2022-08-03 09:49:37 - strategies channel

**liam**

That's a recorder strategy for recording live data 

---

## 2022-08-03 09:42:11 - strategies channel

**Johnny Boston**

Hey [@U4H19D1D2](@U4H19D1D2) - so this is the gist of it.



In prod I am recording for win and place markets, and in the simulation I wanted to record for all the PRO files for back data but only `WIN` markets



Here is the entire strategy and the class being instantiated...

---

## 2022-08-03 08:50:19 - strategies channel

**Johnny Boston**

Yeah it's done before the add strategy

---

## 2022-08-03 08:49:35 - strategies channel

**liam**

Yeah assuming its done before the `add_strategy` but something odd is happening

---

## 2022-08-03 08:24:45 - strategies channel

**Johnny Boston**

Yes, I'll get it to you. I do it like this to not change a strategy I have in prod.

---

## 2022-08-03 08:14:12 - strategies channel

**liam**

I am unable to replicate this but then the way you are setting the `market_filter` like that is confusing me, do you have some code I can run to replicate? For example here is the simulation.py code I am running



```strategy = LowestLayer(

    market_filter={"markets": markets, "market_types": ["PLACE"]},

    max_order_exposure=1000,

    max_selection_exposure=105,

    context={"stake": 2},

)

framework.add_strategy(strategy)```

---

## 2022-08-03 05:01:24 - strategies channel

**Tiago Augusto Ferreira**

Hello. I am try filter my strategy using the competition_ids. But i receive a error SUBSCRIPTION_LIMIT_EXCEEDED. What is the correct form to filter by this field?

`strategy_over = MyStrategy(`

    market_filter=market_filter(competition_ids=[141]),

    name='OVER05HT_MODELO',

    max_trade_count=3,

    max_live_trade_count=3,

    max_order_exposure=12,

    conflate_ms=1000,



)



The error:



2022-08-03 00:57:07 *ERROR*    [MarketStream: 2001]: SUBSCRIPTION_LIMIT_EXCEEDED: trying to subscribe to 14995 markets whereas max allowed number was: 200

2022-08-03 00:57:07 INFO     [MarketStream: 2001]: *FAILURE* (9 connections available)

---

## 2022-08-02 23:40:36 - strategies channel

**Johnny Boston**

Hey - I am using this filter for a simulation on the pro files



```    strategy.market_filter = {

        "markets": markets,

        "market_types": ["WIN"],

        "listener_kwargs": {

            "inplay": False,

            "seconds_to_start": 600,

            "calculate_market_tv": True,

        },

    }```

I am still getting `PLACE` markets through in my *`process_closed_market` function of the simulation strategy class, is that expected?*

---

## 2022-08-02 16:24:50 - general channel

**Peter**

I think that [@UPMUFSGCR](@UPMUFSGCR) was thinking for blotter.market_exposure() which I wrote. But that won't give you what you're looking for. The blotter.get_exposures() method may help though as that will return what you could win and what your could lose for a given strategy/selection combination, but you'd need to interpret the results yourself and you would probably want to only sparingly it in process_market_book as it's a tad CPU-intensive.

---

## 2022-08-01 21:11:03 - random channel

**Michael**

This may be my ignorance, but how does framework.run() work. If I have functions defined within the strategy, how are they run?

---

## 2022-08-01 11:05:04 - strategies channel

**Alessio**

In general if i may add, the edge of a complex modelling technology like SVM or NNs pays off only with (1) a lot of data (like millions of examples) and/or (2) a loss function that is specialized for your task. XGBoost for non-linearity and classic regression will probably squeeze 90% of it. What is much more important is defining the objective, engineer feature and clean data like no tomorrow.

---

## 2022-08-01 10:53:00 - strategies channel

**Mo**

Some thoughts:



1. SVM is an odd choice; if you want state of the art then use XGBoost. If you want simplicity, speed, ease of implementation and a method that has stood the test of time then use Logistic Regression

2. I'm not sure about including starting odds - you mention form, speed, rating: all of these will already be incorporated into the odds. So it will come down to whether there is any marginal value in your "own inputs" over and above the odds

3. Another downside to starting odds is they are only available when the race starts. Typical setup for a pre-race strategy would be to use the starting odds (implied probabilities) as the target for your model rather than binary win/loss

4. I think you're thinking along the right lines with what I'll summarise as "truncated finishing positions" although I still think just using the implied probabilities from the starting odds would be way better

---

## 2022-07-31 23:44:21 - strategies channel

**Troy Edwards**

Hi all long time since chatting.  I have been trying some strategies with Aussie and NZ greyhound racing and still don't have an edge yet.  So back to learning and I have come across SVM - Support Vector Machine regression tool which I want to apply to greyhound data.  Some of the X inputs will be form, speed, rating, starting odds etc and some of my own inputs.  However for the Y inputs which are the results, should I enter say 1 (True) for the winner and then -1 (False) for the other 7 runners?  OR should I enter the actual finishing positions 1 thru 8?    I am wondering if training the model with positions 1-8 may introduce errors OR be too difficult?  I was also thinking I could just set positions 1-3 True and everything else False as most of my strategies are for Lay bets?   I  have started any coding yet for the model but am going to use Accord.MachineLearning.VectorMachines.Learning in the .NET library.

---

## 2022-07-29 14:58:35 - random channel

**Peter**

Blotter class has a selection_exposure() method which gives you the net exposure of a runner for a given strategy.

---

## 2022-07-29 13:31:30 - random channel

**LM**

Any examples of hedging/greening in flumine based on current strategy market exposure (or matched exposure for each runner)?

---

## 2022-07-28 21:54:42 - general channel

**Michael**

Just thinking of a way to do this, I guess I can't do this in the strategy class, so would need to make a stream class and then take a input of the horse name and market name (venue / time) and then pull the ID from the stream and then send to the strategy class?

---

## 2022-07-28 17:23:17 - random channel

**Mick**

Not streaming - I don't think I need the high speed stuff. I'm betting hours before the off.

---

## 2022-07-28 17:05:56 - random channel

**Mick**

I have the following code...



```	price_filter = betfairlightweight.filters.price_projection(price_data=['EX_ALL_OFFERS', 'SP_PROJECTED'])

	print(f"mk_id={mk_id}")

	print(f"price_filter={price_filter}")

	market_books = trading.betting.list_market_book(market_ids=[mk_id],price_projection=price_filter)```

Which produces the following output



```mk_id=1.201434570

price_filter={'priceData': ['EX_ALL_OFFERS', 'SP_PROJECTED'], 'exBestOffersOverrides': {}, 'virtualise': True, 'rolloverStakes': False}

Traceback (most recent call last):

  File "c:\Users\mick\Predictor\bfapi\bfex.py", line 2556, in &lt;module&gt;

    display_odds_for_this_race( course,stime,None,race_fp,            True,        "WIN")

  File "c:\Users\mick\Predictor\bfapi\bfex.py", line 1065, in display_odds_for_this_race

    market_books = trading.betting.list_market_book(market_ids=[mk_id],price_projection=price_filter)

  File "c:\users\mick\appdata\local\programs\python\python310\lib\site-packages\betfairlightweight\endpoints\betting.py", line 283, in list_market_book

    (response, response_json, elapsed_time) = self.request(method, params, session)

  File "c:\users\mick\appdata\local\programs\python\python310\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 55, in request

    self._error_handler(response_json, method, params)

  File "c:\users\mick\appdata\local\programs\python\python310\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 81, in _error_handler

    raise self._error(response, method, params)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketBook

Params: {'marketIds': ['1.201434570'], 'priceProjection': {'priceData': ['EX_ALL_OFFERS', 'SP_PROJECTED'], 'exBestOffersOverrides': {}, 'virtualise': True, 'rolloverStakes': False}}

Exception: None

Error: {'code': -32602, 'message': 'DSC-0018'}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}```

BTW, if instead I just had this at the start:

```	price_filter = betfairlightweight.filters.price_projection(price_data=['EX_ALL_OFFERS']) ```

then there is no error.

---

## 2022-07-27 13:49:54 - general channel

**Newbie99**

You don't have to use Flumine, if you prefer a non-streaming approach, you can just use BFLW:



[https://github.com/betcode-org/betfair/blob/master/examples/exampletwo.py](https://github.com/betcode-org/betfair/blob/master/examples/exampletwo.py)



But you may find (as many of us here did), that actually streaming is a more viable way to go long term and then its worth using Flumine as a lot of the hard work is already done (not to say there isn't plenty more hard work in developing a strategy of course). This example may help:



[https://github.com/betcode-org/flumine/blob/master/examples/example-single.py](https://github.com/betcode-org/flumine/blob/master/examples/example-single.py)



You can also use BFLW for streaming, without using Flumine, but unless you have a very specific use case, on the assumption you're starting from scratch it probably makes sense to use Flumine, here is the BFLW streaming example anyway:



[https://github.com/betcode-org/betfair/blob/master/examples/examplestreaming.py](https://github.com/betcode-org/betfair/blob/master/examples/examplestreaming.py)

---

## 2022-07-27 13:32:56 - general channel

**Michael**

I'm quite new to coding so struggling to read the docs for Flumine. If I'm creating the strategy outside of Flumine (i.e. I have marketID and I have runnerID and amount I'd like to bet) do I need to have a strategy class or can I just use Baseorder?

---

## 2022-07-27 00:12:32 - issues channel

**birchy**

I've not had this issue, so presumably your strategy repeatedly sees the order status as `EXECUTABLE` and then calls the cancel function in Flumine? If that's the case, then it seems logical that Flumine would need to handle `BET_TAKEN_OR_LAPSED` and update the order status to either `EXECUTION_COMPLETE` or flag it some other way. I'm assuming that this is actually an issue at Betfair's end and Flumine is simply relaying the received order status? If that's the case then all you can do is save the order id to market.context (or wherever) and ignore it in your cancellation call.

---

## 2022-07-26 22:12:04 - issues channel

**Newbie99**

This BET_TAKEN_OR_LAPSED issue has returned again (the full log won't help, its just a perpetual loop of Cancelling &amp; Executable):



```{"asctime": "2022-07-26 18:49:36,460", "levelname": "INFO", "message": "execute_cancel", "trading_function": "cancel", "elapsed_time": 0.0769505500793457, "response": {"customerRef": "b236ce8e0d1311ed95da02054918c7c6", "status": "FAILURE", "errorCode": "BET_ACTION_ERROR", "marketId": "1.201257099", "instructionReports": [{"status": "FAILURE", "errorCode": "BET_TAKEN_OR_LAPSED", "instruction": {"betId": "275113850428"}}]}, "order_package": {"id": "b236ce8e-0d13-11ed-95da-02054918c7c6", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7fd0c9f06d10&gt;", "market_id": "1.201257099", "orders": ["138781504696928340"], "order_count": 1, "package_type": "Cancel", "customer_strategy_ref": "ip-172-31-4-105", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}```

What does confuse me though, is that it says retry_count is 0 (and this always shows zero looking through), even though it attempts to cancel the order multiple times.



Appreciate this is a known issue, but I'm really struggling to come up with a stopgap solution as nothing I've tried works, does anyone have any sticking plaster suggestions for now?



Just in case anyone reading this hasn't seen this before, it occurs when Flumine tries to cancel an order that has already been matched, for some reason in some situations it gets stuck in an endless loop, trying to cancel the bet that no longer exists...but I can't figure out why. Even more strangely it seems to occur loads over a period and then stops for weeks or months on end!

---

## 2022-07-26 10:53:46 - general channel

**Michael**

ATR data - strategy won't be that profitable but its moreso so I can bet and then stream data to build other models

---

## 2022-07-25 21:40:06 - general channel

**George**

My question is: can it all be done using a single strategy? Simply by adding a `sports_data_filter = ['raceSubscription']`  option into the main MarketRecorder example which captures the exchange market data, and then using the `process_sports_data`  method to write to a file, in exactly the same way that `process_raw_data` does?

---

## 2022-07-25 21:39:08 - general channel

**George**

A quick question about recording racing inplay/TPD market data using Flumine.

The Flumine docs say that the inplay recording should be done like this:

```strategy = MarketRecorder(market_filter=None, stream_class=RaceDataStream, context={...})```

and that's fair enough. But it means you need two strategies; one to capture the exchange market data and one for the inplay/TPD data.

---

## 2022-07-24 13:03:05 - random channel

**PeterLe**

Thanks Mandelbot. Sorry i didnt explain myself fully. I understand the code you posted above (filter). I could use a separate account and do it the way you suggested, but i though that if did it by adding a separate strategy I could set the context up correctly so that it recorded the additional sport to a different directory. ie multiple sports using a single instance, each recording to named directories

---

## 2022-07-24 12:48:47 - random channel

**PeterLe**

[@U010GM77S4W](@U010GM77S4W) recently explained how to add more than one strategy to a single instance (thanks madelbot) using this :

import logging

import betfairlightweight

from pythonjsonlogger import jsonlogger



from flumine import Flumine, clients

from flumine.streams.datastream import DataStream

from Strategy1 import Strategy1

from Strategy2 import Strategy2





logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = betfairlightweight.APIClient('username', 'password', app_key='app_key',

					certs='/path/to/certs')

trading.login()



client = clients.BetfairClient(trading)



framework = Flumine(client=client)



markets1 = betfairlightweight.filters.streaming_market_filter(

           event_type_ids=["7"],

           country_codes=["GB", "IE"],

           market_types=["WIN"]

)



markets2 = betfairlightweight.filters.streaming_market_filter(

           event_type_ids=["4339"],

           country_codes=["GB"],

           market_types=["WIN"]

)





strategy1 = Strategy1(

    name="Strategy1",

    market_filter=markets1,

    max_order_exposure=50000000,

    max_selection_exposure=6000000,

    max_trade_count=200,

    max_live_trade_count=1,

    context={"stake": 2},

)



strategy2 = Strategy2(

    name="Strategy2",

    market_filter=markets2,

    max_order_exposure=50000000,

    max_selection_exposure=6000000,

    max_trade_count=2000,

    max_live_trade_count=2,

    context={"stake": 2},

)



framework.add_strategy(strategy)

framework.add_strategy(strategy2)



framework.run()



I assume you can use the same principle using the market recorder to record more than one sport/category?

If so, Ill probably just add one more sport category for now, but is it good practice to add multiple sports. Does it start to slow the system down too much if you add multiple? Would it be reasonable to assume it could handle 3 or 4 categories easily? (Im using ubuntu on AWS 4gb ram, 2 CPU's)

(Can someone remind me of the subscription limit too please?) Thanks in advance

---

## 2022-07-24 11:04:44 - general channel

**liam**

Have you had a look at the example controls? Fairly sure there is one that does a lookup for the market, `StrategyExposure` I think 

---

## 2022-07-24 10:32:19 - issues channel

**Gib**

Traceback (most recent call last):

  File "bflw_stream_v4.py", line 21, in &lt;module&gt;

    trading.login_interactive()

  File "/usr/local/lib/python3.8/dist-packages/betfairlightweight/endpoints/logininteractive.py", line 30, in __call__

    (response, response_json, elapsed_time) = self.request(

  File "/usr/local/lib/python3.8/dist-packages/betfairlightweight/endpoints/logininteractive.py", line 56, in request

    check_status_code(response)

  File "/usr/local/lib/python3.8/dist-packages/betfairlightweight/utils.py", line 34, in check_status_code

    raise StatusCodeError(response.status_code)

betfairlightweight.exceptions.StatusCodeError: Status code error: 403

---

## 2022-07-24 05:29:31 - issues channel

**mandelbot**

Thanks! But I actually use unique contexts per strategy already

---

## 2022-07-24 03:41:01 - general channel

**Johnny Boston**

Howdy, is there any way to access the Market class from an Order?



My use case is that I'm wanting to implement my own trading controls and variable exposure limits for a cross different markets. Eg. A small Monday race I'll have smaller exposures to a big weekend race.



I see that exposures are set at the strategy level, so I was hoping to control that in the trading controls, but I'm not having any luck obtaining the Market class from the Order object passes to those controls.



Thank you in advance for any help.

---

## 2022-07-23 22:12:14 - issues channel

**Beginner**

I confess that I was a little confused when trying to automate my investments via `Betfairlightweight`, so my request for help is as simple as possible:



I have market id `1.201255552` and runner id `55270`, and I want to invest `210.00` in `Back`.



To login I already used:



```trading = betfairlightweight.APIClient(...)

trading.login()```

Now, to actually make the investment, how should I pass the arguments? As I understand it, I should use:



`betfairlightweight.endpoints.betting.place_orders()`



Could someone show me an example of how I should do it using this values?

I looked at the `flumine` examples on strategies but couldn't understand (*sorry for my lack of knowledge*).



I just really want to use an option to set the values and place the bet, I'm not generating a complex strategy or anything like that.

---

## 2022-07-23 16:37:36 - issues channel

**foxwood**

I got caught in some confusion and determined that if one framework is running multiple strategies on the same markets then a single market.context is being shared across all strategies. This is obviously correct since it is a "market context" but that was not the way I was using it and was storing strategy specific data for that market in there ! So, since all my strats have my own common base above flumine, I patched things up by making a dict per strategy within the market context like this which was a simple refactor of "market.context" usage. Maybe you're in a similar rabbit hole ?

I also ended up having to solve unique strategy naming for "customer_order_ref" on orders so that the blotter could be parsed per strategy if needed.



```class myBaseStrategy(BaseStrategy):



    def add(self) -&gt; None:

        self.ctxname = self.__class__.__name__

        ...

    def check_market_book(self, market, market_book) -&gt; bool:

        ...

        if self.ctxname not in market.context:

            market.context[self.ctxname] = {}

            market.context[self.ctxname]["mktBetsThisStrategy"] = 0

            ...

        ...



class strategy_XYZ(myBaseStrategy):



    def add(self) -&gt; None:

        myBaseStrategy.add(self)

        ...```



---

## 2022-07-23 10:25:09 - general channel

**PeterLe**

One thing I've found extremely useful is gaining a deeper understanding of the relationship of the key components and execution;  ie matching rates, stake, placement (amongst others) and the very delicate nature of those interactions.

the biggest eye opener for me is that one of the key ingrdients in a very long time running strategy (15 years) 'maybe' isnt that important as i thought it was. In fact Ive stripped it out and started to run a live account from yesterday for comparison.

It will be really useful to see how this perform live.

One of the things that stood out for me when reading Daniel Khanerman's work many years ago is Conjunction Fallacy. (Linda the bank teller). It really struck a chord with me in the realms of what we do. (Check it out of you're not aware). Seems obvious when you read it.

I've always believed that keeping things as simple as possible (occams razor) is a good basis for most things

...anyway on with the testing too much chatting  :grinning:

---

## 2022-07-21 16:52:10 - general channel

**birchy**

Yeah, I've thought many times about how it would work but it would end up as a messy available_to_... delta for every runner and strategy.

---

## 2022-07-21 15:01:16 - general channel

**PeterLe**

Just on simulation; Although its early days for me using it properly. The results I am getting seem to be accurate in terms of confirming, whether of not a strategy is profitable overall, (and it performs inline with my understanding of the markets, eg I know from experience that if I increase X Variable too much, then my match rates and profits fall). The actual profits appear to be quite conservative. ie the actual profits seem less than what I find in reality.

Mainly I'm been using it to fine tune some existing strategies. I just wondered how others use it.

How instrumental has it been in finding new stuff and do you use it more of a verification tool and gauge rather than expect to find new strategies ?

---

## 2022-07-21 14:04:26 - strategies channel

**Newbie99**

Yes...but the problem comes if its hundreds of transactions over a year...obviously if its a small number its not a problem, but we're talking about automated betting here, so realistically its likely to be a lot of transactions.



Now admittedly not all need to involve converting to Fiat, so you can keep it down to some degree, but its still an unnecessary headache!

---

## 2022-07-21 13:39:38 - strategies channel

**Unknown**

I appreciate the stimulating discussion, things have been pretty quiet on here lately. I do think there's a future for crypto but I think betting exchanges - both traditional and crypto - have major problems and crypto is not currently offering solutions to these - in fact, making them worse on balance. Better to focus on things crypto is suited to solving IMHO

---

## 2022-07-21 13:07:46 - strategies channel

**Unknown**

Automated trading strategies - actually any kind of trading - needs two parties to agree on the price



Who is going to think that these automated trading strategies are posting prices they want to match with? Either it's dumb money that's price insensitive, it's other sharks who think the price is wrong or it's people with different incentives - ie they want to lay off some risk and are happy to pay the margin to do so



With the crypto angle you are heavily disincentivising the laying off of risk. No regulated bookmaker or sports entity is going to be doing this on a black/grey market exchange



Sharks eating sharks does not lead to sustainable liquidity



So now you have pretty much all of the same problems that Betfair has attracting dumb liquidity - and they are big problems - and crypto doesn't really help you solve them. Punters find it hard enough to understand the exchange model and now you want them to educate themselves around crypto on boarding etc? If you want to remain black market then you have some advantage but it's not something I would personally risk jail time for





---

## 2022-07-21 13:04:25 - strategies channel

**D C**

Another aspect that makes it unattractive is that if it is TRULY decentralised then there must be a consensus mechanism where the result can be established truthfully and be safe from bad actors. Augur used to have the REP token for this so that holders would "vote" to verify settlement results but I have no idea if this is still the case as I have not looked at it for ages. As others have said though, its hard enough to drive punters to the exchange anyway through better prices. My father is a lifelong recreational punter and is far from stupid, but he still doesn't really "get" the exchange model.

---

## 2022-07-21 12:01:47 - strategies channel

**liam**

Fairly sure the days of low hanging fruit on that strategy are long gone across all the venues 

---

## 2022-07-20 22:43:07 - general channel

**birchy**

I know this has been asked before, but a slack search didn't reveal anything, so I guess it's been lost to the archives. As a rough ballpark figure, using Flumine simulation with a basic horses inplay strategy that places ~100 bets per market, how long should it take to run per 1000 markets on a modern laptop? I currently have a somewhat dated ProBook with 8gb ram, SSD and (I think) an Intel i3 CPU and it takes around 10-15 minutes per 1000 markets. It's sufficient for general programming and development work but lacks when running more intensive stuff like simulations, so I'm wondering if it's time to upgrade?

---

## 2022-07-20 11:07:23 - general channel

**liam**

`place_reset_seconds` is seconds to wait after an order on a market/strategy/selection has reset, ie execution complete



`reset_seconds` is seconds to wait after an order has already been placed on a market/strategy/selection

---

## 2022-07-20 10:19:33 - issues channel

**liam**

This is probably my fault;



*paper trading* is just forward testing, ie. testing on live markets but no real orders being placed



*backtesting* I see as applying a strategy on historical data



*simulation* is accurate play back of historical data as is if it was live using exactly the same code/integration



I changed the name in flumine as I found backtesting to be a bit vague as the simulation in flumine is far more powerful however I accept many will argue backtesting/simulation are the same. I will regularly 'backtest' outside of flumine using csv/pandas/jupyter before coding up properly and simulating in flumine. This allows quicker iterations without the heavy processing 'simulating' requires

---

## 2022-07-20 10:12:07 - issues channel

**D C**

Probably an idiot question but seen a lot of these things mentioned lately in a flumine context - can someone explain the difference (if any) between what you collectively refer to as back-testing, simulation and paper trading? In particular there seems to be an implied difference between back-testing and simulaton?

---

## 2022-07-18 15:14:31 - random channel

**PeterLe**

Good Afternoon, Wow its cracking the flags in Manchester today! :hot_face:



Although I have the market recorder running fine in windows, Im trying to get it running in Ubuntu and I can see it is failing due to the certs reference below.



import time

import logging

import betfairlightweight

from pythonjsonlogger import jsonlogger



from flumine import Flumine, clients

from flumine.streams.datastream import DataStream

from marketrecorder import MarketRecorder

# from flumine import MarketRecorder



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



myacc = str(input("please enter account name: "))

app_key = str(input("Please enter key: "))

mypass = str(input("Please enter Password and 2FA: "))

trading = betfairlightweight.APIClient(myacc,mypass, app_key, certs=r"C:\certs")



# client = clients.BetfairClient(trading) //Changed 21st July

client = clients.BetfairClient(trading, order_stream=False)



framework = Flumine(client=client)



strategy = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE"],

        market_types=["WIN"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/home/ubuntu/flumine",

        "force_update": False,

        "remove_file": True,

    },

)



framework.add_strategy(strategy)



framework.run()



Question Please: Can i copy over the certs I have in my windows systems and then reference them something like : -

trading = betfairlightweight.APIClient(myacc,mypass, app_key, certs=r"/home/ubuntu/certs") I assume they are just a digital file and not specific to an OS?

Or, more likely, am I going about this the wrong way. Thanks in advance

(PS I will set the environment settings soon :grinning:)

---

## 2022-07-16 20:58:42 - general channel

**birchy**

I've been using python for years but have discovered a strange (to me) issue with copying lists in a Flumine strategy. So all of these create a REFERENCE to the same object, however I was expecting a new list/dereferenced copy:



`atbs = runner.ex.available_to_back[:]

atbs = runner.ex.available_to_back.copy()

atbs = [d for d in runner.ex.available_to_back]`



If I make changes to elements in `atbs`, they are also changed in the Flumine object  `runner.ex.available_to_back`. The only way to make a real copy is:



`atbs = deepcopy(runner.ex.available_to_back)`



I'm going to hazard a guess that this is due to the list being dict elements, so the shallow copy methods copy the dict references rather than making new ones? Python has probably always done this and I've just not noticed it before...

Just to clarify, I don't think this is an issue with Flumine.

---

## 2022-07-16 11:15:16 - strategies channel

**Michael**

Four months is a reasonable amount to develop with, so maybe you're just looking at a relatively high volatility / low margin strategy that just needs quite a lot of bets to shake out. The simple answer is more data, which will resolve all questions. Like [@UBS7QANF3](@UBS7QANF3) says, one month of horse racing data is not as much as you might think.

---

## 2022-07-16 10:49:52 - strategies channel

**Tom Cannon**

[@UGV299K6H](@UGV299K6H) I only have 4 months of data and using one month for simulation. I could form this model / strategy completely theoretically though to be honest; although I have tuned it with the data I have. But I see your point regarding simulation size.

---

## 2022-07-16 10:43:21 - strategies channel

**Tom Cannon**

[@UCQB6S222](@UCQB6S222) this would be ideal. I've just implemented a green strategy and unfortunatly I'm getting similar negative profits in simulation - which doesn't make much sense to me ...



[@U4H19D1D2](@U4H19D1D2)

Am I correct in thinking that OrderStatus.EXECUTION_COMPLETE is only true when an order has been fully matched? So laying immediately at the BSP using MarketOnCloseOrder should give me a margin if BSP &lt; matched_back_price (which it does when I track it) but in simulation It's as if my lay order is never fulfilled. The only similar debugging I can find is here [https://github.com/betcode-org/flumine/issues/354](https://github.com/betcode-org/flumine/issues/354) Of which I think is still present in FlumineSimulation.__process_s_simulation_orders().



I also seem to be getting matched in simulation at strange prices. For ~95% it's sensible (matched at 5 &amp; BSP = 4.677) but some are far too high in my opinion (for instance matched at 170 for BSP 26) I suspect that these aren't actually getting matched - are there other reasons that EXECUTION_COMPLETE would be triggered?

---

## 2022-07-16 09:11:18 - strategies channel

**Michael**

Is one months worth of data all you have or is your strategy developed using a bigger data set and you're just using a month's worth as a hold out set for testing?



If it's the former then you simply may not have enough markets. Depending on your odds you might be asking too much of too small a data set.



If you were to bet randomly at BSP would you expect to be at zero after &lt; 1000 markets?

---

## 2022-07-15 18:43:01 - random channel

**AP**

Is anyone here using or has used the Proform racing software? Just looking to see whether people have found it useful for fundamental modelling purposes

---

## 2022-07-15 17:44:12 - strategies channel

**George**

One possibility is that you have a strategy which is highly predictive for the BSP but not necessarily highly predictive for the actual race result, and therefore greening is actually the correct way to go in this case.

However, I wouldn't base any decisions at all off of a month of data.

---

## 2022-07-15 17:22:31 - strategies channel

**Tom Cannon**

My expected returns based on EV and simulation are so wildly off I think both of your points probably means I've either made an error or discovered a very niche area of BSP's that are not representing Pr(Win). If I were a betting man :face_with_rolling_eyes: I'd assume the error :joy:.

---

## 2022-07-15 16:54:31 - strategies channel

**Tom Cannon**

Hey all,



Following from my previous post (5 posts above).  Thank you all for the pointers I'm making far better progress!



I have changed strategy and am now successful matching better than BSP (On FlumineSimulation). In fact ... I match about 100 trades correctly and 20 incorrectly per race. Which is great!



But I have vast differences in expected profit from calculation and expected profit from Flumine. Calculations make me rich :slightly_smiling_face: and simulation makes me poor :grimacing:

I'm simulating on a months worth of Horses Win data - and so expect that this is statistically significant enough to tend them to the same expectation. (If BSP is a good indicator of probability?)



For each back trade matched I calculate expected return as:



E_back = Pr(Win) * return - Pr(Lose) * stake

E_lay = Pr(Lose) * stake - Pr(Win) * return



Where:  Pr(Win) = 1/bsp,       Pr(Lose) = 1 - (1/bsp),       return = (price-1)*(stake)



Profit is calculated directly from Flumines market.blotter order.simulated.profit (which I'm assuming works from race results)



Can anyone see any issues / had any similar realisations with using BSP as an estimate of Pr(win), or have any suggestions of where I might have made an error?



Ofcourse ... I could just engineer a green at BSP method and remove the need for expected returns ... #teamgreen :face_with_rolling_eyes:

---

## 2022-07-15 13:57:12 - random channel

**liam**

this gets tricky, we need the simulation engine for paper trading but its on a per client basis, there is a flag in the `clients` class which might help?

---

## 2022-07-15 13:55:28 - random channel

**Newbie99**

Can the latest version of Flumine distinguish between types of simulation mode (by which I mean backtesting via historic data vs paper trading)?



The problem I'm trying to solve, is when in simulation (backtesting) use historic score data, but of course when in simulation (paper) use live score data.



I can check whether its in simulation mode, but is it possible to distinguish between the two, or do I need to create something myself?

---

## 2022-07-14 12:32:46 - random channel

**Mo**

1. At a glance the instructions seem reasonable

2. The file is not secure in the sense that if someone could log into your account they could read the file in plain text on disk. This is going to apply to pretty much every solution

3. I've only ever used 2FA on my master so can't comment

Some additional comments:



1. Do you not already have a configuration file for your strategy? If you do then you might as well just add the credentials to that rather than using environment variables

2. I use [https://github.com/fugue/credstash|credstash](https://github.com/fugue/credstash|credstash) for managing secrets in AWS

---

## 2022-07-14 12:15:29 - random channel

**PeterLe**

Afternoon,

If you set environmental variables (so you don't hard code your details) for use in cloud

Are these instructions credible:



[https://able.bio/rhett/how-to-set-and-get-environment-variables-in-python--274rgt5](https://able.bio/rhett/how-to-set-and-get-environment-variables-in-python--274rgt5)



Also is a .env file secure or do you need to encrypt it somehow?

In addition, how you you append the 2FA onto your password? (or do you input just once and leave it running?)



I currently do it like this:



twofa = str(input("Please enter Pass and 2FA for Sub4: "))

trading = betfairlightweight.APIClient("Removed", twofa, app_key="Removed", certs=r"C:\certs")

sorry for the noddy questions. Thanks in advance

---

## 2022-07-14 09:36:53 - general channel

**liam**

[https://github.com/betcode-org/flumine/blob/master/HISTORY.rst#221-2022-07-14|flumine 2.2.1](https://github.com/betcode-org/flumine/blob/master/HISTORY.rst#221-2022-07-14|flumine 2.2.1) released, few bug fixes but also added `SimulatedSportsDataMiddleware` this allows the ability to process betfair sports data (cricket or race) chronologically through the simulation engine with a single line:



```framework.add_market_middleware(

    SimulatedSportsDataMiddleware("cricketSubscription", "res/sportsdata")

)```

The [https://github.com/betcode-org/flumine/blob/master/flumine/markets/middleware.py#L287|middleware](https://github.com/betcode-org/flumine/blob/master/flumine/markets/middleware.py#L287|middleware) will pick up the file on the marketId and create a generator that is then called based on the publishTime of the market, this could easily be modified to simulate other historic events football/tennis/scores/custom events etc



Full example strategy [https://github.com/betcode-org/flumine/blob/master/examples/simulate-sportsdata.py#L22|here](https://github.com/betcode-org/flumine/blob/master/examples/simulate-sportsdata.py#L22|here) that places a back bet on the bowling team on a wicket :moneybag:

---

## 2022-07-14 09:28:52 - random channel

**Newbie99**

I use the market catalogue middleware example when backtesting and it all works fine:



[https://github.com/betcode-org/flumine/blob/master/examples/middleware/marketcatalogue.py](https://github.com/betcode-org/flumine/blob/master/examples/middleware/marketcatalogue.py)



However, when self recording, the market catalogues are saved as a .json.gz, so if I run the following in a standalone script:



```mc_path = '/1.200396929.json.gz'



with open(mc_path, "rb") as r:

    data = gzip.GzipFile(fileobj=r).read()

    catalogue_json_data = json.loads(data)

    print(catalogue_json_data)```

As expected it returns:



```{'marketId': '1.200396929', 'marketName': 'Over/Under 2.5 Goals', 'marketStartTime': '2022-06-22T16:00:00.000Z', 'description': {'persistenceEnabled': True, 'bspMarket': False, 'marketTime': '2022-06-22T16:00:00.000Z', 'suspendTime': '2022-06-22T16:00:00.000Z', 'bettingType': 'ODDS', 'turnInPlayEnabled': True, 'marketType': 'OVER_UNDER_25', 'regulator': 'GIBRALTAR REGULATOR', 'marketBaseRate': 2.0, 'discountAllowed': False, 'wallet': 'UK wallet', 'rules': '&lt;!--Football - Over/Unders --&gt;&lt;br&gt;How many goals will be scored in this match.&lt;br&gt; All bets apply to Full Time according to the match officials, plus any stoppage time. Extra-time/penalty shoot-outs are not included.&lt;br&gt;&lt;br&gt;&lt;/b&gt;For further information please see &lt;a href=[http://content.betfair.com/aboutus/content.asp?sWhichKey=Rules%20and%20Regulations#undefined.do](http://content.betfair.com/aboutus/content.asp?sWhichKey=Rules%20and%20Regulations#undefined.do) style=color:0163ad; text-decoration: underline; target=_blank&gt;Rules &amp; Regs&lt;br&gt;&lt;br&gt;\n', 'rulesHasDate': True, 'priceLadderDescription': {'type': 'CLASSIC'}}, 'totalMatched': 35.4, 'runners': [{'selectionId': 47972, 'runnerName': 'Under 2.5 Goals', 'handicap': 0.0, 'sortPriority': 1, 'metadata': {'runnerId': '47972'}}, {'selectionId': 47973, 'runnerName': 'Over 2.5 Goals', 'handicap': 0.0, 'sortPriority': 2, 'metadata': {'runnerId': '47973'}}], 'eventType': {'id': '1', 'name': 'Soccer'}, 'competition': {'id': '4051', 'name': 'Norwegian Cup'}, 'event': {'id': '31543907', 'name': 'Strindheim v Kristiansund', 'countryCode': 'NO', 'timezone': 'GMT', 'openDate': '2022-06-22T16:00:00.000Z'}}```

However, if I try to adapt the middleware code as follows:



```class MarketCatalogueMiddleware(Middleware):

    def add_market(self, market) -&gt; None:

        try:

            zipped_catalogue_file_path = str(get_mc_folder(market, zipped_folder_path))

            catalogue_file_path = os.path.join(MARKET_CATALOGUE_PATH, market.market_id + '_market_catalogue.json')

            if zipped_catalogue_file_path is not False:

                if os.path.exists(zipped_catalogue_file_path):

                    with open(zipped_catalogue_file_path, "rb") as r:

                        data = gzip.GzipFile(fileobj=r).read()

                        catalogue_json_data = json.loads(data)

                        print(catalogue_json_data)```

Then I just get the following error:



```Exception 'int' object has no attribute 'startswith' occured on market 1.200522372```

If I use a different approach, as follows:



```class MarketCatalogueMiddleware(Middleware):

    def add_market(self, market) -&gt; None:

        try:

            zipped_catalogue_file_path = str(get_mc_folder(market, zipped_folder_path))

            catalogue_file_path = os.path.join(MARKET_CATALOGUE_PATH, market.market_id + '_market_catalogue.json')

            if zipped_catalogue_file_path is not False:

                if os.path.exists(zipped_catalogue_file_path):

                    with gzip.open(zipped_catalogue_file_path, 'rb') as fin:

                        catalogue_json_data = json.loads(fin.read().decode('utf-8'))

                        market.market_catalogue = MarketCatalogue(**catalogue_json_data)```

Then I get the following error:



```Exception Not a gzipped file (b'{"') occured on market 1.199593125```

Now of course, I can get around this by unzipping the files first, but I feel I must be missing something obvious here, why can I unzip into memory from a static script, but not via middleware, I presume there is a logical reason and whilst it doesn't matter as there is an obvious alternative approach, I would like to understand why this doesn't work if possible?

---

## 2022-07-14 09:02:05 - general channel

**Rudeger Jamison**

ahh ok, I am doing things differently.



My current implementation is



```class DatabaseStream(BaseStream):

    """

    This stream reads from a database and updates the context with the data required

    """



    def __init__(self, sql_path: str, context_key: str, table_name: str, strategy_name_filter: str, *args, **kwargs):

        BaseStream.__init__(self, *args, **kwargs)

        self.sql_path = sql_path

        self.context_key = context_key

        self.table_name = table_name

        self.strategy_name_filter = strategy_name_filter



    def run(self) -&gt; None:

        logger.warning(

            "Starting Stream: {0}".format(self.__class__.__name__),

            extra={"update_interval": self.streaming_timeout, "context_key": self.context_key, "sql_path": self.sql_path},

        )



        while self.is_alive():

            response = self.get_sql(sql_path=self.sql_path, table_name=self.table_name)



            def callback(framework, event):

                for strategy in framework.strategies:

                    if self.strategy_name_filter in strategy._name:

                        if strategy.context:

                            strategy.context.update({self.context_key: event.event})

                        else:

                            strategy.context = {self.context_key: event.event}



            event = CustomEvent(response, callback)

            self.flumine.handler_queue.put(event)

            time.sleep(self.streaming_timeout)  # this is the time to check again```

---

## 2022-07-14 06:47:39 - general channel

**Rudeger Jamison**

but you only have access to the stuff [https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py|here](https://github.com/betcode-org/flumine/blob/master/flumine/strategy/strategy.py|here) in the strategy?



I would have to work out a way to find `time_to_next_market` or something like that?



That would have to be done with bflw and the market catalogue, yeah ?

---

## 2022-07-14 03:20:35 - general channel

**Rudeger Jamison**

Is there any smart way to trigger a stream from a strategy?



Eg I have some `model odds`  that I want updated every 5 seconds when a market is within 5 minutes of jump, but otherwise I dont care ( so dont want it to be pinging away when the markets are closed overnight )

---

## 2022-07-13 11:49:11 - random channel

**Leo**

Yeah it's a tricky one really. I use fundamental models and my general assessment is that the chances of a horse improving significantly over a new distance or first time in handicaps etc is usually overestimated in the market in comparison to its previous form. But there are definitely exceptions 

---

## 2022-07-13 08:54:15 - random channel

**LM**

is the self referring to the instance of the BaseStrategy class?

---

## 2022-07-13 03:25:39 - random channel

**LM**

Any examples anywhere of using the prices in the win market in a place market strategy (or what is the best way to get the last traded price of each runner in the win market for the corresponding races place market)?

---

## 2022-07-11 19:48:55 - general channel

**Fab**

```greyhound_strategy = GreyhoundStrategy(

    market_filter = streaming_market_filter(

        event_type_ids = ["4339"],

        market_types = ["WIN"],

    )

)



football_strategy = FootballStrategy(

    market_filter = streaming_market_filter(

        event_type_ids = ["1"],

        market_types = ["MATCH_ODDS"],

    )

)



cricket_strategy = CricketStrategy(

    market_filter = streaming_market_filter(

        event_type_ids = ["4"],

        market_types = ["MATCH_ODDS"],

    )

)



framework = Flumine(client=client)

framework.add_strategy(greyhound_strategy)

framework.add_strategy(football_strategy)

framework.add_strategy(cricket_strategy)

framework.run()```

May I ask for some clarification regarding the above Flumine scenario.



• A) Betfair adds new greyhound markets every 24H. My understanding is that the above code would receive automatically start receiving streaming messages for new markets. Correct?

• B) Would running simple strategies for 3 different sports be too tasking on a cloud machine with 1 CPU and 2GB RAM?

• C) Is there a `streaming_market_filter` combo to auto-subscribes to only football matches starting in the next 2 hours? (instead of all matches like in the example above)

---

## 2022-07-11 15:33:26 - issues channel

**Gib**

i think that worked, im now getting a certs error, so im guessing it will only work with trading.login() not trading.login_interactive()?

---

## 2022-07-08 23:30:50 - random channel

**LM**

Hey [@UBS7QANF3](@UBS7QANF3). Thanks for the great list of podcasts. I've just listened to the TPD episode you mentioned. Do you know whether betfair provides live TPD data?

Alternatively do you know if historical TPD data can be sourced to model before buying a subscription?

---

## 2022-07-08 20:35:54 - random channel

**Jonjonjon**

[@UBS7QANF3](@UBS7QANF3) What's so great about Chat With Traders? I used to listen to it, but most of the interviewees were the delusional types who think that a positive mental attitude will make you a winning trader. I don't see how my mindset affects the performance of Python betting scripts?



The worst was a guy who thought that any strategy would win with the correct mindset. Suppose you ran the same Python script as me. Suppose you think it's great and I think it's nonsense. Would that make the script perform better for you?

---

## 2022-07-08 16:05:37 - random channel

**Mo**

Haha I was going to mention Flirting with Models as well but I thought I'd written enough :sweat_smile:

---

## 2022-07-08 16:04:51 - random channel

**Ralegh**

Ah brilliant thanks for writing those out, time to sit out in the sun and listen to a couple. I don't have much to give in exchange but I've been heavily recommended [https://open.spotify.com/show/1IXldCXztfTaZeHbtcDRQI|Flirting with models](https://open.spotify.com/show/1IXldCXztfTaZeHbtcDRQI|Flirting with models) by the algotrading crowd (lots of quants plus a couple stories of gambling antics).

---

## 2022-07-08 15:38:04 - random channel

**Mo**

The absolute pinnacle is [https://twitter.com/halfkelly|Risk of Ruin](https://twitter.com/halfkelly|Risk of Ruin). It's described as "Audio documentaries about gambling" and that sums it up perfectly. If I'm nitpicking, the focus can be a bit too heavily on casino advantage play but I've enjoyed every episode nonetheless. Top pick of episode would be "A Seemingly Obvious Idea" featuring Andew Black, one of the co-founders of Betfair



Also fascinating but sadly no longer in production is Matthew Trenhaile's [https://podcast.app/inside-betting-p536238/|Inside Betting](https://podcast.app/inside-betting-p536238/|Inside Betting). I could happily listen to Matthew speak about gambling all day long. Everyone who has ever complained about Betfair Premium Charge should start by listening to Episode 14 "Betting Exchange Premium Charges"



One of the original podcasts is the [https://podcasts.apple.com/gb/podcast/business-of-betting-with-jason-trost/id1223927895|Business of Betting](https://podcasts.apple.com/gb/podcast/business-of-betting-with-jason-trost/id1223927895|Business of Betting). A big word of warning is that it has recently been taken over by Jason Trost, CEO of Smarkets who - in my very humble opinion - is a complete nob. However, don't let that put you off exploring the excellent back catalogue. There are probably too many must listen episodes to mention but to name a few: both episodes (26 and 127) with Marco Blume, director of trading at Pinnacle, episode 107 with Will Duff Gordon, the CEO of TPD - very relevant to anyone doing in-running horse racing - episode 119 with Andrew Mack, author of Statistical Sports Models in Excel volumes 1 and 2, episode 116 with Lloyd Danzig if you're interested in the US market, episode 96 with Matthew Davidow and Ed Miller, authors of The Logic of Sports Betting, episode 29 with William Ziemba who has published some standout papers on statistical modelling of horse racing, episode 28 with Dan Weston if tennis is your sport



Betting adjacent, I like [https://chatwithtraders.com/|Chat With Traders](https://chatwithtraders.com/|Chat With Traders). The host, Aaron Fifield seems quite naive but there's no doubting the quality of talent he gets on the show. Top pick would be Episode 109 with Ed Thorp who is a legend in both gambling and investing. Of some controversy on here is episode 215 featuring William Beauchamp of Seamless Capital. If you search the episodes you can pick out plenty of bettors that have made the jump to financial markets but the pure finance guys can certainly be worth listening to as well



There are quite a few US-centric podcasts like [https://podcasts.apple.com/gb/podcast/bet-the-process/id1291010585|Bet The Process](https://podcasts.apple.com/gb/podcast/bet-the-process/id1291010585|Bet The Process), [https://podcasts.apple.com/gb/podcast/be-better-bettors/id1493902736|Be Better Bettors](https://podcasts.apple.com/gb/podcast/be-better-bettors/id1493902736|Be Better Bettors) and [https://podcasts.apple.com/us/podcast/gambling-with-an-edge/id459476611|Gambling With An Edge](https://podcasts.apple.com/us/podcast/gambling-with-an-edge/id459476611|Gambling With An Edge) but personally I don't much care for them as it can seem like they're speaking a different language. It's not just the obvious focus on US sports, you're also got the increased focus on line betting, the impossible to understand odds system, the obsession with "off shore" bookmakers and Vegas, etc. etc.

---

## 2022-07-06 21:11:51 - issues channel

**Jonjonjon**

I have a strategy that places bets exactly at scheduled off.



For some markets, the scheduled off can change. In my backtests, the bets get fired off at the correct time. But in live trading, sometimes my bets get placed at the prior market start time.



I believe this is because I use "seconds_to_start", which uses "market_start_datetime", which will come from the market_book's market_definition.



In live trading, the market_start_time will come from the market_catalogue. So I am guessing that in live trading, the process that updates the market_catalogue might be misbehaving.



What would be the cleanest way to solve this?

---

## 2022-07-05 15:43:59 - general channel

**D C**

I used to do a similar thing but nowhere near on that scale. I gave it up as I found that I just couldn't separate strategies from the point of view of mutual interference. How do you get around that or are you spread across so many sports that you don't have to worry about inter strategy competition?

---

## 2022-07-05 15:36:05 - general channel

**Jonjonjon**

Good point. I probably confused myself when writing that. I think each Python script has 1 instance of a Flumine framework. Then I have a spreadsheet of parameters, and the script uses the spreadsheet to construct the strategy instances that it adds to the framework. I don't think it's elegant but I'm too old to keep up with best practices.

---

## 2022-07-05 15:28:26 - general channel

**mandelbot**

for example like this



```import logging

import betfairlightweight

from pythonjsonlogger import jsonlogger



from flumine import Flumine, clients

from flumine.streams.datastream import DataStream

from Strategy1 import Strategy1

from Strategy2 import Strategy2





logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = betfairlightweight.APIClient('username', 'password', app_key='app_key', 

					certs='/path/to/certs')

trading.login()



client = clients.BetfairClient(trading)



framework = Flumine(client=client)



markets1 = betfairlightweight.filters.streaming_market_filter(

           event_type_ids=["7"],

           country_codes=["GB", "IE"],

           market_types=["WIN"]

)



markets2 = betfairlightweight.filters.streaming_market_filter(

           event_type_ids=["4339"],

           country_codes=["GB"],

           market_types=["WIN"]

)





strategy1 = Strategy1(

    name="Strategy1",

    market_filter=markets1,

    max_order_exposure=50000000,

    max_selection_exposure=6000000,

    max_trade_count=200,

    max_live_trade_count=1,

    context={"stake": 2},

)



strategy2 = Strategy2(

    name="Strategy2",

    market_filter=markets2,

    max_order_exposure=50000000,

    max_selection_exposure=6000000,

    max_trade_count=2000,

    max_live_trade_count=2,

    context={"stake": 2},

)



framework.add_strategy(strategy)

framework.add_strategy(strategy2)



framework.run()```

---

## 2022-07-05 15:20:54 - general channel

**mandelbot**

[@UQL0QDEKA](@UQL0QDEKA) just use `framework.add_strategy(strategy)` to add more strategies to a framework

---

## 2022-07-05 14:40:37 - general channel

**Jonjonjon**

Within a Python instance, they use the same connection for market data. Mostly, they use the same Strategy subclass, but with different parameters.

---

## 2022-07-05 14:35:23 - general channel

**Aaron Smith**

150 instances? I usually put a few strategies in each instance, but you d be having close to 1k strats running at a time if that was the case? Do you guys make 1 instance per strategy? Also how is so many strategies even possible in regards to subscription limits??

---

## 2022-07-05 14:13:31 - general channel

**mandelbot**

FYI you can put more than one strategy into an instance

---

## 2022-07-05 14:09:44 - general channel

**liam**

Strategy/market/count dependant, personally I want a CPU per instance 

---

## 2022-07-05 11:38:12 - general channel

**Phil Anderson**

Hi all. I'm having problems with market_start_time filter. I've used this same filter with football and it works fine:



```comp_filter = filters.market_filter(

                                    event_type_ids=[7],

                                    venues=[race_edit],

                                    market_countries=['GB', 'IE'],

                                    market_start_time={

                                        "from": current_time2.format(datetime.date.today()),

                                        "to": "{0}T14:45:00Z".format(datetime.date.today())

                                       }```

But for horse racing it's showing races after 14:45. I was actually looking to find the exact time (i.e. market_start_time=["14:45"] but it didnt like that so was just going to put "from2 and "to" as race start time, but realised the cutoff time didn't seem to have any effect.



In essence my questions are:

1. Is there something different with horse racing why my cutoff time doesnt work?

2. How do I find a specific race?

I can cycle through the races and match the time but I'm sure there must be a simpler way to do it.



EDIT:



OK so I've actually got it working. After the original filter i've put:



```results = trading.betting.list_events(

    filter=comp_filter

)



for i in results:

    print(i.event.id, i.event.name)

    market_types_filter = betfairlightweight.filters.market_filter(event_ids=[i.event.id],

                                                                   market_type_codes=["WIN"],                                                                           

                                                                   market_start_time={

                                        "from": "{0}T14:45:00Z".format(datetime.date.today()),

                                        "to": "{0}T14:45:01Z".format(datetime.date.today())

                                       }

                                                                   )```

Now this works fine, but I'd still like a way of putting in the start time if possible. something like:



```market_start_time = "{0}T14:45:00Z".format(datetime.date.today())```

Whatever way I try it I get highlighted as an error. Does the market_start_time ave to have a "from" or a "to". And if so is there another way to do this?



Thanks in advance for any help.

---

## 2022-07-03 14:38:22 - issues channel

**Dave**

Haven't improved any models since Jan.  Worked a liiittle on execution, also tried quadrupling my stakes and got my arse handed to me so dialed it back to usual sizes.

---

## 2022-07-02 22:06:22 - strategies channel

**thambie1**

My models have changed way too much for that to be a fair comparison. That said, I'm not getting the impression that my volumes are unreasonably low

---

## 2022-07-02 13:56:16 - strategies channel

**nthypes**

&gt; First thing I would do is run a simple simulation where you assume that you had 100% of your bets matched at your generated prices Vs actual win/lose outcomes. That will tell you how your prices compare to real world results and should generate a profit/loss close to zero if your model is well calibrated.

If shows a profit in this scenario, the model is not calibrated / bad?

---

## 2022-07-02 13:18:25 - strategies channel

**birchy**

[@U01A64T6DJQ](@U01A64T6DJQ) 

As [@USYQKE5HN](@USYQKE5HN) has said, keep it simple. Getting matched at value prices is a bigger issue than generating probabilities. First thing I would do is run a simple simulation where you assume that you had 100% of your bets matched at your generated prices Vs actual win/lose outcomes. That will tell you how your prices compare to real world results and should generate a profit/loss close to zero if your model is well calibrated.



Assuming the above generates expected results, THEN you can run backtests in Flumine:

`if betfair_available_price &gt; my_price:

    side = 'BACK'

if betfair_available_price &lt; my_price:

    side = 'LAY'`

The Flumine simulation engine will give you a good approximation of which bets will get matched, which ones won't and a simulated "real world" profit/loss which will hopefully be &gt; 0. You should also calculate the "what if I bet at BSP instead" profit/loss, where you replace the simulated matched price with BSP, keeping the matched amount the same. If the BSP performance is better, it's back to the drawing board.



FYI: The above assumes straight betting and no greening/hedging nonsense.

---

## 2022-07-02 11:20:04 - random channel

**river_shah**

Checking if of interest to anyone in the community: I am looking for a developer to help setup some core infra / data collection / middleware / simulation systems. I am too occupied on other projects and have not done this work properly even after 18+ months of betting.



Will pay competitive day rates for the initial build phase and any ongoing support needed. Familiarity with `flumine` and `bflw` a must. Please direct message me if of interest and we can walk through more details.

---

## 2022-07-01 20:14:40 - strategies channel

**James T**

I would try backtesting earlier in the day, say 1 hour before race start, or at around 9am, for example. With those bets that get placed (assume same strategy of model vs market price) do they beat bsp? i.e. can you close at bsp for a better price consistently?

---

## 2022-07-01 20:12:11 - strategies channel

**James T**

Personally, to keep it simple I'll just use bsp for backtesting sometimes. You can achieve something close to bsp if you think about execution strategy.



vwap calculated a few seconds before the off is going to be very close to bsp. But that is equally impossible to know since you don't know when it's going to go off!



vwap across the whole history of pre-race is not going to be close to bsp.

---

## 2022-07-01 20:09:11 - strategies channel

**James T**

When is your model price calculated? Is it calculable at any time, or only at the off, or does it use BSP as an input as well?



If it's calculable at any time then you could also try backtesting betting earlier in the day. Prices tend to less efficient then, but there is less volume available. But to do that you'll need to use tick data.

---

## 2022-07-01 20:05:37 - strategies channel

**James T**

I think you're overthinking it. Just backtest it over 10,000 runners for example - if modelWinOdd &gt; bsp then back at bsp price, if modelWinOdd &lt; bsp then lay at bsp price. Make sure you're calculating your P&amp;L correctly!



1. Use simple staking proportional to price.

2. Try adding a threshold where you only back / lay if model disagrees with market &gt; certain impl %

3. Stake relative to your estimated edge, so proportional to price but also abs(modelImpl - marketImpl)



You need to do this for each individual runner - don't bucket runners into a "price range". Treat each individual runner as its own bet. Only then will you properly be benchmarking against bsp.



For your model to stand a chance as a working strategy then the above should really work.

---

## 2022-07-01 16:33:17 - strategies channel

**nthypes**

When my `winOdd` predicted by the model is greather than pre-play vwap, the average BSP is 14 and median of 7.6.



My model predicted odd is 4 or 4.02

---

## 2022-07-01 16:19:32 - strategies channel

**Alessio**

If your model predicts odd X you expect the horse to win 1/X. In your first case, the 95% CI is 9.6% to 13.3%, which includes the 10.5% you have. Great. This means your model is not that bad at computing odds. This is the calibration and prediction aspect.

---

## 2022-07-01 16:13:00 - strategies channel

**nthypes**

&gt; When do odds of your model and odds of betfair disagree, what happens, for example

Hm, I didn't understand that part.

---

## 2022-07-01 16:06:26 - strategies channel

**Alessio**

On one hand, you may have a calibration issue imho: your model says it should have ~12.5% of winning probability and you get 22% ?  It seems to scale correctly from this example (double the odds, half the probability), but the real question is not whether the model has an edge on its own, but whether it has an edge w.r.t. what other models do. When do odds of your model and odds of betfair disagree, what happens, for example?

---

## 2022-07-01 16:00:04 - strategies channel

**Unknown**

Suppose the following dataframe, filtered by horses who model predicted odds was between `8 &lt;&gt; 8.02`. `winOdd` is the model projected odds for the horse.



From the universe of *1127* horses, *128* horses finished in 1st (~10.5%).



In the second example filtered by horses who model predicted odds was between `4 &lt;&gt; 4.02`



From the universe of *889* horses, *213* horses finished in 1st (~24%).



It's a valid approach to confirm that the model has an edge?

---

## 2022-06-30 21:48:01 - strategies channel

**Tom Cannon**

Interesting, thanks for the reply. I've been mainly focused on taking small profits from selection greening back/lay over short periods of time. What do you count as value? Is just value on BSP?



So my objective would be to model the current state of the market and predict an accurate BSP, and then I can make value decisions based on this prediction, instead of short term price movements?

---

## 2022-06-30 21:35:03 - strategies channel

**liam**

Any strategy that makes money needs to get value so you are heading in the right direction. Your question is very open but many (including myself) are profitable working purely off market data and many others are profitable off free form data, you don't have to spend money to find an edge 

---

## 2022-06-30 21:10:59 - strategies channel

**Tom Cannon**

Hey all, I've been working on and off with price only indicators for awhile. For short term price changes, my predictions are not too bad, but i'm finding it hard to get matched at predictions to make any decent money (even in back-testing).



So I'm looking to change strategy to a value based approach. I'm wondering if any of you have a suggestion of where to gather runner (or team) data, and a ball-park estimation of how much the data costs to have enough for predicting successful value? I'm currently doing a Machine Learning PhD and hoping to see how well I can apply it, but this does mean I'm on somewhat of a budget!



Thank you!

---

## 2022-06-30 18:07:05 - general channel

**liam**

How are you initiating the strategy, looks like you have max_selection_exposure set to 30

---

## 2022-06-30 18:01:51 - general channel

**PeterLe**

Hi Liam, This is hte message (which i can now see is coming from flumine) : "Violation", "violation_msg": "Order has violated: STRATEGY_EXPOSURE Error: Potential selection exposure (32.00) is greater than strategy.max_selection_exposure (30)"

---

## 2022-06-30 13:14:12 - general channel

**PeterLe**

Afternoon, I noticed I had some exposure message yesterday. I have the exposure setting at account level (ie via my betfair account) and also in tradingcontrols. Is there anywhere else I would need to set this value in Flumine? Thanks. (by the way; if you breach the exposure value in tradingcontrols, is the message you receive the same as if you exceed the exposure level set at account level? (sorry for simple question :grinning:) Thanks

---

## 2022-06-30 12:32:00 - strategies channel

**nthypes**

No. Based on a model who gives each horse a rating.

---

## 2022-06-30 12:28:47 - strategies channel

**D C**

What modelling technique are you using to estimate the probabilities that you say are summing to more than 1

---

## 2022-06-30 12:16:55 - strategies channel

**D C**

What technique are you using to model?

---

## 2022-06-30 12:12:23 - strategies channel

**D C**

That sounds more like the way you are doing the modelling than the approach itself.

---

## 2022-06-30 01:45:53 - strategies channel

**nthypes**

The best way to model odds is individual modeling, which means find a win probability for every and each horse in a race, or, find the favorite, predict the odds for the favorite and all other horses odds will derivate from this odd?

---

## 2022-06-29 17:15:25 - strategies channel

**ShaunW**

[@UUE6E1LA1](@UUE6E1LA1) BSP is going to be the last traded mid or thereabouts. If its x away from your model price get on it. If the BSP est comes back towards your price then cancel. Something like that.

---

## 2022-06-29 17:09:19 - strategies channel

**D C**

Sorry if this is a bit of a thick question, but what is meant by betting "against" BSP? You don't know what BSP is going to be before the off so you just use it as a benchmark to establish if you are getting CLV ?? I've never placed a BSP bet in my life and I am not even sure how they calculate it so can someone explain what betting "against" it means?

---

## 2022-06-29 13:45:00 - general channel

**Wayne**

Thank you, and I do appreciate the feedback - not that my word counts for anything on here but I promise this is real. I consult for most of the established trading firms globally. The salaries on the low latency focussed dev roles are not much different to those in finance nowadays

---

## 2022-06-29 12:54:11 - general channel

**Wayne**

Hey all, I hope this posting is best placed in the general channel.



I am helping to scale a trading syndicate, so far they have a team of 17 quants and quant devs and focus on football and horse racing - it is not all Betfair focussed. Looking to hire developers with experience and interest trading sports – that led me here.



The client uses a mix of low latency and value-based approaches, latency is quite key to some strategies they run so C++ experience is a big plus. Compensation will consist of base salary, guaranteed bonus for the first year (team profit share after) and a sign on bonus to compensate for any strategy you have running currently. As a guide, dependent on experience base salary can range from £110-200k (huge range I know this is not helpful).



Let me know if you're interested in hearing more! Or let me know if this is not the right place for this message and I will not reoffend!

---

## 2022-06-28 23:17:13 - strategies channel

**AndyL**

Ive heard that said before that assume your model will not be as good as BSP, ie straight betting against it will be -ve.

But a model is a model,ie you are hoping it is close to the truth... so that helps you to then combine it with factor X, to get an edge. Because you know betting on both +X and -X is -ve, but maybe just +X has an edge.

---

## 2022-06-28 18:02:07 - strategies channel

**Mr West**

The only way to know if a strategy works is to run it in the live market. There's only so much you can do with back testing. Use small stake and be prepared to lose some money.

---

## 2022-06-28 17:22:25 - strategies channel

**John Foley**

Enjoying reading some of the discussion above in relation to backtesting. Very helpful to anyone like myself who has made the humbling decision to try modelling from fundamentals and betting pre-live close to the off :slightly_smiling_face:

Say you have a model and you’re pretty sure your probabilities are better than BSP (humour me). Next sensible step would be to bet against BSP historically and hope for a profit. What strategy/judgement do people use to be sure that the profit is due to edge and not noise? Is there a quantitative way to combine the sample size, the prices you’re taking, your staking plan and coming up with a “degree of certainty” that your profit is definitely due to an edge? In my head what I’m trying to get to is almost a bayesian result where you say “im x% certain that I have an edge here”

---

## 2022-06-26 14:15:10 - issues channel

**Beginner**

[@UBS7QANF3](@UBS7QANF3) Ah ok, so it was definitely the wrong estimation model I looked at, now it makes perfect sense! Thank you very much!

---

## 2022-06-26 13:39:18 - issues channel

**Beginner**

Yesterday I discovered that Heroku and several other code clouds don't have a path to tell the code where to find the certificate files: `cert_files=('./certs/bf_certs.pem')`



So I tried another approach, logging into my machine, saving a pickle file and uploading it to Google Drive:



```with open('betfair_login.pickle', 'wb') as handle:

    trading = betfairlightweight.APIClient('email', 'pssw', app_key='app_key', cert_files=('./certs/bf_certs.pem'),session=requests.Session())

    trading.login()

    pickle.dump(trading, handle, protocol=pickle.HIGHEST_PROTOCOL)```

And on Heroku use `urllib.request.urlopen` passing the url of the Drive file:



```from urllib.request import urlopen

    loaded_pickle_object = pickle.load(urlopen("[https://drive.google.com/file/d/xxxxxxxxxxxxxxxx/](https://drive.google.com/file/d/xxxxxxxxxxxxxxxx/)"))

    trading = loaded_pickle_object```

However, when trying to open it generates an error `invalid load key, '&lt;'.`



Could someone help me find an option to use the betfairlightweight when there is no way to pass the path where the certificates are?

Thank you in advance and happy Sunday to all!

---

## 2022-06-24 16:47:36 - issues channel

**Aaron Smith**

Hi ppl!

I m trying to extract bsp (and result) from historic streaming files. Here is what i do:



```def get_selection_id_to_result(trading, streaming_file: str) -&gt; dict:

    stream = trading.streaming.create_historical_generator_stream(

        file_path=streaming_file,

        listener=StreamListener(

            max_latency=None, update_clk=False,

        ),

    )

    with patch("builtins.open", smart_open.open):

        g = stream.get_generator()

        selection_id_to_result = {}

        for market_book in g():

            market_book = market_book[0]

            if market_book.status == 'OPEN':

                continue

            for rb in market_book.runners:

                if rb.selection_id not in selection_id_to_result:

                    selection_id_to_result[rb.selection_id] = {'bsp': float('nan'), 'result': ''}

                sp = get_sp(rb)

                if isinstance(sp, float):

                    if not math.isnan(sp):

                        selection_id_to_result[rb.selection_id]['bsp'] = round(sp, 3)

                selection_id_to_result[rb.selection_id]['result'] = rb.status



    return selection_id_to_result```

`get_sp`  is liams function from flumine/utils.

Mostly it works, but sometimes it doesnt get the sp even though there is one. Does anyone have an idea what could be causing this?

---

## 2022-06-23 10:18:59 - strategies channel

**James T**

You're still better off benchmarking against market prices like BSP since, like Michael said in the other thread, if you can't beat market prices then it's pointless anyway. How can you best test if your model is better than market prices? Well just bet against them. Market price &gt; model then back, market price &lt; model then lay. You said when you did this that your returns were either zero or very volatile. That just means your edge doesn't exist or isn't big enough against the market. 



My alternative recommendation is betting earlier in the day to match less efficient prices, but there's limited liquidity. 

---

## 2022-06-22 23:09:57 - strategies channel

**nthypes**

Found this: [https://neptune.ai/blog/brier-score-and-model-calibration|https://neptune.ai/blog/brier-score-and-model-calibration](https://neptune.ai/blog/brier-score-and-model-calibration|https://neptune.ai/blog/brier-score-and-model-calibration)

---

## 2022-06-22 22:54:51 - strategies channel

**nthypes**

Maybe is a dumb question, but what a _calibrated_ model means [@UBS7QANF3](@UBS7QANF3)?

---

## 2022-06-22 22:53:52 - strategies channel

**Mo**

No this just tells you the model is well _calibrated_, nothing about the accuracy

---

## 2022-06-22 22:48:16 - strategies channel

**Unknown**

`winProb` is the predicted probability of win.

`total` is the total number of horses that the model identified within this range of probability of win

`winners` is the numbers of horses from the total that finished in 1st place

`ratio` is winners/total



It's ok to quantify the model quality/accuracy based on winProb vs ratio?

---

## 2022-06-22 15:10:44 - strategies channel

**Michael**

if your model doesn't return more accurate prices than the market at the moment of analysis then you can't do anything with it. Just having a brier score of X isn't of any consequence.



That said just saying "if odds &gt; model odds" is a bit simple, you could start by looking for the greatest differences and work from that point.



There's no magic anywhere though, you've got to price better than the market.

---

## 2022-06-22 13:42:47 - general channel

**EJono**

Im struggling to find any documentation on the inplayservice end point. Is there a resource or page i can reference to find out requests limits for this service and other important parameters to be aware of. Is there a problem hitting the endpoint as often as possible doing something like:



`while True:`

    `response = [http://trading.in|trading.in](http://trading.in|trading.in)_play_service.get_scores(event_ids=[EVENT_IDS])`

    `queue.put(response)`



where EVENT_IDS can be be anywhere from 50 to 1000 elements in length. Cheers

---

## 2022-06-22 12:50:08 - strategies channel

**mandelbot**

Perhaps filter/combine with some sort of pricing model.

---

## 2022-06-22 12:48:27 - strategies channel

**mandelbot**

Is your model price based or fundamentals based?

---

## 2022-06-22 12:45:22 - strategies channel

**nthypes**

Actually, let's say is not equal, but quasi-equal.



Given that BSP has a Brier Score of ~0.08, and the model has a Brier Score of 0.09.

---

## 2022-06-22 12:39:20 - strategies channel

**nthypes**

Let's suppose that you found a model that his accuracy is equal to the BSP. What are your thoughts on the best strategy to exploit this model? Looks like that a simple BACK if odds are above the predicted value has a poor performance/high variance.

---

## 2022-06-22 09:09:53 - random channel

**Mo**

Depends on the strategy

---

## 2022-06-21 21:56:40 - random channel

**birchy**

However many it takes to get to the CPU running at 99%? :grinning: 

Serious answer...depends on how much computing each strategy uses. I don't think there's a limit in flumine other than CPU limitations, particularly on AWS. I guess latency would be the key metric?

---

## 2022-06-20 09:50:35 - strategies channel

**Jorge**

I basically look at expected value and std when evaluating preplay strategies. And also when checking if a strategy that I have put live is performing as it "should"

---

## 2022-06-20 09:48:12 - strategies channel

**Jorge**

Adding to Ruben's question. If I calculate the expected value from BSP, does it make sense to estimate the variance that my strategy has using: Var[X] = E[X^2] - E[X]^2 ?

---

## 2022-06-18 16:46:44 - general channel

**Halil Erdoğan**

Hello guys :wave: I have a question regarding the exchange API of betfair and i am using [https://github.com/betcode-org/betfair](https://github.com/betcode-org/betfair). Currently I am working on upcoming F1 Race and would like to get all traded data. When I am getting _streaming update,_ i can just see 3 _ladder_ in the `"trd"` OTOH, if you check [https://graphs.betfair.com/#/1.200149997/10997893/0](https://graphs.betfair.com/#/1.200149997/10997893/0) you can see that there are many more ladders which are already _traded_. Are there any way to get all of those ladders?

```output_queue = queue.Queue()



listener = betfairlightweight.StreamListener(output_queue=output_queue)

stream = trading.streaming.create_stream(listener=listener)

market_filter = streaming_market_filter(market_ids=[1.200149997])



market_data_filter = streaming_market_data_filter(

    fields=["EX_BEST_OFFERS_DISP", "EX_BEST_OFFERS", "EX_ALL_OFFERS", "EX_TRADED", "EX_TRADED_VOL", 

                "EX_LTP", "EX_MARKET_DEF", "SP_TRADED", "SP_PROJECTED"],

    ladder_levels=10)





streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=2000)





t = threading.Thread(target=stream.start, daemon=True)

t.start()

while True:

    updates = output_queue.get()

    for update in updates:

        print(update.json())

    break # just for testing purpose, will be removed later on!



# id of leclerc -  10997893



for update in updates:

    for rc in update.streaming_update["rc"]:

        if rc["id"] == 10997893:

            print (rc["trd"])```

---

## 2022-06-18 08:42:43 - strategies channel

**Mo**

Otherwise I would say this is standard practice for evaluating a strategy that trades pre-event in sports where there is either a literal BSP or the market can be assumed to be efficient at the off

---

## 2022-06-18 08:39:13 - strategies channel

**Ruben**

What are your thoughts on evaluating a strategy that places preplay bets by taking the set of bets placed during a period of time and randomly sampling bets placed and simulating the event outcome by the market inferred probabilities from the BSP, right before the off. As a way to create multiple realizations of the bets observed, as opposed to just keeping the single realization that we observed

---

## 2022-06-16 16:57:04 - issues channel

**RMG**

Have created keys with XCA, uploaded .crt to BF security, but when i try and use trading.login() I'm getting similar errors to above:  Max tries exceeded with url: /api/certlogin.

---

## 2022-06-16 06:11:57 - general channel

**liam**

That is context per strategy

---

## 2022-06-16 02:59:37 - general channel

**Rudeger Jamison**

Hey - I cant work it out - does doing :point_down: work out your runner exposure in your specific strategy or across all strategies running on Flumine?



```            runner_context = self.get_runner_context(

                market_id=market.market_id, selection_id=runner.selection_id, handicap=runner.handicap

            )```

---

## 2022-06-15 15:18:53 - strategies channel

**D C**

[@U9JHLMZB4](@U9JHLMZB4) If it is scaled correctly yes. For example, I can see the wisdom of weighting stake according to ask price but not using Kelly. If I have a model that the 1000-1 available is huge value when in reality it is not value then I could end up placing much larger chunks. I would want to make sure my probabilities were pretty accurate before I went anywhere near Kelly. It's only optimal if your probabilities are up to the task.

---

## 2022-06-15 14:32:38 - strategies channel

**Michael**

Regarding how your plot looks, realistically just the look of a backtest plot doesn't tell you anything in isolation. Say for example you had massively overfitted your model, you could have a brilliant looking plot but it would be wrong to put any faith in it. If you want to have confidence in your strategy performing I think the best way is to develop it using a process that you can have confidence in. Only you can say whether you've done that.

---

## 2022-06-15 14:12:18 - strategies channel

**nthypes**

Second one: strategy bet on only a small percentage of 'qualifying' markets



First I qualify the selection and run 1/4 kelly, after that I qualify a second time to consider only selections that produced &lt;= $10 kelly stake.

---

## 2022-06-15 14:10:31 - strategies channel

**Michael**

Ok, so that's a small percentage of all the HR markets in that time, is that because only some small set of markets qualify (only 6f flat races or whatever) or does your strategy bet on only a small percentage of 'qualifying' markets?

---

## 2022-06-15 13:59:57 - strategies channel

**Unknown**

With 1/4 Kelly, only on stakes &lt;= $10

---

## 2022-06-15 13:55:31 - strategies channel

**nthypes**

About the volume, maybe I can put a trigger to only simulate Kelly stakes of maximum $10? Maybe this can solve "partially" the volume problem with a realistic assumption?

---

## 2022-06-15 13:53:38 - strategies channel

**Unknown**

I made another selection rule, to restrict the model selections using VWAP.



With $1 fixed stake:

---

## 2022-06-15 13:37:45 - strategies channel

**Mo**

What odds are you putting into your Kelly calculation? You don't know what BSP is going to be in advance...

---

## 2022-06-15 13:27:48 - strategies channel

**D C**

I'd personally use flat staking to try and get a feel for how the strategy performs. Don't try stake manipulations to try and force something. I know Kelly is "optimal" but try and find out the quality of your probabilities first. Just an opinion - I'm pretty low on the food chain.

---

## 2022-06-15 13:18:39 - strategies channel

**Unknown**

*Strategy P/L Critic*



The following graph is a simulated strategy (implemented with 1/4 Kelly) bankroll cumulative profit/losses for ~1300 events. Any insights about the profit curve? The most intriguing for me are these downtrends.



Initial Bankroll: *$100*



Also, one part that intrigues me is that until the event no *400* it's look a solid growth pace, but after event *600* the growth explodes.

---

## 2022-06-15 13:06:24 - strategies channel

**nthypes**

`favoriteProbability`: my model probability prediction for the horse with the higher predicted probability of win



`favoriteBsp`: the bsp of the horse above

---

## 2022-06-15 12:26:51 - random channel

**liam**

You can change it per running instance using `config.customer_strategy_ref` however best practise is to use `loggingcontrol` for all order recording

---

## 2022-06-15 11:52:19 - random channel

**LM**

I am passing the name parameter to a strategy but the customer_strategy_ref I am getting when hitting the list_cleared_orders API are the IP address of the machine running the strategy. What am I doing stupidly?

---

## 2022-06-15 09:40:35 - strategies channel

**Peter**

It depends somewhat on the type of model, but in general I’d argue that models don’t have profitability. Expected profitability is calculated for strategies, which wrap predictive models with staking plans and triggers.



So one approach to assessing profitability is to take a large number of events whose outcomes weren’t used to build the model and use it to make predictions (usually in the form of probabilities) for those outcomes. Then use the chosen triggers to evaluate which selections should be traded and the side for that trade, and use the staking plan to determine its size. The available odds and actual outcomes can then be used to calculate whether each trade would have been a profit or a loss. Finally profitability can be calculated by summing the profits and losses and dividing by the total exposure (i.e. the stakes for back bets and the liability for lay bets).



I also like to order trades by datetime and plot the cumulative profit as that gives a clue as to the frequency and size of drawdowns.



In practice though the whole process is much more iterative than this and a lot of work (for me at least) goes into determining the triggers and evaluating different staking plans.



Moreover, if you’re offering, rather than taking prices, you can’t assume that you’re going to be matched for all trades. Running the strategy through the Flumine backtesting process (assuming you have the data for those events) can give an indication as to which are likely to be matched, which can have a huge impact on the profitability of a strategy.



There’s also a step in my process, way before I even start to consider profitability, where I evaluate the model’s “effectiveness”. One way of doing this is to calculate the Brier Score for its predictions and compare it to the available odds. Rarely will it be better (if it is it’s time to break out the champagne) but you may find types of bet in the overall population where the model outperforms the odds, and that’s where you’ll find value.

---

## 2022-06-15 08:23:47 - random channel

**Mo**

[https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723](https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723)

[https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175](https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175)

[https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458](https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458)

[https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522](https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522)

[https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X](https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X)

[https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139](https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139)

[https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975](https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975)

---

## 2022-06-15 08:19:52 - random channel

**D C**

Might be worth thinking about whether you want to base something off fundamentals or market data.  If the former, you will need to buy/find/scrape data but there is a school of thought that you won't find anything useful in public domain / free data. If the latter, start recording betfair market prices for markets of interest (probably a good idea to do that ASAP anyway). I don't use it myself but I believe that flumine does this so that might be a good place to start. Depending on your knowledge of betting, it might be useful to read some basic books on the subject - [@UBS7QANF3](@UBS7QANF3) used to have a link to a list of good reads in this area so you might be able to find that on one of the channels. Ultimately it depends on what you want to achieve but be warned you can waste literally hundreds/thousands of hours (I certainly have and I am definitely not alone) pursuing things that don't work so be very aware that success really is not guaranteed if being successful is equlvalent to being profitable.

---

## 2022-06-15 00:28:49 - strategies channel

**nthypes**

Folks, whats the best way to test a model profitability? There is any guidance about this subject?

---

## 2022-06-14 23:04:52 - random channel

**Jonjonjon**

A good place to start will be the Flumine examples. Watching Youtube tutorials about Betfair trading might reduce, rather than increase, your chances of success.

---

## 2022-06-14 22:58:17 - random channel

**Steve**

Hey all! :slightly_smiling_face: I’m brand new here and I’m trying to figure out how much more I need to study before I should put together my first betting angle/model using statistics and data analysis. What exact prerequisite knowledge should I have before even attempting to do so? I’m specifically interested in doing Horseracing if that helps.



I’ve got a background in Math (studied Civil Engineering at uni) and I’ve studied Python for a few months now (was playing around with Selenium in Pycharm to automate work things) but not too confident on what I should be learning exactly from all the Python content out there. I’m just wondering what the next steps for myself are. I’ve watched a few tutorials on the Betfair Youtube channel and have had a look through a few resources.



I'm just trying to put together a learning curriculum for myself to give myself a realistic timeline and tangible goal to work towards, and I feel like there’s more to it than just what I’ve found as I don’t know what I don’t know, so does anyone have any suggestions? Also let me know if this question has been asked already as I couldn’t find a similar thread anywhere.

---

## 2022-06-14 08:59:38 - betfair-news channel

**Mo**

I agree with [@UGV299K6H](@UGV299K6H) but in the mean time some brief comments:



1. I think it's pointless to learn R if you already know Python

2. Domain knowledge is very valuable - i.e. how the Betfair API works, how betting in general works, how horse racing works. For example, the choice of modelling technique will be largely irrelevant compared to knowing the valuable factors to put into your model. I would prioritise learning these above anything you've mentioned

---

## 2022-06-13 23:28:44 - betfair-news channel

**Steve**

Hey all! :slightly_smiling_face: I’m brand new here and I’m trying to figure out how much more I need to study before I should put together my first betting angle/model using statistics and data analysis. What exact prerequisite knowledge should I have before even attempting to do so? I’m specifically interested in doing Horseracing if that helps.

I’ve got a background in Math (studied Civil Engineering at uni) and I’ve studied Python for a few months now (was playing around with Selenium in Pycharm to automate work things) but not too confident on what I should be learning exactly from all the Python content out there. I’m just wondering what the next steps for myself are. I’ve watched a few tutorials on the Betfair Youtube channel and have had a look through a few resources that I think I should go through:

1. Learn Intro to Stats 110x - [https://learning.edx.org/course/course-v1:HarvardX+STAT110x+2T2021/home](https://learning.edx.org/course/course-v1:HarvardX+STAT110x+2T2021/home)

2. Learn how to use R - using [http://Datacamp.com|Datacamp.com](http://Datacamp.com|Datacamp.com)

I'm just trying to put together a learning curriculum for myself to give myself a realistic timeline, and I feel like there’s more to it than just what I’ve found as I don’t know what I don’t know, so does anyone have any suggestions? Also let me know if this question has been asked already as I couldn’t find a similar thread anywhere.

---

## 2022-06-13 11:54:23 - betfair-news channel

**Oliver Archer**

Hi all, potential noob question incoming.. I'm looking to write an automated trading script in Python that uses a scheduler to run every couple of minutes. I could run it on my local machine but ideally don't want to have to have my laptop on 24/7 so looking to move it to the cloud. I've previously written a similar automated script trading crypto through a Binance API using a combination of Kaggle notebooks and PythonAnywhere (followed a guide on Towards Data Science) but when I try to do the same using betfairlightweight I get a 403 error when logging in which I'm assuming is a result of the servers being based in the US. So question is, how would people recommend I move my script to the cloud? Would ideally like to use the Kaggle/PythonAnywhere route if at all possible given I'm paying for that already, but can sign up to something else if I have to! Thanks in advance!!

---

## 2022-06-11 15:32:16 - issues channel

**Brøndby IF**

[@UFTBRB3F1](@UFTBRB3F1) So, but in `trading.betting.list_events` I put a filter so that it only pulls event ids that contain at least some of the mentioned markets, correct?



So it wouldn't make sense for a game that started 0-0 or that is 2-1 to appear with a blank market return.



Detail, if I run every 1 second, for example, I think it would make more sense for failures of thousandths of difference to happen, but this happens by calling 1 time per minute, so it doesn't seem to me that it's a coincidence to always get it right at the time of the problem, must have some little detail that lasts for at least 1 minute or more (I think. Haha)



Or am I missing something because of my lack of knowledge?

---

## 2022-06-11 09:20:55 - issues channel

**Rudeger Jamison**

```    def _process_cleared_orders(self, event):

        if event.event.orders:

            client = boto3.client("kinesis", region_name="eu-west-1")

            orders = [json.dumps(o.__dict__, default=str).encode("utf-8") for o in event.event.orders]

            self._write_logs(client=client, data=orders, write_table="cleared_orders")



    def _process_cleared_orders_meta(self, event):

        orders = event.event

        updated_orders = []

        for order in orders:

            if order.order_type.ORDER_TYPE == OrderTypes.LIMIT:

                size = order.order_type.size

            else:

                size = order.order_type.liability



            if order.order_type.ORDER_TYPE == OrderTypes.MARKET_ON_CLOSE:

                price = None

            else:

                price = order.order_type.price



            order_data = {

                "bet_id": order.bet_id,

                "market_id": order.market_id,

                "selection_id": order.selection_id,

                "trade_id": order.trade.id,

                "date_time_placed": order.responses.date_time_placed,

                "price": price,

                "price_matched": order.average_price_matched,

                "size": size,

                "size_matched": order.size_matched,

                "side": order.side,

                "market_type": order.market_type,

                "elapsed_seconds_executable": order.elapsed_seconds_executable,

                "customer_strategy_ref": order.trade.strategy.name,

                "order_status": order.status.value,

                "market_note": order.trade.market_notes,

                "trade_notes": order.trade.notes_str,

                "order_notes": order.notes_str,

                "is_cleared_order": True if order.cleared_order else False,  # it is either None or True, so need to coerce

                **order.context,

            }

            updated_orders.append(json.dumps(order_data, default=str).encode("utf-8"))



        if updated_orders:

            client = boto3.client("kinesis", region_name="eu-west-1")

            self._write_logs(client=client, data=updated_orders, write_table="cleared_orders_meta")```

---

## 2022-06-10 20:46:06 - issues channel

**Brøndby IF**

Good afternoon everyone!

At certain times of the day, when I pull up the list of live football games ids that contain certain markets:



`markets_base = [`

        `'FIRST_HALF_GOALS_05','FIRST_HALF_GOALS_15','FIRST_HALF_GOALS_25',`

        `'OVER_UNDER_05','OVER_UNDER_15','OVER_UNDER_25','OVER_UNDER_35','OVER_UNDER_45','OVER_UNDER_55','OVER_UNDER_65','OVER_UNDER_75','OVER_UNDER_85'`

        `]`



`market_filter = betfairlightweight.filters.market_filter(`

        `event_type_ids=['1'],`

        `in_play_only=True,`

        `market_type_codes=markets_base`

    `)`

`soccer_events = trading.betting.list_events(filter=market_filter)`



Like for example: 31518957



And I immediately use these ids to collect the game's market data:



`filter_catalog_markets = betfairlightweight.filters.market_filter(`

            `event_ids=[event_id],`

            `market_type_codes = markets_base`

            `)`



        `catalog_markets = trading.betting.list_market_catalogue(`

            `filter=filter_catalog_markets,`

            `max_results='100',`

            `sort='FIRST_TO_START',`

            `market_projection=['EVENT','COMPETITION','MARKET_START_TIME','RUNNER_METADATA']`

            `)`



One or other sporadically returns `catalog_markets` as empty → `[]`.

Is this something 'normal' to happen?



When I say sporadically, I tested run every 1 minute all day and this happened 13 times, one time for each different games.



My question is just to know if this is common to analyze if I can just ignore such an empty return or if I should worry about some structural flaw in the way I'm researching.

---

## 2022-06-10 08:51:41 - issues channel

**Rudeger Jamison**

Nope, but I am matching on bet_id.



I just get my "strategy" name in the meta orders

---

## 2022-06-09 13:43:41 - betfair-news channel

**Cez Klimczuk**

Hey guys, I'm a newbie to betfairlightweight - I was wondering what's the best way of obtaining market_ids from a given event? Of course I could find them using the navigaiton endpoint, but that's an overkill. I'm currently using the betting.list_events() function with a filter. But I do not know how to bridge this with betting.list_market_book(), which requires market ids as an input. What the best way to go about it?

---

## 2022-06-08 01:10:14 - random channel

**Rudeger Jamison**

Hey - I am trying to do this within flumine and make the currency request process every 24 hours as a CustomStream.



I am trying to access the bflw object in order to make a request.



tried *`self.clients.get_betfair_default().betting_client.account.list_currency_rates("AU")`*



*but get an error* 

```Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'AANGX-0002', 'data': {'exceptionname': 'AccountAPINGException', 'AccountAPINGException': {'requestUUID': 'null', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}}}, 'id': 1}```

---

## 2022-06-03 16:33:08 - issues channel

**Beginner**

Hi guys, good afternoon. Do any of you have a model that reproduces the creation of the price/volume chart of the markets?

If have it, if can share I would greatly appreciate it!



I'm wanting to generate one with timeline (current match minute and local hour), it would help me a lot to save time on the project.

---

## 2022-06-01 06:20:08 - strategies channel

**liam**

Just patch or create your own StrategyExposure control 

---

## 2022-06-01 03:12:27 - strategies channel

**Rudeger Jamison**

Can I confirm that from reading the code the setting `max_selection_exposure`  that is handled in the `StrategyExposure` control works that for the LAY side it takes the `to_lose` amount and for the back side it takes the `stake` ?



sample:



```LAY $5 @ 5.0

BACK $10 @ 3.0



selection_exposure = $30```

If I wanted to adjust this so that my back exposure is not the stake and instead the `to_win` amount `( (odds - 1 ) * stake )`  is there any easy way?



I notice you have some of these fields in the blotter already ?

---

## 2022-05-31 18:57:29 - random channel

**Newbie99**

[@UUX1L88MC](@UUX1L88MC) I was playing around with your Betfair Data library and I just wanted to check whether it can be used in conjunction with Flumine for backtesting?



I ask as I noted you can output BFLW objects, but I can't seem to get it to work for this purpose, so I'm wondering if this isn't a valid use case?



As an example, I would normally do something like this with a standard file (uncompressed from a .gz file):



```markets = ["Y:/betcode/unzipped_recorder_files/1.199726796"]





strategy = example_strategy(market_filter={"markets": markets},

        market_data_filter=streaming_market_data_filter(

            fields=[

                "EX_ALL_OFFERS",

                "EX_TRADED",

                "EX_TRADED_VOL",

                "EX_LTP",

                "EX_MARKET_DEF",

                "SP_TRADED",

                "SP_PROJECTED",

            ]

            ),

            name='dummy_strategy_name',

            )



framework.add_strategy(strategy)```

So I assumed I could do something like this:



```markets = bfd.Files(["Y:/betcode/unzipped_recorder_files/1.199726796.gz"])





strategy = example_strategy(market_filter={"markets": markets},

        market_data_filter=streaming_market_data_filter(

            fields=[

                "EX_ALL_OFFERS",

                "EX_TRADED",

                "EX_TRADED_VOL",

                "EX_LTP",

                "EX_MARKET_DEF",

                "SP_TRADED",

                "SP_PROJECTED",

            ]

            ),

            name='dummy_strategy_name',

            )



framework.add_strategy(strategy)```

But then I get the following:



```  File "D:\Python38\lib\site-packages\flumine\baseflumine.py", line 101, in add_strategy

    self.streams(strategy)  # create required streams

  File "D:\Python38\lib\site-packages\flumine\streams\streams.py", line 44, in __call__

    markets.sort()

AttributeError: 'builtins.Files' object has no attribute 'sort'```

So I essentially wanted to check whether I'm doing something wrong in terms of my approach, or whether this isn't what it is designed to do?

---

## 2022-05-29 23:48:00 - general channel

**Rudeger Jamison**

Hey [@U4H19D1D2](@U4H19D1D2) - any chance we can discuss this?



I see you hash the strategy name into the customer order ref - that would be good enough for me, but I can't work out how to decode the hash because you limit the length of it in the `create_cheap_hash` function. Any ideas?

---

## 2022-05-28 01:01:24 - random channel

**Gooat**

Isn't someone always a courtsider...quicker data, better model, more experience

---

## 2022-05-27 00:54:40 - general channel

**Rudeger Jamison**

Hey [@U4H19D1D2](@U4H19D1D2) - looking to revisit this conversation.



Is there anyway to actually set this `customer_strategy_ref` per strategy with multiple strategies operating within a framework.



The reasoning is quite simple - currently I have some strategies that run on the polling api and now some on Flumine.



I collect the data through the `LoggingControls` and that is well and good, but if for any reason the stream is down on my end I am obviously going to lose data and as a result, I am not able to allocate my orders to a specific `customer_strategy_ref.`



In the polling api - when I place an order in the polling api - I can do so like:



```trading.betting.place_orders(

                market_id=market_id,

                customer_strategy_ref=strategy_name,

                instructions=instructions_list,

            )```

Which allows me to `list_cleared_orders` and identify my strategy by the `customer_strategy_ref`



Is this a shortcoming of the stream api that I am unable to get around?

---

## 2022-05-26 11:58:05 - issues channel

**LM**

Any thoughts on below error. Seems to occur sporadically after flumine has been running for a while

```{"asctime": "2022-05-26 10:56:10,717", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ec2-user/.local/lib/python3.8/site-packages/flumine/worker.py\", line 229, in _get_cleared_market\n    cleared_markets = betting_client.betting.list_cleared_orders(\n  File \"/home/ec2-user/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/betting.py\", line 434, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ec2-user/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"/home/ec2-user/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.199541139'], 'customerStrategyRefs': ['ip-172-31-43-15'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang03a-prd-05180823-000f838978', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang03a-prd-05180823-000f838978', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.199541139'], 'customerStrategyRefs': ['ip-172-31-43-15'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang03a-prd-05180823-000f838978', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang03a-prd-05180823-000f838978', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}```

---

## 2022-05-26 08:08:57 - issues channel

**Oliver Varney**

very very early to bed, early up :joy: I think the use case is strategy specific, alot of my strategy is based of the process of making predictions then creating trades off the back, rather then specific signals that maybe is more conventional. I dont think theres a correct / best practice. The two bullet points youve described above are logical I believe, as they were my similar thoughts when having code in both sections.  have you confirmed that the code is doing what youve listed above in live?

---

## 2022-05-26 06:16:21 - issues channel

**Unknown**

for me its just confirmed that any order create with my style of strategy is not worth raising out of process_orders, only exposure calcs and cancels.

---

## 2022-05-25 08:00:18 - issues channel

**Jonjonjon**

Basically I have a  class that places my algo orders. It subclasses BaseStrategy, and is used by other strategies to place orders.



In Flumine 1.x, the algo trading class would always have it's process orders called.

---

## 2022-05-25 00:22:27 - issues channel

**Jonjonjon**

I worked it out... In Flumine 2.0, strategy.process_orders only gets called if the strategy already has live orders. My code was relying on it being called more frequently.

---

## 2022-05-23 07:32:32 - issues channel

**mandelbot**

So I've recently ported my marketrecorder to a linux ec2 but it keeps getting shut down for some reason. Can someone shed light on this for me please?



```{"asctime": "2022-05-23 05:16:35,115", "levelname": "INFO", "message": "Market removed", "market_id": "1.199445646"}

{"asctime": "2022-05-23 05:16:35,119", "levelname": "INFO", "message": "Market closed", "market_id": "1.199439954", "clients": {"Betfair": {"d": {"username": "d", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fcb7bddd190&gt;"], "order_stream": false, "best_price_execution": true, "paper_trade": false}}, "Simulated": {}, "BetConnect": {}}, "markets": {"market_count": 728, "open_market_count": 670}, "streams": ["&lt;DataStream(DataStream, started daemon 140511599916800)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140512124557120)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 140511835891456)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 140511825401600)&gt;", "&lt;Thread(WIN_load_processor, started daemon 140511814911744)&gt;", "&lt;DataStream(DataStream, started daemon 140511599916800)&gt;"]}

{"asctime": "2022-05-23 05:16:35,123", "levelname": "INFO", "message": "Removing market 1.199445645", "clients": {"Betfair": {"d": {"username": "de", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fcb7bddd190&gt;"], "order_stream": false, "best_price_execution": true, "paper_trade": false}}, "Simulated": {}, "BetConnect": {}}, "markets": {"market_count": 728, "open_market_count": 670}, "streams": ["&lt;DataStream(DataStream, started daemon 140511599916800)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140512124557120)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 140511835891456)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 140511825401600)&gt;", "&lt;Thread(WIN_load_processor, started daemon 140511814911744)&gt;", "&lt;DataStream(DataStream, started daemon 140511599916800)&gt;"]}

{"asctime": "2022-05-23 05:16:35,123", "levelname": "INFO", "message": "BackgroundWorker keep_alive shutting down", "worker_name": "keep_alive", "function": "&lt;function keep_alive at 0x7fcb7967f5f0&gt;"}

{"asctime": "2022-05-23 05:16:35,426", "levelname": "INFO", "message": "/home/ec2-user/.local/lib/python3.7/site-packages/flumine/historical/ALL/1.199439954.gz successfully loaded to s3"}

{"asctime": "2022-05-23 05:16:35,452", "levelname": "INFO", "message": "1.199439954 successfully loaded marketCatalogue to s3"}

{"asctime": "2022-05-23 05:16:35,452", "levelname": "INFO", "message": "Removing: /home/ec2-user/.local/lib/python3.7/site-packages/flumine/historical/ALL/1.199445646.gz, age: 3669.27s"}

{"asctime": "2022-05-23 05:16:35,453", "levelname": "INFO", "message": "Removing: /home/ec2-user/.local/lib/python3.7/site-packages/flumine/historical/ALL/1.199445646, age: 3669.29s"}

{"asctime": "2022-05-23 05:16:35,453", "levelname": "INFO", "message": "Removing: /home/ec2-user/.local/lib/python3.7/site-packages/flumine/historical/ALL/1.199445645.gz, age: 3659.23s"}

{"asctime": "2022-05-23 05:16:35,453", "levelname": "INFO", "message": "Removing: /home/ec2-user/.local/lib/python3.7/site-packages/flumine/historical/ALL/1.199445645, age: 3659.26s"}

{"asctime": "2022-05-23 05:16:39,124", "levelname": "INFO", "message": "BackgroundWorker poll_market_catalogue shutting down", "worker_name": "poll_market_catalogue", "function": "&lt;function poll_market_catalogue at 0x7fcb78031440&gt;"}

{"asctime": "2022-05-23 05:16:43,124", "levelname": "INFO", "message": "Shutting down Execution (SimulatedExecution)"}

{"asctime": "2022-05-23 05:16:43,124", "levelname": "INFO", "message": "Shutting down Execution (BetfairExecution)"}

{"asctime": "2022-05-23 05:16:43,196", "levelname": "INFO", "message": "Client logout", "username": "d", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fcb7bddd190&gt;"], "order_stream": false, "best_price_execution": true, "paper_trade": false}

{"asctime": "2022-05-23 05:16:43,197", "levelname": "INFO", "message": "Exiting flumine", "clients": {"Betfair": {"d": {"username": "d", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x7fcb7bddd190&gt;"], "order_stream": false, "best_price_execution": true, "paper_trade": false}}, "Simulated": {}, "BetConnect": {}}, "markets": {"market_count": 727, "open_market_count": 670}, "streams": ["&lt;DataStream(DataStream, started daemon 140511599916800)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140512124557120)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 140511835891456)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 140511825401600)&gt;", "&lt;Thread(WIN_load_processor, started daemon 140511814911744)&gt;", "&lt;DataStream(DataStream, started daemon 140511599916800)&gt;"]}

Traceback (most recent call last):

  File "/home/ec2-user/.local/lib/python3.7/site-packages/flumine/strategies/marketrecorder.py", line 54, in &lt;module&gt;

    framework.run()

  File "/home/ec2-user/.local/lib/python3.7/site-packages/flumine/flumine.py", line 43, in run

    self._process_close_market(event)

  File "/home/ec2-user/.local/lib/python3.7/site-packages/flumine/baseflumine.py", line 350, in _process_close_market

    self._remove_market(market)

  File "/home/ec2-user/.local/lib/python3.7/site-packages/flumine/baseflumine.py", line 211, in _remove_market

    self.markets.remove_market(market.market_id)

  File "/home/ec2-user/.local/lib/python3.7/site-packages/flumine/markets/markets.py", line 31, in remove_market

    self.events[market.event_id].remove(market)

ValueError: list.remove(x): x not in list```

---

## 2022-05-21 18:44:36 - issues channel

**foxwood**

This may be a dumb question and my class design is wrong but where several strategies are working the same markets with identical streaming_market_filter and streaming_market_data_filter is it possible to share one stream across all these strategies. At the moment it seems that as each strategy is constructed it is opening it's own pair of sockets (order + market) and the connection limit of 10 means that only 5 strategies can be run ?

---

## 2022-05-21 14:29:05 - random channel

**Kai**

I guess some agents are good enough to trust them with some money to prove a winning strategy before you set up an office in Malta. But you have to do  research on your own because it is a shady business and I don't know if the (good) agents take UK customers.

[https://www.sportsbookreview.com/forum/sportsbooks-industry/](https://www.sportsbookreview.com/forum/sportsbooks-industry/)

has countless stories about bookies and agents, some of them can be entertaining to read.

---

## 2022-05-21 09:57:03 - general channel

**Alessio**

To come back to your original, though, a GPU is useful only if you either have (1) very deep NNs or (2) special operations like convolutions. Unless you are processing images, you probably don't need either. You will understand you need a GPU the moment it takes days and days to train your model

---

## 2022-05-19 17:37:06 - random channel

**charlie_v**

This will help with your trading



[https://www.amazon.co.uk/music/player/albums/B0087F7VLQ](https://www.amazon.co.uk/music/player/albums/B0087F7VLQ)

---

## 2022-05-19 14:08:43 - random channel

**Mo**

No, just thought the product might help with coming up with strategy ideas and improvements

---

## 2022-05-18 17:52:42 - random channel

**Michael**

What is the Pinnacle business model [@UBS7QANF3](@UBS7QANF3)? How does it differ from any other book?

---

## 2022-05-18 10:15:51 - general channel

**Stefan**

I am using Orange app to run my ML models using different ML algorithm, it is actually visual designing ML. So have no idea how python will utilize GPU. Orange uses *numpy, scipy and scikit-learn, so my question is: are these libraries able to detect what your system offers, and use GPU of graphic card automatically?*

---

## 2022-05-18 06:18:40 - general channel

**Peter**

When you feed this into the simulator, Flumine will process each update to construct a market object, which includes the market_book, and an orders object based on the actions that you strategy would have taken in response to market changes.

---

## 2022-05-18 06:16:16 - general channel

**Peter**

Close. It's a flat file containing the raw updates received in the stream in json format. One update per line. It's the output from the marketrecorder strategy.

---

## 2022-05-17 12:12:30 - random channel

**Mo**

You're not familiar with the Pinnacle business model?

---

## 2022-05-17 12:11:07 - random channel

**Oliver Varney**

the problem you will find is that, if they stick to their word initially about no limiting and large stake sizes, then everyone who has fairly okay pre off models will go after them

---

## 2022-05-15 06:41:11 - issues channel

**Rudeger Jamison**

nothing of note,



The closest error since the first `NO_SESSION` error was just a `STRATEGY_EXPOSURE` Warning, no actual errors.

---

## 2022-05-15 06:17:16 - issues channel

**Rudeger Jamison**

```

Traceback (most recent call last):

File "/usr/local/lib/python3.9/site-packages/flumine/clients/betfairclient.py", line 44, in keep_alive

return self.betting_client.keep_alive()

File "/usr/local/lib/python3.9/site-packages/betfairlightweight/endpoints/keepalive.py", line 30, in __call__

(response, response_json, elapsed_time) = self.request(session=session)

File "/usr/local/lib/python3.9/site-packages/betfairlightweight/endpoints/keepalive.py", line 60, in request

self._error_handler(response_json)

File "/usr/local/lib/python3.9/site-packages/betfairlightweight/endpoints/keepalive.py", line 67, in _error_handler

raise self._error(response)

betfairlightweight.exceptions.KeepAliveError: API keepAlive FAIL: NO_SESSION```

---

## 2022-05-15 05:51:12 - issues channel

**Rudeger Jamison**

It appears as though the session has lapsed and Flumine hasnt renewed it, when I run another local instance of Flumine the error does not occur and the bot starts betting again.



Is there a parameter to provide to make sure Flumine handles my session for me?

---

## 2022-05-15 05:48:48 - issues channel

**Rudeger Jamison**

```Traceback (most recent call last):\n File \"/usr/local/lib/python3.9/site-packages/flumine/worker.py\", line 229, in _get_cleared_market\n cleared_markets = betting_client.betting.list_cleared_orders(\n File \"/usr/local/lib/python3.9/site-packages/betfairlightweight/endpoints/betting.py\", line 434, in list_cleared_orders\n (response, response_json, elapsed_time) = self.request(method, params, session)\n File \"/usr/local/lib/python3.9/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request\n self._error_handler(response_json, method, params)\n File \"/usr/local/lib/python3.9/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler\n raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.199151822'], 'customerStrategyRefs': ['ip-10-2-10-44.e'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang03b-prd-04211134-00307ff265', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang03b-prd-04211134-00307ff265', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}",```

---

## 2022-05-14 14:25:24 - general channel

**EJono**

Getting to grips with the fromRecord indexing that can be used for retrieving current orders when over 1000 active trades exist. Do other filters work as normal inside the list_current_orders call when doing the following:



```p_orders = []

record_count = 0



while more_available:

    orders = trading.betting.list_current_orders(

        from_record=record_count,

        lightweight=True,

    )

    p_orders += orders.get('currentOrders', [])

    more_available = orders.get('moreAvailable', False)

    record_count += len(orders)```

for instance when using fromRecord for order retrieval the docs are ambiguous how other parametes like the following can affect the response or if they will at all:

```date_range={

    "from": startTime,

    "to": endTime

},

customer_strategy_refs=["strategy_ref"]```

if i added these to list_current_orders request will i now index through bets that meet the other parameters passed?

---

## 2022-05-13 07:10:39 - general channel

**Rudeger Jamison**

is there anyway to get it from *`_process_cleared_orders` because the `ClearedOrder` object doesnt know about the strategy or the trade by the looks of things* :disappointed:

---

## 2022-05-13 06:46:42 - general channel

**liam**

I think you are after `order.trade.strategy.name`

---

## 2022-05-13 06:42:07 - general channel

**Rudeger Jamison**

because if I am setting it globally how will it be different per strategy ?

---

## 2022-05-13 06:41:10 - general channel

**Rudeger Jamison**

I would assume that by Flumine accepting multiple strategies that you can set multiple customer_strategy_refs

---

## 2022-05-13 06:41:03 - general channel

**liam**

Just log/store the strategy name as well?

---

## 2022-05-13 06:40:08 - general channel

**Rudeger Jamison**

because I have loads of different strategy names and I use that to differentiate how they perform in my logging.



I send all the logs to athena in aws, and that is the way I can differentiate an order from one strategy to the next

---

## 2022-05-13 06:39:05 - general channel

**liam**

Why do you want to change the strategy ref?

---

## 2022-05-13 06:37:10 - general channel

**Rudeger Jamison**

Can i set it per strategy though?

---

## 2022-05-13 06:37:02 - general channel

**liam**

```Strategy(name=“whatever”, market_filter..)```

---

## 2022-05-13 06:20:21 - general channel

**Rudeger Jamison**

Hey - how do I explicitly set my `customer_strategy_ref` so that it isn't my host name? if I want a different strategy name to the class name of my actual strategy ?

---

## 2022-05-12 11:59:35 - general channel

**Nicholas vizard**

Hey guys, bit of a left-field question here. I was wondering if anyone knew were to find aggregate stats on betfair's recent general performance, particularly relating to their importance in the betting landscape.



For example, things like what was the total traded volume through betfair in 2021? How many sports did betfair cover? How many markets were run in 2021? etc. Just looking to do a brief right up of the importance of betfair and any help would be much appreciated.



Cheers,

Nick

---

## 2022-05-12 09:06:31 - general channel

**liam**

You are just missing a while loop, notice the use of `is_alive` so it can end cleanly and a sleep which I have used the streaming_timeout



```import time

import requests

from flumine.events.events import CustomEvent

from flumine.streams.basestream import BaseStream





class CustomStream(BaseStream):

    def run(self) -&gt; None:

        while self.is_alive():

            # connect to stream / make API requests etc.

            response = self._get_random_data()



            # callback func

            def callback(framework, event):

                for strategy in framework.strategies:

                    strategy.process_my_event(event)



            # push results through using custom event

            event = CustomEvent(response, callback)



            # put in main queue

            self.flumine.handler_queue.put(event)



            time.sleep(self.streaming_timeout)



    def _get_random_data(self):

        response = requests.get("[https://random-data-api.com/api/cannabis/random_cannabis?size=2](https://random-data-api.com/api/cannabis/random_cannabis?size=2)")

        return response.json()```

---

## 2022-05-12 03:23:53 - general channel

**Rudeger Jamison**

Hey [@U4H19D1D2](@U4H19D1D2) - finally getting around to this.



If I have some code eg.



```import requests

from flumine.events.events import CustomEvent

from flumine.streams.basestream import BaseStream





class CustomStream(BaseStream):

    def run(self) -&gt; None:

        # connect to stream / make API requests etc.

        response = self._get_random_data()



        # callback func

        def callback(framework, event):

            for strategy in framework.strategies:

                strategy.process_my_event(event)



        # push results through using custom event

        event = CustomEvent(response, callback)



        # put in main queue

        self.flumine.handler_queue.put(event)



    def _get_random_data(self):

        response = requests.get("[https://random-data-api.com/api/cannabis/random_cannabis?size=2](https://random-data-api.com/api/cannabis/random_cannabis?size=2)")        

        return response.json()```

I then handle this in my strategy, now how would I go about making sure this is updated for example every 1 hour?



Is that something I can do within the framework?

---

## 2022-05-11 10:09:00 - issues channel

**liam**

find out which process is causing the problems (probably the trading one) and then profile using cprofilev, 5 minutes later you will have some answers

---

## 2022-05-11 07:17:25 - issues channel

**Jorge**

The AWS CPU utilization plot looks OK, reaches 40% CPU utilization only.

I run 1 instance of flumine and 1 instance of betfairlightweight for market and order streaming + separate python processes for trading (around 5 processes).

---

## 2022-05-10 16:13:17 - random channel

**Mo**

```stream = trading.streaming.create_historical_generator_stream(

    file_path=path_to_prices_file,

    listener=StreamListener(

        max_latency=None, lightweight=lightweight, update_clk=False, **kwargs

    ),

)

with patch("builtins.open", smart_open.open):

    g = stream.get_generator()

    for market_book in g():

        pass```



---

## 2022-05-10 13:24:10 - issues channel

**Unknown**

error I got using trading.login() is displayed below . Any help will be greatly appreciated! Thank you :slightly_smiling_face: :cat2:

---

## 2022-05-10 13:01:53 - issues channel

**Oliver Varney**

Struggling to get the datetime.utcnow() to patch to the publish time in flumine (2.0.5). Is there anything in particular I should be doing. Currently I just create a FlumineSimulation instance , add the strategy and then call the run(). I can see it set correctly in the config, just cant seem to call .utcnow() and get the publish_time back. Probably having a blonde moment or misunderstanding something basic here

---

## 2022-05-09 21:05:55 - betconnect channel

**Ruben**

very interesting stuff....I am wondering what is your business model? meaning, if it is possible to back at bookmaker prices when they offer value, who is taking on this risk? the bookmakers? will they continue to do so once they realise that the bets coming from your bettors are -EV for them?

---

## 2022-05-08 13:56:18 - general channel

**Peter**

It's a general upgrade of the API. Including improvements to the Football API to provide new endpoints and better reliability (not that I've perceived that to be a problem) and extra filtering options.



It also converts the APIto a multi-sport data model to make it easier for them to add more sports in future and for us users to give us a more consistent structure for ingesting different sports.

---

## 2022-05-07 19:14:45 - strategies channel

**foxwood**

Might be a doh moment then - I've not tried just assuming !

eg I derive mystrat from BaseStrategy and add it to the framework - since (from logs) that takes 2 sockets I presumed that's the way things worked - I've never added more than 1 strategy to framework ie I'm running one strategy per top module - maybe that's the bit I should study ?!



So are you saying the framework will recognize identical streaming_market_filters across all strategies added to it ?

```framework.add_strategy(

    mystrat(

        name=mystrat.__class__.__name__,

        market_filter = betfairlightweight.filters.streaming_market_filter(

            event_type_ids=["4339"],

            country_codes=["GB"],

            market_types=["WIN"],

            ),

        market_data_filter = streaming_market_data_filter( fields=[

            "EX_ALL_OFFERS", "EX_TRADED", "EX_TRADED_VOL", "EX_LTP",

            "EX_MARKET_DEF", "SP_TRADED","SP_PROJECTED",]

            ),

        context = { "stratparms": mystratParms, "client": client, },

    )

)```



---

## 2022-05-07 18:22:23 - strategies channel

**foxwood**

I have a derived base strategy which does all sorts of parameter driven grunt work and provides helpers for various tasks. Deriving from this makes it easy to create and modify strategies quickly but each strategy ends up with it's own stream as part of the flumine BaseStrategy  construction.



When different strategies have identical market filter requirements is there any way to share a single stream to save on sockets and duplicate processing ? I could use lots of if/elif code but that quickly becomes a maintenance / debug 'mare.



One solution I'm considering is introducing another layer that feeds an array of child strategies in some way - just seems a bit messy compared to having a shared common feeder stream. Any ideas / Python tricks / alternative design patterns welcome :)

---

## 2022-05-07 15:38:42 - issues channel

**Peter**

[@U03EF29QFS4](@U03EF29QFS4) You don't need to separate the strategies. One of the strengths of Flumine is that you can use the same strategy in production as you used in backtesting. It's only the market filter than changes.

---

## 2022-05-06 12:22:36 - random channel

**Oliver Varney**

Is there any optimisation just to get those that have been updated? i.e. just those trades that have had updates? I guess why isnt strategy_orders called with LIVE_STATUS ?

---

## 2022-05-06 12:13:52 - random channel

**Oliver Varney**

Am I correct in thinking process_orders in flumine is called with all orders for a strategy rather than the ones that have received an update via the stream?

---

## 2022-05-05 17:43:22 - general channel

**Rudeger Jamison**

[https://betcode-org.github.io/flumine/advanced/|https://betcode-org.github.io/flumine/advanced/](https://betcode-org.github.io/flumine/advanced/|https://betcode-org.github.io/flumine/advanced/) - instead of process my event you mean to just actually add to the strategy.context.



Got ya. Thanks.

---

## 2022-05-05 17:38:41 - general channel

**liam**

Yeah that is the correct use case, use a custom event with a callback to update a market or strategy context 

---

## 2022-05-05 17:37:41 - general channel

**Rudeger Jamison**

Hey, when adding a Custom Streams for something like dynamically updated model odds that are written to a Db by another process. (is this a good use case?)



How do I then access that data in my strategy after adding it to the franweork.

---

## 2022-05-05 15:47:24 - general channel

**Ivan Zhou**

Whats the best way to grab a log of your bets at the end of the day? Having issues using the blotter to collect results on a live strategy the same way as you would for a simulation

```# Collect results

results = []

for market in framework.markets:

    print("Profit: {0:.2f}".format(sum([o.simulated.profit for o in market.blotter])))

    for order in market.blotter:

        results.append(

            [

                order.market_id,

                order.selection_id,

                order.responses.date_time_placed,

                order.status,

                order.order_type.price,

                order.average_price_matched,

                order.size_matched,

                order.simulated.profit,

            ]

        )```

---

## 2022-05-05 12:00:20 - issues channel

**Newbie99**

I'm still getting these perpetual cancel loops, which occur when a bet is (presumably) matched after I've sent the cancel request:



```{"asctime": "2022-05-05 10:56:32,246", "levelname": "INFO", "message": "execute_cancel", "trading_function": "cancel", "elapsed_time": 0.19069957733154297, "response": {"customerRef": "05f0b9cbcc6211eca0d32016d8944b85", "status": "FAILURE", "errorCode": "BET_ACTION_ERROR", "marketId": "1.167249009", "instructionReports": [{"status": "FAILURE", "errorCode": "BET_TAKEN_OR_LAPSED", "instruction": {"betId": "267210054221"}}]}, "order_package": {"id": "05f0b9cb-cc62-11ec-a0d3-2016d8944b85", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x0000010E03500FA0&gt;", "market_id": "1.167249009", "orders": ["138710406780430137"], "order_count": 1, "package_type": "Cancel", "customer_strategy_ref": "BlueOcean", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}```

---

## 2022-05-04 07:25:08 - general channel

**liam**

Have a read of the strategy code in check_market_book 

---

## 2022-05-04 07:22:48 - general channel

**liam**

Very strategy dependant, if you are getting latency warnings then you have gone way too far 

---

## 2022-05-04 04:11:06 - general channel

**Steve Roach**

Hi Guys,



I've implemented the datacollectwom.py strategy from GitHub: flumine-strategy-development and I've run a few PRO files through it. The resulting datapoints are about 5 seconds apart. Is this about right? Is this what I would expect running Flumine against a live market?



Cheers

---

## 2022-05-04 01:16:11 - general channel

**Rudeger Jamison**

Hey - is there a general strategy limit that is known to slow down Flumine?



eg. Is there any advice to run one instance of Flumine with say 5 strategies or is it resilient enough to  use with say 30 strategies +?



I can test this out myself, just thought you guys would have experience with this already. Cheers

---

## 2022-05-03 16:34:28 - issues channel

**D**

That's fine, but the nature of that work affects my opinion of what you should be doing. Here's 3 suggestions for you to consider:

1. Log in inside the function that runs in the separate process so it has its own copy of a trading object - if you're work is really cpu-bound;

2. Use Threads instead of processes, then you can pass 'trading' to all threads - this would be useful if the work involves going out to other websites/APIs to collect information, i.e. IO-bound.

3. Do separate login as per option 1) but pass market ids in a queue so you don't have to keep logging in for many markets - if your work is cpu bound and you have many markets.

Unfortunately, without knowing more about the nature of the work it's hard to give a definitive answer. I think the correct answer may be 'Use Flumine' but I am not fluent enough with it to advise.

---

## 2022-05-03 16:15:33 - issues channel

**Beginner**

Hi [@URMM9463X](@URMM9463X) thanks to help. Check it out, yesterday I sent the code here without using multiprocessing, it works perfectly because I can send `trading` as an argument without any difficulties. But, it generates a slowness that when using it on a day by day, I confess to you that it ends up getting in the way of making decisions in the market. So, if I could use multiprocessing to collect the information all at once without having to wait for an analysis to finish and move on to another, it would improve a lot for me.

---

## 2022-05-03 15:45:16 - issues channel

**Unknown**

Hello guys, updating my question, with the current code, the error `TypeError: cannot pickle 'module' object` of not being able to send `trading` as an argument disappeared, but the function `odds_search` that analyzes the odds is not being executed. When I go to look at the two lists, they are empty and `print('odds search run')` does not appear in the terminal, indicating that the function was not even called.

---

## 2022-05-03 11:07:48 - issues channel

**Rudeger Jamison**

Last question! In the example-single.py, you provide the strategy with the kwarg `max_trade_count=1` and then you check in process_market_book for  ​`if​ ​runner_context​.​trade_count​ ​&gt;​ ​0​`.



Am I right in assuming that Flumine will handle not placing a trade if there's already one according to the kwarg argument? Or how is it handled in general with those safe guards?

---

## 2022-05-03 00:35:31 - issues channel

**Rudeger Jamison**

```{"asctime": "2022-05-02 23:33:50,466", "levelname": "INFO", "message": "[OrderStream: 1001]: connection_id: 102-020522233350-5969716"}

{"asctime": "2022-05-02 23:33:50,607", "levelname": "INFO", "message": "Starting MarketStream 2000", "stream_id": 2000, "market_filter": {"eventTypeIds": ["7"], "marketTypes": ["WIN"], "countryCodes": ["AU"], "raceTypes": ["Flat"]}, "market_data_filter": {"fields": ["EX_BEST_OFFERS", "EX_MARKET_DEF"], "ladderLevels": 3}, "conflate_ms": null, "streaming_timeout": null}

{"asctime": "2022-05-02 23:33:50,609", "levelname": "INFO", "message": "Starting output_thread (MarketStream 2000)"}

{"asctime": "2022-05-02 23:33:50,610", "levelname": "INFO", "message": "[Register: 2001]: marketSubscription"}

{"asctime": "2022-05-02 23:33:50,611", "levelname": "INFO", "message": "[MarketStream: 2001]: \"MarketStream\" created"}

{"asctime": "2022-05-02 23:33:50,755", "levelname": "ERROR", "message": "[OrderStream: 1002]: INVALID_SESSION_INFORMATION: DSC-0036"}

{"asctime": "2022-05-02 23:33:50,756", "levelname": "ERROR", "message": "OrderStream 1001 run error", "exc_info": "Traceback (most recent call last):\n  File \"/Users/benmuller/code/betfair-trading-bots/.venv/lib/python3.9/site-packages/flumine/streams/orderstream.py\", line 51, in run\n    self._stream.start()\n  File \"/Users/benmuller/code/betfair-trading-bots/.venv/lib/python3.9/site-packages/betfairlightweight/streaming/betfairstream.py\", line 67, in start\n    self._read_loop()\n  File \"/Users/benmuller/code/betfair-trading-bots/.venv/lib/python3.9/site-packages/betfairlightweight/streaming/betfairstream.py\", line 233, in _read_loop\n    self._data(received_data)\n  File \"/Users/benmuller/code/betfair-trading-bots/.venv/lib/python3.9/site-packages/betfairlightweight/streaming/betfairstream.py\", line 274, in _data\n    raise ListenerError(self.listener.connection_id, received_data)\nbetfairlightweight.exceptions.ListenerError: connection_id: 102-020522233350-5969716, data: {\"op\":\"status\",\"id\":1002,\"statusCode\":\"FAILURE\",\"errorCode\":\"INVALID_SESSION_INFORMATION\",\"errorMessage\":\"DSC-0036\",\"connectionClosed\":true,\"connectionId\":\"102-020522233350-5969716\"}"}```

---

## 2022-05-02 18:32:09 - issues channel

**Unknown**

Guys, this code is to analyze if everything is ok in both markets and if it is, it responds with `'Approved to invest'`



This file is called `Betfair.py`, so in my main code I call it like this:



`import Betfair`

`print(Betfair.match_data(31410834))`



This id `31410834` is from an example game that has open markets and everything is ok.



Perfect, you guys who have advanced knowledge in Python and have been using betfairlightweight for a long time... As can see, in this place in the code:



`for _ in range(3):`

        `for _, market in markets.iterrows():`

            `odds_search(trading,market)`



I'm asking to generate a loop for 3 times in the analysis of the filtered markets, calling the `odds_search` function.



It works perfectly, but as you can see, I add the login data to the api (`trading`) when calling the function, but when I try to use basic multiprocessing or pool, I can't send `trading` as an argument, this error appears: `TypeError: cannot pickle 'module' object`.



When someone has some spare time, could help me out and show me how I could edit this code to make it work with multiprocessing so that these 3 loops are done at the same time to increase speed to colect the data?



I can create a question on stackoverflow if want. Any help will be most welcome!

---

## 2022-05-02 05:41:37 - issues channel

**Rudeger Jamison**

*Then all I see printed is `starting strategy 'ExampleStrategy'` and it seems I am in an infinite loop.... not sure where to go from here!?*

---

## 2022-05-02 05:41:26 - issues channel

**Rudeger Jamison**

```from flumine import Flumine, clients

from flumine import BaseStrategy

from betfairlightweight.filters import (

    streaming_market_filter, 

    streaming_market_data_filter,

)

trading = betfairlightweight.APIClient(

    username=Ssm.get_secret(f"/betfair/username/{account}"),

    password=Ssm.get_secret(f"/betfair/password/{account}"),

    app_key=Ssm.get_secret(f"/betfair/app_key/{account}"),

    # lightweight=True,

)



client = clients.BetfairClient(trading)



framework = Flumine(

    client=client,

)



class ExampleStrategy(BaseStrategy):

    def start(self):

        # subscribe to streams

        print("starting strategy 'ExampleStrategy'")



    def check_market_book(self, market, market_book):

        print("checking market book")

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True



    def process_market_book(self, market, market_book):

        # process marketBook object

        print(market_book.status)







strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["AU"],

        market_types=["WIN"],

        # race_types=["Flat"]

        

    ),

    market_data_filter=streaming_market_data_filter(fields=["EX_ALL_OFFERS"], ladder_levels=3)

)



framework.add_strategy(strategy)



framework.run()```

---

## 2022-04-30 09:31:16 - random channel

**Jonjonjon**

Seems like a lot of us are in the same boat. I wonder if we have the same strategy?

---

## 2022-04-30 09:29:48 - random channel

**Dave**

Turnover for me is much higher, lower margin though as I kicked out some volatile strategies in favour of higher-sharpe. Finding it hard to make fundamental improvements to models though, a handful of new features which looked decent on paper but not sure it has changed pnl trajectory much.

---

## 2022-04-29 23:12:20 - general channel

**Tom**

```from matchbook.apiclient import APIClient

from matchbook.exceptions import AuthError, PasswordError, ApiError, MBError



import logging

import os

logger = logging.getLogger(__name__)

MATCHBOOK_PW = os.environ.get('MATCHBOOK_PW')

MATCHBOOK_USR = os.environ.get('MATCHBOOK_PW')

api = APIClient(MATCHBOOK_USR, MATCHBOOK_PW)



def get_client():



    try:

        if not api.session_token or api.session_token is None:

            api.login()

            logger.warn(f'this is the {api.session_token}')

    except (AuthError,ApiError,MBError):

            api.login()

    return api



def get_orders():

    api = get_client()

    r = api.betting.get_orders(runner_ids=None, market_ids=None, offer_id=None, offset=0, per_page=500,

                    interval=None, side=Side.Default, status=Status.All, session=None)

    print(r)

    print(api.session_token)```

Hi there, I was wondering if anyone is using this repo for matchbook [https://github.com/rozzac90/](https://github.com/rozzac90/)

I cannot log in again after 6 hours to refresh the token. For some reason I can't run the except block to create a new token when ApiError occurs. Does anyone know how best to handle logging in to refresh the session? My get orders function polls indefinitely so I need to be able to handle the logging in again when the token expires. Thanks

---

## 2022-04-29 13:49:20 - betconnect channel

**Mauricio Garcia**

As chosen by the community, we'll be hosting the event at *5pm!*



Please register here and we'll send the invite link beforehand: [https://forms.gle/4CuiS5MNTKiG6d449](https://forms.gle/4CuiS5MNTKiG6d449)



Feel free to drop questions in this channel about BetConnect's API platform and business model or any other questions you have, so we can address them on the call.



Happy bank holiday!

---

## 2022-04-29 11:27:26 - random channel

**Alessio**

I guess the next step is to build a company that sells "features" for the models that people want to do this stuff ... that way you are an intermediary, no matter their performance.

---

## 2022-04-29 10:23:52 - random channel

**Aaron Smith**

That sounds like a surviving strategy as you basically put yourself higher up the hierarchy. If no new players are introduced, i dont think this would solve anything in the long run though.

---

## 2022-04-29 10:05:54 - random channel

**D C**

It is the "modern" C++ that I don't like. All this heavy reliance on templating makes code close to unreadable at times. Last place I worked as a C++ dev, there were coders who preferred to use 50 classes with functions that had a single line of code rather than a a few functions with 10ish lines of code. To me that is plain stupid but it seems a popular way of thinking now. I presume it is so that they can unit test code to death but I would rather take a career change than do that for a living. All my stuff is pretty much restricted to C++11 which for me is fine, but when trying to get a job again that is going to be a problem. I also have the problem that I had to endure C# and Windows in my last job at a betting firm so my CV looks a bit wobbly right now.

---

## 2022-04-29 09:36:31 - random channel

**James T**

I used to turnover quite a lot at low margin, especially in 2018/19, but I guess because of higher adverse selection I now have to lower my stakes and aim for more accurate models with higher margin, but overall less profit than back then. 

---

## 2022-04-29 09:28:36 - random channel

**Leo**

I use more fundamental pre race models, but I’ve also seen a drop off since about November 2021, trying to figure out what has changed  

---

## 2022-04-29 07:48:05 - general channel

**Kunal Maneck**

Any recommendations on books or reading material on strategy? 

---

## 2022-04-26 16:26:49 - issues channel

**Beginner**

I collect data from football matches, game information and odds. But when I tried to use pool multiprocessing to fetch multiple games at once, I got the problem of not being able to send `trading = ...` data.

---

## 2022-04-26 16:07:24 - issues channel

**Unknown**

Okay, here's the full file. I need to leave `trading.login` inside `main()` because I call this function from another Python code like this → `API_Betfair.Betfair_API()`

---

## 2022-04-26 15:29:18 - issues channel

**Beginner**

Guys, hello! I have a very beginner question but maybe you with very advanced knowledge can help me.



Is there a way to send API Client login data to a separate function? For example, I have the `trading.login()` in the `main()` function and I'm trying to send this data to be able to work with a separate function::



`def matches(trading):`

    `trading = trading`

    `id_event = '12345'`



    `filter_catalog_market = betfairlightweight.filters.market_filter(`

        `event_ids=[id_event],`

        `market_type_codes = [`

            `'MATCH_ODDS'`

            `]`

        `)`



    `catalog_market = trading.betting.list_market_catalogue(`

        `filter=filter_catalog_market,`

        `max_results='100',`

        `sort='FIRST_TO_START',`

        `market_projection=['RUNNER_METADATA']`

    `)`



`def main():`

    `trading = betfairlightweight.APIClient(username, pw, app_key=app_key, cert_files=('blablabla.crt','blablabla.key'))`

    `trading.login()`

    `matches(trading)`



The error that appears is:



`TypeError: cannot pickle 'module' object`



Is there any way to send this API Client login data to a separate function?

I'm sorry for the question that I know is simple, but I'm really struggling to understand.

---

## 2022-04-26 11:12:15 - strategies channel

**PirellOne**

hi All. I am Marco, from Italy, so no possibility to register on the [http://Betfair.com|Betfair.com](http://Betfair.com|Betfair.com) Api or even open account. So my question is: there's nobody from UK could help me just to get notifications (telegram, mail or whatelse..) when a massive bet is occurring only Soccer, only last 30 minutes before match starting PREGAME,  only MATCH ODDS market.. very easy task for someone having Api and know how to use Zapier or similar...i guess.. if you are interested just write..is something that would not break any betting law or any BETFAIR law.. example of this could be: 

GET notified when 10000£ bet  is made on HOME_WIN



..i am new to Slack. If i wrote in the wrong place just let me know..

---

## 2022-04-26 08:39:58 - random channel

**Newbie99**

I can now just use:



```market.blotter.strategy_selection_orders(self, runner.selection_id, runner.handicap, order_status=[OrderStatus.EXECUTABLE])```

---

## 2022-04-26 08:23:35 - random channel

**Newbie99**

A significant improvement...unsurprisingly perhaps it was mostly due to inefficient looping, but I re-wrote a few other bits too.



One thing that is confusing me however, is that occasionally I do get a:



```"status": "Violation", "status_log": "Violation", "violation_msg": "Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failed: live_trade_count (1) &gt;= max_live_trade_count (1)"```

But I perform this check before trying to place an order:



```live_trades = market.blotter.strategy_selection_orders(self, runner.selection_id, runner.handicap, order_status=[OrderStatus.EXECUTABLE])



    if len(live_trades) == 0:```

---

## 2022-04-25 12:29:15 - random channel

**Newbie99**

Okay cool, I think I see what the issue is. This is where I'm checking all orders in the market (regardless of strategy) to avoid self matching...



Will have a re-write

---

## 2022-04-25 12:14:36 - random channel

**Newbie99**

```53265807 function calls (53250311 primitive calls) in 151.446 seconds



   Ordered by: cumulative time



   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

     5682    0.076    0.000  124.859    0.022 D:\Python37\webpages\place_order_functions.py:192(place_or_cancel)

      738    0.068    0.000  124.829    0.169 D:\Python37\webpages\market_making.py:19(place_passive_order)

      341    0.007    0.000  116.552    0.342 D:\Python38\lib\site-packages\flumine\baseflumine.py:254(_process_current_orders)

      681    0.001    0.000  115.210    0.169 D:\Python38\lib\site-packages\flumine\utils.py:259(call_process_orders_error_handling)

      681    0.003    0.000  115.209    0.169 D:\Python37\webpages\betting_strategy.py:32(process_orders)

     5697   21.047    0.004   80.373    0.014 D:\Python37\webpages\risk_functions.py:18(get_runner_exposure)

     4997    0.022    0.000   43.979    0.009 D:\Python37\webpages\place_order_functions.py:188(cancel_orders_by_price)

     4997    0.014    0.000   42.767    0.009 D:\Python37\webpages\place_order_functions.py:180(get_orders)

     4997    0.541    0.000   42.754    0.009 D:\Python37\webpages\place_order_functions.py:185(&lt;listcomp&gt;)

    77775    0.790    0.000   42.540    0.001 D:\Python37\webpages\place_order_functions.py:132(construct_price)

    73587    0.095    0.000   39.810    0.001 D:\Python37\webpages\place_order_functions.py:489(adjust_price_for_self_matching)

    73587    0.390    0.000   39.715    0.001 D:\Python37\webpages\validation_functions.py:425(validate_order_self_matching)

   147174    0.484    0.000   39.253    0.000 D:\Python37\webpages\validation_functions.py:465(get_order_list)

   147174   37.736    0.000   37.736    0.000 D:\Python37\webpages\validation_functions.py:474(&lt;listcomp&gt;)

  1056788   23.509    0.000   23.509    0.000 D:\Python37\webpages\risk_functions.py:33(&lt;listcomp&gt;)

      108    0.001    0.000   21.532    0.199 D:\Python38\lib\threading.py:270(wait)

      997   21.530    0.022   21.530    0.022 {method 'acquire' of '_thread.lock' objects}

      464    0.004    0.000   21.454    0.046 D:\Python38\lib\queue.py:153(get)

     5697    0.030    0.000   19.673    0.003 D:\Python37\webpages\risk_functions.py:78(check_combined_strategy)

     5697    3.140    0.001   19.598    0.003 D:\Python37\webpages\risk_functions.py:86(&lt;listcomp&gt;)

       50    0.002    0.000    9.686    0.194 D:\Python38\lib\site-packages\flumine\baseflumine.py:134(_process_market_books)

      625    0.001    0.000    9.638    0.015 D:\Python38\lib\site-packages\flumine\utils.py:222(call_strategy_error_handling)

       57    0.000    0.000    9.624    0.169 D:\Python37\webpages\betting_strategy.py:22(process_market_book)

  2113432    4.618    0.000    9.271    0.000 D:\Python38\lib\site-packages\flumine\utils.py:80(create_cheap_hash)

  8518043    4.560    0.000    8.305    0.000 D:\Python38\lib\site-packages\flumine\order\order.py:426(size_matched)

  2113059    2.288    0.000    7.743    0.000 D:\Python37\webpages\risk_functions.py:11(get_order_matched_exposure)

  4291494    2.451    0.000    7.361    0.000 D:\Python37\webpages\risk_functions.py:4(get_order_matched_stake)

  2113821    3.039    0.000    5.130    0.000 D:\Python38\lib\site-packages\flumine\order\order.py:259(customer_order_ref)

 10643310    4.577    0.000    4.577    0.000 D:\Python38\lib\site-packages\flumine\order\order.py:188(current_order)

     5696    0.775    0.000    4.467    0.001 D:\Python37\webpages\risk_functions.py:39(&lt;listcomp&gt;)

   1391/2    0.018    0.000    3.269    1.635 {built-in method builtins.exec}

        1    0.000    0.000    3.269    3.269 startup.py:1(&lt;module&gt;)

  1045/16    0.014    0.000    3.082    0.193 &lt;frozen importlib._bootstrap&gt;:986(_find_and_load)

  1044/16    0.007    0.000    3.081    0.193 &lt;frozen importlib._bootstrap&gt;:956(_find_and_load_unlocked)

  1002/16    0.007    0.000    3.066    0.192 &lt;frozen importlib._bootstrap&gt;:650(_load_unlocked)

   890/16    0.005    0.000    3.065    0.192 &lt;frozen importlib._bootstrap_external&gt;:777(exec_module)

  1348/16    0.002    0.000    3.053    0.191 &lt;frozen importlib._bootstrap&gt;:211(_call_with_frames_removed)

  2113432    2.341    0.000    2.341    0.000 {method 'hexdigest' of '_hashlib.HASH' objects}

  2113469    1.233    0.000    2.061    0.000 D:\Python38\lib\site-packages\flumine\order\order.py:419(average_price_matched)

      341    0.013    0.000    1.827    0.005 D:\Python38\lib\site-packages\flumine\order\process.py:33(process_current_orders)

  563/115    0.003    0.000    1.797    0.016 {built-in method builtins.__import__}

       46    0.001    0.000    1.721    0.037 D:\Python38\lib\site-packages\flumine\order\process.py:93(create_order_from_current)

        7    0.000    0.000    1.603    0.229 D:\Python38\lib\site-packages\flumine\baseflumine.py:197(_add_market)

        7    0.008    0.001    1.596    0.228 D:\Python37\webpages\middleware_example.py:24(add_market)

2117384/2117380    1.525    0.000    1.525    0.000 {method 'format' of 'str' objects}

 1227/677    0.003    0.000    1.475    0.002 &lt;frozen importlib._bootstrap&gt;:1017(_handle_fromlist)

     1586    0.005    0.000    1.400    0.001 D:\Python38\lib\logging\__init__.py:1553(_log)

        1    0.000    0.000    1.335    1.335 D:\Python37\webpages\orders_worker.py:1(&lt;module&gt;)

        1    0.000    0.000    1.332    1.332 D:\Python37\webpages\racing_functions.py:1(&lt;module&gt;)

  2113432    1.331    0.000    1.331    0.000 {built-in method _hashlib.openssl_sha1}

        1    0.000    0.000    1.325    1.325 D:\Python37\webpages\import_historic_horse_data.py:1(&lt;module&gt;)

     1586    0.002    0.000    1.308    0.001 D:\Python38\lib\logging\__init__.py:1579(handle)

     1586    0.012    0.000    1.305    0.001 D:\Python38\lib\logging\__init__.py:1633(callHandlers)

     4758    0.011    0.000    1.293    0.000 D:\Python38\lib\logging\__init__.py:937(handle)

    77775    0.183    0.000    1.271    0.000 D:\Python37\webpages\place_order_functions.py:222(get_base_price_source)

     4758    0.019    0.000    1.265    0.000 D:\Python38\lib\logging\__init__.py:1069(emit)

     1505    0.007    0.000    1.249    0.001 D:\Python38\lib\logging\__init__.py:1424(info)

        6    0.000    0.000    1.222    0.204 D:\Python38\lib\site-packages\requests\api.py:16(request)

        6    0.000    0.000    1.199    0.200 D:\Python38\lib\site-packages\requests\sessions.py:470(request)

     4997    0.018    0.000    1.189    0.000 D:\Python37\webpages\cancel_and_replace.py:33(cancel_orders)

        6    0.000    0.000    1.111    0.185 D:\Python38\lib\site-packages\requests\sessions.py:626(send)

        6    0.000    0.000    1.105    0.184 D:\Python38\lib\site-packages\requests\adapters.py:394(send)

   153222    1.010    0.000    1.078    0.000 D:\Python38\lib\site-packages\flumine\markets\blotter.py:268(__iter__)

        6    0.000    0.000    1.062    0.177 D:\Python38\lib\site-packages\urllib3\connectionpool.py:518(urlopen)

        6    0.000    0.000    1.058    0.176 D:\Python38\lib\site-packages\urllib3\connectionpool.py:357(_make_request)

        5    0.000    0.000    1.056    0.211 D:\Python38\lib\site-packages\requests\api.py:107(post)

        1    0.000    0.000    1.056    1.056 D:\Python38\lib\site-packages\pandas\__init__.py:3(&lt;module&gt;)```

---

## 2022-04-25 09:29:40 - random channel

**Newbie99**

```import logging

from flumine import config

from flumine.utils import STRATEGY_NAME_HASH_LENGTH

from flumine.markets.middleware import Middleware

from flumine.order.trade import Trade

from misc_functions import get_utc_time

from datetime import datetime

import pytz



logger = logging.getLogger(__name__)





class OrdersMiddleware(Middleware):

    """

    Middleware to add execution complete orders

    to the blotter. This is required on a restart

    as the order stream does not include

    EXECUTION_COMPLETE orders

    """



    def __init__(self, flumine):

        self.flumine = flumine



    def add_market(self, market) -&gt; None:

        ''' This checks each market, subject to the below filters (if the check is True then it will call list_current_orders) '''



        ''' Checks to see if the market is politics (2378961) or if it is due to start within the next 20 mins for others...hardcoded, may need to change.'''

        if market.seconds_to_start &lt;= 1200 or str(market.event_type_id) == str(2378961):



            ''' Calls list_current_orders and loops through if there are more than 1000 '''

            current_order_list = get_current_orders_flumine(self, 'ALL', market=market, all_market_orders=True)



            ''' If the output of current_order_list is non zero then checks the market_book to get runner info to use later...if the market_book hasn't loaded makes

             a call to the API to get the latest market_book'''

            if len(current_order_list) &gt; 0:

                if market.market_book is None:

                    market_book = self.flumine.clients.get_betfair_default().betting_client.betting.list_market_book(market_ids=[market.market_id])[0]

                    # market_book = self.flumine.client.betting_client.betting.list_market_book(market_ids=[market.market_id])[0]

                else:

                    market_book = market.market_book



                ''' Creates a list of Active runners (so that non-active runners are not included later when orders are created) '''

                runner_list = [(str(runner.selection_id), str(float(runner.handicap))) for runner in market_book.runners if runner.status == 'ACTIVE']

                for current_order in current_order_list:

                    if (str(current_order.selection_id), str(float(current_order.handicap))) in runner_list:

                        if current_order.customer_strategy_ref != config.hostname or current_order.status not in ['EXECUTABLE']:

                            if str(current_order.bet_id) not in [str(o.bet_id) for o in market.blotter]:

                                [http://logger.info|logger.info](http://logger.info|logger.info)(

                                    "OrdersMiddleware: Processing order {0}".format(current_order.bet_id),

                                    extra={

                                        "bet_id": current_order.bet_id,

                                        "market_id": current_order.market_id,

                                        "customer_strategy_ref": current_order.customer_strategy_ref,

                                        "customer_order_ref": current_order.customer_order_ref,

                                    },

                                )

                                order = self._create_order_from_current(current_order, market)

                                if order:

                                    order.update_current_order(current_order)

                                    if current_order.status == "EXECUTION_COMPLETE":

                                        order.execution_complete()

                                    else:

                                        # if order.bet_id not in [o.bet_id for o in market.blotter]:

                                        order.executable()

                                    # order.execution_complete()



        ''' Adds flag to market.context, so market is not processed until all orders added '''

        if 'order_startup_process_time' in market.context.keys():

            market.context.update({'order_startup_process_time': get_utc_time()})

        else:

            market.context['order_startup_process_time'] = get_utc_time()



    def _create_order_from_current(self, current_order, market):

        ''' Some legacy Politics markets had manual orders, this assigns a strategy to them '''

        legacy_market_id_list = ['1.160740937',

                                 '1.129176457',

                                 '1.160683973',

                                 '1.160843673',

                                 '1.176878927',

                                 '1.166577732',

                                 '1.160663234',

                                 '1.167249009'

                                 ]

        # strategy_name_hash = current_order.customer_order_ref[

        #     :STRATEGY_NAME_HASH_LENGTH

        # ]

        # order_id = current_order.customer_order_ref[STRATEGY_NAME_HASH_LENGTH + 1 :]

        if current_order.market_id in legacy_market_id_list:

            if current_order.side == 'BACK':

                strategy_name_hash = 'd0df7e7076e65'

            else:

                strategy_name_hash = '3203239236f2d'

            order_id = current_order.bet_id

        else:

            strategy_name_hash = current_order.customer_order_ref[

                                 :STRATEGY_NAME_HASH_LENGTH

                                 ]



            order_id = current_order.customer_order_ref[STRATEGY_NAME_HASH_LENGTH + 1:]

            # Had to put this in, so that replace orders were picked up correctly (otherwise it thinks they are already in the blotter and doesn't add the latest)

            # order_id = current_order.bet_id

        # get strategy

        strategy = self.flumine.strategies.hashes.get(strategy_name_hash)

        if strategy is None:

            logger.warning(

                "OrdersMiddleware: Strategy not available to create order {0}".format(

                    order_id

                ),

                extra={

                    "bet_id": current_order.bet_id,

                    "market_id": current_order.market_id,

                    "customer_strategy_ref": current_order.customer_strategy_ref,

                    "customer_order_ref": current_order.customer_order_ref,

                    "strategy_name": str(strategy),

                },

            )

            return

        # add trade/order

        trade = Trade(

            market.market_id,

            current_order.selection_id,

            current_order.handicap,

            strategy,

        )



        order = trade.create_order_from_current(client=self.flumine.clients.get_betfair_default(), current_order=current_order, order_id=order_id)

        market.blotter[order.id] = order

        runner_context = strategy.get_runner_context(*order.lookup)

        runner_context.place(trade.id)

        [http://logger.info|logger.info](http://logger.info|logger.info)(

            "OrdersMiddleware: New order trade created",

            extra={

                "bet_id": current_order.bet_id,

                "market_id": current_order.market_id,

                "customer_strategy_ref": current_order.customer_strategy_ref,

                "customer_order_ref": current_order.customer_order_ref,

                "strategy_name": str(strategy),

            },

        )

        return order



def get_current_orders_flumine(self, order_status, market=False, all_market_orders=True):

    start_record = 0

    complete_order_list = []

    if market is not False:

        market_ids = [market.market_id]

    else:

        market_ids = None



    if all_market_orders is True:

        strategy_ref = None

    else:

        strategy_ref = [config.hostname]



    while True:

        # market_orders = self.flumine.client.betting_client.betting.list_current_orders(

        market_orders = self.flumine.clients.get_betfair_default().betting_client.betting.list_current_orders(

            market_ids=market_ids,

            customer_strategy_refs=strategy_ref,

            order_projection=order_status,

            from_record=start_record)

        complete_order_list.extend(market_orders.orders)

        start_record +=1000

        if not market_orders.more_available is True:

            break

    return complete_order_list```

---

## 2022-04-23 18:21:49 - random channel

**Lee**

Try something like

```client = self.flumine.clients.get_betfair_default()

client.betting_client.betting.list_current_orders(PARAMS)```

---

## 2022-04-23 18:13:37 - random channel

**Newbie99**

Prior to the recent breaking changes to Flumine, I used to call list_current_orders as follows, from Middleware to avoid logging in separately via BFLW:



```self.flumine.client.betting_client.betting.list_current_orders(PARAMS)```

I haven't so far, been able to work out the new syntax, to be able to do the same, presuming it's still possible, could anyone point out what I need to change, I can't seem to figure it out from the docs?

---

## 2022-04-23 15:58:00 - issues channel

**Unknown**

I keep getting a BET_TAKEN_OR_LAPSED error when cancelling, my cancel logic is as follows:

```orders = [order for order in market.blotter.strategy_orders(self) if

        (order.selection_id, order.handicap) == (runner.selection_id,runner.handicap)]```

```for order in orders:

    runner_exposure = get_runner_exposure(self, market, selected_runner=order)

    if order.status == OrderStatus.EXECUTABLE:

        if order.side == 'BACK':

            if positive_runner_exposure &lt; runner_exposure['if_win']:

                logging.info('Cancelling {0} due to positive exposure breach, runner exposure is: {1} and limit is: {2}.'.format(order.bet_id, runner_exposure, negative_runner_exposure))

                market.cancel_order(order)

            elif validate_current_order(order, time_to_cancel_orders) is True:

                logging.info('Cancelling {0} as order has been live for {1} seconds.'.format(order.bet_id, time_to_cancel_orders))

                market.cancel_order(order)

        else:

            if negative_runner_exposure &gt; runner_exposure['if_win']:

                [http://logging.info|logging.info](http://logging.info|logging.info)('Cancelling {0} due to negative exposure breach, runner exposure is: {1} and limit is: {2}.'.format(order.bet_id, runner_exposure, negative_runner_exposure))

                market.cancel_order(order)

            elif validate_current_order(order, time_to_cancel_orders) is True:

                [http://logging.info|logging.info](http://logging.info|logging.info)('Cancelling {0} as order has been live for {1} seconds.'.format(order.bet_id, time_to_cancel_orders))

                market.cancel_order(order)```

I don't understand how this error could (repeatedly) happen when I check to ensure the order is EXECUTABLE before cancelling (logs for one example attached, I have had multiple instances of this today)?



(I do appreciate it will be an error on my side, I'm just completely stumped as to what it could be), so any clues would be greatly appreciated!

---

## 2022-04-22 17:48:13 - random channel

**Aaron Smith**

Its kinda sad considering all the effort put into programming and maths, but my most successful day was when i had a few beers and put 200bucks on a horse that i thought looked nice. Despite its good results, i decided to not further investigate that strategy.

---

## 2022-04-22 15:22:58 - random channel

**ShaunW**

TA isn't just using numbers, like price or volume, it's a term to describe looking for patterns in market data to identify trends, and seeing as there's almost no similarity between a sports market and any other type of market it's very unlikely there's much crossover.  But, TA will always get mentioned because sports gambling has never been shy of trying to borrow credibility from established forms of trading whether it's helpful or not.

---

## 2022-04-21 20:33:53 - random channel

**Unknown**

This is a real P&amp;L from a pure TA strategy. Implemented 100% in Flumine. It doesn't make a lot, but the result is definitely consistent.

---

## 2022-04-21 12:21:22 - strategies channel

**PeterLe**

It would be a know good strategy JonJon, but starting from a low balance.

---

## 2022-04-21 12:20:30 - strategies channel

**PeterLe**

Hi Liam, yes I do have an element of AB testing as I have multiple versions of the same strategy and always comparing/contrasting anyway. The advantage of doing it as mentioned is that as you know, the stakes will increase/compound rapidly whenever you apply to a successful strategy. If the account stated with a small balance say £200, htat would be my maximum loss and i would be less worried about things when it stated throwing in large stakes. Stakes that I would not normally be comfortable with.  Now execution..that's a whole new ball game :grinning:

---

## 2022-04-21 12:10:41 - strategies channel

**Jonjonjon**

Why not just try it with a small strategy?

---

## 2022-04-21 11:19:52 - random channel

**Jonjonjon**

i thought most people here used price action as the primary input of their models?

---

## 2022-04-21 11:18:26 - general channel

**liam**

flumine isn't designed for this as it will keep running (as you have found out) Best practice is to take advantage of the stream and have a nice wide filter on your `market_filter` ie eventType+marketType and then filter in the strategy via `strategy.check_market_book`



Resulting in a single running process

---

## 2022-04-21 11:16:09 - general channel

**Jon K**

Hi all, I'm following some Flumine examples and have created a Python script that accepts a marketId as a parameter.

The strategy then uses that MarketId as part of the market filter, using this example

market_filter=streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB"],

        market_types=["WIN"],

        market_ids=[marketToCheck]

    )



This works fine but I notice more and more python processes remain open (using Windows Task Manager) as each new call is made to the script despite the market(s) in question being closed.

Should I be adding something specific to stop the framework running, maybe at this point?



framework.add_strategy(strategy)

framework.run()

---

## 2022-04-21 09:04:51 - random channel

**liam**

Maybe, personally thinking TA was a thing severely stunted my advances in strategy development

---

## 2022-04-20 16:28:20 - general channel

**Dave**

Trust me, modelling this is really hard, you don't want to try

---

## 2022-04-20 13:30:13 - general channel

**river_shah**

a full state space model ends up being underdertmined (in the system of equations sense) so you do end up plugging in simulation driven estimates of critical parameters

---

## 2022-04-20 13:26:38 - general channel

**river_shah**

my intuition as why parametric models have such trouble fitting CS markets is that the goal transition probabilities change drastically conditional on game state / time

---

## 2022-04-20 13:24:58 - general channel

**river_shah**

put the poisson model in the trash bin for sure though

---

## 2022-04-20 10:59:52 - general channel

**Mo**

I speak from personal experience of trying to reverse engineer the parameters of a competitor's model and then finding out that the model was blended with their position making that essentially impossible

---

## 2022-04-20 10:46:35 - general channel

**thambie1**

A bit of a long shot, but figured this is worth a try. Willing to pay £3k to anyone who can tell me the goal distribution model being used by the primary market maker of the football correct score market. Hint it's not poisson, or anything I've been able to find in academic papers.

---

## 2022-04-19 21:39:01 - issues channel

**liam**

Yeah if you can, you can call the check_hour function but it’s not very clean to be calling it from a strategy and not very efficient on strategy/execution 

---

## 2022-04-19 21:36:09 - issues channel

**Ruben**

atm I am developing my first strategy with small stakes, so maybe I can go above the 5k but not much beyond that. Maybe I should look at being more selective with the tx that I post

---

## 2022-04-19 18:20:20 - general channel

**Michael**

Ok. Personally I would focus on that. You don't want to be carpet bombing the exchange if you can help it.



One thing that you've done well is played a long game and hung in there - don't let that go. Stay patient and work out where your winnings are coming from.



You might find yourself tempted to try to jack up your betting in the hope that you'll win more that way - you won't.



Take your time, build slowly and drive up the average profit of your transactions. Go for the robust long term operation, not the short term win.

---

## 2022-04-19 17:49:37 - general channel

**AP**

What's the best way to alter/append to the customer order ref within a strategy?

---

## 2022-04-19 16:04:31 - general channel

**AndyL**

I have a separate Flumine python process for each strategy at the moment. Surprisingly cpu usage is quite low, memory good, so mainly network bound

---

## 2022-04-19 16:01:37 - general channel

**liam**

strategy/market/instance dependant, just make sure you have some decent logging on what is important (to you)

---

## 2022-04-19 15:22:02 - strategies channel

**Douglas Hickling**

Thanks, I have been doing that with a form of kelly, was just wondering if there was a better way

---

## 2022-04-19 15:05:47 - strategies channel

**thambie1**

[@UGV299K6H](@UGV299K6H) Not for all of us. I tend to consider betting on each runner in sequence, rather than all at once. Kelly criterion does the job

---

## 2022-04-19 07:31:13 - strategies channel

**birchy**

Thanks [@U4H19D1D2](@U4H19D1D2). Let's say I wanted to use the WIN markets to calculate prices for the PLACE markets, how would we set that up? I'm assuming it would require 2 separate strategies and some form of IPC? Or can it be done within one strategy? Also, where would we find the "Betfair created event file"?

---

## 2022-04-18 13:00:13 - strategies channel

**Ruben**

any necessary adaptations to port a strategy that has only been running in preplay to inplay? from what I gather reading examples and documentation, the instructions to place/cancel orders should be the same, and there will be an additional inplay delay for placing/cancellations, but nothing more than that

---

## 2022-04-17 22:25:04 - general channel

**Krz Heph**

Most likely C++ or Rust.. Python maybe to prototype or train models?

---

## 2022-04-17 09:56:40 - general channel

**D**

I always assumed with these kinds of deals that they don't want you to share your secret model, or to share their model with you - what they're looking for is people competent/experienced at all the surrounding systems such as data capture, reporting, trade execution etc. All of that stuff is quite time consuming and treated as a boring distraction by some people. I agree it seems unworkable if there's any intention of sharing algorithms/strategies without profit share.

---

## 2022-04-17 09:31:06 - issues channel

**Ruben**

good morning everyone; hoping you can give me some pointers with this...basically every saturday my aws instance (t3.small) has a spike in CPU usage and after that it dies. When that happens, I'm usually subscribed to about 50 soccer markets which doesn't seem like that much compared to what I often hear around here. Around that time I often hit the 5000 max transaction limit as well. Only running 1 strategy, which admittedly is quite CPU intensive since after every update it has to do work to keep a clear picture of the market book

---

## 2022-04-16 10:56:42 - general channel

**Graham**

Ultimately, unless the rev share is significant then it’s unworkable. Even from the perspective of the fund. Market cap doesn’t allow for a significant enough amount to warrant someone simply handing their model over for the sake of their stakes increasing. 

---

## 2022-04-15 20:47:08 - general channel

**Oliver Varney**

For example the job above, anyone decent wouldn't give up a strategy for the wage they are offering?

---

## 2022-04-14 18:33:31 - issues channel

**foxwood**

worked a treat - set it in the top module to use the file name so (for me) ends up different for each framework:

```config.customer_strategy_ref = os.path.basename(__file__).split(".")[0][-15:]```



---

## 2022-04-14 14:34:39 - general channel

**D C**

Do people really use Python for low latency trading?

---

## 2022-04-14 14:16:18 - general channel

**ShaunW**

One missing thing [@UPCC7TU8L](@UPCC7TU8L), wages?   As a guide my brother-in-law is in low latency financial trading development and makes £750 a day.

---

## 2022-04-14 11:21:34 - general channel

**DFL**

Hi all, I hope this posting this here is considered kosher!



We have a sports trading team with background in (financial) algo trading industry that is looking to add developers. We've had initial success in a few different sports and really looking to scale up.



Python Developer: Looking for someone to help us collect new data, build new tools and automate our systems.



Core Developer: Also will be primarily python, prefer someone with development within Financial, Crypto or Sportsbetting. Need to have proficiency in building low-latency network applications and experience with low-latency trading applications is a huge plus.



We may also have a role for someone with a JavaScript background.



Our team is based in Dublin, but we may be open to other locations or remote for the right candidates. Let me know if you're interested in hearing more!

---

## 2022-04-13 16:33:16 - random channel

**D C**

I was running another strategy on another box and didnt have the same issues.

---

## 2022-04-13 16:08:09 - issues channel

**Beeblebrox**

I think customerRef or customerOrderRef can have 32 characters, customerStrategyRef is limited to 15.

---

## 2022-04-13 12:50:38 - issues channel

**Beeblebrox**

You can override the default by setting `config.customer_strategy_ref` to something else

---

## 2022-04-13 12:17:24 - issues channel

**foxwood**

I'm running 2 live frameworks on same server for the first time - one for "ok" strategies and another for suspect ones and debugging.



As they both place bets it ends up with cross-talk warnings in the other framework's log log saying "Strategy not available to create order" and "Order %s not present in blotter". Was a bit worrying at first sight lol.



Presume this is in part caused by both frameworks having the socket hostname as the customer order ref since this does not happen when running the two frameworks on separate machines.



Suggestions: if the common hostname is the cause then extend the hostname with python PID (poss problems with multi proc) or an instance specific framework uuid property (logging does a short uuid for example) ?

---

## 2022-04-13 09:53:03 - random channel

**D C**

I don't use flumine/bflw but I batch multiple orders per strategy (but have about 14 strategies run concurrently) so even placing large numbers of bets at once it is already going to be split over fewer than 10 calls to placeOrders.

---

## 2022-04-13 08:23:15 - issues channel

**Jorge**

Hi, my streaming_market_data process is suddenly using a lot of memory RAM. For the first couple of days it is completely OK but then suddenly it starts accumulating more RAM and in a couple of days it takes all the available RAM in the Server, making the process freeze. Yesterday it took 80MB RAM (normal) and today it went up to 250MB RAM. Has anyone experienced something similar? This is basically my code for the process:



```trading = betfairlightweight.APIClient(... , lightweight=True)

trading.login()



market_filter = streaming_market_filter(event_type_ids=event_type_ids, market_types=market_type_codes, turn_in_play_enabled=True, country_codes=country_codes)

market_data_filter = streaming_market_data_filter(fields=["EX_BEST_OFFERS_DISP", 'EX_TRADED_VOL', "EX_MARKET_DEF"], ladder_levels=1)

streaming = Streaming(trading, market_filter, market_data_filter)

streaming.start()



while True:

    try:

        new_market_books = streaming.output_queue.get()

        publish_to_redis(db_0, new_market_books)

        log_debug('Total markets saved in Redis: {}'.format(len(db_0.keys())))



    except Exception as e:

        log_exception(e)```

I don't see any ERROR logs. Only some WARNINGs here and there about "Latency high", but I had those long time ago and the same process did not accumulate RAM memory...

---

## 2022-04-12 03:11:04 - general channel

**AP**

What would be the best way to extract the market p&amp;l within the Strategy class with flumine? Something within process_closed_market?

---

## 2022-04-09 16:24:23 - general channel

**JFP**

Hi all, I'm trying to filter out Novice races for a live strategy. For back testing the below code works:



```if "Nov" in market_book.market_definition.name:```

However I get NoneType error when running live. I have tried using the catalogue:



```if "Nov" in market.market_catalogue.market_name:```

This does not work either (I am trying to use this in the process market_book function). Would really appreciate it if someone could point me in the right direction. Thanks

---

## 2022-04-09 15:44:22 - strategies channel

**Aaron Smith**

`runner_context.placed_elapsed_seconds`  lets you know how many seconds passed since you last placed an order on the runner, so you can use this to adjust the rate at which orders can be placed. RunnerContext also shows orders placed on the runner, so you can use that in your decision of if you want to place more orders aswell:

[https://github.com/betcode-org/flumine/blob/0f12a0f9d200b4a4c36c8bd26c9f4fbe82f8cce1/flumine/strategy/runnercontext.py](https://github.com/betcode-org/flumine/blob/0f12a0f9d200b4a4c36c8bd26c9f4fbe82f8cce1/flumine/strategy/runnercontext.py)

---

## 2022-04-08 13:42:45 - strategies channel

**liam**

yeah its really handy, assumes you have subscribed to that marketType as well for that strategy

---

## 2022-04-08 13:40:04 - strategies channel

**J**

Is there a good way to go about it? I thought the strategy operates only within the context of the market so I must be missing something

---

## 2022-04-06 16:08:51 - issues channel

**ShaunW**

Sportbook/bookmaker prices are still subject to pressures from opinion as their objective is to maintain a balanced book. eg ideally not more than half the money accepted at evens etc.  That's one of the bigger differences between an open exchange and a single entity counterparty such as a bookmaker.  And the hive mind is a match for any model so no doubt a consideration if not the whole story.

---

## 2022-04-06 11:36:21 - issues channel

**Iván Gómez**

I understand that the odds that Betfair is setting in their Sportsbook are the result of the execution of complex models in real time and that the average odds that we can see in the Exchange is like the opinion of the persons that are betting (as its a per-to-per betting platform)

---

## 2022-04-04 17:16:07 - general channel

**VT**

Is it possible from a market ID to check the profit and loss (final balance containing all bets on this market)? I tried to download the account_statement from bflw but it only returns 100 results even changing record_count.



start_time = str(datetime.today() - timedelta(days=3))[:10] + "T00:00:00Z"

end_time = str(datetime.today())[:10] + "T00:00:00Z"



time_range = betfairlightweight.filters.time_range(from_=start_time, to=end_time)



bets= trading.account.get_account_statement(

     item_date_range=time_range,

     record_count = 10000

)

---

## 2022-04-04 15:07:35 - issues channel

**liam**

you are just checking the live_trade_count so once matched or cancelled or it will place another, the logs will tell you exactly what it's doing.



You should be simulating or paper_trading as well if coding up a strategy

---

## 2022-04-04 15:06:27 - issues channel

**Jon K**

And the output comes out as

starting strategy 'ExampleStrategy'

0

Windsor 4th Apr

Placing bet on  24244533

TradeStatus.LIVE

TradeStatus.LIVE

0

Windsor 4th Apr

Placing bet on  24244533

TradeStatus.LIVE

TradeStatus.LIVE

---

## 2022-04-04 13:37:39 - issues channel

**liam**

the reason it doesn't work is because betfair doesn't provide order data in the market stream so `matches_by_strategy` will always be empty

---

## 2022-04-04 13:23:24 - issues channel

**Jon K**

Hi, Just following some of the examples for Flumine and can place a bet ok (in fact, it places lots of bets...) but I'm struggling to see if a Runner already has a bet placed on it, so for example

Heres the simple Trade method

trade = Trade(

                    market_id=market_book.market_id,

                    selection_id=runner.selection_id,

                    handicap=runner.handicap,

                    strategy=self

                )

                order = trade.create_order(

                    side="BACK",

                    #order_type=LimitOrder(price= one_tick_higher(runner.sp / 2), size=2.00)

                    order_type=LimitOrder(price= 1000, size=2.00)

                )

                print (trade.status)

                market.place_order(order)

                print (trade.status)



But next time when I'm going through the Runners I try and use

runner.matches

runner.matches_by_strategy



but can't see anything obvious, they just show as 0 or [ ]

I've tried len(runner.matches_by_strategy) as I'm assuming its a list but I get 0.

I think I need to be calling runner.matches_by_strategy with a strategy name ("self") maybe ? But I don't understand how.

Simply put, I don't want it to place any bets on a Runner that already has a bet on it.

---

## 2022-04-01 10:08:12 - betfair-news channel

**Neil T (Betfair)**

Morning [@UUE6E1LA1](@UUE6E1LA1) - This isn’t something under consideration. The main reasons for this are lack of liquidity, the practicalities of managing it accurately and picture latency. Many greyhound races are largely determined by what happens in the first second or two after the traps open so it isn’t something which lends itself easily to Exchange in-play betting.

---

## 2022-03-31 13:43:09 - betconnect channel

**Karl Sutt**

`__repr__` should generally be the Python representation of the object, if at all possible. You should be able to copy-paste the representation into a Python shell and get a valid object out. [https://docs.python.org/3/reference/datamodel.html#object.__repr__](https://docs.python.org/3/reference/datamodel.html#object.__repr__)

---

## 2022-03-31 13:22:12 - betconnect channel

**Karl Sutt**

Also not sure about the `customer_strategy_ref` and `customer_order_ref` fields — it doesn't look like valid Python to me. Is that just the representation?

---

## 2022-03-31 13:17:38 - betconnect channel

**Graham**

```CreateBetRequestFilter(fixture_id=108400430, market_type_id=10160, competitor='10840043052320480', price=29.0, stake=500, handicap=None, bet_type='Win', customer_strategy_ref=Customer strategy ref: horse_racing, customer_order_ref=Customer order ref: 9168296c-23e7-4abd-b158-6355ddc5615f)```

---

## 2022-03-31 11:43:07 - betconnect channel

**Graham**

```{'source_fixture_id': '108400418', 'source_market_id': '101608400418', 'source_market_type_id': '10160', 'source_selection_id': '10840041852297932', 'trading_status': 'Trading', 'name': 'Patagonia', 'competitor_id': '1052297932', 'max_price': '4.33'}```

---

## 2022-03-30 19:46:09 - random channel

**Aaron Smith**

can someone explain `conflate_ms`  from flumine BaseStrategy to me? I see this will determine how often i get a market_book update, but how exaclty does it work? Is it still receiving all market_books and every conflate_ms millis it sends the newest one through? Also what are reason to set this to any specific value? Could i miss the the market_book update where the market closes (and would trigger process_closed_market) if i set it to a higher value? Pretty sure last one wont be the case, but i want to rule it out :smile:

---

## 2022-03-30 12:32:26 - issues channel

**Javier Martín Pérez**

Oh, so if I didn´t record it there is no way back directly with Betfair, am I right? I wasn´t recording any of the data as at first I didn´t care about the venue, but it seems that it has an impact on results. It´s Greyhounds where there it seems to be a big discrepancy on UK vs AU with my current strategy.

---

## 2022-03-30 09:35:25 - issues channel

**Jonjonjon**

I worked it out. It was a typical case on user error. In my check_market_book I was excluding NSW markets for live trading. But not for backtesting. Apologies for wasting everyone's time.:face_palm::skin-tone-6:

---

## 2022-03-29 18:08:00 - betconnect channel

**Oliver Varney**

just working on a fix will be either later on or early tomorrow morning, for now if your testing just populate customer_order_ref and customer_strategy_ref per the horse racing example

---

## 2022-03-29 18:02:02 - betconnect channel

**Oliver Varney**

no its todo with customer order ref and strategy refs

---

## 2022-03-29 17:05:54 - betconnect channel

**Oliver Varney**

try this maybe:

```client.betting.bet_request_create(

    request_filter=resources.filters.CreateBetRequestFilter(

        fixture_id=selection.source_fixture_id,

        market_type_id=int(selection.source_market_type_id),

        competitor=selection.competitor_id,

        price=max_price,

        stake=5,

        bet_type="Win",

        handicap=None

    )

)```



---

## 2022-03-29 13:45:47 - betconnect channel

**Graham**

placing a bet request with some manual fields

```            bet_create_response = client.betting.bet_request_create(

                request_filter=resources.filters.CreateBetRequestFilter(

                    fixture_id=fixture.fixture_id,

                    market_type_id= 10160, #win_market_type.market_type_id,

                    competitor=selection.competitor_id,

                    price=2.75,#best_price.price,

                    stake=500,

                    bet_type=win_bet_type,

                    customer_strategy_ref=resources.CustomerStrategyRef.create_customer_strategy_ref(

                        STRATEGY_NAME

                    ),

                    customer_order_ref=resources.CustomerOrderRef.create_customer_order_ref(

                        str(uuid.uuid4())

                    ),

                )

            )```

returns a validation error

```

Traceback (most recent call last):



  File "C:\Users\Graham\AppData\Local\Temp/ipykernel_3964/974456888.py", line 67, in &lt;module&gt;

    bet_request_get = client.betting.bet_request_get(



  File "C:\Users\Graham\anaconda3\lib\site-packages\betconnect\endpoints\betting.py", line 221, in bet_request_get

    return self.process_response(



  File "C:\Users\Graham\anaconda3\lib\site-packages\betconnect\endpoints\baseendpoint.py", line 192, in process_response

    return resource.create_from_dict(data)



  File "C:\Users\Graham\anaconda3\lib\site-packages\betconnect\resources\baseresource.py", line 26, in create_from_dict

    return cls.parse_obj(d)



  File "pydantic\main.py", line 572, in pydantic.main.BaseModel.parse_obj



  File "pydantic\main.py", line 400, in pydantic.main.BaseModel.__init__



ValidationError: 1 validation error for BetRequest

backer_stats

  field required (type=value_error.missing)```

---

## 2022-03-29 13:39:10 - betconnect channel

**Graham**

I'm using this one [@U010GM77S4W](@U010GM77S4W)

```bet_create_response = client.betting.bet_request_create(

                request_filter=resources.filters.CreateBetRequestFilter(

                    fixture_id=fixture.fixture_id,

                    market_type_id=win_market_type.market_type_id,

                    competitor=selection.competitor_id,

                    price=best_price.price,

                    stake=500,

                    bet_type=win_bet_type,

                    customer_order_ref=resources.CustomerOrderRef.create_customer_order_ref(

                        str(uuid.uuid4())

                    ),

                )

            )```

---

## 2022-03-29 13:37:09 - betconnect channel

**mandelbot**

I'm getting

```{"asctime": "2022-03-29 12:35:10,069", "levelname": "ERROR", "message": "Issue with request for: [https://stgapi.betconnect.com/api/v2/bet_request_create](https://stgapi.betconnect.com/api/v2/bet_request_create), message: Input payload validation failed", "exc_info": "NoneType: None"}```

my bet looks like this:

```                            client.betting.bet_request_create(                                request_filter=resources.filters.CreateBetRequestFilter(

                                fixture_id=selection.source_fixture_id,

                                market_type_id=selection.source_market_type_id,

                                competitor=selection.competitor_id,

                                price=max_price,

                                stake=5,

                                bet_type="Win",

                                handicap=None

                                )

                                )```



---

## 2022-03-29 11:35:03 - strategies channel

**Ruben**

was asking because I chose to go live with my first strategy, which happens to be a making strategy, and I had not backtested (mainly because at the time I was not recording anything) and I see that it has quite a large variance and it will take a while to tell if the strategy makes money or not

---

## 2022-03-29 11:25:47 - strategies channel

**Mo**

Personally I would not bother backtesting a making strategy. It's impossible to know exactly how the market's behaviour would change with the presence of your orders. At least if you are testing taking then you know for sure that a price was available to take at a time. Provided you don't get yourself in a position where you try to take the same bet twice in a backtest

---

## 2022-03-29 10:44:02 - strategies channel

**liam**

Making is more realistic in matching (can prevent double counting of liquidity) but discounts impact, taking theoretically is impacted less by impact but doesn't handle double counting of liquidity.



However if you have reached this point you should be doing the analysis live, simulating is more for confirming a model/backtest and as a final integration test although I am very guilty of using it too much as it works so well..

---

## 2022-03-28 08:08:12 - random channel

**PeterLe**

just to add; i did some test many years ago on Virtual V Dedicated, using similar specs and the exact same strategy, and then comparing the betids, I found the dedicated to be marginally slower (and more expensive as Mo has stated)

---

## 2022-03-27 23:39:09 - random channel

**Jonjonjon**

When using Flumine to run live trading on cloud servers, do people tend to to for shared or dedicated CPUs?

---

## 2022-03-27 17:39:58 - random channel

**Mo**

Depends on the strategy

---

## 2022-03-27 12:31:28 - random channel

**mandelbot**

I'm only asking because I believe I have it toggled off yet my account details shows

```{"asctime": "2022-03-27 10:59:58,616", "levelname": "INFO", "message": "Client update account details", "username": "username", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x0000023775B21D00&gt;"], "order_stream": false, "best_price_execution": true, "paper_trade": false}```

`"best_price_execution": true`

---

## 2022-03-26 16:18:49 - issues channel

**mandelbot**

So I'm trying to use the example to login to the betconnect staging area but get the following error

```    return cls.parse_obj(d)

  File "pydantic\main.py", line 511, in pydantic.main.BaseModel.parse_obj

  File "pydantic\main.py", line 331, in pydantic.main.BaseModel.__init__

pydantic.error_wrappers.ValidationError: 1 validation error for AccountPreferences

building

  none is not an allowed value (type=type_error.none.not_allowed)```

How do i pass this `AccountPreference`  in?

---

## 2022-03-26 10:43:15 - issues channel

**Jonjonjon**

In the order logs that Flumine places for me, I see that I placed some orders 8 days ago. However, they aren't in my cleared orders on the website. So Iel assume they were voided. But voided orders only go back 7 days. I think my strategy might be subject to this problem quite a lot as my live bet count is a lower than what I get if I subsequently run the same market through a backtest.



What is the best way to monitor this situation?

---

## 2022-03-25 15:57:48 - general channel

**mandelbot**

Not sure what im missing here

```Traceback (most recent call last):

  File "C:/FlumineNew/Lib/site-packages/flumine/examples/strategies/BSPtest.py", line 210, in &lt;module&gt;

    framework.run()

  File "C:\FlumineNew\lib\site-packages\flumine\flumine.py", line 15, in run

    with self:

  File "C:\FlumineNew\lib\site-packages\flumine\baseflumine.py", line 415, in __enter__

    self._add_default_workers()

  File "C:\FlumineNew\lib\site-packages\flumine\flumine.py", line 54, in _add_default_workers

    client_timeouts = [

  File "C:\FlumineNew\lib\site-packages\flumine\flumine.py", line 55, in &lt;listcomp&gt;

    client.betting_client.session_timeout for client in self.clients

AttributeError: 'NoneType' object has no attribute 'session_timeout'```

---

## 2022-03-25 14:24:30 - strategies channel

**D C**

I suppose accuracy depends on how good my strategy is. Hard to verify actual GPS accuracy without watching the race back. The more I speak with other GPS players, the more I feel I am doing something slightly different to the crowd. I tend to get my worst results on races with small fields and very short odds on favourites that don't rise above BFSP during the race.

---

## 2022-03-25 08:27:46 - strategies channel

**liam**

ROI is much higher for me, strategy/risk tolerance dependant on how you play the game. My results tend to be majority break even (slightly +ve) with some nice wins on top, although recently I have found it's very easy to get the opposite when pushing things too hard... :joy:

---

## 2022-03-24 16:55:44 - random channel

**D C**

I'd heard that Ladbrokes sold it back to the original owner so was hoping that might be a return to a true exchange focused business model. I suppose even if that were true it would take time to change things around and modernise it. SOAP just feels dirty to me in this day and age.

---

## 2022-03-24 12:32:36 - betconnect channel

**Unknown**

Hello everyone, we've got a few spots left for our first API event in Mayfair next week. It will be hosted at the Candy Capital bar where we will be chatting about our business model and the value that we are bringing to API bettors. This first event will be focused on backers, let us know if you want to come! :beers:

---

## 2022-03-23 11:43:27 - general channel

**Alex Alex**

So without having spent much time on this: Is there a way for me to see the orderbook? I.e. I want to see the available back bets that I could lay. I’d be quite interested in this. I have a model that could be adopted for pre game.

---

## 2022-03-23 08:27:32 - random channel

**Peter**

I agree with [@USYQKE5HN](@USYQKE5HN). It's imperative that you test with more data. Two weeks isn't very long for the dogs. Although you get a lot of races, the narrowness of the grading bands means there's also a lot of unpredictability in the race results and the type of strategy you're testing, i.e. dependant on a few big wins will be very sensitive to the number of wins you manage to pick.

---

## 2022-03-23 00:14:45 - random channel

**James T**

I'd test with more data, and see whether you have a decent edge betting outright or not (no hedge). But that's a riskier route. You'd want a few months of data.



If your strategy is purely price action based then you're never going to get a massive margin when taking volume anyway. Offering may be better, but that's harder to test.



I'd recommend just trying it live with small stakes and see whether you can realise that 0.6% or not. If your backtest says you should be getting 95% positive days when hedging out, but the first day you try you lose money, then you can quickly just say it's back to the drawing board.



You're probably not far off having something though.

---

## 2022-03-22 22:31:18 - random channel

**James T**

For pre-play I would generally want more than 1% profit on stakes. 0.6% is a little low, since you're likely to loose a little to slippage / moving the market if you are taking volume once you go live. Or if you are offering then you'll have unmodelled adverse selection. 0.6% is just a bit too low on margin for it to be realistic and scalable. Might depend on when you are trading though, and how much you are trading (combining backs and lays) vs taking large outright bets.

---

## 2022-03-22 22:03:02 - random channel

**Jonjonjon**

What sort of POT figures to people consider respectable, and why is it important? I've just calculated the statistic for a model I'm calibrating. Just considering the back side, the POT is 0.6%.

---

## 2022-03-22 16:53:02 - general channel

**VT**

Hi guys, I'm having problems with the order_stream connection, after some time I get disconnected by Betfair. Is there a way for me to automatically reconnect when this happens? I use the simplest code.



----------------------------------------------------------------------------

Exception in thread Thread-13:

Traceback (most recent call last):

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 230, in _receive_all

    part = self._socket.recv(self.buffer_size)

  File "C:\anaconda3\lib\ssl.py", line 1226, in recv

    return self.read(buflen)

  File "C:\anaconda3\lib\ssl.py", line 1101, in read

    return self._sslobj.read(len)

ConnectionResetError: [WinError 10054] Forced cancellation of an existing connection by the remote host



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "C:\anaconda3\lib\threading.py", line 932, in _bootstrap_inner

    self.run()

  File "C:\anaconda3\lib\threading.py", line 870, in run

    self._target(*self._args, **self._kwargs)

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 60, in start

    self._read_loop()

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 212, in _read_loop

    received_data_raw = self._receive_all()

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 234, in _receive_all

    raise SocketError("[Connect: %s]: Socket %s" % (self._unique_id, e))

betfairlightweight.exceptions.SocketError: [Connect: 2]: Socket [WinError 10054] Forced cancellation of an existing connection by the remote host

----------------------------------------------------------------------------



Code:



output_queue = queue.Queue()

listener = betfairlightweight.StreamListener(output_queue=output_queue, lightweight=True)

stream = trading.streaming.create_stream(listener=listener)

order_filter = streaming_order_filter()

streaming_unique_id = stream.subscribe_to_orders(order_filter=order_filter, conflate_ms=0)

t = threading.Thread(target=stream.start, daemon=True)

t.start()

---

## 2022-03-22 09:47:18 - general channel

**Eamonn**

BetConnect offers the chance to access soft bookmaker prices rather than playing against other sharps on the traditional exchanges.



Back bets are typically layed by matched bettors who have no opinion on your back selection and will place the bet at a bookmaker on your behalf. They then have a flat position and try to exploit bookmaker promotions which are not passed on to the backers on BetConnect.



BetConnect offers backers the chance to bet earlier in the market cycle when liquidity on traditional exchanges is poor. The big advantage in this spot is that the roi is much higher for skilled bettors and negates the over round you are betting into.



Yes I work at BetConnect and we welcome all questions. We would love to get more users from betcode taking advantage of BetConnect

---

## 2022-03-22 09:39:32 - random channel

**LM**

This should handly it pretty easily?

```            # create lay order if back order was matched  

            if order.status == OrderStatus.EXECUTION_COMPLETE and order.size_matched &gt; 0:

                

                market_id, selection_id, handicap = order.lookup

                

                runner_context = self.get_runner_context(

                        market_id, selection_id

                    )

                if runner_context.trade_count == 1:

                

                    trade = Trade(

                        market_id=market_id,

                        selection_id=selection_id,

                        handicap=handicap,

                        strategy=self,

                    )

                    # create order

                    order = trade.create_order(

                        side="LAY",

                        order_type=LimitOrder(lay_price, order.size_matched),

                    )

                    # place order for execution

                    market.place_order(order)```

---

## 2022-03-22 09:31:06 - random channel

**LM**

Something like this (reference for anyone wondering):

```def process_orders(self, market, orders):

    for order in orders:

        # kill order if unmatched in market for greater than 5 seconds

        if order.status == OrderStatus.EXECUTABLE and order.side == 'BACK':

            if order.elapsed_seconds and order.elapsed_seconds &gt; 5:

                market.cancel_order(order)



        # create lay order if back order was matched  

        if order.status == OrderStatus.EXECUTION_COMPLETE and order.size_matched &gt; 0:

            

            market_id, selection_id, handicap = order.lookup

            

            trade = Trade(

                market_id=market_id,

                selection_id=selection_id,

                handicap=handicap,

                strategy=self,

            )

            # create order

            order = trade.create_order(

                side="LAY",

                order_type=LimitOrder(lay_price, order.size_matched),

            )

            # place order for execution

            market.place_order(order)```

---

## 2022-03-22 08:21:02 - random channel

**Unknown**

Interesting meetup on the AUS slack about AFL modelling from Michael Lean, given me a few ideas on other sports..

---

## 2022-03-18 08:59:33 - issues channel

**Nacho Uve**

Sorry, I have no time yesterday to send them.



Here there are the logs with one of the cases.



The strategy places some orders with prices greater than the current ones.



So, here is what happens:



- Order 100000000001: Back 2.00€ - @1.41 is matched when [back 1.37 - lay 1.42] at the price @1.41  (Better than the best back market_book price for that selection. Is it part of the backtesting to simulate the behaviour of the real market?)

- Order 100000000002: Back 2.67€ - @1.47 is matched when [back 1.49 - lay 1.56] at the price @1.47. (It does not match the best price )

- Order 100000000003: Back 1.00€ - @1.60 is matched when [back 1.55 - lay 1.61] at the price @1.60. (Case 1)

- Order 100000000004: Back 1.00€ - @1.66 is matched when [back 1.64 - lay 1.77] at the price @1.66. (Case 1)



The zip includes:

• file with the regular logs

• file some prints with extra info with the market_book prices and other state of the strategy

• the recorded stream file (it is recorded with the delayed api key)

---

## 2022-03-17 12:39:04 - issues channel

**Nacho Uve**

I don't understand something I'm seeing when backtesting a very simple strategy.



My strategy backs a selection at price @1.71. The order is placed and it has  status "Executable".  Ok.



Then the price of that selection is rising and at some point it is greater that @1.71. But it is not matched, although it has enough "size" to do it.



What do you think could bt the problem here?

---

## 2022-03-17 12:04:44 - general channel

**liam**

Yes ideally, how slow is the modelling process? 

---

## 2022-03-17 11:54:21 - general channel

**anomaly**

Hmm I think i've gotten myself in a tangle because of the way the modelling has been done. I'm currently using bflw to manage and then spawn a model that makes a selection. Given that selection, I want to place a bet.

Each model communicates through a queue to the main thread which I originally planned to have place the bets through bflw... but now it appears flumine is much better suited for this purpose.

In summary, the current setup is: bflw process loop (monitor market stream) -&gt; spawn models according to some trigger logic and each model makes a single prediction -&gt; send the (market_id, selection_id, order_type, stake) through the queue -&gt; bflw process reads the queue and places bet -&gt; bflw closes and cleans up the model process

Given what you said and having another look at the code it seems I need to instead encode the model spawning logic _inside_ the BaseStrategy (process_market_book, check_market_book etc). Is this correct?

---

## 2022-03-17 05:25:03 - general channel

**anomaly**

[@U4H19D1D2](@U4H19D1D2) I was able to run the code successfully! is there a way to use same framework/betfair client to push new strategies?



.run() seems to be blocking but I would like to call framework.add_strategy(strategy) on demand. i.e. a framework process is reading a queue and it constructs aribtrarily many new Strategies on demand, and pushes them to the framework.



Additionally, assuming it's possible to seamelessly add strategies, how would you safely "remove" them?

---

## 2022-03-16 09:32:38 - general channel

**anomaly**

Can do! So essentially a typical situation is this:



1. you have a strategy name. say it's called "back_strat_42". it's betting on UK horseracing.

2. you have a single market_id and a single selection_id that you want to place a bet on

3. you have the liability to stake (back or lay doesn't matter).

4. you want to place just a single bet on the selection at anytime and leave it in the market. so for simplicity say a OrderType=MARKET_ON_CLOSE with PersistenceType=MARKET_ON_CLOSE

5. you want a log/trace of the result of the bet that you placed for post-race analysis (typically with a database dump)



This is to be repeated multiple times from a few different strategies but the logic is essentially as above and the current system design is to place these bets from individual threads or processes.

A follow up question is if you have dozens of these happening in parallel will it be an issue from a betfair api perspective? I'm connecting with a live api key with bot login (certs) and it seems you're only allowed 9 connections. Would this be an issue with the above setup?

---

## 2022-03-16 06:00:25 - general channel

**liam**

Nothing wrong with using flumine for this (we push a never green policy) however you would only need a single instance/strategy and take advantage of the strategy.trade_count to limit the number of bets per selection.



If you provide a rough idea of what you are doing (market type / bet type etc) I can provide a simple example.



Flumine uses the refs internally and instead designed to record all bets / strategy info through logging control. 

---

## 2022-03-16 02:23:18 - general channel

**anomaly**

Hi all,



Newbie to flumine/bflw here! Got a few question about best practice placing single ex / bsp bets with flumine. In the examples, it seems you need to wrap BaseStrategy and internally define the logic in process_market_book() which seems straightforward enough. Peeking inside the Flumine class the .run() executes a while True loop suggesting that the process_market_book() will run forever when triggered.

In my case, I simply want to execute a single bet on demand and that's it. What's the recommended practice for placing single market-selection_id bets like this? Is it fine to continuously initialise new Flumine() instances per market and include a select_id as an additional class attribute (e.g self.selection_id)? In hindsight, I have a feeling flumine might be overkill for what I need and that a simple bflw order placement is enough... but don't know enough to know if I should be taking advantage of what flumine has to offer (order tracking, error handling, etc) - the impression is that it seems more trading-focused which is not what I need right now.



The last question is, what's the best way to uniquely identify a strategy in bflw or flumine so that it's easy to track specific strategies and the bets they place? From what I understand it's ideal to use the listClearedOrders api and also customerOrderRef / customerStrategyRef. How do you specify these with bflw / flumine?

---

## 2022-03-15 10:07:00 - general channel

**Mo**

Not sure how common it is but obviously your strategy will need to be able to handle it

---

## 2022-03-15 08:09:46 - general channel

**Jorge**

Hey, I am betting pre-game and do not want to bet in_play because my bots don't use action data. But I would like to bet as close as possible to the market start time. So far, I check if the market is in_play using betfairlightweight streaming MarketBook.inplay. Is there a better way of knowing when the event will start?

---

## 2022-03-14 18:38:06 - random channel

**D C**

Yeah I can see the sense in that. Parameter selection is usually about balance anyway. I suppose I was thinking about things untuitively or where there is an obvious bias. For example I don't know for certain but I would imagine that total points in NBA is consistent on a per venue basis as all basketball courts have the same dimensions so I would probably not even look at it. But the baseball venue altitude is a "known" thing. I suppose there though you are getting close to the edge of fundamentals based modelling as stuff like weather and humidity come into play. Was really just trying to get a feel for the general opinion on these types of problem.

---

## 2022-03-14 18:02:40 - random channel

**Peter**

My starting point is to use a categorical variable in statsmodel and look at the coefficients and the p-test results to see whether the feature on which I might split has the variability and significance to justify a split.

---

## 2022-03-14 18:01:40 - random channel

**Peter**

I try both ways. It's a balance between having a bigger dataset to model with versus and the potential of increased precision when targeting different models to different circumstances. There's not one answer. You have to suck and see which generates the best results for the specific sport.

---

## 2022-03-14 16:27:40 - random channel

**D C**

If you are modelling a sport, do you ever "split" the modelling in the sense of using separate models across (fairly) homegeneous groupings? I am thinking along the lines of football - would you have many per-league models, or have the league as a cateregorical variable within a single more generic model? What about in the cases of differing environments? For example, if you were modelling snooker, you would not expect there to be much difference between venues. But for something like modelling total score in a baseball game, there are clear outliers (it was or still is the case that average runs per game at colorado games was higher due to the altitude above sea level) - would you model this venue seperately or place venue as a categorical variable within a broader model? These are not the best examples but the best I could think of but I am really interested in people's approaches or if there is a theoretically sound best practice for this kind of modelling?

---

## 2022-03-14 16:09:06 - random channel

**Peter**

LOL [@UUE6E1LA1](@UUE6E1LA1). You had it easy. I was pumped to find that my Masters dissertation (based on the results of models and data coded on punch cards  loaded and run overnight on a mainframe) still had value. But then had 40 years of catching up to do.

---

## 2022-03-14 15:49:52 - random channel

**D C**

I basically just want to be able to model using GLMs in a similar manner to that of R so that I can do model validation, residual checks and all the other stuff. This PolynomialFeatures looks to be more useful for pure approximation problems rather than inference. I am clearly going to have to get used to changes in terminology over the last 20 years. What seems now to be called a "feature" we used to call an explanatory or dependent variable. Similarly design matrix (or observation matrix) now seems to be called feature matrix. I guess this is ML based terminology superceding the stats/approximation theory lingo now. I'll stick with R for now as I don't want to be creating extra columns myself to try to model interaction effects.

---

## 2022-03-14 15:34:23 - random channel

**Alex Alex**

Did you have a look at `sklearn.preprocessing.PolynomialFeatures` ([https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html)) I’m not sure how the R implementation differs from the PolynomialFeatures. Generally I occasionally use sklearn for this purpose and never found it too bad. You can neatly package this into a pipeline with whatever model you want to run afterwards.

---

## 2022-03-14 14:10:13 - random channel

**D C**

Yeah I definitely prefer the statsmodels so far as at least you can get p-vals and parameter CI. Never even heard of rpy2 but that sounds like a great solution.

---

## 2022-03-14 14:08:33 - random channel

**Mo**

Depends what you are doing, `statsmodels` is decent just not as good as base R. You can always use `rpy2` to call R code from Python if that helps

---

## 2022-03-14 14:03:18 - random channel

**Oliver Varney**

although interaction effects im not sure about that tbh though, isnt that more stats based models?

---

## 2022-03-14 14:00:38 - random channel

**D C**

I've been starting to use Python to perform logistic regression but struggling to find a way to model interaction effects. In R this is easy. I've tried sklearn and statsmodels but so far can't see an easy way to do this as both make use of the dataframe columns you provide. I am brand new to this in a python setting so may have missed something obvious but is there a simple way to do this or am I better off (from speed point of view) sticking with R ?

---

## 2022-03-14 09:13:45 - random channel

**liam**

Just in case anyone finds this useful, this is working well in a flumine strategy:



```def get_context(self, market_id: str = None) -&gt; dict:

    if "AB" in self.context:

        _context = self.context["AB"]

        ab_context = self._get_rand_context(market_id, _context)

        context = {}

        for k, v in self.context.items():

            if k == "AB":

                continue

            if k in ab_context:

                context[k] = ab_context.pop(k)

            else:

                context[k] = v

        for k, v in ab_context.items():

            context[k] = v

        return context

    else:

        return self.context



@staticmethod

def _get_rand_context(market_id: str, context: List[Dict]) -&gt; dict:

    id_ = int(market_id[2:])

    r = (0.5 + _INVERSE_GOLDEN_RATIO * id_) % 1

    return context[int(r // (1 / len(context)))].copy()```

```Strategy(

    context={

        "AB": [

            {"bankroll": 1},

            {"bankroll": 1.3},

            {"bankroll": 1.5},

        ],

        "var_one": "LAY",

        "var_two": True,

    }

)```

---

## 2022-03-14 06:47:38 - general channel

**Oliver Varney**

yup :+1: I just find the modelling part the only enjoyable part tbh

---

## 2022-03-14 06:44:13 - general channel

**Mo**

A key question is how much this actually matters as I have no idea how sensitive the success of my strategy is to the prediction of the duration

---

## 2022-03-12 19:13:36 - random channel

**Mo**

Have production and test servers both running live trading code. New features get live tested before going into production

---

## 2022-03-12 11:49:05 - general channel

**Laybot McBackbot**

No, I am not watching this real-time. I am running the script overnight and I want to be able to come to back to it in the morning and decide whether I want to continue running or just abort if I find it halfway that it is not a strategy I want to pursue.  I am also running a lot of other stuff/simulations on my machine and there is always a chance something goes wrong and it doesn't finish.

---

## 2022-03-12 11:38:09 - general channel

**Peter**

You could build something into your strategy to output the P&amp;L of each market as the backtesting closes it, possibly by adding something into the strategy's process_closed_market() method. But I wouldn't recommend it.



Better would be to understand that if you're going to be doing this seriously, you'll be doing a lot of backtesting, and sitting watching the results in real-time is going to get old really quick. So rather than solving this problem, maybe have a think about how you could use the backtesting run time more productively.

---

## 2022-03-11 16:38:39 - random channel

**liam**

Anyone see any issues with this? Takes a list of dictionaries and returns a random one based on the marketId, ie a list of `strategy.context`



```def _get_rand_context(market_id: str, context: list[dict]) -&gt; dict:

    id_ = int(market_id[2:])

    r = (0.5 + _INVERSE_GOLDEN_RATIO * id_) % 1

    count = len(context)

    x = [(i * (1 / count)) for i in range(1, count + 1)]

    for i, y in enumerate(x):

        if r &lt; y:

            return context[i].copy()

    return context[-1].copy()



context = _get_rand_context("1.23", [{"a": 1}, {"a": 2}, {"a": 3}])```

---

## 2022-03-11 14:49:47 - issues channel

**Dave**

My end goal is to populate a poisson model with betfair odds and fixtures

---

## 2022-03-10 09:33:33 - general channel

**Mo**

I have a prediction model but it's not ML and that seems overkill for in running horse racing IMHO

---

## 2022-03-10 09:24:10 - general channel

**J**

Yeah the commission rates are a pain. Although I can keep playing with it with $1 bets until I get the model right. I was wondering who had played with machine learning models in the inflight data. I've been adding them to Flumine and they're working pretty well

---

## 2022-03-09 00:00:36 - issues channel

**Brøndby IF**

Good evening everyone, is there any way I can make a call and find out all the possible paths of data I can collect? For example, in football by `trading.betting.list_events` I collect: `event.name, event.id, event.open_date`  and I would like to know if in Python there is any way to pull all the other paths to make it easier because I have difficulty understanding the way through the Betfair mapping, their site is very messy.

---

## 2022-03-08 09:24:55 - issues channel

**J**

UnicodeDecodeError: 'charmap' codec can't decode byte 0x81 in position 82: character maps to &lt;undefined&gt; &lt;--Does anyone hit this a lot in Flumine when loading stored markets on disk (like historic files)? I'm hitting it often but somewhat randomly. Hitting it in both historic files and also marketrecorded files



Ful trace: Traceback (most recent call last):

  File "c:\Users\heari\Desktop\flumine\bfbulk v2.py", line 537, in &lt;module&gt;

    *framework.add_strategy(strategy2)*

  File "C:\Users\heari\AppData\Local\Programs\Python\Python39\lib\site-packages\flumine\baseflumine.py", line 90, in add_strategy

    self.streams(strategy)  # create required streams

  File "C:\Users\heari\AppData\Local\Programs\Python\Python39\lib\site-packages\flumine\streams\streams.py", line 45, in __call__

    market_type = get_file_md(market, "marketType")

  File "C:\Users\heari\AppData\Local\Programs\Python\Python39\lib\site-packages\flumine\utils.py", line 67, in get_file_md

    first_line = f.readline()

  File "C:\Users\heari\AppData\Local\Programs\Python\Python39\lib\encodings\cp1252.py", line 23, in decode

    return codecs.charmap_decode(input,self.errors,decoding_table)[0]

*UnicodeDecodeError: 'charmap' codec can't decode byte 0x81 in position 82: character maps to &lt;undefined&gt;*

---

## 2022-03-07 20:44:48 - general channel

**Jonjonjon**

Good observation Peter. I saw some large bets smash up my signal late last year, but again it lasted 3 days. The last couple of days have been tough too. A strategy that hadn't had a losing day this year took a couple or small losses. But I'd increased the size on some other strategies. Hmmm... Maybe my bot is doing the trampling? :thinking_face:

---

## 2022-03-07 19:42:04 - issues channel

**Aaron Smith**

s3_recorder is on the newest version, only difference is my add function:

```    def add(self) -&gt; None:

        [http://logger.info|logger.info](http://logger.info|logger.info)("Adding strategy %s with id %s" % (self.name, self.recorder_id))

        # check local dir

        if not os.path.isdir(self.local_dir):

            os.makedirs(self.local_dir)  # added by smiffy

            # raise OSError("File dir %s does not exist" % self.local_dir) &lt;- original by liam

        # create sub dir

        directory = os.path.join(self.local_dir, self.recorder_id)

        if not os.path.exists(directory):

            os.makedirs(directory)```

Trying to fix the problem i restarted the recorder from scratch and got tired of manually making the local file each time :smile:

---

## 2022-03-07 18:09:53 - general channel

**Peter**

I have seen similar. A strategy that was placing several hundred bets a day, suddenly just stopped. I anticipated an error in my code, some sort of untrapped condition that I'd failed to allow for and catch.



However when I dug into it, it turned out to be a large bets coming arriving in a way that trampled all over my signal, to the point when very few of my trades were still were still in range, and those that were still triggered, were failing a 2nd signal. Lasted about three days, then went back to normal.



I suspect that somebody was running a new strategy that didn't work out for them - maybe because they pushed me and others out and didn't like what they were left with. But it did warn me that my strategy was more sensitive than I'd realised.

---

## 2022-03-07 12:01:20 - general channel

**liam**

if you check in the `strategy.process_closed_market` there should be the correct status

---

## 2022-03-05 12:09:24 - issues channel

**Stefan**

[@U011VL3CA2Y](@U011VL3CA2Y), [@U9JHLMZB4](@U9JHLMZB4) I do this for data strategy visualization: [https://youtu.be/FM79mZWkfxI?t=56](https://youtu.be/FM79mZWkfxI?t=56)



Basically there are 3 types of data: scalar,  object, collection. And so to visualize them I use property browse, grid view and chart view.

---

## 2022-03-04 20:38:36 - general channel

**J**

That multi processor backtesting works like a dream too... whipped up a strategy brute forcer today with it that's humming along at 100% on all 16 cores perfectly

---

## 2022-03-03 12:25:26 - general channel

**EJono**

Thank you very much for the code example. A few things to help m,e understand how it should be used:



Should this class be utilised like any other strategy ie i would initialise by

strategy = ClosedMarketLogging(...)

framework.add_strategy(strategy)

framework.run()   ?



Could i call "def _process_cleared_orders_meta(self, event): " in my strategy that i have set up and running currently and expect it to correctly run at the end of a market



And is the order information you are accessing via

orders = event.event

Available in one of the standard methods that run in a flumine strat like process_market_book, process_orders, process_closed_market obviously once the market outcome has been determined?



Apologies if the above questions are nonsensical, my undertanding of flumine is still quite surface level at this stage. cheers

---

## 2022-03-02 06:09:44 - strategies channel

**J**

Exact code is below. Is this the correct way to place a back order? The only examples I can find are lays





                                        print('Placing bet')

                                        market.context['betstatus'] = 'y'

                                        betstatus = 'y'

                                        trade = Trade(

                                            market_id=market_book.market_id,

                                            selection_id=r.selection_id,

                                            handicap=1.0,

                                            strategy=self,

                                        )

                                        order = trade.create_order(side="BACK", order_type=LimitOrder(price=1.01, size=5.00))

                                        market.place_order(order)

                                        print('Bet placed.')

---

## 2022-03-02 05:58:21 - strategies channel

**J**

Whipped up a bot/strategy today in flumine but it's not placing bets. The market.place_order(order) call goes through without error (and on to the next line of code fine so there's no silent exception in the main code) but no order is placed. Is there a place that order errors are logged?

---

## 2022-03-01 13:10:43 - general channel

**Nacho Uve**

Some newbie questions:



1. Is it possible to combine the "market_recording_mode=True" with trading strategies?

2. Are the orders placed manually in the BF web interface noted on the market.blotter?

---

## 2022-03-01 11:38:13 - strategies channel

**liam**

so you can do it in the strategy and store in `strategy.context` or `market.context` but you also have middleware that you can create/use so that it can be shared with all strategies (this is how the simulated logic works)

---

## 2022-03-01 11:09:12 - strategies channel

**J**

Out of interest, is detecting price changes through process market book in a strategy the fastest way to detect a runner price change? Or should I be hooking directly into something underlying?

---

## 2022-03-01 10:59:54 - strategies channel

**J**

Yep, but on digging it seems it's in betfairlightweight (runnerbookcache)? Essentially I'm trying to make a strategy that triggers on a % change in price in in play races

---

## 2022-03-01 08:11:21 - general channel

**liam**

They basically seed it themselves and its loss making so any strategy that involves exploiting its inefficiency results in banning, its for the 'greeners' / to compete with betfair BSP

---

## 2022-02-28 21:52:05 - general channel

**Jonjonjon**

I think you need £200 in your account. Otherwise it wasn't hard for me to get access. But they didn't like my strategy of placing orders far away from the current market, so I didn't get anywhere with it.

---

## 2022-02-28 20:07:46 - issues channel

**William**

```   # setup logging

    logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updat



    # create trading instance

    trading = betfairlightweight.APIClient(user, password, app_key=appKey, certs='/certs')



    # login

    trading.login_interactive()

    # create queue

    output_queue = queue.Queue()



    # create stream listener

    listener = betfairlightweight.StreamListener(

        output_queue=output_queue

        # lightweight=True

    )

    # create stream

    stream = trading.streaming.create_stream(

        host="race",

        listener=listener

    )

    # create filters (GB WIN racing)



    market_filter = streaming_market_filter(

        # event_type_ids=['7'],

        # country_codes=['AU'],

        # market_types=['WIN'],

        market_ids=market_id

    )

    market_data_filter = streaming_market_data_filter(

        # fields=['EX_LTP', "EX_ALL_OFFERS", 'EX_MARKET_DEF', 'EX_TRADED_VOL', 'EX_TRADED'],

        # fields=['EX_ALL_OFFERS', 'EX_MARKET_DEF'],

        # ladder_levels=9,

    )

    # subscribe

    streaming_unique_id = stream.subscribe_to_markets(

        market_filter=market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=100,  # send update every 1000ms

    )

    stream.start()

    return trading, output_queue, listener```

---

## 2022-02-28 11:52:06 - general channel

**Tony**

Hi all :wave:, i am new to the channel. I am going to try create a  tennis trading bot as i already trade it daily but would like to try automate certain scenarios. I have a delayed API key but from reading around it doesn’t feel like it would allow me to get an accurate picture and also i would like to stream some data for backtest purposes but the betfair free files don’t seem to have what i would like either. What is the best place way to get the live key activated?

---

## 2022-02-27 18:32:20 - general channel

**VT**

Welcome, I'm part of this group of stupid questions and it's not that bad. If you need bets with a tendency to null EV an option can be the over 2.5 goals in Premiere League games betting less than 1 hour to the start of the game.

---

## 2022-02-27 12:27:57 - general channel

**Aaron Smith**

I did it like a real man, no paper-trading no backtest - just raw negative EV :smile: Anyways, i think you need to trade at least a little when streaming the data, otherwise betfair may dislike your use of their api. Shouldnt cost a lot though, with minimal stakes and only a few bets. You may aswell win some, EV and reality converge towards each other slowly

---

## 2022-02-27 11:31:07 - general channel

**Peter**

[@U033HM6Q8BU](@U033HM6Q8BU) You don't have to lose money while you're learning. Checkout the paper trading option in the Flumine documentation. You can build a model that works with live data but doesn't place live bets, just measures what would have happened if you had. Make sure to place some real bets though, so that Betfair doesn't think you're just stealing their data.

---

## 2022-02-24 09:26:31 - issues channel

**river_shah**

Perfect, problem found. The offending strategy did indeed override `finish`

---

## 2022-02-24 09:16:58 - issues channel

**liam**

`strategy.finish` was [https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1211-2022-01-10|updated](https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1211-2022-01-10|updated) to take `flumine` as a variable, looks like you have strategy that looks like this



```def finish(self) -&gt; None:

    # called before flumine ends

    return```

instead of this



```def finish(self, flumine) -&gt; None:

    # called before flumine ends

    return```

---

## 2022-02-24 09:11:53 - issues channel

**river_shah**

```Anyone seeing this:



  File "/usr/local/lib/python3.9/site-packages/flumine/flumine.py", line 48, in run

    del event

  File "/usr/local/lib/python3.9/site-packages/flumine/baseflumine.py", line 399, in __exit__

    self._process_end_flumine()

  File "/usr/local/lib/python3.9/site-packages/flumine/baseflumine.py", line 354, in _process_end_flumine

    self.strategies.finish(self)

  File "/usr/local/lib/python3.9/site-packages/flumine/strategy/strategy.py", line 242, in finish

    s.finish(flumine)

TypeError: finish() takes 1 positional argument but 2 were given```



---

## 2022-02-23 21:19:16 - random channel

**Jonjonjon**

[@U4H19D1D2](@U4H19D1D2) Would you be happy if I added a trading control to limit the max exposure of a strategy?

---

## 2022-02-23 12:18:38 - issues channel

**Nacho Uve**

The strategy is initialized like that:

```    strategy = Dummy_Strategy(

        market_id = '1.193102045',

        selection_id = 56085,

        market_filter={

            "markets": markets,

            "market_types":["MATCH_ODDS"],

            "listener_kwargs": {"seconds_to_start": 600},

        }

    )

    framework.add_strategy(strategy)```

Do you need the market file? Is it right to share it?

---

## 2022-02-23 12:16:43 - issues channel

**Nacho Uve**

I've made a dummy strategy to get familiarized with the framework and backtesting.

I feed it with just one market file that I recorded, and it is just configured to place a back bet at a specific price when the match starts.



I see the order is placed correctly in the logs.



That price is reached after some minutes and log shows that the order is matched [EXECUTION_COMPLETED].

But when I summarized using the blotter, it looks like it was nothing there. No winning or losses.



&gt; marketId      sel_id  date_time_placed	   Order.status			price  avg_price_matched  size_matched    profit

&gt; 1.193102045   56085   2022-01-26 19:48:55    EXECUTION_COMPLETE 	1.6    0.0                0.0             -0.0



Where is my error?



Strategy Code here: [https://pastebin.com/amQPbdKN](https://pastebin.com/amQPbdKN)

---

## 2022-02-22 21:22:25 - strategies channel

**foxwood**

I've finally worked out a combination of market filters and strategy parameters and as I read it flumine provides one common order stream and a discreet market stream for each strategy ie if the framework is running 2 strategies it uses up 3 connections.



Question: I'm running some instances of the sample marketrecorder and each one has an open order stream. How can I close that order stream and release a connection - or must it stay open ? I've looked in the debugger, docs etc but can't see an obvious way to reach the stream object and call stop() - I thought I had it with client.order_stream but that was a bool flag ! (I know I should wrap the recorders in one instance but that's a job for another day)

---

## 2022-02-22 19:02:23 - issues channel

**AndyL**

[@UPMUFSGCR](@UPMUFSGCR) i only restart scripts when needed for strategy upgrade

I think its betfair server glitches as [@UEA14GBRR](@UEA14GBRR) is seeing them at exactly same times

---

## 2022-02-19 10:37:41 - general channel

**Mo**

```import logging

import queue

import threading



import betfairlightweight



# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# create trading instance (app key must be activated for cricket stream)

trading = betfairlightweight.APIClient("username", "password", app_key="appKey")



# login

trading.login()



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)



# create stream

stream = trading.streaming.create_stream(listener=listener, host="sports_data")



# start stream in a new thread (in production would need err handling)

t = threading.Thread(target=stream.start, daemon=True)

t.start()



# subscribe

streaming_unique_id = stream.subscribe_to_cricket_matches()



# check for updates in output queue

while True:

    updates = output_queue.get()

    for update in updates:

        print(update.json())```

---

## 2022-02-18 21:49:47 - strategies channel

**foxwood**

Yes, I was looking at running dogs and horses through a parameterized general purpose strategy to keep number of streams down (assume each strategy gets it's own pair of streams). Given the differences between the strategies I have it's going to be easier to just run two dedicated strategies for now with their own filtered streams.

---

## 2022-02-18 16:05:33 - general channel

**Alex Alex**

By doing it in the strategy itself I assume you mean run the calc for each market? The calculation is not super slow, but slow enough that I’d rather run it only once for all markets.

---

## 2022-02-18 15:38:46 - general channel

**liam**

Depends how slow the calculation is, you can use a worker to update the context and do it in the strategy itself or like you describe in a worker

---

## 2022-02-18 14:10:54 - general channel

**Alex Alex**

Thinking of moving my live model code into the flumine framework. I quite like that it seems to have the option to simulate execution and run backtest/live interchangeably. I want to 1) get the current score, and 2) do some calculations on all matches within an event to generate a return forecast. From the `tennsiexample.py` I gather that the correct way to do this within flumine is to add a background worker that generates a custom event once it is done doing all its calcs. Then move the return forecast into market context when processing custom event. Or is there a more straight forward way to do this within flumine?

---

## 2022-02-18 10:51:15 - random channel

**liam**

there isn't really, first 50% of a race there tends not to be too much value (as you know) so even having a decent model isn't much to take advantage

---

## 2022-02-18 10:40:11 - random channel

**D C**

For those of us who use TPD stuff, has anyone ever tried to create a model like the one that TPD sell to bookies (or at least what I imagine that model/product is)? Essentially a model that updates prices from start to finish ?

---

## 2022-02-17 22:24:33 - issues channel

**Aaron Smith**

Lately my market_recorder is throwing some of those bois below over the day. Often times the market_recorder fails to put the market files into the s3 bucket (at any step, all i know for now is they are not in the bucket at the end of the day). For a single day/run cycle of the market recorder, either all or none of markets that have orders in them makes it into the bucket. Anyone having an idea whats going on here?

```{"asctime": "2022-02-16 19:08:14,104", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):

  File \"/path/prod_market_recorder/venv/lib/python3.10/site-packages/flumine/worker.py\", line 230, in _get_cleared_market

    cleared_markets = betting_client.betting.list_cleared_orders(

  File \"/path/prod_market_recorder/venv/lib/python3.10/site-packages/betfairlightweight/endpoints/betting.py\", line 434, in list_cleared_orders

    (response, response_json, elapsed_time) = self.request(method, params, session)

  File \"/path/prod_market_recorder/venv/lib/python3.10/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request

    self._error_handler(response_json, method, params)

  File \"/path/prod_market_recorder/venv/lib/python3.10/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler

    raise self._error(response, method, params)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.194823061'], 'customerStrategyRefs': ['ip-xxx-xx-xx-x'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} 

Exception: None 

Error: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang30b-prd-02011018-001f0d3c34', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} 

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang30b-prd-02011018-001f0d3c34', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders 

Params: {'betStatus': 'SETTLED', 'marketIds': ['1.194823061'], 'customerStrategyRefs': ['ip-xxx-xx-xx-x'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} 

Exception: None 

Error: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang30b-prd-02011018-001f0d3c34', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} 

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang30b-prd-02011018-001f0d3c34', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}```

---

## 2022-02-16 11:24:18 - issues channel

**river_shah**

What are the reasons why this may occur?

```WARNING[betfairlightweight.streaming.stream:on_update:68] [OrderStream: 1001]: Latency high: 1.75960373878479```

Not seeing high latency warnings on `MarketStream` so strategy is definitely keeping up with market data

---

## 2022-02-15 11:41:25 - random channel

**Oliver Varney**

```def read_prices_file(

    path_to_prices_file: str, lightweight: bool = True, **kwargs

) -&gt; Union[List[MarketBook], List[Dict[str, Any]]]:

    import smart_open

    from unittest.mock import patch



    trading = APIClient(username="", password="", app_key="")

    stream = trading.streaming.create_historical_generator_stream(

        file_path=path_to_prices_file,

        listener=StreamListener(

            max_latency=None, lightweight=lightweight, update_clk=False, **kwargs

        ),

    )



    with patch("builtins.open", smart_open.open):

        g = stream.get_generator()

        return list(mbs[0] for mbs in g())```



---

## 2022-02-13 20:16:31 - issues channel

**Brøndby IF**

```order_filter = betfairlightweight.filters.ex_best_offers_overrides(

    best_prices_depth=3

)



price_filter = betfairlightweight.filters.price_projection(

    price_data=['EX_BEST_OFFERS'],

    ex_best_offers_overrides=order_filter

)



# Obtendo odds para o mercado

market_books = trading.betting.list_market_book(

    market_ids=jogo_betfair_exchange_mercados['IDMercado'],

    price_projection=price_filter

)



#Lista de runners

runners = market_books[0].runners```

hi guys, please help me understand why this error is occurring and what should I do to solve it?



The error is:



```betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketBook

Params: {'marketIds': '1.194661463', 'priceProjection': {'priceData': ['EX_BEST_OFFERS'], 'exBestOffersOverrides': {'bestPricesDepth': 3}, 'virtualise': True, 'rolloverStakes': False}}

Exception: None

Error: {'code': -32602, 'message': 'DSC-0018'}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}```



---

## 2022-02-13 18:04:12 - issues channel

**Brøndby IF**

```import datetime

import pandas as pd

import betfairlightweight

import time



username = 'AAAAAAAAAAAAAAAAAAAAAA'

pw = 'BBBBBBBBBBBBBBBBBB'

app_key = 'CCCCCCCCCCCCCC'



trading = betfairlightweight.APIClient(username, pw, app_key=app_key, cert_files=('./certs/myAppBetfair1.crt','./certs/client-2048.key'))

trading.login()



df_final = pd.DataFrame()

for i in range(0,1):

    order_filter = betfairlightweight.filters.ex_best_offers_overrides(

        best_prices_depth=3

    )



    price_filter = betfairlightweight.filters.price_projection(

        price_data=['EX_BEST_OFFERS'],

        ex_best_offers_overrides=order_filter

    )



    # Obtendo odds para o mercado

    market_books = trading.betting.list_market_book(

        market_ids=['1.190674822'],

        price_projection=price_filter

    )



    #Lista de runners

    runners = market_books[0].runners



    back = []

    for i in range(0,3):

        try:

            back.append([runner_book.ex.available_to_back[i].price

                                    if runner_book.ex.available_to_back

                                    else 1.01

                                    for runner_book

                                    in runners])

        except:

            back.append([1.01,1.01])



    df_back = pd.DataFrame(back,columns=['Casa','Visitante','Empate'])

    df_back['data'] = datetime.datetime.now()

    df_final = df_final.append(df_back)

    time.sleep(2)```

To collect the odds offered in back I use this code, could someone help me and show me how the code would look if I wanted to collect the lastPriceTraded instead of the offered odds?



The person who helps me with codes is on vacation and I really need help to do this, unfortunately I can't do it alone.

---

## 2022-02-12 23:04:01 - general channel

**anomaly**

Not filtering with market ids right now, however doesn't the same problem occur even if you were to use market ids in the filter: new day ticks over, new markets appear in the catalogue, the old market filter is not relevant anymore. I guess the question boils down to how do ensure a continually updated set of streams for the "current" set of markets. Would a reasonable approach simply be manage pool of streaming threads that periodically get killed and repopulated with new stream threads as new markets appear in the market catalogue?  Right now I can get away with a single thread per (betting_type, country) and periodically kill existing and create a new streaming thread when new markets appears in the market catalogue. It seems to be working but not sure if it's best practice

---

## 2022-02-12 19:15:12 - issues channel

**Nacho Uve**

I find a lot these errors in the log using "marketrecorder.py":



{"asctime": "2022-02-12 18:08:02,572", "levelname": "ERROR", "message": "poll_market_catalogue error", "exc_info": "Traceback (most recent call last):\n  File \"c:\\users\\myuser\\appdata\\local\\programs\\python\\python38\\lib\\site-packages\\flumine\\worker.py\", line 128, in poll_market_catalogue\n    market_catalogues = client.betting_client.betting.list_market_catalogue(\n  File \"c:\\users\\myuser\\appdata\\local\\programs\\python\\python38\\lib\\site-packages\\betfairlightweight\\endpoints\\betting.py\", line 233, in list_market_catalogue\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"c:\\users\\myuser\\appdata\\local\\programs\\python\\python38\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"c:\\users\\myuser\\appdata\\local\\programs\\python\\python38\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketCatalogue \nParams: {'filter': {'marketIds': ['1.194430217', '1.194430009', '1.194553817', '1.194429905', '1.194430113', '1.194441740']}, 'marketProjection': ['COMPETITION', 'EVENT', 'EVENT_TYPE', 'RUNNER_DESCRIPTION', 'RUNNER_METADATA', 'MARKET_START_TIME', 'MARKET_DESCRIPTION'], 'maxResults': 25} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang11a-prd-02010955-99993c3ac9', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang11a-prd-02010955-99993c3ac9', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_market_catalogue", "response": "SportsAPING/v1.0/listMarketCatalogue \nParams: {'filter': {'marketIds': ['1.194430217', '1.194430009', '1.194553817', '1.194429905', '1.194430113', '1.194441740']}, 'marketProjection': ['COMPETITION', 'EVENT', 'EVENT_TYPE', 'RUNNER_DESCRIPTION', 'RUNNER_METADATA', 'MARKET_START_TIME', 'MARKET_DESCRIPTION'], 'maxResults': 25} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang11a-prd-02010955-99993c3ac9', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0003', 'data': {'APINGException': {'requestUUID': 'ie1-ang11a-prd-02010955-99993c3ac9', 'errorCode': 'INVALID_SESSION_INFORMATION', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}



More lines of example here:

[https://pastebin.com/2VutqGi8](https://pastebin.com/2VutqGi8)



So, it returns a errorCode: 'INVALID_SESSION_INFORMATION'.   It is strange because the program continues with the recording, and the files stream files are OK, makes the gzip, etc.

---

## 2022-02-12 18:17:28 - strategies channel

**AndyL**

Multi process works great, all 4 cores zooming

I also cProfiled my strategy and improved its performance by another factor of x4     :rocket:

---

## 2022-02-11 08:53:38 - random channel

**liam**

Along the lines of this Mo is there an easy way to add another box with a value, for example LTP or a model calculation etc?

---

## 2022-02-10 19:09:17 - general channel

**Laybot McBackbot**

I have too many different values for one hot encoding. Also, the algorithm it uses for categorical data somehow is working great for me. So I would rather stick with it because between screwing around with what is working I prefer to choose the easier solution -- either get a gpu machine on AWS or continue running from home for now.



My return from this model should be able to cover the AWS cost but I would still like to save money wherever possible.

---

## 2022-02-10 16:54:16 - general channel

**Laybot McBackbot**

Talking about ML model. I need gpu for inference for this particular model.  Usually I train with GPU on my workstation then use CPU for inference. But it doesn't work for this particular model.

---

## 2022-02-09 14:49:50 - general channel

**Guy Incognito**

The only output I get is 

```starting strategy 'ExampleStrategy'

```

From my understanding should this code just place bets on all selections on all greyhound races in Australia over and over again?

---

## 2022-02-09 06:37:19 - general channel

**Guy Incognito**

Hey Guys, trying to follow the flumine quick start guide and just place bets on any greyhound market but doesn't seem to be working. Am I missing something?



```from flumine import BaseStrategy

from flumine.order.trade import Trade

from flumine.order.order import LimitOrder





class ExampleStrategy(BaseStrategy):

    def start(self):

        # subscribe to streams

        print("starting strategy 'ExampleStrategy'")

        

    def check_market_book(self, market, market_book):

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True



    def process_market_book(self, market, market_book):

        for runner in market_book.runners:

            if runner.selection_id == runner.selection_id:

                trade = Trade(

                    market_id=market_book.market_id, 

                    selection_id=runner.selection_id,

                    handicap=runner.handicap,

                    strategy=self

                )

                order = trade.create_order(

                    side="BACK", 

                    order_type=LimitOrder(price=1000, size=5.00)

                )

                market.place_order(order)```

```from betfairlightweight.filters import (

    streaming_market_filter, 

    streaming_market_data_filter,

)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["4339"],

        country_codes=["AU"],

        market_types=["WIN"],

    ),

    market_data_filter=streaming_market_data_filter(fields=["EX_ALL_OFFERS"])

)



framework.add_strategy(strategy)```

```framework.run()```



---

## 2022-02-08 21:51:13 - general channel

**Dan Q**

So there's the issue where atb and atl are non-virtualized and thus not very useful comparisons to the live pulled atb/atl data. The LTP is usually pretty close to both though, when there's decent liquidity (which there usually is), so it's fine. However, there are intense volatility spikes in LTP that I can't explain and had to take great pains to treat. Stuff like a team being comfortably in the lead at the very end of the game with 1.01 odds and then suddenly updates will come in at much higher odds, like 2.4 in the middle of the more sensible 1.01 prices. Stuff like that. It got to the point where for the historicals I need to calculate local volatility in the LTP time series and take the rolling median as the actual LTP and the rolling min as the best_atb just to be safe, otherwise my models perform way worse because there's so much noise.



It could be an issue of me making some incorrect assumption early on when reading in the data as I had to kind of blindly feel my way through rather than using something like BFLW to read them in properly, but I don't think so, I'm pretty sure I did it right as I've reviewed it a lot.

---

## 2022-02-08 20:17:35 - general channel

**Dan Q**

Hey, just wanted to share my process and do a quick sanity check since I'm not super familliar with BFLW/Flumine. This is my process right now:

• Container on AWS ECS recording Betfair odds data every 5 seconds - using the API via BFLW - for the markets I'm interested in (NBA) and writing to a DB

• Model trained on historical data from Betfair pro files (lots of cleaning/processing as there are very weird behaviors in the historicals that don't reflect the live environment)

    ◦ All historical reading and treatment done with code I wrote myself, no BFLW here

• External data read from other sources and also fed into a DB. Historicals are used along with BF historicals to train the model.

• Live, constantly running betting bot reads the most recent data from the DB for live games joined with external data, manipulates it to the format the model expects, and makes a decision based on model output and strategy parameters

    ◦ Again a custom class/process, BFLW used only to connect to the API to collect bankroll info and place orders

• If bet decision is made, sends a fill or kill limit order through BFLW client

• Strategy parameters are determined through intensive backtesting/bootstrapping on the live data collected so far

    ◦ Also a custom backtesting suite I wrote to calculate expected profitability and other stats over n games in the season based on resampling previous games

This is working well and is thankfully profitable so far, but I feel like I may have reinvented the wheel at least five times during the whole thing considering BFLW/Flumine exists. I've seen a lot of mention of backtesting on Flumine, would it also allow more complex operations like I described with using external data and output from a model? What is the benefit of doing so vs. the solution I've described? One thing I'm not doing which I know I could be is streaming and recording the data instead of the 5-second snapshots I'm using right now, but so far it's served me well and I haven't seen a reason to switch.

---

## 2022-02-08 16:04:47 - general channel

**VT**

Hi guys, I'm trying to send a Fill or Kill order but I can't see the error.



    limit_order_filter = filters.limit_order(

        size=3,

        price=2,

        persistence_type='LAPSE',

        time_in_force='FillOrKill'

        )



    instructions_filter = filters.place_instruction(

        selection_id=id_leader,

        order_type="LIMIT",

        side='BACK',

        limit_order=limit_order_filter,

        )



    order = trading.betting.place_orders(

        lightweight=True,

        async_=True,

        market_id=id_mercado,

        instructions=[instructions_filter],

        session=session

        )



--------------------------------------



Error: {'code': -32602, 'message': 'DSC-0018'}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}



I searched for DSC-0018 error in API



DSC-0018 MandatoryNotDefined Client 400 A parameter marked as mandatory was not provided

---

## 2022-02-08 11:01:05 - issues channel

**river_shah**

Just hit this error:

```2022-02-08 10:48:12.425 CRITICAL[flumine.utils:call_strategy_error_handling:233] Unknown error 'Market' object has no attribute 'blotter' in process_market_book```

Any idea why it may occur? Prod only, let me know what further debug I can provide (although I have very little aside from this `CRITICAL`message)

---

## 2022-02-06 18:59:52 - random channel

**Dave**

Has anyone tried running their same strategies on smaller exchanges? E.g. maybe using the same pricing model but just executing on betdaq instead? If so, do you find that your margins are higher (i.e. profit / volume traded)?

---

## 2022-02-06 18:58:14 - strategies channel

**rjj**

Yeah it's on an external drive but should be pretty quick. With logging off, I can get the base strategy to process a market in about 10-20 seconds depending on how active the market was. I'm guessing this is more in line with your expectations?

---

## 2022-02-06 11:59:53 - strategies channel

**rjj**

Turns out in my case it is the sheer volume of ticks, even with the base strategy (i.e. do nothing) it still takes O(hours) most of the time in _process_runner and creating MarketBook objects

---

## 2022-02-06 10:24:26 - issues channel

**liam**

```stream = trading.streaming.create_stream(host="race", listener=listener)```

basic with one thing missing :wink:

---

## 2022-02-06 10:23:31 - issues channel

**Peter**

Very basic:



```import os

import logging

import queue

import threading



import betfairlightweight



# setup logging

# logging.basicConfig(level=logging.DEBUG)  # change to DEBUG to see log all updates

logging.basicConfig(

    level=logging.DEBUG,

    filename='tpd/race-subscription.log',

    filemode="a",

    format='%(asctime)s - %(levelname)s - %(message)s',

)



# create trading instance (app key must be activated for streaming)

workspace_prefix = os.getenv("WORKSPACE_PREFIX")

trading = betfairlightweight.APIClient(os.getenv("BETFAIR_USERNAME"), os.getenv("BETFAIR_PASSWORD"), app_key=os.getenv("BETFAIR_LIVE_KEY"), certs=workspace_prefix + "certs")



# login

trading.login()



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)



# create stream

stream = trading.streaming.create_stream(listener=listener)



# subscribe

streaming_unique_id = stream.subscribe_to_races()



# start stream in a new thread (in production would need err handling)

t = threading.Thread(target=stream.start, daemon=True)

t.start()



# check for updates in output queue

while True:

    update = output_queue.get()

    print(update)```

---

## 2022-02-05 11:09:20 - random channel

**Oliver Varney**

Another random one, Is .get() vs [''] used in all places for resources and isnt specifically used to return None when missing. Im just looking into to doing some work around dataclass/pydantic models.

---

## 2022-02-05 10:20:10 - random channel

**Oliver Varney**

[https://github.com/liampauling/betfair/blob/b202fe192b2a46c4d19ab50cf60e380f2a38cb4e/betfairlightweight/resources/bettingresources.py#L216](https://github.com/liampauling/betfair/blob/b202fe192b2a46c4d19ab50cf60e380f2a38cb4e/betfairlightweight/resources/bettingresources.py#L216)

---

## 2022-02-05 07:28:19 - random channel

**Oliver Varney**

[@U4H19D1D2](@U4H19D1D2) , random one , MarketCatalogueDescription.keyLineDefinition / key_line_definition is never set in bflw betting resources?

---

## 2022-02-04 21:42:06 - general channel

**Alex Alex**

You want to model the spread as a function of traded prices. In a liquid market, if you see an uptick compared to the ltp this is likely hitting the offer price (lay price in betfair terms). Not really accurate if you don't have many trades though.

---

## 2022-02-03 12:24:13 - issues channel

**foxwood**

Puzzled by differences between live and backtest that I'm not expecting. Yesterday recorder and live betting were running on same VPS as separate processes under PyCharm.  Placed 28 live bets. Running the backtest later on it came up with bets on different runners on 4 of the races compared to what the live had done - sufficient to show a significantly different PL.



Looked at one in detail - no latency issues in log - recorder saw bet placed 187ms after logged by bet process. EX_BEST.. not used. Strategy source code the same for backtest/live. Betting triggering on EX_ALL.. price movements.



I expected the backtest to trigger on the same runner at the same time as the live did.



The recorder packets seem to be 4, 5 or 6 per second - could it be dropping packets that the live betting is seeing ? I thought they were all kept and cached if the app couldn't keep up ie excess latency compared to "pt" - ie not possible to miss any packets that BF push out ?



Any suggestions as to cause or where to look next ?

---

## 2022-02-02 09:11:34 - random channel

**Peter C**

Hi [@UBS7QANF3](@UBS7QANF3), I'm having a play with this this morning, but I'm having problems loading my self recorded data. I get the following error, please would you help me debug? I get the same error importing various files with a variety of the betfairutil functions. I installed betfairutil/viz as above



```~\anaconda3\lib\site-packages\betfairutil\__init__.py in read_prices_file(path_to_prices_file, lightweight)

    792     stream = trading.streaming.create_historical_generator_stream(

    793         file_path=path_to_prices_file,

--&gt; 794         listener=StreamListener(

    795             max_latency=None, lightweight=lightweight, debug=False, update_clk=False

    796         ),



TypeError: __init__() got an unexpected keyword argument 'debug'```

---

## 2022-01-31 12:42:23 - general channel

**Rob**

```from typing import Sequence 



import logging

import unittest.mock

import os

import tarfile

import zipfile

import bz2

import glob

import betfairlightweight



market_paths = [

    "data/2021_10_OctRacingProAu.tar",

]



# loading from tar and extracting files

def load_markets(file_paths: Sequence[str]):

    for file_path in file_paths:

        if os.path.isdir(file_path):

            for path in glob.iglob(file_path + '**/**/*.bz2', recursive=True):

                f = bz2.BZ2File(path, 'rb')

                yield f

                f.close()

        elif os.path.isfile(file_path):

            ext = os.path.splitext(file_path)[1]

            # iterate through a tar archive

            if ext == '.tar':

                with tarfile.TarFile(file_path) as archive:

                    for file in archive:

                        yield bz2.open(archive.extractfile(file))

            # or a zip archive

            elif ext == '.zip':

                with zipfile.ZipFile(file_path) as archive:

                    for file in archive.namelist():

                        yield bz2.open(archive.open(file))

    return None





logging.basicConfig(level=logging.WARN)

trading = betfairlightweight.APIClient("username", "password", "appkey")

listener = betfairlightweight.StreamListener(max_latency=None)



count = 0

for i, file_obj in enumerate(load_markets(market_paths)):

    with unittest.mock.patch("builtins.open", lambda f, _: f):  

        stream = trading.streaming.create_historical_generator_stream(

            file_path=file_obj,

            listener=listener,

        )

        gen = stream.get_generator()

    

        for market_books in gen():

            for market_book in market_books:

                count += 1



        print("&gt; Market {} Update {}".format(i, count), end='\r')

                ```

---

## 2022-01-30 21:28:33 - random channel

**D C**

Hi chaps. I have a generic question about open source licenses. Basically I am in the process of making my manual ladder trader code into an open source project (mainly because I have zero interest in manual trading now and no time to work on it) but not sure about what license to apply. It is build using an open source licence version of Qt creator which I believe is LGPL3. I want to use MIT license as I believe that means that anyone can do whatever they like with it. I want it to be used by anyone for any purpose and I believe MIT is the best here. I am hoping that some here might know more about open source license stuff as I have zero interest in this kind of thing and don't really know much about it.

---

## 2022-01-30 16:24:07 - issues channel

**birchy**

Has something changed in the Flumine order validation, because, for example, a LAY bet of £1@10.0 is now throwing:

`Order has violated: ORDER_VALIDATION Error: Order size is less than min bet size (2) or payout (10) for currency`

This is a 6+ months running strategy (live) which is still working ok, but fails when backtesting.

If I change the size to £2, validation passes.

FYI: live is running on Flumine 1.20.13 and backtesting is 1.21.2

Ok, so this seems to be related to PR #546:

[https://github.com/liampauling/flumine/blob/770fcf967dab590cba63350dd2ee46839363f8d1/flumine/controls/tradingcontrols.py#L71|https://github.com/liampauling/flumine/blob/770fcf967dab590cba63350dd2ee46839363f8d1/flumine/controls/tradingcontrols.py#L71](https://github.com/liampauling/flumine/blob/770fcf967dab590cba63350dd2ee46839363f8d1/flumine/controls/tradingcontrols.py#L71|https://github.com/liampauling/flumine/blob/770fcf967dab590cba63350dd2ee46839363f8d1/flumine/controls/tradingcontrols.py#L71)

As far as I can tell, £1@10.0, £0.10@100, etc should still be valid?

[https://docs.developer.betfair.com/plugins/servlet/mobile?contentId=3833942#placeOrders-Abilitytoplacelowerminimumstakesatlargerprices|https://docs.developer.betfair.com/plugins/servlet/mobile?contentId=3833942#placeOrders-Abilitytoplacelowerminimumstakesatlargerprices](https://docs.developer.betfair.com/plugins/servlet/mobile?contentId=3833942#placeOrders-Abilitytoplacelowerminimumstakesatlargerprices|https://docs.developer.betfair.com/plugins/servlet/mobile?contentId=3833942#placeOrders-Abilitytoplacelowerminimumstakesatlargerprices)

---

## 2022-01-30 16:01:40 - random channel

**river_shah**

I really think `flumine` is a fantastic name (a play on streams and evocative of steampunk) and we already have a community around it who understand that it is an integrated quant betting system. Sorry to repeat but my strong vote would be to promote `flumine` as the org name / all other packages / repos under this umbrella.



Users can still pick and choose sub packages or install the whole of `flumine` and get all the `flumine` eco-system dependencies sorted for them.

---

## 2022-01-30 15:23:52 - random channel

**Alessio**

[@U4H19D1D2](@U4H19D1D2) very late to the convo as usual, but I see how the 'api/automation/modelling' full circle looks like a key point. I landed here because flumine looked like a full integrated thing, so I'd suggest stuff like BetStudio or BetDeveloper or BetCharm. Or NeverGreen, possibly with an altered version of Never Gonna Green You Up :wink:

---

## 2022-01-29 10:11:38 - random channel

**Newbie99**

I think it really comes down to the new audience you're trying to attract.



Is it a case of trying to get people on-board who are already using their own code for automated betting on other sides?

Is it people who are currently manually betting on betfair without the API?

The same as above but manually betting via the betfair API?

What about people who see themselves as 'sports traders' would that bring in a new audience?



And so on...



Once the target has been selected the name probably is easier to derive.

---

## 2022-01-29 09:32:53 - random channel

**Dave**

Personally I think the name should be semantic and not try to be some flashy brand. bflw did achieve that the first time round. Wannabe sport bettors and retail traders in finance love the flashy crap like "NinjaTrader" etc. I think we are all here to take a systematic and scientific approach to capitalise on market in efficiencies, and the name should reflect that. Flumine is nice as it relates to flow of liquid(ity) and I think we all appreciate the link to markets there. PyBet IMO is too generic. Something related to quantitative/systematic/non-discretionary betting would be good. Some of the flashy "brand names" here would put me off tbh, and also cater a lot to the same audience from whom you make your money off.

---

## 2022-01-28 19:42:45 - issues channel

**AndyL**

If I try and start a strategy subscribing to say uk greyhounds and it tries to get over 200 markets i get the subscription limit exceeded error, is there a parameter to say just subscribe to the next 200 ?

---

## 2022-01-28 17:39:17 - general channel

**VT**

I would also like to say that I am very grateful for everyone's help, even with my primitive knowledge *I can send and close orders (market stream hosted in the UK) faster than any program I've ever used*. Having access to the stream also opens up many possibilities for semi-automated trading in live football.

---

## 2022-01-28 14:56:10 - random channel

**Aaron Smith**

whats the common ground for all ppl in the group? betting or automated betting or betting with python? I guess its automated betting? PyBet does sound nice tho :smile:

---

## 2022-01-28 09:32:36 - random channel

**liam**

Morning, I have been thinking about this for a while but looking to have a name change / rebrand for bflw to open the doors to everyone who is involved in betting but keeping the API/model/programming link.



Nothing would change other than the name of this group and the creation of a GitHub organisation to hold any relevant libraries (wrappers/flumine etc) I have signed a few of you up to this already but if anyone else wants to be a member of the org please let me know :slightly_smiling_face:



The only blocker is the name, anyone got any ideas?

---

## 2022-01-26 10:24:16 - issues channel

**Unknown**

I really need to do a doc on it, but flumine follows this design but with a queue for updates where every strategy gets a call

---

## 2022-01-26 10:18:30 - issues channel

**D C**

What mechanism is used to share the stream info with the strategies? As my own stuff uses async TPC socket components I get away without using threading but only because I only focus on a small number of markets (relatively speaking). I would prefer to see what other architectures are available though as you mention a "few schools of thought" about building the trading system. Any recommended sources of reading or codebases other than flumine?

---

## 2022-01-26 09:14:57 - issues channel

**Jorge**

Makes sense [@U4H19D1D2](@U4H19D1D2), thanks for your help as always! I started trading some time ago without multiprocessing knowledge and without flumine so I chose Mo's approach. I'll read about it and think if it's worth the update!

---

## 2022-01-26 08:58:39 - issues channel

**liam**

Ah, unless you have experience in building a trading system I recommend having a read of some code. Few schools of thought on how one should be built but the central idea is to consume market/order data and make decisions. 



flumine uses a FIFO queue with strategies, threads for streams and workers and a thread pool for execution. Its lightweight and fast whilst still being adapted per use case, as well as being very easy to get started.



Mo's design gives you a highly available / scalable (complicated) system that can do whatever you want and at a guess very easy to deploy upgrades etc. But I wouldn’t recommend this to someone starting out.

---

## 2022-01-25 20:39:25 - random channel

**James T**

They also have a prop trading team who trades against customers on their own exchange (obviously without charges and probably at lower latency). And they can see whose bets are whose. I don't think that's a fair market. 



Last time I looked a couple years ago, they make far more money from betting against customers than they do on exchange revenue. 

---

## 2022-01-25 17:31:29 - strategies channel

**foxwood**

ok fixed that safely. strategy prints out immediate info from process_closed_market for markets still on BF but closed so getting there. Actually made some bets but I'd changed stake to £1 so not taken but no error message in log - maybe it doesn't - no probs. However, nothing in log except high latency messages for {MarketStream: 2201] with typical time of 0.84 - no flumine setup messages / bet errors / markets or anything like that - not sure what to expect lol. What section of processing / transmission is the latency referring to ?

---

## 2022-01-25 16:17:28 - strategies channel

**foxwood**

VPS running 2 x mktrec + 1 x BA fine today - 5 connections. Tried strategy live locally today (simply removed paper_trade=True). Seemed to log in ok but after 20 mins log had about 18k lines all like this `{"asctime": "2022-01-25 10:21:47,343", "levelname": "WARNING", "message": "[MarketStream: 2001]: Latency high: 0.8610439300537109"}` No other message about set up or starting of flumine which appears normal in mktrec. Message printed "starting strategy xxx"  when strat class started so it was starting off ok but that was all. Killed it after 20 mins and went for long walk lol. Any suggestions/clues - I can see the time it gives exceeds max latency of 0.5 but presume things should still function but quite slowly.

---

## 2022-01-25 09:09:24 - strategies channel

**liam**

[@U02RN7YDRQ9](@U02RN7YDRQ9) what are your strategies doing? If you are getting latency issues its likely you are maxing CPU or doing something slow in the strategy (network or db call etc)

---

## 2022-01-24 23:09:38 - random channel

**Aaron Smith**

I make a key for each strategy in market.context

---

## 2022-01-24 22:17:55 - random channel

**Jonjonjon**

I've been looking at market.context too. But the data is specific to each strategy/market combination. So I'm not sure about it.

---

## 2022-01-24 22:14:47 - random channel

**Jonjonjon**

Suppose I want to store some information relating to a particular runner. This information will be different for every different strategy instance. The information is generated on-the-fly (i.e. it's a particular indicator that I'm using). Should I be storing this is `BaseStrategy.context`?

---

## 2022-01-24 21:55:24 - issues channel

**birchy**

While on the subject of RAM, how do you guys handle "big" backtests/signal processing with Flumine? I've found that if I run a strategy that produces 200k+ bets, the Framework eventually falls over because my 4GB AWS machine falls over with OOM errors. I know that increasing the amount of RAM is a solution (as is running on my local 8GB machine), but am wondering if there's a way to break up the framework into smaller chunks so that it can run on lower spec hardware?

---

## 2022-01-23 23:11:43 - strategies channel

**foxwood**

I want to shift a backtest strategy to live - my first live flumine play. The strategy is based on the DataCollectWOM strategy example at [https://github.com/liampauling/flumine-strategy-development/blob/master/main.py](https://github.com/liampauling/flumine-strategy-development/blob/master/main.py)



Obvious things I need to do is change the wrapper to use live client login, remove mock_patch and provide a bflw streaming market filter.



There are 2 possible gotchas in my strategy where I'm not sure if things exist in live ie will it crash if these references are left in:

a) market_catalogue is used to get the runner name - is this just a backtest feature and should this middleware be removed if a catalogue is constructed during live streaming ?

b) in function process_closed_market the field "order.simulated.profit" is printed and logged - will that field exist or will this crash things if the reference is left in ?



Any advice or thoughts about other things I might not think of first time more than welcome

---

## 2022-01-20 13:53:57 - general channel

**PeterLe**

So this is what I received back:

20/01/2022 13:45:38: [G_Auto 1] :  £ 2.00 Lay bet placed on Geordie Des Champs at 1.7. Entirely unmatched when it initially reached the market.   Ref: 256340606189          ( Fill or kill bet with 5 seconds delay.   )

20/01/2022 13:45:40: [G_Auto 1] :  £ 0.40 Lay bet placed on Geordie Des Champs at 1.7. Entirely unmatched when it initially reached the market.   Ref: 256340607494          ( Fill or kill bet with 5 seconds delay.   )



Given the difference in the Betid's you're probably right James.

So to close the loop on this...The reason i was asking this originally is because I was reviewing some data last night against a particular strategy and the sub £2 bets seemed to be doing much better overall (irrespective of the odds). i was wondering if it was because these bets were hitting the market slightly behind the £2 bets...now I know :grinning:

---

## 2022-01-20 13:32:43 - random channel

**Oliver Varney**

someone must have a great strategy catching out people to slow to cancel orders

---

## 2022-01-20 09:53:10 - random channel

**liam**

assuming you have a trigger or model, to increase volatility I would just need to move my trigger further away from its optimum, sometimes this will increase profit but at a cost of volatility and potential scaling so not sure why you would?

---

## 2022-01-18 22:48:38 - general channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) just to confirm... do Flumine PR's #538 and #539 now allow us to "safely" run backtests without double counting the matchable volumes? I have some icky historical code in my strategies that essentially checks `current_bet != last_bet` to avoid the double betting issue but of course that means I miss quite a few opportunities where the available size is &gt; my stake/payout.

---

## 2022-01-18 19:54:32 - strategies channel

**foxwood**

I have built a strategy using "datacollectwom.py" as a template. In that example it adds a new dictionary variable named "data" to market.context the first time any new market is passed to check_market_book. I've copied that approach for a strategy that watches market movements and prices and bets when appropriate. That's testing out reasonably so far with history files but I've hit some questions / doubts ...



1) is there a special reason for using market.context for the "data" variable or could I do something safely at a higher level without interfering with bflw/flumine eg market.mydatavar = {} ?

2) is it common / naughty in Python to add a variable dynamically like that ?

3) if the "enhanced" market object is deleted then any data in that variable would be lost. In bflw or flumine is there a case of a market object being deleted and recreated from scratch ie some sort of mcm case where the approach is to discard what was held and rebuild the market object from scratch ?

4) the main.py for the datacollectwom is processing history files - would the same structure /code for a strategy (less mock_patch) work with live streaming data ie would it just be simply a change of input source for the json ?



Sorry if some of these questions seem basic but trying to fill in some of my python and flumine gaps

---

## 2022-01-16 10:41:26 - random channel

**Oliver Varney**

dont know if this can be leveraged (maybe off topic to the specific use case here) [https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html)

---

## 2022-01-16 05:45:03 - general channel

**Colin**

Does anyone have any experience with developing their own bot and using it with a stake that is below the default minimum amount in your region/country for a prolonged period of time and for betting types that were not classed as closing out? If so, did you receive a warning from Betfair quite swiftly?

I note the 4th bullet point here, [https://developer.betfair.com/en/exchange-api/faq/](https://developer.betfair.com/en/exchange-api/faq/)

I'm keen to production-ise my bot soon, but I also want to start slow given it is not feasible for me to use Betfair's historical data to back test the algorithm I am using.

---

## 2022-01-15 21:18:22 - random channel

**Jonjonjon**

When doing A/B testing, what do people use to check whether to choose A or B?



So I have a strategy, and given a market_id, I want to always choose the same A or B, but at random.



I currently have the following code, but it is the slowest part of my program and is causing performance issues:



```def rand_int_from_market_id(

        market_id: str,

        low: int=0,

        high: int = 2

):

    """

    Deterministic way to generate a random int from a market id.

    The purpose of this is to help us do A/B testing

    Parameters

    ----------

    market_id



    Returns

    -------



    """

    seed = int(market_id.replace('.', ''[-6:]))

    state = np.random.RandomState(seed)

    return state.randint(low, high)```

Would it be safe to just choose odd market ids for A, and even numbers for B? Or could something like this be safer:



```(((market_id % 7) % 5) % 3) % 2```



---

## 2022-01-15 12:33:56 - strategies channel

**foxwood**

I'm developing some analysis based on the example datacollectinwom.py and am gathering lists of data per runner for graphing etc. I hadn't allowed for getting a None price from non-runners so it blew up (expected behaviour lol). However, that got me thinking about some key assumptions I had made and I wonder if they were safe, particularly with non-runners - maybe those with more knowledge could comment.

Assumptions:

1) the strategy callback argument "market_book" is the same object as could be accessed at "market.market_book"

2) the strategy callback "check_market_book" is made for every "mcm" streaming packet received and if that returns True then "process_market_book" is called - this means the strategy is offered every packet

3) for each callback all the data from the supplied market/market_book pointers has been updated to reflect the changes implied by the packet

4) the list of runners in the market_book and their index order is invariant ie runner Fred will be at the same index in "market_book" from first recording through to closed market



I think the first three are correct but not sure relying on the index position is safe - perhaps selection_id has to be used as a dict key for my saved lists which would slow things down quite a bit - important if it was a live betting strategy ?



I have noticed that BF change the "sort_priority" field for runners when there are withdrawals but not sure how/if that impacts flumine.



One area of difference I have found is with "market.market_book.market_definition.runners" which appears to be in BF sort order with N/R at the end whereas "market.market_catalogue.runners" and "market.market_book.runners" appear to remain in fixed positions regardless of withdrawal.

---

## 2022-01-15 11:42:26 - random channel

**Newbie99**

I guess the problem then is you might run out of connections (as presumably if you are collecting data using the same filters as a live strategy flumine shouldn't open up a new connection). But if that is the best approach then I can revert back to that, in a sense its easier to record locally as it saves transferring everything and then can test on the same machine!

---

## 2022-01-15 11:36:37 - random channel

**Peter**

Last conversation I remember here o this topic said the opposite, i.e. keep data collection separate from strategy execution. However it's very possible to combine the execution of multiple strategies on a single server and this is generally what people advise.

---

## 2022-01-15 11:03:33 - random channel

**Newbie99**

yes, thats correct, so 1 instance which effectively does:



```framework.add_strategy(strategy)



recorder = MarketRecorder(

            name="MR_horse_greyhounds",

            market_filter=streaming_market_filter(

                    event_type_ids=[7],

                    country_codes=['GB','IE','US','FR', 'AU'],

                    market_types=['WIN', 'PLACE', 'EACH_WAY'],

                ),

            stream_class=DataStream,

            context={

                "local_dir": ai.unprocessed_data,

                "bucket": "fluminetest",

                "force_update": False,

                "remove_file": True,

            },

        )

framework.add_strategy(recorder)



framework.run()```

Is that not a sensible approach (previously I did have it on a separate instance, but I thought people on here suggested they had everyone on one and it might be simpler)?

---

## 2022-01-15 09:30:23 - random channel

**Newbie99**

Apologies as this is a bit open ended, but I'm not understanding what went wrong here, last night around 1 am, out of (seemingly) no-where it looks like I suddenly got latency warnings and then eventually the process killed:



```{"asctime": "2022-01-15 01:00:05,664", "levelname": "INFO", "message": "Placing new LAY order for runner ('Jaime Jamel', 35971913, 0), runner exposure is: {'selection_id': 35971913, 'handicap': 0, 'if_win': 0.539, 'runner_matched_stake': 0.0, 'runner_matched_exposure': 0.0, 'min_market_exposure': -18.509999999999998} and limit is: 0.3."}

{"asctime": "2022-01-15 01:00:05,664", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.193372878", "selection_id": 35971913, "handicap": 0, "id": "138615012056645370", "customer_order_ref": "7c44d7544ce40O138615012056645370", "bet_id": null, "date_time_created": "2022-01-15 01:00:05.664573", "publish_time": "2022-01-15 01:00:05.647000", "market_version": null, "async": false, "trade": {"id": "7a2c3bee-759e-11ec-b096-02054918c7c6", "strategy": "betting_market_lay", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138615012056645370"], "offset_orders": [], "notes": "R3 5f Allw,2022-01-15 01:02:00,WIN,Flat,US,Charles Town,False,False,None,False,Jaime Jamel,2.64,2479.75,8,1,False,None,0,Charles Town (US) 14th Jan,31175177,7,{'strategy_name': 'betting_market_lay', 'selection_id': 35971913, 'handicap': 0, 'price_percentage': 0.768, 'min_valid_external_value': 0.8, 'current_back_price': 48, 'current_mid_price': 56.5, 'current_lay_price': 65, 'previous_back_price': 50, 'previous_mid_price': 62.5, 'previous_lay_price': 75},1", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 50.0, "size": 0.31, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.31, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Pending", "status_log": "Pending", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "R3 5f Allw,2022-01-15 01:02:00,WIN,Flat,US,Charles Town,False,False,None,False,Jaime Jamel,2.64,2479.75,8,1,False,None,0,Charles Town (US) 14th Jan,31175177,7,{'strategy_name': 'betting_market_lay', 'selection_id': 35971913, 'handicap': 0, 'price_percentage': 0.768, 'min_valid_external_value': 0.8, 'current_back_price': 48, 'current_mid_price': 56.5, 'current_lay_price': 65, 'previous_back_price': 50, 'previous_mid_price': 62.5, 'previous_lay_price': 75},1", "market_notes": null}

{"asctime": "2022-01-15 01:00:30,284", "levelname": "INFO", "message": "1.193373059: 0 cleared orders found, more available: False"}

{"asctime": "2022-01-15 01:01:13,244", "levelname": "WARNING", "message": "[FlumineStream: 4002]: Latency high: 0.9758524894714355"}

{"asctime": "2022-01-15 01:01:13,245", "levelname": "WARNING", "message": "[MarketStream: 3001]: Latency high: 0.9100987911224365"}

{"asctime": "2022-01-15 01:01:13,245", "levelname": "WARNING", "message": "[MarketStream: 2001]: Latency high: 0.8022336959838867"}

{"asctime": "2022-01-15 01:12:41,802", "levelname": "INFO", "message": "Deleting requests.Session", "sessions_created": 36, "session": "&lt;requests.sessions.Session object at 0x7f2c6a5195d0&gt;", "session_time_created": 1642208309.3769233, "session_time_returned": 1642208405.607362, "live_sessions_count": 1, "err": true}

{"asctime": "2022-01-15 01:12:41,813", "levelname": "WARNING", "message": "[MarketStream: 3001]: Latency high: 689.2287058830261"}

{"asctime": "2022-01-15 01:12:41,814", "levelname": "WARNING", "message": "[FlumineStream: 4002]: Latency high: 689.5181279182434"}

{"asctime": "2022-01-15 01:12:41,814", "levelname": "WARNING", "message": "[MarketStream: 2001]: Latency high: 689.121832370758"}```

The only change I've made (and so at this stage I'm assuming is the culprit) is to run the market recorder on my live instance, as opposed to my local test instance (previously I recorded locally and kept my live stuff separate), so I added this just before framework.run() on my live code in AWS:



```recorder = MarketRecorder(

            name="MR_horse_greyhounds",

            market_filter=streaming_market_filter(

                    event_type_ids=[7],

                    country_codes=['GB','IE','US','FR', 'AU'],

                    market_types=['WIN', 'PLACE', 'EACH_WAY'],

                ),

            stream_class=DataStream,

            context={

                "local_dir": ai.unprocessed_data,

                "bucket": "fluminetest",

                "force_update": False,

                "remove_file": True,

            },

        )



        framework.add_strategy(recorder)```

Am I potentially trying to record too much in one go and/or from the error am I somehow creating too many sessions (and if so how might I stop this)?



Again apologies for the open ended nature, I'm clearly not understanding something about sessions I feel!

---

## 2022-01-14 16:31:18 - general channel

**Dario Scardina**

hello everyone :slightly_smiling_face:



Has somebody ever faced this exception



`ERROR Invalid response received: {'accountStatement': bla bla bla...`



with `trading.account.get_account_statement` method?



It seems that json response is not in a valid format...

---

## 2022-01-14 04:47:22 - issues channel

**west**

I have been following the tutorial and I cant seem to be able to get the runner names. Saw a question on here but couldnt understand how to apply that to the example in the docs.

```# Create a price filter. Get all traded and offer data

price_filter = betfairlightweight.filters.price_projection(

    price_data=['EX_BEST_OFFERS']

)



# Request market books

market_books = trading.betting.list_market_book(

    market_ids=['1.193314179'],

    price_projection=price_filter

)



# Grab the first market book from the returned list as we only requested one market 

market_book = market_books[0]



runners_df = process_runner_books(market_book["runners"])```

At which part of the code/example do I make changes to ensure the horse names come through? Thanks

---

## 2022-01-14 04:04:50 - issues channel

**Colin**

Hi All. I've tried searching for this and found similar occurrences, but extending the read and connect timeout values didn't seem to help. Any ideas?



Error:

Traceback (most recent call last):

  File "/Users/xxx/Documents/Personal/Python/learn/betfair.py", line 143, in &lt;module&gt;

    trading.login_interactive()

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/betfairlightweight/endpoints/logininteractive.py", line 30, in __call__

    (response, response_json, elapsed_time) = self.request(

  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/betfairlightweight/endpoints/logininteractive.py", line 53, in request

    raise APIError(None, exception=e)

betfairlightweight.exceptions.APIError: None

Params: None

Exception: HTTPSConnectionPool(host='[http://identitysso.betfair.com|identitysso.betfair.com](http://identitysso.betfair.com|identitysso.betfair.com)', port=443): Read timed out. (read timeout=3.05)



Source:

trading = betfairlightweight.APIClient(username=my_username,

                                       password=my_password,

                                       app_key=my_app_key)



    trading.betting.read_timeout = 30

    trading.betting.connect_timeout = 30

    trading.login_interactive()

---

## 2022-01-13 11:14:21 - general channel

**rob smith**

`import betfairlightweight`

`import datetime`

`import pandas as pd`

`from betfairlightweight import filters`

`from time import sleep`

`from datetime import datetime`

`from datetime import timedelta`



`username = ""`

`password = ""`

`api_key = ""`

`pd.set_option('display.max_rows', 1000)`



`def current_time(message):`

    `current_time = datetime.now()`

    `current_time = current_time.strftime('%H:%M:%S:%f')`

    `print(f'{current_time}: {message}')`



`def get_todays_games():`



    `trading = betfairlightweight.APIClient(`

            `username, password, app_key=api_key`

        `)`

    `trading.login_interactive()`

    `print("Logged in")`



    `trading.keep_alive()`



    `t20_filter = betfairlightweight.filters.market_filter(`

        `event_type_ids=[4],`

        `market_type_codes=["MATCH_ODDS"],`

        `market_start_time={`

            `'to': (datetime.utcnow() + timedelta(days=1)).strftime("%Y-%m-%dT%TZ")`

        `}`

    `)`

    `t20_events = trading.betting.list_events(`

        `filter=t20_filter`

    `)`



    `t20_events_today = pd.DataFrame({`

        `'Event Name': [event_object.event.name for event_object in t20_events],`

        `'Event ID': [event_object.event.id for event_object in t20_events],`

    `})`



    `print(t20_events_today)`



    `print()`

    `event_id = input("Input Event ID:  ")`

    `print()`



    `market_catalogue_filter = betfairlightweight.filters.market_filter(event_ids=[event_id])`



    `market_catalogues = trading.betting.list_market_catalogue(`

        `filter=market_catalogue_filter,`

        `max_results='100',`

        `sort='FIRST_TO_START'`

    `)`



    `market_types_mooney_valley = pd.DataFrame({`

        `'Market Name': [market_cat_object.market_name for market_cat_object in market_catalogues],`

        `'Market ID': [market_cat_object.market_id for market_cat_object in market_catalogues],`

        `'Total Matched': [market_cat_object.total_matched for market_cat_object in market_catalogues],`

    `})`

    `print(market_types_mooney_valley)`



    `print()`

    `market_id = input("Input Market ID:  ")`

    `print()`



    `market_books = trading.betting.list_market_book(`

            `market_ids=[market_id],`

            `price_projection=filters.price_projection(`

                `price_data=filters.price_data(ex_all_offers=True)`

            `),`

        `)`



    `while True:`

        `for market_book in market_books:`

            `print(` 

                `market_book.market_id,`

                `market_book.inplay,`

                `market_book.status,`

                `market_book.total_matched,`

            `)`

        `sleep(1)`



        `if market_book.inplay == True:`



            `while True:`

                `for runner in market_book.runners:`

                    `print(`  

                        `runner.selection_id,`

                        `runner.status,`

                        `runner.last_price_traded,`

                        `runner.total_matched,`

                    `)`

                `sleep(1)`



`get_todays_games()`

---

## 2022-01-11 22:14:24 - issues channel

**Andy B**

Morning all, (cross posting here with the Betfair Quants slack channel) I'm getting an error in a script that hasn't given me issues previously and I was wondering if there was a data error causing anyone else grief? I am getting the list of todays greyhound markets and runner ID's but it is getting stuck on Capalaba greys with the following error:

Traceback (most recent call last):

  File "c:\Users\andy\OneDrive\Punting\Scripts\FastTrack\GetAllRaces.py", line 318, in &lt;module&gt;

    Races = market_catalogue_filter(Events['Event ID'][ind], Track)

  File "c:\Users\andy\OneDrive\Punting\Scripts\FastTrack\GetAllRaces.py", line 99, in market_catalogue_filter

    market_catalogues = trading.betting.list_market_catalogue(

  File "C:\Python\lib\site-packages\betfairlightweight\endpoints\betting.py", line 233, in list_market_catalogue

    (response, response_json, elapsed_time) = self.request(method, params, session)

  File "C:\Python\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 55, in request

    self._error_handler(response_json, method, params)

  File "C:\Python\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 81, in _error_handler

    raise self._error(response, method, params)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketCatalogue

Params: {'filter': {'eventIds': ['31170555'], 'marketCountries': ['AU', 'NZ'], 'marketTypeCodes': ['WIN']}, 'marketProjection': ['MARKET_START_TIME', 'RUNNER_DESCRIPTION'], 'sort': 'FIRST_TO_START', 'maxResults': '1 00'}

Exception: None

Error: {'code': -32602, 'message': 'DSC-0018'}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}

PS C:\Users\andy&gt;

---

## 2022-01-10 18:51:28 - random channel

**D C**

It does go beyond 90 days for market level P&amp;L just not at the bet level. I can get stuff by strategy reference per market as far back as 2020. Depends on how specific you need the info.

---

## 2022-01-10 09:16:55 - issues channel

**liam**

Fixed in [https://github.com/liampauling/flumine/pull/550|1.21.1](https://github.com/liampauling/flumine/pull/550|1.21.1) with `strategies.finish` now called on `__exit__` and self passed to `strategy.finish` so you have access to market/blotter objects

---

## 2022-01-09 22:10:44 - random channel

**Michael**

Is this theoretical or does it really arise as a practical question? In my experience there is no comparison between betting returns and investment returns. You bet everything the market will take, Investment is just what you do with your profits.

---

## 2022-01-09 14:45:55 - issues channel

**Ruben**

how could one access the orders from the strategy there? I cant seem to figure it out, there is no market object (so no blotter), only the strategy `self`

---

## 2022-01-09 10:04:50 - issues channel

**Ruben**

on that same topic, if I wanted to cancell all unmatched orders when a `TerminationEvent` occurs (such as unhandled exception), would `finish()` of the strategy be the right spot?

---

## 2022-01-08 15:44:27 - general channel

**Jono**

i have a simple middleware script set up in one of my strategies to add EXECUTION_COMPLETE orders into the blotter upon restarting the flumine instance. Ive noticed the order.date_time_created field doesnt actually reflect the placedDate field from the betfair response that looks something like this normally in the response json   'placedDate': '2021-01-08T12:38:46.000Z' instead its just the utc datetime from when the object was created.  Is this palcedDate information accessible from order objects as once i restart a strategy i cant seem to actually determine how long a go it was placed from the process_orders(self, market, orders) function. I believe i could gather this placedDate field in from a separate listCurrentOrders call but this seems inefficient. Am i missing an obvious attribute that stores this placedDate info in the order object? Thank you!

---

## 2022-01-08 09:18:32 - strategies channel

**birchy**

I was just thinking that after I'd posted. :man-facepalming: So in a nutshell, the only way to separate orders is to run a separate AWS instance per strategy? OR...use one instance with logging control for each strategy (which I do anyway) and only use the polled listClearedOrders data for basic analysis at account level.

---

## 2022-01-08 08:57:21 - strategies channel

**birchy**

Like this?

`strategy = A1(

    ...

)

config.customer_strategy_ref = strategy.name

framework.add_strategy(strategy)`



`strategy = A2(

    ...

)

config.customer_strategy_ref = strategy.name

framework.add_strategy(strategy)`

---

## 2022-01-08 08:42:51 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) I'm a bit confused.... The reason I changed the customer_strategy_ref was because I have one deployment server which runs 2 independent frameworks (one per betfair account), each of which has 1+ independent strategies. Obviously they're all on the same hostname, so all of the orders had the same reference which was a PITA. So what's best practice for this kind of setup?

---

## 2022-01-08 08:20:30 - strategies channel

**liam**

The order stream filters on it, fine if you only have one strategy 

---

## 2022-01-08 06:52:24 - strategies channel

**Oliver Varney**

What's wrong with the customer order ref for this (unless I'm misunderstanding). Can't remember how flumines property looks like now but I just override it with a custom value encoding strategy and trade information, everything I need to rebuild the trade basically

---

## 2022-01-08 00:16:00 - strategies channel

**birchy**

I recently added this to my strategies because I discovered that when using bflw to poll `listClearedOrders` in order to save the history beyond the 3 months the website offers, I was unable to identify which strategy had placed which bets because they all used the same host name. I use `loggingControl` but also wanted the 'official' numbers from betfair.

---

## 2022-01-08 00:08:22 - strategies channel

**birchy**

Oh...so is this wrong? `config.customer_strategy_ref = strategy.name`

---

## 2022-01-07 19:13:43 - strategies channel

**JC**

Interesting stuff, thanks for your thoughts. Guess the trick definitely is in identifying inefficiencies rather than building a perfect model. I do wonder if there are many here who have built fundamental models that outperform the market on average though!

---

## 2022-01-07 18:08:35 - general channel

**VT**

I send a bet using the code:



limit_order_filter = filters.limit_order(size = 5, price = 1.01, persistence_type = 'LAPSE')



order = trading.betting.place_orders(

         lightweight = True,

         async_ = True,

         market_id = market_id,

         instructions=[instructions_filter],

         session=session)



I can't get the order ID but I can see the ID through streaming_order_filter.

---

## 2022-01-07 18:02:44 - issues channel

**Ke**

not sure if market.blotter.strategy_selection_orders(self, runner.selection_id, runner.handicap) is the correct way to get the live status of my order. The order i get from this method is telling me that my order still 100% unfilled, but it is actually filled already when i check on web

---

## 2022-01-07 17:57:08 - issues channel

**Ke**

anyway to get my orders' latest status by force during process_market_book? I'm calling market.blotter.strategy_selection_orders(self, runner.selection_id, runner.handicap), but the order's remain_size/matched_size seem to be wrong

---

## 2022-01-07 17:09:29 - general channel

**VT**

Hi everyone, when I send an order through trading.betting.place_orders I get the response:



{'status': 'SUCCESS',

  'marketId': '1.193107086',

  'instructionReports': [{'status': 'SUCCESS',

    'instruction': {'selectionId': 2542448,

     'limitOrder': {'size': 5.0, 'price': 1.01, 'persistenceType': 'LAPSE'},

     'orderType': 'LIMIT',

     'side': 'LAY'},

    'orderStatus': 'PENDING'}]}



However I don't get the order ID. I noticed there is a PlaceOrderInstructionReports class but I don't know how to use it.

---

## 2022-01-07 14:27:20 - strategies channel

**Ruben**

understood, no problem, in practical terms this means that us users must keep track of which orders belong to each strategy, correct? no way to do that with flumine

---

## 2022-01-07 14:16:23 - strategies channel

**Ruben**

in flumine, is it possible to pass the parameter customerStrategyRef somewhere to tag orders from the same strategy? I haven't been able to find it looking at the method definitions

---

## 2022-01-07 13:44:54 - general channel

**Ke**

Can someone explain the concept of trade in flumine? I found it's very confusing. Is that just supposed to manage all the order for one runner in one market with one strategy?

---

## 2022-01-07 11:23:00 - issues channel

**liam**

Just realised I have already designed for this, run function uses self as a context manager, so exit gets called on any error, and you can see a few things are already called however `process_end_flumine` isn't. With this added you can add any callbacks in your strategy in the `finish` function

---

## 2022-01-07 09:20:20 - strategies channel

**Peter**

A while back I took the results data for one of my most active strategies and plotted cumulative profit against the underlying model's calculated EV. At first it climbed, but surprisingly quickly it turned and headed down again. So now that strategy has an EV limit beyond which it doesn't trade (though I also paper trade it without the limit so that I can make future adjustments if anything changes or more data allows a more refined approach).

---

## 2022-01-07 09:02:13 - strategies channel

**D C**

_"I agree with [@UBS7QANF3](@UBS7QANF3) too that the times when your model deviates the most from the market are probably the times when your model is the least performant."_



That is an interesting point [@U9JHLMZB4](@U9JHLMZB4) because it makes for an interesting expirement for people who want to dabble with any kind of kelly based stake calculation. If the hypothesis is correct and your model is most shit when it is furthest from the market then you will get rinsed a lot faster using kelly.

---

## 2022-01-07 08:51:57 - strategies channel

**Peter**

[@U0160E9HS2G](@U0160E9HS2G) In the scenario you posited, you would still suffer from adverse selection. Your offer is taken or you're able to take that price, because on balance the market (which is slightly better informed than your model) recognises a -EV opportunity. Ignoring commission helps, but in markets with very small spreads it becomes disproportionately important, so ignoring it helps with your hypothesis, but will adversely affect your bank.



To recast slightly what I was saying earlier, I believe that there's a consensus here that the market is pretty darned good, but not perfect. So most of the time it's pretty much accurate, but sometimes it's a bit off. Classic financial theory holds that efficient markets incorporate all the publicly available information and reflect it in their prices. By contrast your model incorporates only the information that it can infer from the features that you have given it. So most of the time the market performs better than your model 'cos it knows more, but sometimes your model may perform better than the market 'cos what it does know is more important in specific circumstances.



So if you use your model all of the time, you'll sometimes win, but mostly lose. The trick is to identify those (I'll use [@UBS7QANF3](@UBS7QANF3)'s word here) scenarios where your model outperforms the market and then focus all your attention there.



I agree with [@UBS7QANF3](@UBS7QANF3) too that the times when your model deviates the most from the market are probably the times when your model is the least performant.

---

## 2022-01-07 07:55:45 - strategies channel

**D C**

Don't forget it is not just about model data but also speed of getting hold of that data. Consider a team sport using a model that has parameters that are team aggregated statistics versus one that uses the selected players individual statistics. Model A won't change if a player is injured/dropped from the team but model B will - and people with the first knowledge of lineups/injuries will update their model and have the advantage. So much depends on the type of sport and whether you use exchange or bookie. For example, the former big syndicate employee Misha used to inform us regularly that in horses, the big players don't get involved until 2 minutes before the race off - but in other sports betting with bookies, chances are you want to get in early before all the sharps snap up the value.

---

## 2022-01-06 23:42:38 - strategies channel

**birchy**

[@U0160E9HS2G](@U0160E9HS2G) The way I see it is that no model is 100% accurate, so we have to overcome this by using a margin of error big enough to give us confidence that the ends of our probability intervals are +EV. Then we pick the spots where the market overreacts and crosses our approximated +EV prices. The difficult part is optimising the model and narrowing the margin to achieve sufficient volumes of bets that are still +EV.

---

## 2022-01-06 19:20:44 - strategies channel

**JC**

Also cheers [@U9JHLMZB4](@U9JHLMZB4),  I was thinking about markets that have very small spreads so that adverse selection can be minimised and you benefit from being a market taker, or just by getting to the front of the offer queue. In this scenario you can expect a return of zero/breakeven in the long run by betting randomly (ignoring commission). So logically, if you are betting in a direction nominated by a good (but not as good as the market) model, you are likely to do better, and possibly generate a profit?

---

## 2022-01-06 19:11:24 - strategies channel

**JC**

[@U01DVUAE2G1](@U01DVUAE2G1) thanks this is a good illustrative example. I see now that it may only be profitable in this scenario because you have an edge or are doing something different to most/the rest of the market. If you were only using a predictive parameter that is well-established and already baked into the market price, then there is no reason the market would be more likely to be wrong in the direction your model suggests. It may even be more likely that the market is wrong in the opposite direction, since your indicator may be so commonly used that it is overbet?

---

## 2022-01-06 18:24:08 - strategies channel

**Peter**

I share [@UBS7QANF3](@UBS7QANF3)’s view that it's unlikely that you could make money by betting against the market based on triggers from a model that you know to be inferior to the market (as most are). That seems to be inviting adverse selection.



But let's look at a hypothetical that illustrates how it might be made to work. Suppose you built a fundamental model that gets into the ballpark for soccer match odds markets. Upon closer examination you spot that it performs well for teams in major leagues with large followings, especially for televised games. You could rationalise this as lots of fans backing their team and driving the price below what your model's idea of value and indeed "true value". In this scenario you could use your model to trigger trades with +EV.



However, if you started using it to trade outside that specific scenario, you're likely to come unstuck very quickly as the market snaps up each trade where it knows better than your model, and ignores those where your model has actually taken you in the right direction.

---

## 2022-01-06 18:09:41 - strategies channel

**Aaron Smith**

On another note, being more precise than the market is rather vague without specifying the time. Making a model that creates probabilites better than the market right before the off seems nearly impossible, however you may still find value earlier on, when the market isnt as efficient yet.

---

## 2022-01-06 18:07:32 - strategies channel

**Aaron Smith**

[@U0160E9HS2G](@U0160E9HS2G) Yes, that is possible. To make a oversimplified example, suppose you found a significant parameter that the market doesnt take into account. Now, you dont know anything else but this single parameter, so your modeled probabilities would be nonsense. However, you could still let the market create its price and when the spread is sufficiently small, go in the direction of your "model".

---

## 2022-01-06 17:20:20 - strategies channel

**JC**

Thanks Mo, this makes sense. In theory though, could your model be worse than the market on average but you bet _every_ time in the direction that your model suggests the market is wrong, and you still make a profit? Presumably, the market would be closer to the 'true' probability than your model on average if it has a lower brier score, but if it is slightly wrong then would it not be more likely to be wrong in the direction suggested by your model? Of course, when there is a massive discrepancy it suggests your model is missing some key information and this may not be the case.

---

## 2022-01-06 17:01:43 - strategies channel

**Mo**

Can your model be worse than the market ON AVERAGE and better than the market in some specific scenarios? Yes. If you only bet in those scenarios can you make money with a model that is worse than the market on average? Yes. Is it likely that you are right when your prices deviate most strongly from the market? No, these are probably the worst situations to bet in

---

## 2022-01-06 16:45:18 - strategies channel

**JC**

Hi guys, might be a strange question but hoping it can get some discussion started. Is it possible to be profitable with a fundamentals model that is technically worse than the market by placing bets when there is over x % estimated value? Let's say your model's brier score and accuracy are a little worse than the market-implied probabilities, but that your prices deviate from the market - can you still make a profit from betting in the direction that your model suggests the market is wrong? I imagine this is especially possible if you are offering prices and avoiding the spread. Or is the only way for a fundamentals model to be profitable long-term for it to have a lower brier score than the market?

---

## 2022-01-05 09:46:40 - issues channel

**Aaron Smith**

[@UBS7QANF3](@UBS7QANF3)

```            "bet_id BIGINT," \

            "strategy_name TEXT," \

            "market_id TEXT," \

            "selection_id INT," \

            "date_time_placed TEXT," \

            "price NUMERIC," \

            "price_matched NUMERIC," \

            "size NUMERIC," \

            "size_matched NUMERIC," \

            "side TEXT," \

            "elapsed_seconds_executable NUMERIC," \

            "order_status TEXT," \

            "market_note TEXT," \

            "order_notes TEXT," \

            "PRIMARY KEY (bet_id, market_id, selection_id));"```

---

## 2022-01-01 14:59:27 - random channel

**VT**

Happy New Year everyone!



I plan to increase my profits in soccer manual trading by adding some tools that I can program in Python, I hope this will give me an advantage (even if small) over the other manual traders.

---

## 2022-01-01 12:12:26 - random channel

**river_shah**

Happy New Year everyone! Thanks for all the contributors on this slack. Really invaluable.



I started betting in good size in Feb ’21. Not that I had any priors, but been a decent first year and my goals for ’22 are to continue using sports betting as a test bed for ideas for statistical modelling / simulation / optimal scaling. While the sports betting market is small relative to traditional financial markets, the rapid feedback that sports markets provide is particularly useful for my use case.



My stretch goal for sports betting for this year would be to reliably crack football markets.

---

## 2022-01-01 11:41:15 - random channel

**liam**

Happy New Year everyone! Thanks for making this such an awesome group :grinning:



Happy with my first goal as flumine has certainly become more stable, failed on the second.



This year looking to make this more of a programming/betting group rather than just python/bflw so maybe a rename and moving some libraries to an organisation. Personally I want to keep things ticking over and look to future proof certain areas. 

---

## 2021-12-31 13:07:24 - random channel

**liam**

I try and keep one instance per core, strategy dependant but another CPU will help or condense / profile 

---

## 2021-12-30 19:34:06 - random channel

**PeterLe**

I'm in the Vanguard Lifestrategy 60% equity JonJon for the last 4 or 5 years, served me well

---

## 2021-12-30 18:44:13 - random channel

**James T**

I think it can make sense to have a regional bias to where you live though. I believe the UK Vanguard LifeStrategy 100% equity fund is global equities, but has a higher weighting towards the UK for example. 

---

## 2021-12-30 13:30:10 - issues channel

**nthypes**

```strategy = SomeStrategy(

    market_filter=streaming_market_filter(

        market_ids=["1.192827234"]

    ),   market_data_filter=streaming_market_data_filter(fields=["EX_BEST_OFFERS"])

)

)```

---

## 2021-12-29 11:43:41 - general channel

**Oliver Varney**

the topic of benchmarks is quite interesting though, especially from a modelling perspective

---

## 2021-12-29 11:32:43 - general channel

**nthypes**

If I understand correctly, the "model" at this moment shows the "true" price as 1.50 as well. Is that correct [@U016TGY3676](@U016TGY3676)?

---

## 2021-12-29 11:30:59 - general channel

**birchy**

This raises a question...so we all generally agree that comparing our bet prices vs BSP is a good measure of model accuracy. Given that the BSP book is rarely 100%, presumably it makes sense to remove the overround/underround before comparing?

---

## 2021-12-29 11:26:52 - general channel

**river_shah**

Easily testable. Write a strategy that backs at BSP systematically and see ROI profile for staked amount. Keep stakes small to set aside adverse selection impact

---

## 2021-12-29 11:21:44 - general channel

**birchy**

One point worth mentioning is that "unintended"  greening is possible when you can both back and lay at value prices. e.g. you have a model (which you are confident is correct) that tells you the "true" price is ~2.0. You initially get a back bet matched at 2.5 and then, a short time later, you have an opportunity to lay at 1.5. Both bets are _individually_ +EV (if your model's predicted price is correct), however you have also "greened" your position and reduced your exposure.

---

## 2021-12-28 22:03:27 - strategies channel

**Peter**

Market.blotter has the orders for the current strategy / market combination.

---

## 2021-12-28 20:51:47 - general channel

**VT**

[@U024A7ACBA7](@U024A7ACBA7) The basic principle in betting, value, is simple to understand, the question here is whether it's worth investing time in a crowded and difficult area. If you are looking for money, the answer will likely be no, if you're just looking for extra money I recommend that you study the entire tradematesports website, they do a serious job. Betfair, programming and math seeking to beat the markets is possibly the most complex alternative.

---

## 2021-12-28 18:24:03 - general channel

**Aaron Smith**

By value he means the expected value(win/loss) of a bet. Generally, when placing a bet you d want the expected value to be &gt;0, otherwise you wont be making any money in the long run obviously. When greening (closing exposure), you place a bet independent of value, which generally means negative expected value and thats also why many dont green up. Still, you ll find other (also on here) who do green up. Greening up does have some advantages. Lower variance is the obvious one and may be important when starting out. Also greening up reduces paid commission and maybe (if you dont track orders yet) allows you to more quickly judge if a strategy is working or not.

---

## 2021-12-28 18:03:06 - general channel

**Shashi Khaya**

Thanks all for your input! I am still very new to the idea of sports trading and just have a few ideas that I thought could work - What is the reason for never greening?! And [@U4H19D1D2](@U4H19D1D2) where you say - we only take value - what do you mean by that? Sorry for all the questions but this seems like such a great thing to get involved in and I am eager to learn!

---

## 2021-12-28 17:38:23 - general channel

**Shashi Khaya**

Haha is this in response to my question? If you have a strategy that predicts particular price movements rather than final results (E.g. back under X goals market before match and lay X mins in for a small profit/loss) how does one implement that in Flumine?

---

## 2021-12-28 17:28:39 - general channel

**Shashi Khaya**

Hi folks, would a single strategy have the logic included to open and close positions on a market. If so has anyone got an example of how to efficiently trigger the closing part of the strategy once a position is open (e.g. there is some liability for a particular market id) ?

---

## 2021-12-28 14:22:35 - issues channel

**mandelbot**

So my strategy placed hedging bets at BSP but there were no bets matched to hedge in the first place

---

## 2021-12-27 23:34:14 - general channel

**VT**

Hi everyone, the only way to send orders on bflw is through trading.betting.place_orders, even for those who use the stream? I'm doing my first tests, I want to send an order and as soon as it is matched send a counter order to close the position. The quickest way is to monitor the order stream and once the order is matched I send another trading.betting.place_orders?

---

## 2021-12-27 10:32:02 - issues channel

**Jimmy**

Thanks. Will take a look. 



This strategy doesn't cancel any orders though so I'm a little confused. Will take a look :+1::skin-tone-2:

---

## 2021-12-27 00:41:20 - general channel

**VT**

I'm getting this error when I run the basic BFLW code for stream market, does anyone know why?

The error happens when I send an order to the market (by an external software).



import queue

import threading

import betfairlightweight

from betfairlightweight.filters import streaming_order_filter



trading = betfairlightweight.APIClient("username", "password", app_key="appKey")

trading.login()



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)



# create stream

stream = trading.streaming.create_stream(listener=listener)



# create filters

order_filter = streaming_order_filter()



# subscribe

streaming_unique_id = stream.subscribe_to_orders(

    order_filter=order_filter,

    conflate_ms=1

)



# start stream in a new thread (in production would need err handling)

t = threading.Thread(target=stream.start, daemon=True)

t.start()



# check for updates in output queue

while True:

    current_orders = output_queue.get()

    print(current_orders)



===================================================



Exception in thread Thread-10:

Traceback (most recent call last):

  File "C:\anaconda3\lib\threading.py", line 932, in _bootstrap_inner

    self.run()

  File "C:\anaconda3\lib\threading.py", line 870, in run

    self._target(*self._args, **self._kwargs)

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 60, in start

    self._read_loop()

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 219, in _read_loop

    self._data(received_data)

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 258, in _data

    if self.listener.on_data(received_data) is False:

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\listener.py", line 151, in on_data

    self._on_change_message(data, unique_id)

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\listener.py", line 194, in _on_change_message

    self.stream.on_update(data)

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\stream.py", line 73, in on_update

    img = self._process(data[self._lookup], publish_time)

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\stream.py", line 209, in _process

    order_book_cache.update_cache(order_book, publish_time)

  File "C:\anaconda3\lib\site-packages\betfairlightweight\streaming\cache.py", line 587, in update_cache

    runner.matched_backs.update(order_changes["mb"])

TypeError: update() missing 1 required positional argument: 'active'

[&lt;CurrentOrders&gt;]

---

## 2021-12-26 22:21:08 - issues channel

**Jimmy**

Getting this in the logs _sometimes_.



```{"asctime": "2021-12-26 12:21:57,626", "levelname": "CRITICAL", "message": "'NoneType' object has no attribute 'profit' exception raised in 'NoneType' object has no attribute 'profit'", "exc_info": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.8/dist-packages/flumine/controls/loggingcontrols.py\", line 34, in run\n    self.process_event(event)\n  File \"/usr/local/lib/python3.8/dist-packages/flumine/controls/loggingcontrols.py\", line 65, in process_event\n    self._process_cleared_orders_meta(event)\n  File \"/home/strategies/loggingcontrol.py\", line 14, in _process_cleared_orders_meta\n    mydb.insert_cleared_order(order.bet_id, order.trade.strategy, order.market_id, order.selection_id, order.trade.id, order.responses.date_time_placed, order.order_type.price, order.average_price_matched, order.order_type.size, order.size_matched, order.cleared_order.profit, order.side, order.elapsed_seconds_executable, order.status.value, order.trade.market_notes, order.trade.notes_str, order.notes_str, False)\nAttributeError: 'NoneType' object has no attribute 'profit'", "event": "&lt;CLEARED_ORDERS_META [LOGGING]&gt;"}```

---

## 2021-12-26 21:19:19 - general channel

**AP**

Try



```market_filter=streaming_market_filter(

            event_type_ids=[2],

            market_types=["SET_BETTING", "MATCH_ODDS", "SET_WINNER", "NUMBER_OF_SETS"]

        ),```

---

## 2021-12-26 20:37:46 - general channel

**S G**

Based on the below link,

[https://betfairlightweight.slack.com/archives/C4HL6EZTQ/p1635427333064000?thread_ts=1635415964.059500&amp;cid=C4HL6EZTQ](https://betfairlightweight.slack.com/archives/C4HL6EZTQ/p1635427333064000?thread_ts=1635415964.059500&amp;cid=C4HL6EZTQ)



I tried to create the below strategy, but failed. Any ideas?

```strategy = MarketRecorder(

    name=recorder_name,

    market_filter=[

        streaming_market_filter(

            event_type_ids=[2],

            market_types=["SET_BETTING", "MATCH_ODDS"]

        ),

        streaming_market_filter(

            event_type_ids=[2],

            market_types=["SET_WINNER", "NUMBER_OF_SETS"]

        ),

    ],

    stream_class=DataStream,

    context={

        "local_dir": DATA_DIR_TENNIS,

        "force_update": False,

        "remove_file": True,

        "remove_gz_file": False,

    },

)```

I get the below error:

{"asctime": "2021-12-26 20:26:04,798", "levelname": "ERROR", "message": "DataStream 3001 run error", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\sg\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\flumine\\streams\\datastream.py\", line 143, in run\n    self._stream.start()\n  File \"C:\\Users\\sg\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\betfairlightweight\\streaming\\betfairstream.py\", line 60, in start\n    self._read_loop()\n  File \"C:\\Users\\sg\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\betfairlightweight\\streaming\\betfairstream.py\", line 212, in _read_loop\n    received_data_raw = self._receive_all()\n  File \"C:\\Users\\sg\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\betfairlightweight\\streaming\\betfairstream.py\", line 242, in _receive_all\n    raise SocketError(\nbetfairlightweight.exceptions.SocketError: [Connect: 3002]: Connection closed by server"}

{"asctime": "2021-12-26 20:26:06,813", "levelname": "INFO", "message": "Starting DataStream 3001", "stream_id": 3001, "market_filter": {"eventTypeIds": [2], "marketTypes": ["SET_WINNER", "NUMBER_OF_SETS"]}, "market_data_filter": {"fields": ["EX_ALL_OFFERS", "EX_TRADED", "EX_TRADED_VOL", "EX_LTP", "EX_MARKET_DEF", "SP_TRADED", "SP_PROJECTED"]}, "conflate_ms": null}

---

## 2021-12-26 17:11:37 - random channel

**Jonjonjon**

Yes. But it depends on your strategy. For what I do, 8% is best as my returns are relatively consistent. But if your strategy is less consistent a lower % could be better. [@UGV299K6H](@UGV299K6H) shared a useful spreadsheet for doing the calculations a long time ago.

---

## 2021-12-24 05:41:39 - issues channel

**Unknown**

Recently I've started getting the same error. When I run the model in debug the errorenous unrounded amount is even showing up in the betfair message.

---

## 2021-12-22 19:48:17 - random channel

**mandelbot**

The air and pro? It's pretty much identical to the 13 inch pro model except for some extra battery life it seems. The 14" and 16" have more cores and ram etc

---

## 2021-12-22 10:00:20 - general channel

**Techno**

[@U4H19D1D2](@U4H19D1D2) When I use runner.ex.traded_volume in the program to output trd for each runner the output looks like this for each price: [&lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x0000014BEB606EF0&gt;]

---

## 2021-12-22 09:46:07 - general channel

**liam**

`runner.ex.traded_volume` [https://github.com/liampauling/betfair/blob/b202fe192b2a46c4d19ab50cf60e380f2a38cb4e/betfairlightweight/resources/bettingresources.py#L378|here](https://github.com/liampauling/betfair/blob/b202fe192b2a46c4d19ab50cf60e380f2a38cb4e/betfairlightweight/resources/bettingresources.py#L378|here)

---

## 2021-12-21 09:08:40 - issues channel

**mandelbot**

So I'm trying to place a limit back bet to a target payout, but I am getting the following error `"Unknown error __init__() missing 1 required positional argument: 'size' in process_market_book"` my order looks like this :

```order = trade.create_order(

    side="BACK",

    order_type=LimitOrder(price=get_price(runner.ex.available_to_back,0), bet_target_type="BACKERS_PROFIT", bet_target_size=50)

)```

Not sure why I have to give a 'size' if I'm betting to a target payout. The relevant betfair documentation doesn't seem to require a size parameter [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/placeOrders#placeOrders-BettoPayoutorProfit/Liability](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/placeOrders#placeOrders-BettoPayoutorProfit/Liability)

---

## 2021-12-21 08:46:19 - issues channel

**JFP**

Here is my backtest code



```client = clients.BacktestClient()



framework = FlumineBacktest(client=client)



root_folder = 'C:/BF_PRO_DATA/Nov/'

folders = os.listdir(root_folder) #list of folders

markets = []



for folder in folders:

    folder = os.path.join(root_folder, folder) #dir to open folder in list of folders

    _markets = os.listdir(folder) # list of files inside folder inside list of folders

    _markets = [x for x in _markets if x.endswith('.bz2')] #adds file names to list

    _markets = [os.path.join(folder, x) for x in _markets] #adds file names to a dir string

    markets.extend(_markets) #adds exact dir for each file to market list





spList=[]



class Test1(BaseStrategy):





    def check_market_book(self, market, market_book):

        if (market.seconds_to_start &lt;= 360) and (market_book.status != "CLOSED") and not market_book.inplay and market.market_type == "WIN":

            return True



    def process_market_book(self, market, market_book):

        

        if (ABC):



            for runner in market_book.runners:

                

                runner_context = self.get_runner_context(market.market_id, runner.selection_id, runner.handicap)

                

                back1 = get_price(runner.ex.available_to_back, 0)

                back2 = get_price(runner.ex.available_to_lay, 0)

                

                #exit current selection itteration if back1 = None

                if back1 == None or back2 == None:

                    continue



                

                if (XYZ):

                        

                    trade = Trade(

                        market_id=market_book.market_id, 

                        selection_id=runner.selection_id,

                        handicap=runner.handicap,

                        strategy=self

                    )

                    

                    order = trade.create_order(

                        side= Side, 

                        order_type=LimitOrder(price=back1, size= sizeB1),

                        notes=OrderedDict(market_vol=round(totalVol, 4), sel_volume = selTradedVol, event_details = market_book.market_definition.name, order_num = 1)

                    )

                    

                    market.place_order(order)

                        

    def process_closed_market(self, market, market_book) -&gt; None:



        for runner in market_book.runners:

            spList.append([runner.selection_id, runner.status, runner.sp.actual_sp])





with mock_patch("builtins.open", smart_open.open):

    strategy = Test1(

        market_filter={"markets": markets,"listener_kwargs": {"seconds_to_start": 360}, "market_types":["WIN"]},

        max_trade_count = 4,

        max_live_trade_count = 4,

        max_order_exposure = 10000,

        max_selection_exposure = 20000

    )

    framework.add_strategy(strategy)

    framework.run()



dfList=[]



for market in framework.markets:



    for order in market.blotter:

        dfList.append(

        [

            market.venue,

            market.country_code,

            market.event_name,

            market.market_start_datetime,

            order.market_id,

            order.selection_id,

            order.notes['event_details'],

            order.notes['market_vol'],

            order.notes['sel_volume'],

            order.notes['order_num'],

            order.responses.date_time_placed,

            order.status,

            order.order_type.price,

            order.average_price_matched,

            order.size_matched,

            order.simulated.profit,

        ]

        )



df = pd.DataFrame(dfList, columns = ['market_venue', 'country_code', 'event_name', 'market_start_datetime', 'market_id', 'selection_id', 'event_details', 'market_vol', 'sel_volume', 'order_num', 'time_placed', 'status', 'price', 'average_price_matched', 'size_matched', 'simulated_profit'])

df['weekday'] = df['time_placed'].dt.dayofweek

df['month'] = df['time_placed'].dt.month



#add bsp

df['bsp']=df['selection_id']

df['selection_status'] = df['selection_id']



for L in spList:

    df.loc[df['selection_id'] == L[0], 'bsp'] = L[2]

    df.loc[df['selection_id'] == L[0], 'selection_status'] = L[1]```

---

## 2021-12-21 08:42:11 - issues channel

**Unknown**

Hi all, I am new to Flumine and am backtesting a strategy using betfair pro data. I have followed the examples and started running backtests but have noticed an issue with simulated profit. Removed runners are returning a simulated profit (please refer to output image below)(Note: this is a backing strategy, it seems odd that the simulation would see a removed runner as winner). Would be greatly appreciated if someone could point out what I’m doing wrong.

---

## 2021-12-20 10:21:34 - issues channel

**Martin Chambers**

Hi all,  Just working the examples given and am having an issues placing a bet.  Am getting the error code below.



Error: {'code': -32602, 'message': 'DSC-0018'}



Any ideas from the code below what I am not doing right?  Appreciate the help.



```# update for test

market_id = "1.192536055"

selection_id = 14884478



def place_order():

    # placing an order

    limit_order = filters.limit_order(size=2.00, price=5.00, persistence_type="LAPSE")

    instruction = filters.place_instruction(

        selection_id=selection_id,

        handicap=0,

        side="WIN",

        order_type="LIMIT",

        limit_order=limit_order,

    )

    place_orders = trading.betting.place_orders(

        market_id=market_id, instructions=[instruction]  # list

    )



    print(place_orders.status)

    for order in place_orders.place_instruction_reports:

        print(

            "Status: %s, BetId: %s, Average Price Matched: %s "

            % (order.status, order.bet_id, order.average_price_matched)

        )



place_order()```

---

## 2021-12-19 18:59:01 - strategies channel

**Aaron Smith**

I had a strategy placing a lot of orders (not reaching the 5k though) and immediatly got latency issued

---

## 2021-12-19 18:57:16 - strategies channel

**Ruben**

atm I am just trying 1 market, but the strategy places/cancels orders constantly. In fact it often reaches the 5k tx limit with just 1 market (but that's another problem)

---

## 2021-12-19 18:54:18 - strategies channel

**liam**

How many markets? CPU intensive strategy? Spikes of warnings or gradual increase? Look at monitoring in AWS 

---

## 2021-12-19 18:53:05 - strategies channel

**Ruben**

hello everyone, I am experimenting with running my first strategy live, and I am running it in an EC2 t3.micro instance (2 vCPUs, 1gb memory). However, looking at the logs, I am seeing a lot of latency warnings, some with very high latency, like 60s. Could this be due to the CPU of the instance not being fast enough to process updates at the rate they come in?

---

## 2021-12-17 20:07:47 - general channel

**Peter**

I use RDS rather than local databases, because the data is precious to me and I want it somewhere safe with redundancy and backups and not to have to organise that myself.



I do use one big database, but my tables don't generally follow individual strategies. So for example all my orders go in one table with the strategy name as an indexed column so that I can filter by strategy if I wish, but am also forced to store my data consistently, making comparisons between strategies feasible.

---

## 2021-12-17 20:04:31 - general channel

**Peter**

There's no inherent slowness in Mongodb, so if your retrievals are slow, that's probably an indexing issue. Mongo (and indeed any schema-less database) makes more demands on the technical skills of the person setting it up and administering the data than a traditional SQL-based database.



Personally I use a MariaDB instance at RDS as, while a huge fan of Mongodb and Elastic, I haven't in my trading activities found a strong enough case to store data in documents, rather than well-designed rows, to warrant the added complexity.

---

## 2021-12-17 19:17:06 - general channel

**Beeblebrox**

Database questions... I currently have a single MongoDB database, running locally on the same machine as Flumine is running, to store all my orders with each strategy in a separate collection. I chose MongoDB as I know next to nothing about databases and the fact it could easily store JSON data seemed like the easiest solution just to get something working.



However...



1. Getting data from the db for analysis is pretty slow

2. It's crashed a couple of times and lost a load of orders

So I'm thinking there's probably a better choice of db I could chose, but I'm not really sure what and I'm not sure how to design it.



• Is an RDS db a better choice?

• Do people host their db's locally or do you use AWS to host it?

• Do you have one big db with all your orders (and separate tables for each strategy) or separate dbs to store orders for different strats?

I guess the general question is: what do people use and why?

---

## 2021-12-17 09:15:03 - random channel

**Mo**

Or that have a lot of Bitcoin on the books like MicroStrategy (MSTR)

---

## 2021-12-16 12:44:02 - general channel

**Peter**

I thought "that can't be too difficult" then took a look at the now very old script I have running as a daily cron job to do it. Hmmmm.



I'll stick it up here in case it helps. Ignore references to workspaces and the database stuff that uses my custom helper. Also my "trading" == your "client". Hope it helps ...



```import os

import sys

import json

import betfairlightweight

from datetime import datetime, timedelta

from helpers.DatabaseHelpers import database



WORKSPACE_PREFIX = os.getenv("WORKSPACE_PREFIX")

DATABASE_TABLE = "betfair_statement_lines"

SQL = """

    INSERT INTO {}

    (refId, amount, avgPrice, betSize, betType, betCategoryType, commissionRate, eventId, eventTypeId, fullMarketName, grossBetAmount, marketName, marketType, placedDate,

     selectionId, selectionName, handicap, startDate, transactionType, transactionId, winLose, deadHeatPriceDivisor, avgPriceRaw)

    VALUES ({})

""".format(DATABASE_TABLE, ('%s,' * 23)[:-1])



def processing_date():

    if len(sys.argv) &gt; 1:

        return sys.argv[1]

    else:

        return str(datetime.today() - timedelta(days=1))[:10] # returns date as a string without time



def download_account_statement(date_str):

    db = database()

    existing_lines = db.fetch_all('SELECT refId, winLose FROM {} where left(placedDate, 10) = "{}"'.format(DATABASE_TABLE, date_str))

    process = True

    from_record = 0

    while process:

        print(date_str, from_record, "-", from_record + 99)

        start_time = date_str + "T00:00:00Z"

        end_time = date_str + "T23:59:59Z"

        time_range = betfairlightweight.filters.time_range(from_=start_time, to=end_time)

        ast = trading.account.get_account_statement(

            from_record=from_record,

            item_date_range=time_range,

            include_item="ALL",

        )

        txns = []

        for a in ast.account_statement:

            line = json.loads(a.item_class_data["unknownStatementItem"])

            if (int(a.ref_id), line["winLose"]) not in existing_lines:

                txns.append(list({**{"refId": a.ref_id, "amount": a.amount}, **line}.values()))

        result = db.execute_many(SQL, txns)

        if result: print(result)

        from_record += 100

        process = ast.more_available

    db.close()



trading = betfairlightweight.APIClient(os.getenv("BETFAIR_USERNAME"), os.getenv("BETFAIR_PASSWORD"), app_key=os.getenv("BETFAIR_LIVE_KEY"), certs=WORKSPACE_PREFIX + "certs")

trading.login()



download_account_statement(processing_date())```

---

## 2021-12-15 14:45:12 - general channel

**Oliver Varney**

I find it hard that they should be able to market saying its a "trading platform". Obviously another plus for never greening as bankroll is set up for this vs "trading"

---

## 2021-12-14 10:31:14 - general channel

**Techno**

```import betfairlightweight



trading = betfairlightweight.APIClient(

        "username", "password", app_key="app_key", certs="/certs"

    )

trading.login()

&lt;LoginResource&gt;```



---

## 2021-12-14 10:29:34 - general channel

**birchy**

[@U02P76UDUPK](@U02P76UDUPK) might be worth using the Lowestlayer example just to keep you ticking over until you have some other strategy running. Not sure if you are already using it, but PyCharm is a bloody good editor for python scripts.

---

## 2021-12-13 00:48:40 - general channel

**Martin Chambers**

I can see some data being stored in my tmp file now, (and no errors in Visual Studio - so I must be underway!  Will take some time now and see if I can get a simple strategy working.  Appreciate your help guys, awesome!

---

## 2021-12-12 09:44:57 - general channel

**captainonionhead**

Following up on the comment about getting the marketrecorder example going - if you're using a live key, you'll need a strategy to run with it to stop BetFair being upset that you're just scraping data.  I'd recommend posts like: [@U016TGY3676](@U016TGY3676)'s:

[https://betfairlightweight.slack.com/archives/CTPL3R3FU/p1623458534154600](https://betfairlightweight.slack.com/archives/CTPL3R3FU/p1623458534154600)

Which amongst many other things has some useful ways to get a strategy started at the bottom.

I also found a lot of useful discussions in [#CTPL3R3FU|strategies](#CTPL3R3FU|strategies) from around late-June/early-July this year.  It's well worth browsing through these channels as there's lots of super helpful people in here and this is a fabulous resource to get started!

---

## 2021-12-12 08:57:46 - strategies channel

**Mo**

There is a transaction charge that is supposed to discourage excessive numbers of bets but beyond that there aren't any policies on spoofing etc. Your strategy’s behaviour sounds entirely reasonable 

---

## 2021-12-11 23:08:40 - strategies channel

**Oliver Varney**

Nothing against [@U4H19D1D2](@U4H19D1D2) but its impossible to model

---

## 2021-12-11 22:06:24 - strategies channel

**Ruben**

Good night everyone. I am beginning to test my first strategy live, and I am seeing that it matches about 3% of orders it offers. It offered ~1700 orders and only 50 orders were matched. Is this too low for Betfair's standards?

---

## 2021-12-11 20:00:16 - random channel

**Beeblebrox**

[@U016TGY3676](@U016TGY3676) I had something similar today, in my case it was because I was maxing out the cpu.  It had been fine for months, but I started running an extra flumine instance with a new strategy a couple of days ago and it couldn't cope.



My Lightsail instance was Windows (yes, yes I know! I just used that as I'm more used to Windows), but I'm going to try setting up some Unix EC2 instances instead.  As a novice Unix user has anyone got a guide on things like which flavour of Unix to use, which instance types to use (I'm thinking t3.micro), how to install Python, Git, etc, and any other tips?  I'm sure I can work it out myself, but any guidance would be appreciated.

---

## 2021-12-11 15:00:20 - random channel

**Oliver Varney**

Very high memory requirements in terms of models here unfortunately

---

## 2021-12-11 05:21:26 - general channel

**Martin Chambers**

Hi all. First post here. Just getting started and have plenty to learn. Have read the docs at betfairlightweight and flumine. Just after some guidance on a work flow here to create a simple bot/strategy to start with. Login through betfairlightweight and then create a strategy with flumine? I have the been able to log into my account, get the market list etc so far.

---

## 2021-12-09 15:39:28 - general channel

**Aaron Smith**

whats the best way to cancel those? I need to get all markets the strategy has placed an order in to cancel them. I see there is something called strategy._invested, however i cant find where this is being populated

---

## 2021-12-09 14:37:30 - general channel

**Aaron Smith**

when terminating flumine, i want all open bets to be cancelled. I assume this would be done in strategy.finish() ?

---

## 2021-12-09 12:26:23 - general channel

**liam**

My most complicated model (lots of if statements) is for TPD :joy:

---

## 2021-12-09 12:15:34 - general channel

**PeterLe**

I think that a lot wont renew after this first month. For me personally, ive had TPD a while but i find that the more triggers to add to a strategy the less effective it becomes. Im a firm believer that keeping things ultra simple is the best way forward. I know many others using TPD will disagree with this but that's my honest take on it. Appreciate that there maybe other strategies inpay that will benefit from it, but thats not the case for mine.

---

## 2021-12-09 01:34:32 - general channel

**NC**

Yes, completely agree. My expectations are quite low tbh, especially for the model based upon historical data, but I do think RL has a huge role to play to learn new ways to make money. From what I hear it's being used in the financial markets very successfully, and I would imagine something similar could be done on the sports exchange. Also the work that was done on chess, just shows how powerful it can be, outperforming all known engines to date. Anyway, needless to say it's a huge undertaking, but I hope either me or someone else here can make some big steps (if not already)

---

## 2021-12-08 23:51:22 - general channel

**NC**

My main avenue at the moment is building a successful ML model on historical data, and using RL to develop a profitable long term strategy to place bets. I'm confident this will be profitable but at a fairly low %. My secondary avenue will be to create a bot to use RL and make money through trades. My hunch is this will be much more complex but potentially much more lucrative. I get the point about narrowing down some potential strategies though.

---

## 2021-12-08 23:35:31 - general channel

**Jonjonjon**

I've thought about it but it's probably better to have a non-losing baseline strategy to work from first.

---

## 2021-12-07 21:06:50 - general channel

**birchy**

Bugger, I have a strategy leak. Was wondering why my bets were arriving at slightly different times. So something like this:

```for runner in market_book.runners:

    atb = get_price(runner.ex.available_to_back, 0)

    trade = Trade(

        market_book.market_id,

        runner.selection_id,

        runner.handicap,

        self,

    )

    # create order

    order = trade.create_order(

        side="BACK",

        order_type=LimitOrder(atb, self.context["stake"]),

    )

    # place order for execution

    market.place_order(order)```

Should be done like this instead....???

```with market.transaction() as batch:

    for runner in market_book.runners:

        atb = get_price(runner.ex.available_to_back, 0)

        trade = Trade(

            market_book.market_id,

            runner.selection_id,

            runner.handicap,

            self,

        )

        # create order &amp; add to batch

        order = trade.create_order(

            side="BACK",

            order_type=LimitOrder(atb, self.context["stake"]),

        )

        batch.place_order(order)

    batch.execute()```



---

## 2021-12-07 15:48:44 - general channel

**Jeff Waters**

I googled Betfair market definitions, and got this page: [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions),



selectionId and runnerName are listed next to one another.



If I write print(runner.selection_id), I get the id of the runner. However, when I write print(runner.runnerName), Pycharm gives me an unresolved attribute error message.



How do I get around this, please?

---

## 2021-12-07 10:00:42 - strategies channel

**C0rnyFlak3s**

Well I am not limiting myself to the lay side of this strategy strictly. If my first analysis concludes, that there are games where the back side is underpriced, I will surely investigate this side too. :slightly_smiling_face: I just used the lay side, to start with. But yeah thanks for your input, definitely this assumption of the draw being underpriced either needs to be validated or refuted

---

## 2021-12-07 09:57:17 - strategies channel

**Aaron Smith**

surely given you find and analyse the right parameters, you can make a profit from laying the draw. That is kinda true for any market. But why are you limiting yourself to laying the draw? why not back the draw? Feels like there is an underlying assumption that draws are generally underpriced and that sort of assumption surely needs a decent foundation if you want to build a strategy around it.

---

## 2021-12-07 09:28:30 - strategies channel

**C0rnyFlak3s**

haha ^^ I don’t say I am fully convinced by this idea myself, and I am well aware, that this is the most basic and beginner friendly strategy that will be praised by those ebook salesman as you call them. However I think, most of them do not really analyze the parameters around the games with it. But yeah I may try to come up with something the next days, and see how it fairs :stuck_out_tongue:

---

## 2021-12-07 09:24:43 - strategies channel

**D C**

I am sure there are ways to make money from it somehow, but whenever I hear "lay the draw" and "strategy" in the same sentence I can't help but get ebook salesman vibes.

---

## 2021-12-07 09:03:10 - strategies channel

**C0rnyFlak3s**

Has anyone experience with developing a strategy around the ‘lay the draw’ idea in soccer? I know most of you guys focus on horses and dogs, but maybe there are some soccer guys out here too. Obviously the plain lay the draw strategy will not make any profit nowadays, but I think with considering some game parameters and maybe analyse the correct entry time for the lay may proof to be profitable. Any experiences with it?

---

## 2021-12-06 23:33:44 - general channel

**Steve**

I'm trying to get my head around what flumine translate into Cython. I can see that all the flumine module are in pyc format - so I assume almost all the backend runs in Cython. But what happens if I manually make changes to the .py script in the flumine module? Will those changes be translated into Cython or does it just run in python? And does the file where my strategy logic sits get processed in cython or pyhton? Just want to get a better understanding as I rarely use Cython.

---

## 2021-12-06 20:59:27 - strategies channel

**TT**

Yeah, good shout. I'm only at the stage of having one strategy so I could get away with it for now :joy:

---

## 2021-12-06 20:52:33 - strategies channel

**TT**

I'm looking at the example for the BackgroundWorker, and it shows each market context getting updated. I've got a single variable I'd like to make available to all markets but I'd rather not copy it to each market context as it is quite large. Does it make sense to add this to the strategy context directly? I.e.



`def background_worker_function(context, flumine):`

    `x = query_db()`

    `flumine.strategies._strategies[0].context["foo"] = x`



and then you can just access it within the strategy using `self.context["foo"]`

Does that make sense?

---

## 2021-12-06 20:24:05 - issues channel

**Newbie99**

This error has come up a few times recently, when the market cleared event is processed:



```

{"asctime": "2021-12-06 14:30:14,617", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/worker.py\", line 234, in _get_cleared_market\n    group_by=\"MARKET\",\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/betfairlightweight/endpoints/betting.py\", line 434, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.192009763'], 'customerStrategyRefs': ['ip-172-31-4-105'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang11b-prd-10290844-0055b9d69e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang11b-prd-10290844-0055b9d69e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.192009763'], 'customerStrategyRefs': ['ip-172-31-4-105'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang11b-prd-10290844-0055b9d69e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang11b-prd-10290844-0055b9d69e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}```

All I'm doing is the following (using the Closed Market Logging example):



```    def _process_cleared_markets(self, event):

        for market in event.event.orders:

            market_id = market.market_id

            file_path = market_closed_report_path + '/' + str(market_id) + '_cleared_market_data.json'

            cleared_market_data = {'market_id': market_id,

                                  'market_profit': market.profit,

                                  'market_com': market.commission

                                 }



            check_and_create_json(file_path, cleared_market_data)```

But the error looks like Flumine is making an incorrectly constructed API call to Betfair if I'm reading that correctly?

---

## 2021-12-06 14:29:03 - random channel

**Atho55**

[@UBS7QANF3](@UBS7QANF3) The book looks to refer to the same model type I used in your footy comp without the MC element I bolted on

---

## 2021-12-06 12:25:47 - general channel

**Mo**

I mean that you need to build i.e. _engineer_ a complete trading system in order to have an automated betting strategy not just fit a model. You are lucky these days that flumine exists but you still potentially need to integrate with various data feeds, work out how to implement the strategy logic, handle various edge cases, the lifetime of orders, decide how to apply your margin, decide on staking strategy etc etc.

---

## 2021-12-06 10:56:21 - general channel

**Lee**

Add the Middleware to the framework and then the market_catalogue is available for all strategies.



```from flumine import FlumineBacktest, clients, BaseStrategy



from middlewares.marketcataloguemiddleware import MarketCatalogueMiddleware



client = clients.BacktestClient()



framework = FlumineBacktest(client=client)



markets = ["tests/resources/PRO-1.170258213"]





class ExampleStrategy(BaseStrategy):

    def check_market_book(self, market, market_book):

        if market_book.status not in ["CLOSED", "SUSPENDED"]:

            return True



    def process_market_book(self, market, market_book):

        for runner in market.market_catalogue.runners:

            print(runner.selection_id, runner.runner_name)





strategy = ExampleStrategy(

    market_filter={"markets": markets},

    max_order_exposure=1000,

    max_selection_exposure=105,

)

framework.add_strategy(strategy)



market_catalogue_middleware = MarketCatalogueMiddleware()

framework.add_market_middleware(market_catalogue_middleware)



framework.run()```

---

## 2021-12-06 09:53:24 - general channel

**Mo**

I don't think that's offensive at all. I think there's potentially a debate here about _what_ machine learning is.



For example, many people consider logistic regression to be machine learning but really they've just repackaged "statistics". If you think logistic regression is machine learning then is Poisson regression machine learning? Is Elo machine learning?



Tied up with machine learning is big data, and to really take advantage of many of the typical methods e.g. xgboost you're going to need a large data set. _But_ sports just doesn't generate the sorts of massive data sets you see in tech. You're always only going to get 380 matches in a Premier League season, not 380 million of them. You can't just go out and collect some more data.



I think you also miss the wood for the trees by thinking about applying machine learning to sports. Sports is not e.g. computer vision - _you can much more easily get at the data generation process in sports_. e.g. goals in a football match, running times in a horse race.



Machine learning also lets you more easily fall into engaging in intellectual masturbation rather than making money. There's a _hell of a lot_ more that goes into a successful sports betting strategy than just the model. It's really an engineering problem where the model is one small part and often not even that important a part.

---

## 2021-12-06 07:45:41 - issues channel

**birchy**

Bit of a weird problem this morning. Went to restart my marketrecorder that's been running for months and am getting this on startup:

`Traceback (most recent call last):

  File "data_recorder.py", line 118, in &lt;module&gt;

    framework.run()

  File "/home/ubuntu/.local/lib/python3.6/site-packages/flumine/flumine.py", line 29, in run

    self._process_raw_data(event)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/flumine/baseflumine.py", line 203, in _process_raw_data

    strategy.process_raw_data(clk, publish_time, datum)TypeError: process_raw_data() takes 3 positional arguments but 4 were given`

Not on my pc, so unable to debug ATM.

Flumine: 1.20.13

Bflw: 2.15.2

---

## 2021-12-05 22:21:30 - general channel

**Jeff Waters**

Indeed. Incidentally, he does go on to write:



'For the meantime however, the Excel-based models in this book, particularly when applied to smaller markets and derivatives, can offer fairly regular flashes of positive expectancy.'

---

## 2021-12-05 22:05:51 - general channel

**Jeff Waters**

"I’ve learned a lot about using R, Python, Stan, JAGS, and other software platforms that can be used to create considerably more advanced machine learning sports models [than using Excel-based models]. In all seriousness that’s where the future of sports modelling lies.



Even Marco Blume, the head of trading at Pinnacle, has come out openly saying Pinny’s traders are using machine learning models deploying the Caret package in R and the

Scikit Learn package in Python. Someday soon, these platforms are likely to be the only path forward for attacking major sports betting markets."



Mack, Andrew (2019-07-09T23:58:59). Statistical Sports Models in Excel



Agree/disagree?

---

## 2021-12-04 15:33:03 - random channel

**Mo**

I find participating in their hackathons to be an effective strategy

---

## 2021-12-03 09:01:44 - issues channel

**liam**

I was wrong (forgot how this worked), flumine will handle this correctly, for example you just pass the market files:



```strategy = ExampleStrategy(

    market_filter={

        'markets': ["match_odds.txt", "correct_score.txt", ...],

       'listener_kwargs': {'inplay': False, 'seconds_to_start': 600},

       'calculate_market_tv': True,

       'cumulative_runner_tv': True,

       'event_processing': True

    }

)```

The event professing flag will then force flumine to process the files sequentially per eventId

---

## 2021-12-03 07:06:07 - general channel

**captainonionhead**

I've only recently got going and have 2 python processes (one recorder, one simple strategy to keep Betfair happy whilst I gather some data).  These are running on a VPS I already had that I've repurposed.  It's roughly equivalent to a nano and I'm nowhere near stressing it.

However, I'm expecting to move to something more like Peter's setup with many processes on different instances at least partly because it allows me to update different parts of my code/infrastructure without having to take everything down.  At the moment I have a lot of code churn as I implement new features and I expect that to continue as I develop strategies and refine ones that are already running.

---

## 2021-12-02 22:24:24 - strategies channel

**birchy**

Oooh...that was probably around 2003/2004 at a guess. I was "aware" that sample sizes need to be fairly large _before_ that, but was very blinkered and would often pull a strategy that started off badly.

Pretty much everything I look at nowadays has some elements of those early strategies but of course, things are a _lot_ harder nowadays.

---

## 2021-12-02 21:20:18 - general channel

**TT**

How do people deploy the market recorder alongside strategies? My initial thoughts are to try and keep them separate but I can see a few options:

 - Deploy two separate ec2 instances (one for the market recorder and one for running strategies)

 - Use one ec2 instance but run 2 separate python processes

 - Use one instance and just add both the market recorder strategy to the framework alongside the other strategies



 How do other people approach this? And are there any other things to consider i.e latency/connection limit issues etc?

---

## 2021-12-02 18:58:40 - strategies channel

**birchy**

If I was asked to give just ONE piece of advice, it would definitely be to NOT look at short term performance. And I learnt that the hard way. One of my best ever strategies lost over £500 in the first week and left me with around £100 in my account. I was pretty pissed off at the time, so logged out in frustration, thinking I'd never return. I left the bot running. A month or two later, I logged in expecting to see my account empty. It wasn't. It had placed 1000's of bets during my absence and turned out to be a £3K a month strategy at £2 stakes and ran for around 18 months before it started to decline. So the moral of the story is NOT to write-off a strategy just because it's showing a short term loss. Variance can take several months to shake out and you need some fairly large bollocks and a lot of patience to ride on this rollercoaster.

---

## 2021-12-02 11:35:07 - strategies channel

**Peter**

But you are absolutely right that he's not giving too much away. As [@UBS7QANF3](@UBS7QANF3) hinted earlier, the key to success is often coming up with a feature or features that other people aren't using to give you a small edge. He's not giving us anything from his personal secret sauce. Indeed he's showing in his predictions calibration section that there's still rather a lot of work needed to make that model usable.

---

## 2021-12-02 11:31:57 - strategies channel

**Peter**

He's starting with logistic regression, so is training a model that gives win percentages for each runner. Although he then works out the strike rate by seeing how often the runner with the highest win probability actually wins, he describes that as one of the most important metrics, rather than the objective of using the model. This seems to me fair. The first step in assessing any model is whether it returns results that are appreciatively better than random, otherwise ditch it and move on.



However, you're then going on to compare the results with BSP. That's a good instinct, but sets the bar rather too high. In practise most models will tend to perform better over some subsets of the data than others, so for me a more useful question to ask of each model is can I find range of inputs over which it performs particularly well, and focus in on that. Examples might be models that are good at finding runners unlikely to have an impact on an event (and quantifying unlikely) or runners whose early price is wildly out-of-line with where BSP is likely to end up - even if it's off by a few percent from the final BSP price.

---

## 2021-12-02 11:00:10 - strategies channel

**Peter**

Being selective is important too. When I find a profitable strategy, I continue looking at signals to see whether I can achieve the same absolute profit from less bets, and often I can shave 30-40% off, with minimal reductions in profit, giving me a higher hit rate, better ROI and less volatility (i.e. a more comfortable ride).

---

## 2021-12-02 10:57:13 - strategies channel

**Peter**

The numbers were clearly made up :wink:. If you had a strategy capable of that, you'd be quietly raking in the profits rather than seeking advice here :grinning:.



I think that by number of winners in this context, you're referring to hit rate, and that's generally at the heart of whether a strategy has value, i.e. whether the odds at which you can match and the frequency with which they come in, are good enough for the winnings to overcome the losses, because, unlike gamblers, we carefully balance the two.



I believe that Liam's earlier point was that as you get closer to the start time the market gets more efficient. So by moving further away from the start and being selective, you can hope to find more mispriced runners with better odds and increase your hit rate.



After the event you can compare the price you got with the BSP as a proxy for the fair price to see whether the odds that you though were good actually had value, or not, as you can't tell that from the outcome of the race itself.



I very much doubt that you will find a strategy that delivers consistent value, i.e. over a large number of races, but has prices that, on average, are worse than BSP.

---

## 2021-12-02 10:15:31 - strategies channel

**Peter**

That's a 4.8% return, so sounds good to me. Even if that's gross profit, you could take out 8% commission and still have a return of 2.2%, better still of course at lower commission rates, So provided the model had been derived from a sufficiently large sample and produced the same returns against data not used in it's construction, I'd go with it.

---

## 2021-12-02 09:37:49 - strategies channel

**AndyL**

Thanks [@UGV299K6H](@UGV299K6H), i was curious from the [http://betfair.au|betfair.au](http://betfair.au|betfair.au) videos and LR analysis why they were judging it purely on how good each model was at picking the winning favourite, as maybe they do but surely it depends on the price. Say they win 32% of the time and profit 1R, but lose 68% of the time and lose 0.4R, then that's still a profitable strategy?

---

## 2021-12-02 07:58:39 - strategies channel

**Mo**

How does it perform on those dogs that you "like" the price of? If it still performs poorly then the market hasn't got it wrong. It's perfectly acceptable for your model to be more accurate on some particular subset of dogs

---

## 2021-12-02 07:36:45 - strategies channel

**Michael**

All of that said, I doubt that a fundamentals model is your shortest route to making a profit.

---

## 2021-12-02 07:34:09 - strategies channel

**Michael**

I think you're doing ok [@U01PJ5YMFBJ](@U01PJ5YMFBJ) - you might not be there yet but you've certainly come a long way. However the test of whether your prices are better than market prices is whether you win by betting on the difference, if you don't then it doesn't make much sense to "prefer" yours.



It might be that your model doesn't cut the mustard but the process of building it might have given you new ideas or ways of thinking about things, if so it was a worthwhile exercise. Don't sweat the model not out performing the market, it's really difficult to build a good fundamentals model with just basic inputs and I'm always really impressed by people who manage it. I don't think I could.

---

## 2021-12-02 02:42:34 - strategies channel

**ShaunW**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) You're not going to develop a greyhound betting model by watching a few races and saying you often think your prices are more true.

---

## 2021-12-01 22:35:30 - strategies channel

**AndyL**

[@U4H19D1D2](@U4H19D1D2) correct i am doing a simple approach. Basically ive been watching loads of races and corresponding odds and looking at recent form, and ive created my own price formula from the standard features, recent finish positions, recent normalised speed avg and max, recent normalised sectional timings...

I actually quite like the prices it produces, i watch races and compare mine v market, and quite often think mine are more true. For example i quite often see a dog go up a grade and the market immediately gives it a very short fav price say 2.0,but my model has it say more at 3.5+, and to me the market has it so wrong the dog typically finishes near last...

This is where i think my model falls down it's trying to cover all prices and all dogs. Taking what [@UNQGKT0CR](@UNQGKT0CR) i think said isolate more specific variables, eg.short priced upgrade...

---

## 2021-12-01 21:29:14 - strategies channel

**AP**

You could take a step back from building a pricing model (which I think is quite a difficult task) and try to isolate some variables that the market is mispricing and building a strategy around one or more of them

---

## 2021-12-01 20:57:19 - strategies channel

**birchy**

Given that markets are efficient long term, you could literally create a completely random strategy to gather a load of data and then analyse the results to find the combinations of signals that provide the best results.

FYI: I don't practice what I preach. :face_with_rolling_eyes:

---

## 2021-12-01 20:31:21 - strategies channel

**Peter**

A lot of skill when using ML is determining the appropriate type of model to use. Choose a model that takes a set of features and gives you a simplistic answer, and that's what you'll get. But there are other model types, e.g. logistic regression, that do assign probabilities for each possible outcome.

---

## 2021-12-01 18:07:54 - strategies channel

**AndyL**

Thanks [@U01MPC0GUK1](@U01MPC0GUK1) for the video link, good

One thing it highlighted i found odd, they evaluate strike rate based on betting on the predicted model selection with the lowest price, no comparison of market price to predicted price for value evaluation...?

Just bet on most probable winner, their model showed a 32% strike rate at that, where as doing the same using bsp showed a 42% strike rate, hence model needs improvement...

Just find it odd there's no value check?

---

## 2021-12-01 13:59:29 - issues channel

**Peter C**

I'm running a new strategy file today on inplay horses. It uses the field

```runner.last_price_traded```

but I'm running into trouble because this is always None. Below is the streaming filter I'm using

```market_data_filter=streaming_market_data_filter(fields=["EX_MARKET_DEF", "EX_ALL_OFFERS", "EX_TRADED"])```

I can't for the life of me work out why runner.last_price_traded never has a value when live (worked in backtests) - Does anyone know why this might be?

---

## 2021-12-01 09:54:02 - strategies channel

**Beeblebrox**

A greyhound machine learning modelling process was discussed in one of the Aus meetups. Might  be useful for you:



[https://www.youtube.com/watch?v=MLalkyPDiQE&amp;list=PLvw8KRdyfOY19ys_5lpSpcbjpy_PBoZEZ&amp;index=13](https://www.youtube.com/watch?v=MLalkyPDiQE&amp;list=PLvw8KRdyfOY19ys_5lpSpcbjpy_PBoZEZ&amp;index=13)

---

## 2021-12-01 09:52:51 - random channel

**D C**

I've been routinely using the API to obtain all my bet records on the horses since April this year. Before that just have monthly per market stuff. Not sure what the time interval on these things is but I can still query results at a market level (not bet level) per strategy reference going back a year (not tried beyond that).

---

## 2021-12-01 09:35:35 - strategies channel

**James T**

BSP is just a good benchmark. It's a prerequisite. Firstly your strategy should beat BSP on average. (If it doesn't then it would have made more sense to place your bets at BSP because you'd be getting a better price). (It might be a little more nuanced than that, but broadly that's what to aim for). 



Once you're beating BSP you can decide whether to place an (opposite) closing bet at BSP or not. You might find that generates more or less value (normally it's less), but it also relates to the variance of your returns like you have already said. 

---

## 2021-12-01 09:25:06 - strategies channel

**liam**

+1, if you assume the market is as efficient as its going to get at post time, then as you move further back in time then the market should be less efficient. I think you are trying to apply the model / value logic (correct) to your old way of 'trading' the markets.



My understanding is that you were using market signals on racing but it sounds like you are now using historic form on UK dogs? How are you then creating this model?

---

## 2021-12-01 09:24:09 - strategies channel

**James T**

Try not to overthink what everyone else is or isn't doing. Just try to think of ways to make your own price calculation/prediction more accurate. Like you say, you're not beating the market at this point, you just need to make your model better. 

---

## 2021-12-01 09:08:15 - strategies channel

**D C**

I suspect that the word "model" means different things to different people.

---

## 2021-12-01 08:57:29 - strategies channel

**AndyL**

Right...but my extra question is on bsp, i currently find value bets with model then close near off/bsp. My model might be good but the bsp of my selections might be -value, like [@UGV299K6H](@UGV299K6H) said i think..?

---

## 2021-12-01 08:54:32 - strategies channel

**Mo**

My point is I use models to make value bets. If your model is not able to identify value bets then it's back to the drawing board...

---

## 2021-12-01 08:49:49 - strategies channel

**Mo**

What is your theory for why your model is better than that being used by the market makers? If you don’t have one then there’s no reason to think you have an edge. Either you need to be using data they’re not using and/or a modelling technique that can better exploit the data you are both using. The likelihood of this is greater on less efficient markets

---

## 2021-12-01 08:32:31 - strategies channel

**Michael**

Regarding EMH: We all know that markets are not totally efficient, so what we're seeing is "approximate efficiency." We know that overall markets appear entirely efficient so that shows us that the inefficiencies go both ways, in other words as much value is given away by layers as by backers.



Regarding models: The problem is not with models, just your model.

---

## 2021-11-30 23:19:30 - strategies channel

**AndyL**

The other issue with models is 100s of other very smart traders are doing the same...so mug me and 95% of the others create a valid model, we think a selection has value so we back it, but realistically the opposite is going to happen the 5% smart traders lay those offers and the price drifts rather than steam...even though fair value is probably lower...

But the market overall is still efficient because these trades occur both up or down, so even the the individual prices are nothing like fair value overall averaged they are efficient!!

---

## 2021-11-30 23:11:11 - strategies channel

**AndyL**

Ok so if you're aiming to beat BSP or say the price at 5seconds to go on uk dogs, on average, is a model going to help do that?

As that implies the bsp is efficient on average for MY selections. What if say my model happens to pick half the market selections that are below true value?

---

## 2021-11-30 22:51:31 - strategies channel

**AndyL**

How do you guys use models?

Ive created my own model for uk greyhound prices, from recent form, ratings, times, etc.. so i get my prices and compare with the market and they'll typically differ in some way...! The odds are the market is more accurate than my prices, and ive demonstrated that by trying to enter prices when mt model thinks there's value....it isnt!!

Do I just need to refine and improve my model until it is better than 95% of all other people's models, ie.mine is the better?! But then how do i know?

---

## 2021-11-28 16:04:47 - general channel

**Amit Patel**

hey guys! is there any way to get the runner name inside a strategy when running live? I can see its there for backtests but can't figure out if its possible otherwise

---

## 2021-11-28 09:50:16 - issues channel

**Martin Karlsson**

Ok, so something like this?



*# 1. Setting up two connections*

connection_for_markets = betfairlightweight.APIClient(…)

connection_for_orders = betfairlightweight.APIClient(…)



*# 2. Creating one queue for both outputs*

my_combined_queue = queue.Queue()



*# 3. Creating the market streamer*

market_streamer = MyMarketStreaming(

	client=connection_for_markets.trading,

	cm_queue=my_combined_queue,

	...

)



*# 4. Creating the order streamer*

order_streamer = MyOrderStreaming(

	client=connection_for_orders.trading,

	cm_queue=my_combined_queue,

	...

)



*# 5. Starting the streams*

market_streamer.start()

order_streamer.start()



*# 6. Receiving the streams*

while True:

	outputs = my_combined_queue.get()

---

## 2021-11-27 23:15:41 - issues channel

**Martin Karlsson**

How do I stream both order and market updates at the same time?



I've tried to modify the example in [https://github.com/liampauling/betfair/blob/master/examples/examplestreamingerrhandling.py](https://github.com/liampauling/betfair/blob/master/examples/examplestreamingerrhandling.py) but I'm too much of a novice to get it right... =(



My approach has been to create two separate Streaming classes like the one in the above example – one for markets and one for orders. These classes share the same output_queue.



I then check if the output received is of instance MarketBook or CurrentOrders to separate the workflow.



```# Getting market stream

market_streamer = MyMarketStreamer(

  client=self.connection.trading,

  cm_queue=cm_queue,

  market_filter=market_filter,

  market_data_filter=market_data_filter,

)



# Getting order stream

order_streamer = MyOrderStreamer(

  client=self.connection.trading,

  cm_queue=cm_queue,

)



# Starting the streams

market_streamer.start()

order_streamer.start()



# Receiving the stream

while True:

   outputs = cm_queue.get()



   for output in outputs:

      if isinstance(output, MarketBook):

         self.handle_market_changes(mcm=output.streaming_update)

      elif isinstance(output, CurrentOrders):

         self.handle_order_changes(ocm=output.streaming_update)```

This seems to be working just fine except for when it comes to the error handling: then it just stops without retrying.



Maybe this should be done in a completely different manner?



Any help would be greatly appreciated!

---

## 2021-11-27 13:20:52 - general channel

**mon mon**

Is there a way to limit the number of markets subscribed to when using streaming_market_filter?

E.g. I would usually filter markets from the market catalog by time (e.g. only stream markets starting in the next 60 mins) and then set the stream to use only those market ids.

I could do this in flumine when it forst starts up,  but I can't see how I would update the strategy to use this new list of market id's (e.g. how to update the list of market id's every so often).

---

## 2021-11-26 22:16:48 - general channel

**Javier Martín Pérez**

Its not exactly that I don't like it. For example if I set a strategy following Kelly with a bankroll of 10k and i stick to the stakes Kelly is giving me, I will progressively stake more. But if I test the same strategy with someone elses money there wont be any possible damage to the first strategy while I will increase my earnings if there are any.

---

## 2021-11-26 19:31:02 - general channel

**Peter**

“Sports betting is a game where finding edges is fairly easy but _getting matched_ for sizable sums is near impossible”



This is exactly the problem and why sports hedge funds don’t work. Capital isn’t the problem, deploying it is.



I’ve almost lost count of the number of firms that have started and failed in similar manners. In aggregate they have lost millions.



I really wish the markets were ten times bigger, but they are not. So I’ve never felt the need to raise capital and neither has any other successful trader I’ve met.



It’s a self defeating proposition in my mind. You give away an edge and get a fraction of the return in lieu of using money you don’t need.

---

## 2021-11-26 16:40:55 - general channel

**Mo**

Would you decide if a strategy was profitable on the basis of four bets?

---

## 2021-11-26 16:00:16 - general channel

**Unknown**

I was just testing connection time to the API..comparing my home PC (Quite powerful system) v AWS eu-west-1a (Low powered but adequate : 2Gb 4 vCpu's)

from previous threads on here i know that the connection to betfair is asymmetric (as it goes via prolexic)

So I thought i check it out...

Same strategy on each system, simply fires in a lay order at 1.01 as the market signals it is in-play

In 3 out of 4 tests the home PC was able to receive the price data, and obtain a bet reference faster than AWS(as my strategies react to market prices, I thought this was the best way to measure and not worry about the asymmetry)

Would you say this was a reasonable test?

Just putting aside the other benefits of running on AWS, If speed to market is the main important factor is AWS worth it?

---

## 2021-11-26 14:29:15 - issues channel

**C0rnyFlak3s**

Providing ‘market_types’ to the market_filter of a strategy seems to not have any effect in the FlumineBacktest framework. I tried to filter the multi-market file of the historical PRO data from betfair for specific market_types, however without success. Anyone experiencing similar issues?

---

## 2021-11-26 13:54:27 - general channel

**Michael**

Actually no - whilst what you say about being able to use a different strategy is true, if I was them I would certainly want to verify that you are operating at good profits.

---

## 2021-11-26 13:47:40 - general channel

**Javier Martín Pérez**

Not sure about that. But if you think about it, it doesnt really matter because then I can use the strategy the way I want and it doesnt have to be necesarily with the same strategy I used to get those results. So I think there will have to be a test phase anyway where the funds and the stakes are limited and then you will have to proof that the strategy works.

---

## 2021-11-26 13:02:29 - general channel

**Javier Martín Pérez**

Sorry to be a dischordant note here but I believe in this project. As an example I am 50% manual gambler and 50% automatic trader in football and I am collaborating with another company that allows me to place my manual bets with them too and is working pretty well so far. I am still risking the same stakes of my own money but if it goes well I get the gains from this fund. About Mike and randickgroup I was speaking to him yesterday and it sounds legit, and the way it will work it looks unlikely to be a scam. I can explain why I think it can work for most people who have an edge. It doesn´t matter what your edge is, there is always ways to squeeze it harder by increasing risk. So for example, if I have a strategy where I bet 20.000 bets per year with a ROI of 0.5%, why not try to bet 20.000 more with a ROI of 0.2%? In my case I prefer to separate the riskier projects, so I use different accounts, platforms, etc, and I think a company like this will help me increase the profit without increasing the risk. 25% sounds fair to start, in my opinion. Think that many traders will cause them losses, but I think that if you are a successful one you will probably be able to negotiate different conditions with time. Also the fact that is a company where you can invest makes it interesting, but that is because I like the stock exchange and there are not many similar products in the market.

---

## 2021-11-26 11:43:21 - issues channel

**liam**

I assume this in your strategy somewhere, can you remove it or refactor?

---

## 2021-11-26 00:53:48 - issues channel

**Tom**

Recently tried deploying a flumine strategy (which works well locally) to an AWS machine and was experiencing some of the same latency warnings I've seen posted above: `"... High latency between current time and MarketBook publish time", "market_id": "...", "latency": 53.55.."` which sort of continually escalates to the point the strategy was acting on market book updates from 30 seconds prior. CPU utilization was pretty high (40-50%) on a EC2 t3a.medium but not enough to cause this huge bottleneck I thought but i tried it on a EC2 t3a.2xlarge and experienced the same behaviour.



Took the advice to profile the code using cProfile and the biggest difference was the `process_orders` calls [ `baseflumine.py:220(_process_current_orders)` and `process.py:33(process_current_orders)` ] were completing in approx 10ms per call locally but 350ms on the AWS machine. Any ideas why this might be happening? Or anything i can do to clean out + speed up `process_orders` generally? Strategy is pretty order heavy so the partial fills and price updates etc start adding up to a big order list for each market but flumine seems to barely feel it locally.

---

## 2021-11-25 20:14:16 - general channel

**birchy**

I think it's a great idea. I can easily create a strategy that loses £100 a day, so given the 25/75 split, -£100*0.25= -£25, so I'd be £75 a day better off. In fact I could easily scale that to £1000 a day. Eureka!

---

## 2021-11-25 19:10:35 - general channel

**D C**

Heavily implied but not seen it explicitly stated that Betfair is the sole place to get matched though. I agree with pretty much every sceptical comment here but if using bookies instead of Betfair it would alleviate the concerns about PC and getting matched  (assuming that have accounts with bookies who will take large amounts of action). That said, I cannot imagine why anyone making money with a profitable method would want to give that up just to use larger stakes and paying tax on their income but I suppose it really does depend on the nature of the sport and markets in question. [@UGV299K6H](@UGV299K6H) spot on with the website though - Millionnaire factory is just going to attract people with a spectulative profit making system/model that lack the resources of the bottle to go for broke on their own two feet.

---

## 2021-11-25 18:48:32 - general channel

**birchy**

I would agree with everything the others have said and add that the kind of people you want to attract and the people you will attract are very different beasts. Sports betting is a game where finding edges is fairly easy but _getting matched_ for sizable sums is near impossible, particularly if you're looking to play with 4 (or even 5) figure sums. There's just not enough liquidity or "dumb" money available for big volumes.

And those that _do_ get matched have already built up a bankroll larger than they can utilise. Small players who have an edge will quickly scale up due to the quicker returns...and then they're in the same boat as the big players. So that only leaves the wannabes who haven't quite made it yet, and they're not really the kind of people you're looking for?

---

## 2021-11-25 14:55:25 - general channel

**James T**

Anyway, it’s not for us to judge your business model. I wish you the best of luck and cross my fingers you don’t lose all the investors’ money. In the end it’s all a zero sum game (once you remove the entertainment factor), so it’s no good thing and it’s no bad thing. 

---

## 2021-11-25 14:53:34 - general channel

**Aaron Smith**

I do accept that, but those ppl also wont be successful sports bettors. When you have a successful strategy, you need like 2k capital to get it rolling, as the money comes bakc quickly anyway. Its not like the stockmarket where you are having a 0.001% advantage and throw in 10 million to make it worthwhile

---

## 2021-11-25 14:48:45 - general channel

**James T**

I can see that, excluding the capital, some aspiring traders will be interested in the mentoring side of things that you say you offer, but it’s hard to know what expertise your team has in the sports betting front. 



But even for that, the cost seems a bit high when it’s not that hard to find accomplished people willing to help and mentor for free. 

---

## 2021-11-25 14:47:45 - general channel

**Aaron Smith**

The problem compared to a usual hedge fund will be that in usual trading you are dealing with tiny advantages that need a huge scale to have a significant impact, while in sports betting sizes are lower, money comes back to you quickly (after the event ends) and advantages are usually bigger. I dont think anyone would ever consider giving up 75% of their profits (unless those "profits" are losses)

---

## 2021-11-25 12:05:23 - general channel

**Mike Walpole**

You are right, it's ideal for people with track record who want to take their career to the next level. 



I don't think I'd agree with the second paragraph. I've been trading systematic strategies in equities space and I can tell you that psychology played a significant role - from the types of strategies I was designing, to the questions when is it right to switch off your strategy after a losing streak, etc. 



I actually prefer systematic strategies. After all that's why I posted it on this channel. 

---

## 2021-11-25 11:15:59 - general channel

**Mike Walpole**

Good question James, and one we get asked quite regularly. 

I would say that the main benefit we offer is a chance to accelerate your career as a sports trader with investor capital, similar to the way that many traders have done with equities and bonds. If you love what you're doing and think you can build a truly professional trading book, we support you through the process with everything from capital, to trade support, to understanding your actual risk position. 



We hire top tier individuals and help them become world class traders. For example, you will benefit from:



• sessions with sports/performance psychologist to help you unlock your trading potential

• speakers from best equities, FX, commodities trading outfits (Goldman Sachs, Morgan Stanley, Optiver)

• regular debrief on how you're tracking against expectations and what to “do more of”, “stop” and “try”. You will know how you are performing and won’t have to second guess yourself or waste time guessing.

 

We have intentions to list on the stock exchange within 36 months and you have a chance to join us on the ground level of what we are confident will be a truly global trading operation.

---

## 2021-11-25 10:44:04 - general channel

**mon mon**

I got it working -  the solution seems quite simple (once you find it):



Lines in def `run_backtest()` were:

```    framework.add_strategy(strategy)

    with patch("builtins.open", smart_open.open):

        framework.run()```

....but works with:

```    with patch("builtins.open", smart_open.open):

	    framework.add_strategy(strategy)

        framework.run()```

---

## 2021-11-25 06:40:09 - general channel

**Mike Walpole**

Hi guys &amp; gals, not sure if this is the right channel for that. 



I'm running Randwick Group, a sports &amp; racing trading company in Sydney. Founders come from hedge fund and prop FX trading background. We treat sports trading as just another asset class &amp; run the business just like any other high quality hedge fund. 

We currently have 4 traders across racing, basketball and esports. 

We’ve raised additional capital from our investors and are now looking to hire more traders (ideally trading soccer, cricket, UK racing and NFL) to allocate capital to. 



We don't need you to work on this full time, and we're happy for you to trade on personal account as well. We offer market leading profit share of your trading. We respect your IP and don't require you to share your secret sauce. We provide you with a funded account and you trade any way you like (within risk parameters!) 



What we need is a verifiable track record (ideally on BetFair) of deploying money - so no backrests please. DM for a job description or if you have any questions. 

[http://www.RandwickGroup.com|www.RandwickGroup.com](http://www.RandwickGroup.com|www.RandwickGroup.com)

---

## 2021-11-24 13:38:32 - general channel

**Peter C**

Are you running from .zip files? If so I think that this edit to the above file might solve the problem:

```with patch("builtins.open", smart_open.open):

    framework.add_strategy(strategy)

    framework.run()```

---

## 2021-11-24 10:39:10 - random channel

**Jonjonjon**

[@UEA14GBRR](@UEA14GBRR) do you have a similar chart for US racing? My strategy died for that too. For some reason it might have been OK for higher prices runners. I'm a bit confused why short prices should have thrown it off so badly.

---

## 2021-11-23 17:37:09 - general channel

**James T**

Yeah, that’s all I can think of really. 



Sometimes I wonder whether if I don’t place the opening bets whether the bet at SP will still be profitable. But I don’t know how to do that since I’m staking my SP bet based on my open position. I guess I could simulate opening a position. Or else just develop a strategy around a reversed signal at the off. But given both legs are profitable I’ve just left it as it is. And obviously it’s very consistent betting both legs. It just doesn’t scale well so overall profits are tiny. 

---

## 2021-11-23 17:20:43 - general channel

**James T**

Yeah, exactly Michael. I don’t think it can just be me moving the market, but perhaps a ripple effect. I tend to offer in order to get more value, and often undercut the market early in the day to be at the front of the queue, however backtests can’t know if someone would subsequently decide to undercut me or not.



Like you say, it’s likely me and other people using similar factors in our models. I haven’t looked at this particular strategy in a while to be honest, so intend to revisit it. Really I just need to improve the model rather than execution I think. 



Also might look at taking prices only which I suspect is what most bigger fundamental players will do. But again, for that to work I need to be nearer the off with tighter spreads. 

---

## 2021-11-23 17:02:10 - general channel

**Michael**

[@USYQKE5HN](@USYQKE5HN) re your curious result, I find it unlikely that this could be accounted for by your individual effect on the market, to my mind it's more plausible that you're part of a larger phenomenon. For instance it could be that other participants are overweighting the same variables that you are using in your model.



Alternatively it could be that early momentum which you are part of tends to get over weighted by later participants.



Other people will undoubtedly be identifying the same early value opportunities that you are and probably the same signals. I'd expect it to be something to do with that, although that doesn't account for the result not showing up in a back test.



I suppose another explanation would be that your participation increases competition for the value bet, forcing other participants with inferior models to take a worse price and thereby overbetting the selection. That would account for the back test result.



I'm sure you've had these type of thoughts already - what do you think?

---

## 2021-11-22 21:37:34 - issues channel

**AP**

What would be the required changes to that strategy to allow it to use multi processing?

---

## 2021-11-22 21:29:42 - issues channel

**liam**

That strategy isn’t coded for multi processing 

---

## 2021-11-22 21:29:05 - issues channel

**AP**

```import smart_open

import os

import time

import logging

from unittest.mock import patch

from concurrent import futures

from pythonjsonlogger import jsonlogger

from flumine import FlumineBacktest, clients



from inplay_bot.backtest.strategies.data_collection import DataCollectWOM

from inplay_bot.backtest import MARKET_IDS



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))





def run_backtest(market):

    client = clients.BacktestClient()

    client.min_bet_validation = False

    framework = FlumineBacktest(client=client)



    strategy = DataCollectWOM(

            market_filter={

                "markets": [market],

                "listener_kwargs": {

                    "seconds_to_start": 600,

                    "calculate_market_tv": True,

                    "cumulative_runner_tv": True,

                },

            },

            context={

                "update_seconds": 5,

            }

    )



    framework.add_strategy(strategy)



    with patch("builtins.open", smart_open.open):

        framework.run()





if __name__ == "__main__":

    path = "/home/antonypapadimitriou/betfair"

    markets = []

    win_market_ids = MARKET_IDS



    for root, dirs, files in os.walk(path):

        for file in files:

            if file.split(".bz2")[0] in win_market_ids:

                markets.append(os.path.join(root, file))



    with futures.ProcessPoolExecutor(max_workers=48) as pool:

        all_futures = [

            pool.submit(

                run_backtest,

                market=market

            )

            for market in markets

        ]



    for i, future in enumerate(futures.as_completed(all_futures)):

        try:

            print('Future %i of %i completed' % (i + 1, len(all_futures)))

        except:

            print('Error %i of %i' % (i + 1, len(all_futures)))```

---

## 2021-11-22 21:28:27 - issues channel

**AP**

Here are some logs, there are no errors:

```{"asctime": "2021-11-22 21:27:56,178", "levelname": "INFO", "message": "Adding market middleware &lt;flumine.markets.middleware.SimulatedMiddleware object at 0x7f81a8794640&gt;"}

{"asctime": "2021-11-22 21:27:56,178", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2021-11-22 21:27:56,178", "levelname": "INFO", "message": "Adding market middleware &lt;flumine.markets.middleware.SimulatedMiddleware object at 0x7f81a8794730&gt;"}

{"asctime": "2021-11-22 21:27:56,178", "levelname": "INFO", "message": "Adding market middleware &lt;flumine.markets.middleware.SimulatedMiddleware object at 0x7f81a8794820&gt;"}

{"asctime": "2021-11-22 21:27:56,178", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2021-11-22 21:27:56,178", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2021-11-22 21:27:56,178", "levelname": "INFO", "message": "Adding client control MAX_TRANSACTION_COUNT"}

{"asctime": "2021-11-22 21:27:56,179", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2021-11-22 21:27:56,179", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2021-11-22 21:27:56,179", "levelname": "INFO", "message": "Adding strategy DataCollectWOM"}

{"asctime": "2021-11-22 21:27:56,179", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2021-11-22 21:27:56,179", "levelname": "INFO", "message": "Adding trading control MARKET_VALIDATION"}

{"asctime": "2021-11-22 21:27:56,179", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2021-11-22 21:27:56,179", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}```

---

## 2021-11-22 21:26:58 - issues channel

**AP**

That's the strategy

---

## 2021-11-22 21:26:48 - issues channel

**AP**

```import csv

import logging

import os

from flumine.strategy.strategy import BaseStrategy

from flumine.utils import get_sp, get_price

from inplay_bot.util import calculate_vwap_runner_book



logger = logging.getLogger(__name__)



FIELDNAMES = [

    "publish_time",

    "market_id",

    "market_venue",

    "market_name",

    "market_seconds_to_start",

    "market_total_matched",

    "active_runners",

    "selection_id",

    "selection_back",

    "selection_lay",

    "selection_wom_one",

    "selection_wom_two",

    "selection_wom_three",

    "selection_vwap",

    "selection_ltp",

    "selection_total_matched",

    "selection_status",

    "selection_actual_sp",

]





class DataCollectWOM(BaseStrategy):

    """

    Collect market/runner data every

    x update_seconds.

    """



    def __init__(self, *args, **kwargs):

        BaseStrategy.__init__(self, *args, **kwargs)

        self.local_dir = "/home/antonypapadimitriou/betfair_data_collection"



    def add(self) -&gt; None:

        self.context["_data"] = []

        self.context["pt"] = 0

        # check local dir

        if not os.path.isdir(self.local_dir):

            raise OSError("File dir %s does not exist" % self.local_dir)



    def check_market_book(self, market, market_book) -&gt; bool:

        if market_book.status != "OPEN":

            return False

        if market_book.inplay:

            return False

        if "data" not in market.context:

            market.context["data"] = {}

        # check update seconds

        update_seconds = self.context["update_seconds"]

        pt = self.context["pt"]

        if market_book.publish_time_epoch - pt &gt; (update_seconds * 1000):

            self.context["pt"] = market_book.publish_time_epoch

            return True

        return False



    def process_market_book(self, market, market_book) -&gt; None:

        for runner in market_book.runners:

            if runner.status == "ACTIVE":

                # get prices

                back, lay = self._get_back_lay(runner)

                # calculate WOM

                wom_one = self._calculate_wom(runner, 1)

                wom_two = self._calculate_wom(runner, 2)

                wom_three = self._calculate_wom(runner, 3)

                # calculate VWAP

                vwap = calculate_vwap_runner_book(runner.ex.traded_volume)

                # store data in context

                data = {

                    "publish_time": market_book.publish_time,

                    # market

                    "market_id": market.market_id,

                    "market_venue": market_book.market_definition.venue,

                    "market_name": market_book.market_definition.name,

                    "market_seconds_to_start": market.seconds_to_start,

                    "market_total_matched": market_book.total_matched,

                    "active_runners": market_book.market_definition.number_of_active_runners,

                    # selection

                    "selection_id": runner.selection_id,

                    # current state

                    "selection_back": back,

                    "selection_lay": lay,

                    "selection_wom_one": wom_one,

                    "selection_wom_two": wom_two,

                    "selection_wom_three": wom_three,

                    "selection_vwap": vwap,

                    "selection_ltp": runner.last_price_traded,

                    "selection_total_matched": runner.total_matched,

                    # after

                    "selection_status": None,

                    "selection_actual_sp": None,

                }

                self.context["_data"].append(data)



    def process_closed_market(self, market, market_book):

        # get runner status (status and BSP)

        status = {}

        for runner in market_book.runners:

            status[runner.selection_id] = (runner.status, get_sp(runner))

        # write data to csv

        filename = os.path.join(self.local_dir, f"{market_book.market_id.split('.')[-1]}.csv")

        is_new = not os.path.exists(filename)

        with open(filename, "a", newline="") as f:

            writer = csv.DictWriter(f, delimiter=",", fieldnames=FIELDNAMES)

            if is_new:

                writer.writeheader()

            for d in self.context["_data"]:

                _status = status.get(d["selection_id"])

                d["selection_status"], d["selection_actual_sp"] = _status

                writer.writerow(d)

        self.context["_data"].clear()



    @staticmethod

    def _get_back_lay(runner_book, level: int = 0) -&gt; tuple:

        if runner_book is None:

            return None, None

        back = get_price(runner_book.ex.available_to_back, level)

        lay = get_price(runner_book.ex.available_to_lay, level)

        return back, lay



    @staticmethod

    def _calculate_wom(runner_book, depth: int) -&gt; float:

        total_atb, total_atl = 0, 0

        for i in range(0, depth):

            # back

            p = runner_book.ex.available_to_back[i]

            total_atb += p["size"]

            # lay

            p = runner_book.ex.available_to_lay[i]

            total_atl += p["size"]

        if total_atb + total_atl &gt; 0:

            return round(total_atb / (total_atb + total_atl), 4)

        else:

            return 0```

---

## 2021-11-22 21:26:29 - issues channel

**AP**

Hi all, I am trying to run [@U4H19D1D2](@U4H19D1D2)'s data collection example from a little while back. But I'm getting some issues where the code is setting up the client and adding the strategy but not actually running the data collection.

---

## 2021-11-22 21:07:14 - general channel

**Amit Patel**

hey guys! I'm running back tests with a simple strategy for horse WIN markets and it takes around 25 mins for a weeks worth of data. Is this expected and is there anything I can do to improve performance other than buying a better pc? :slightly_smiling_face:

---

## 2021-11-21 20:53:14 - random channel

**bb**

Yeah no changes my end to the code, matching rates have dropped a fair amount but all modelling metrics have stayed within expected bounds 

---

## 2021-11-21 20:17:22 - random channel

**Unknown**

Has anything changed with GB Greyhounds in the last few days? A formerly consisten strategy has fallen off a cliff.

---

## 2021-11-20 12:35:43 - general channel

**Mo**

Decent book for beginners though: [https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew-ebook](https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew-ebook)

---

## 2021-11-20 12:35:07 - general channel

**Mo**

If your focus is models for sports then much better to read academic papers on models for sports IMO

---

## 2021-11-20 12:34:21 - general channel

**S G**

I am new to modelling and strategies and was wondering if anyone can suggest a good book to kick start creating a working sport model.Any thoughts on the below book? More focussed on stocks etc but i guess priciples can be applied to sports. 

[https://www.amazon.co.uk/Machine-Learning-Algorithmic-Trading-alternative/dp/1839217715/ref=asc_df_1839217715/?tag=googshopuk-21&amp;linkCode=df0&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832&amp;psc=1&amp;th=1&amp;psc=1&amp;tag=&amp;ref=&amp;adgrpid=101598704058&amp;hvpone=&amp;hvptwo=&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832|https://www.amazon.co.uk/Machine-Learning-Algorithmic-Trading-alternative/dp/1839217715/ref=asc_df_1839217715/?tag=googshopuk-21&amp;linkCode=df0&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832&amp;psc=1&amp;th=1&amp;psc=1&amp;tag=&amp;ref=&amp;adgrpid=101598704058&amp;hvpone=&amp;hvptwo=&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832](https://www.amazon.co.uk/Machine-Learning-Algorithmic-Trading-alternative/dp/1839217715/ref=asc_df_1839217715/?tag=googshopuk-21&amp;linkCode=df0&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832&amp;psc=1&amp;th=1&amp;psc=1&amp;tag=&amp;ref=&amp;adgrpid=101598704058&amp;hvpone=&amp;hvptwo=&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832|https://www.amazon.co.uk/Machine-Learning-Algorithmic-Trading-alternative/dp/1839217715/ref=asc_df_1839217715/?tag=googshopuk-21&amp;linkCode=df0&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832&amp;psc=1&amp;th=1&amp;psc=1&amp;tag=&amp;ref=&amp;adgrpid=101598704058&amp;hvpone=&amp;hvptwo=&amp;hvadid=430825732529&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15520940606181387990&amp;hvqmt=&amp;hvdev=m&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=9045936&amp;hvtargid=pla-1123856727832)

---

## 2021-11-20 09:42:24 - general channel

**James T**

Conclusion: I basically have to improve my model. 

---

## 2021-11-20 09:39:52 - general channel

**James T**

I think it comes back to what you were talking about yesterday. I think anything fundamental tends to find higher value early, but no liquidity. But then low edge later when there is liquidity. My model isn’t good enough near the off yet. 

---

## 2021-11-20 09:34:50 - general channel

**James T**

In this particular strategy, yes. 

---

## 2021-11-20 09:34:01 - general channel

**Oliver Varney**

[@U01U24AG35W](@U01U24AG35W) People may have strategies to copy large orders as thats seen as a signal maybe. If too many people copy this strategy, it will lead to overbacking and create a +EV exit trade

---

## 2021-11-20 07:55:12 - general channel

**birchy**

IMO, if your model places bets on both sides of the market that are _independently_ +EV, then "unintended" greening is fine as it reduces exposure and frees up money for further bets. Actively looking for exit positions without assessing the EV of the bet is leaking value.

---

## 2021-11-20 07:20:47 - general channel

**liam**

I think the big problem is this idea of ‘trading’ and ‘greening’ is the way you make money whilst ignoring value, you cannot make money without getting value 

---

## 2021-11-20 07:06:17 - general channel

**Oliver Varney**

I do wonder though (havent looked at the maths) on a back to lay strategy with a very high strike rate (80%+)and a super aggressive bankroll on long odd horses (20+), where you can use your money multiple times a day(s) , whether you can make a case for hedging. Market capacity problem would put this dead in the water once the size of your bank has increased

---

## 2021-11-20 07:02:49 - general channel

**ThomasJ**

Very sad to report that I don't have a strategy that comes close to breakeven and that's without commission reduction. But working on it...

---

## 2021-11-20 06:59:37 - general channel

**Oliver Varney**

If you already have a back to lay strategy with historical bet results available, sum up the profit on the exit hedge lay bets only, its likely your losing money on them

---

## 2021-11-20 06:57:21 - general channel

**Oliver Varney**

Just think about your "exit" trade (second bet), its either -EV,0EV or +EV. If you completely forget about the initial entry, would you take on the second trade if its -EV (nope). If its +EV, then if you forget the initial trade again, you just have a strategy that is taking +EV bets (similar to the one you are entering with which should be determined by your predicted price). I guess the argument in an ideal world is that its 0EV and your reducing volatility, but this is unlikely as your probably having to jump the spread to offload.

---

## 2021-11-19 15:59:43 - general channel

**Unknown**

Hey guys, running through the examples @ [https://github.com/betfair-datascientists/API/blob/master/python/API%20Tutorial.ipynb](https://github.com/betfair-datascientists/API/blob/master/python/API%20Tutorial.ipynb) -- looking at tomorrow's horse racing I'm unable to get Total Matched to appear for any individual runner - i've checked the specific race and money is matched on most runners.

market_book.runners[0].total_matched



1. trading.betting.list_runner_book(

2.     market_id='1.190955523',

3.     selection_id=41749336,

4.     price_projection=price_filter_traded

5. )

tried both EX_TRADED and EX_BEST_OFFERS price data projection filters

---

## 2021-11-19 10:28:35 - random channel

**D C**

The content is OK but his conclusions are off. Basically if you are profitable its just survivorship bias seems to be his opinion. I found a few useful things in one of his books when I needed to acquaint myself with some elements of the bookie industry though. I have this new one on my amazon wishlist but this is mainly just because there are so few books about gambling and sports modelling in general so I will give most things a try.

---

## 2021-11-17 11:22:53 - random channel

**Peter C**

I had a look, found the site easy enough to use and navigate, and thought you had the basis of quite a professional presentation. However I found the disparity between the rating given to a horse and the odds you display confusing. What does the rating actually mean, and where are you getting the odds, or are these your calculated odds? The other immediate question I had is if the ratings are so good why aren't you using them for your own betting? I'm sure I'm not your target audience; I don't frequent horse rating websites (in fact yours is the first I've ever visited) so perhaps the questions/feelings I have won't be universal, and I just don't understand the jist of these websites. Thanks for sharing though - you're braver than me putting yourself out there like that.

---

## 2021-11-16 08:05:42 - general channel

**liam**

A tutorial start to finish is certainly on my todo list however there would be the assumption of having an intermediate knowledge of python when it comes to classes/inheritance/design patterns etc.



But because its a framework once you have things figured it can be a few lines of code to setup a variation of your strategy or quickly backtest/paper trade something new. When time is at a premium this can be extremely valuable for anyone starting out.

---

## 2021-11-16 06:58:24 - general channel

**Paul**

I've worked with many less experienced developers who think they need to understand everything in a tool or framework to make progress. Very common if they have a maths/physics background. That's not how this works: you need to know just enough to get the next step done, and only that. If that's you, just trust what was said above and trust it: take an example strategy and go from there.

---

## 2021-11-16 06:55:48 - general channel

**Paul**

Can I ask [@U013ZS16QJZ](@U013ZS16QJZ) - if you have something that works with bflw, what your objective in moving to flumine is? Is that you want to make use of paper trading, historical data stuff, etc.? If so, make that your end goal, don't worry about all the functionality and having a complete picture and just chip away towards your goal

---

## 2021-11-16 06:09:24 - general channel

**Mo**

Good advice [@U01U24AG35W](@U01U24AG35W). [@U013ZS16QJZ](@U013ZS16QJZ) here is a full strategy right here: [https://github.com/liampauling/flumine/blob/master/examples/strategies/lowestlayer.py](https://github.com/liampauling/flumine/blob/master/examples/strategies/lowestlayer.py)

---

## 2021-11-16 03:42:31 - general channel

**VT**

Hi everyone, I've noticed that most people are using Flumine, and apparently it's a more advanced tool. I'm a beginning programmer, I understand Python for working with data science, statistically analyzing data and things like that. I have a betting system using the platform before betfairlightweig and everything works fine, it's a simple system that I was able to develop just using the documentation.



Anyway, I'm trying to learn Flumine but it's challenging for me, I haven't found any real and complete tutorial or practical example. The content of the documentation is quite confusing for a beginning programmer, without practical and simple examples, at least for me.



I would like to know where to start, what I need to study for how to understand the system because I don't even know where to start.



Someone has a basic code, like for example checking the odds prices for the over 2.5 goals of Liverpool's next EPL game and placing a bet.



Thanks

---

## 2021-11-15 12:53:55 - random channel

**liam**

Yeah I can’t see a manual edge here, it very much suits automation / modelling 

---

## 2021-11-13 16:34:26 - general channel

**liam**

`strategy.streaming_timeout`

---

## 2021-11-12 20:18:55 - general channel

**mandelbot**

But your worker would block your strategy if both operating on one core?

---

## 2021-11-12 11:54:48 - general channel

**liam**

Is this once per market? I would just chuck something in



```strategy.start```

in addition to the worker, this is [https://github.com/liampauling/flumine/blob/6216bcc233326cf07852fca9c7d39a18cee265ad/flumine/strategy/strategy.py#L102|called](https://github.com/liampauling/flumine/blob/6216bcc233326cf07852fca9c7d39a18cee265ad/flumine/strategy/strategy.py#L102|called) before the streams start

---

## 2021-11-12 11:29:25 - general channel

**Peter C**

Thanks, I think this is the route I'm going to go. Step away from direct strategy development and focus on improving my coding/code

---

## 2021-11-12 10:14:56 - general channel

**river_shah**

When in doubt, improve the code. A stream of dopamine hits achieved from writing prettier code can be essential to keep morale up during tough times. Improving code also usually reveals sub-optimal components in the strategy / thought process behind the models.

---

## 2021-11-11 16:42:13 - general channel

**Mo**

Read something off this list:



[https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723|https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723](https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723|https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723)

[https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175|https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175](https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175|https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175)

[https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458|https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458](https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458|https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458)

[https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522|https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522](https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522|https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522)

[https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X|https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X](https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X|https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X)

[https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139|https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139](https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139|https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139)

[https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975|https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975](https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975|https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975)

---

## 2021-11-11 10:20:51 - issues channel

**captainonionhead**

Yes, I thought the keepalive thread should stop this...  My client init looks like:

```  trading = betfairlightweight.APIClient(

    creds["username"],

    creds["password"],

    creds["app_key"],

    creds["certs"]

  )



  client = clients.BetfairClient(

    trading,

    order_stream=False,

    market_recording_mode=True

  )



  framework = Flumine(client=client)```



---

## 2021-11-11 10:18:12 - issues channel

**captainonionhead**

Sorry, do you mean how am I adding the recorder strategy to the framework?

---

## 2021-11-11 09:38:16 - general channel

**ThomasJ**

That's an amazing offer Liam and I thank you for it (no... I'm blown away actually)

The weight mainly consists of me storing price history, avail history,  and such and then doing calculation on them every .X of a second.



I set strategy.context to various values to control what I need and I can see exactly what hurts.



I store the accumulated stuff in market.context  whose code is called from  cache.py &gt; _def_ update_cache



I have zero secret sauce unfortunately, but many many lines of code, and countless hours. Ah the common cry of the beginner. :rolling_on_the_floor_laughing: :rolling_on_the_floor_laughing: :rolling_on_the_floor_laughing:

---

## 2021-11-11 03:14:33 - general channel

**ThomasJ**

In Flumine back testing when I want to 'get' a runner directly without iterating over all runners I use the following long winded technique to access the marketbook cache and not the marketbook as I do not see a way to do that in the marketbook. I wonder if I am missing something simple.



So to get say the best available to back price what I do is...

Get the stream's index

`stream_idx = mystrategy.stream_ids.index(market_book.streaming_unique_id)`

and then...

`mystrategy.streams[stream_idx]._listener.stream._caches[market_book.market_id].runner_dict[(selection_id, 0)].available_to_back.serialised[0]["price"]`



It just don't feel right!

---

## 2021-11-10 09:48:20 - general channel

**Newbie99**

This will return 100 markets (just change the max results, but it will cut off around the 200 mark):



```import betfairlightweight as bf



''' Enter parameters here '''

accname = 'account_name'

accpass = 'account_password'

acckey = 'account_key'

path = 'certificate_path'

event_type_ids = ['1']



trading = bf.APIClient(accname, accpass, acckey, certs=path)

trading.login()

filters = bf.filters





market_catalogues = trading.betting.list_market_catalogue(

                    filter=filters.market_filter(event_type_ids=event_type_ids,

                                                 ),

                    market_projection=[

                        "MARKET_START_TIME",

                    ],  # runner description required

                    sort="FIRST_TO_START",

                    max_results=100,

                )



market_books = trading.betting.list_market_book(

            market_ids=[m.market_id for m in market_catalogues],

            order_projection="ALL",

    lightweight=True

        )



for market_book in market_books:

    if market_book['inplay'] is True:

        print('IN PLAY','\n',market_book)

    else:

        print('NOT IN PLAY','\n',market_book)```

---

## 2021-11-10 00:16:26 - general channel

**Newbie99**

```import betfairlightweight as bf



''' Enter parameters here '''

# market_ids = '1.190544753'

accname = 'account_name'

accpass = 'account_password'

acckey = 'account_key'

path = 'certificate_path'

event_type_ids = ['7']

market_types = ['WIN']

country_codes = ['US']



trading = bf.APIClient(accname, accpass, acckey, certs=path)

trading.login()

filters = bf.filters





market_catalogues = trading.betting.list_market_catalogue(

                    filter=filters.market_filter(event_type_ids=event_type_ids,

                                                 market_type_codes=market_types,

                                                 market_countries=country_codes,

                                                 ),

                    market_projection=[

                        "MARKET_START_TIME",

                    ],  # runner description required

                    sort="FIRST_TO_START",

                    max_results=5,

                )



market_books = trading.betting.list_market_book(

            market_ids=[m.market_id for m in market_catalogues],

            price_projection=filters.price_projection(

                price_data=filters.price_data(ex_all_offers=True, sp_traded=True, sp_available=True)

            ),

            order_projection="ALL",

    lightweight=True

        )



for market_book in market_books:

    if market_book['inplay'] is True:

        print('IN PLAY','\n',market_book)

    else:

        print('NOT IN PLAY','\n',market_book)```

---

## 2021-11-09 20:55:44 - general channel

**Newbie99**

```import betfairlightweight as bf



''' Enter parameters here '''

market_ids = '1.190544753'

accname = 'account_name'

accpass = 'account_password'

acckey = 'account_key'

path = 'certificate_path'



trading = bf.APIClient(accname, accpass, acckey, certs=path)

trading.login()



filters = bf.filters

market_books = trading.betting.list_market_book(

            market_ids=[market_ids],

            price_projection=filters.price_projection(

                price_data=filters.price_data(ex_all_offers=True, sp_traded=True, sp_available=True)

            ),

            order_projection="ALL",

    lightweight=True

        )



for market_book in market_books:

    if market_book['inplay'] is True:

        print(market_book)```

---

## 2021-11-09 18:40:40 - general channel

**Aaron Smith**

this is the full function, once you put it into the right place, you ll probably see clearer. The "check_market_book"-function is a method already existing in the BaseStrategy class from flumine. (I realize here i assumed that you are using flumine, which you didnt specify you do, so apologises for the confusion if you dont :smile: , in any case, if you dont maybe check it out anyway to see how it works there). Basically a strategy subscribes to some markets, whenever flumine gets a market_book event for a market this strategy has subscribed to, it will call the "check_market_book" function of this strategy. If this function returns True, it will then call the "process_market_book" function of this strategy

---

## 2021-11-09 17:35:09 - general channel

**Aaron Smith**

[@U013ZS16QJZ](@U013ZS16QJZ) i dont think there is (only a filter for it it will go in_play at all), a market_book however will tell you. Best practice here i think is to subscribe to the markets you eventually want to bet in and then in check_market_book (which is always checked when receiving a market_book and if it returns True, it will go into process_market_book of your strategy) filter out all market_books that are not inplay.

---

## 2021-11-09 16:58:14 - general channel

**Peter**

Seem to remember a discussion a while back about how many runners had gone to 1000 and then won. The answer (I can't verify if it's true or not) was only 3 since Betfair started. If so, laying at 1000 would surely be +EV. The biggest challenge would be having the stones to run a strategy doing it.

---

## 2021-11-09 07:37:59 - random channel

**Paul**

I'm looking for a derivative of kelly that takes into account multiple existing bets and price movement. All I can find are linear programming solutions, or "wind everything back to all green/red and start again". Anything I should be looking at/reading?

---

## 2021-11-08 09:17:36 - strategies channel

**Adrian**

[@ULDAVFDRP](@ULDAVFDRP) thanks mate i appreciate the feedback. i'm not pessimistic about what it's possible to earn, i'm just frustrated that i can't crack it. i don't know if i'm learning the right things. and as for doing the world any good, how do you know? your trading supports Betfair, which helps hundreds (thousands?) of people put food on their table. And gives joy to people who like to gamble at the best possible prices.

---

## 2021-11-08 07:16:24 - random channel

**river_shah**

anyone ever use [https://numba.pydata.org/|numba](https://numba.pydata.org/|numba) for the kind of model building we would use? I have always had julia envy. seems like numba is a good middle round

---

## 2021-11-08 06:17:08 - strategies channel

**Oliver Varney**

[@U01S1VB9X9P](@U01S1VB9X9P) and [@U01PJ5YMFBJ](@U01PJ5YMFBJ),genuine question here (and not meant in a  negative way) , If you took a step back, do you view it as a positive that its hard to crack, knowing its a zero sum game (ignoring comms)? [@U01PJ5YMFBJ](@U01PJ5YMFBJ) personally I think the model approach has alot more legs to it, so if you get it going then there should be some profit out there for you for sure.

---

## 2021-11-08 02:08:02 - strategies channel

**AndyL**

[@U01S1VB9X9P](@U01S1VB9X9P) yes, wom i couldn't find profitability, in fact like all the tech analysis ive tried...

Which is why im looking at modelling my own prices, and then value betting

---

## 2021-11-07 22:12:35 - strategies channel

**Adrian**

[@U4H19D1D2](@U4H19D1D2) how did you progress from looking at data output like the one from this strategy to being able to see if something is profitable or not?

---

## 2021-11-07 22:10:32 - strategies channel

**Adrian**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) thanks for sharing that. so you abandoned wom altogether? what do you mean by models?

---

## 2021-11-07 22:09:35 - strategies channel

**Adrian**

[@ULDAVFDRP](@ULDAVFDRP) i am doing this part time so it's not that it's overwhelming me. it's just that I've been doing this so long for no reward is pretty shitty. i'm trading crypto and nft's now and seeing instant profit, so it really makes me question the validity of this pursuit

---

## 2021-11-07 21:24:45 - strategies channel

**AndyL**

Now im working on models

---

## 2021-11-06 10:26:16 - general channel

**captainonionhead**

Please excuse the newbie questions, only just getting back to starting on this due to a long hiatus when real life got in the way...  Do people have strong views on whether to leave strategies (including recording) running 24-7, even if only betting on UK/IRE markets, for example.  Or should I use something like the terminate worker and kick everything off again the following morning?

---

## 2021-11-06 08:40:59 - strategies channel

**Oliver Varney**

btw I think my model uses both although im not sure off memory which has a higher weight

---

## 2021-11-05 22:49:15 - strategies channel

**Adrian**

[@U4H19D1D2](@U4H19D1D2)

&gt; {"asctime": "2021-11-05 22:49:00,368", "levelname": "CRITICAL", "message": "Unknown error list index out of range in process_market_book (1.186625686)", "exc_info": "Traceback (most recent call last):\n  File \"/Users/adrian/opt/anaconda3/envs/betfair/lib/python3.8/site-packages/flumine/utils.py\", line 204, in call_strategy_error_handling\n    return func(market, market_book)\n  File \"/Users/adrian/Projects/betfair/code/dataanalysis/flumine-strategy-development-master/strategies/datacollectwom.py\", line 60, in process_market_book\n    wom_one = _calculate_wom(runner, 1)\n  File \"/Users/adrian/Projects/betfair/code/dataanalysis/flumine-strategy-development-master/strategies/datacollectwom.py\", line 115, in _calculate_wom\n    p = runner_book.ex.available_to_lay[i]\nIndexError: list index out of range"}

---

## 2021-11-05 12:17:34 - strategies channel

**liam**

[@U01S1VB9X9P](@U01S1VB9X9P) here is the first part in using flumine to collect some raw data



[https://github.com/liampauling/flumine-strategy-development](https://github.com/liampauling/flumine-strategy-development)

---

## 2021-11-05 12:02:42 - general channel

**Aaron Smith**

was this not changed to config.customer_strategy_ref?

---

## 2021-11-05 09:58:55 - strategies channel

**liam**

Have you tried to analyse the strategy described by Dallas? For example:



• Get some pre race data

• Push through bflw and record WOM% / price / odds / … / result into a csv

• Pull into pandas see if there is any relationship between WOM/price/result and thus value 

• The above can be done with graphs/regression/ml etc.

My assumption would be that the above is a half day job and would probably lead you down another route. Also note that we are ignoring matching etc but it would give you a good idea if the idea has any value.

---

## 2021-11-05 09:55:19 - strategies channel

**Mo**

Doesn’t this strategy involve leaving up orders?

---

## 2021-11-05 09:30:04 - strategies channel

**Adrian**

even better i'll give you the exact strategy i've been working on [https://forum.betangel.com/viewtopic.php?f=53&amp;t=16731&amp;sid=6a9993465c324059eb7363d075c5887a](https://forum.betangel.com/viewtopic.php?f=53&amp;t=16731&amp;sid=6a9993465c324059eb7363d075c5887a)

---

## 2021-11-05 03:59:14 - general channel

**Steve**

If I want to run concurrent entirely independent instances of flumine on the same machine but don't want one to be picking up the orders from the other what do I need to change? Is it the betfairlightweight config hostname? Or the strategy name? Or something else?

---

## 2021-11-04 17:13:38 - general channel

**C0rnyFlak3s**

So according to [@U01NJ85MP7F](@U01NJ85MP7F) there may be issues if I only fetch streaming data without trading in the markets for a longer period of time? What will happen in the case I stream data for multiple days to create my own historical data? Is this unwanted behavior by the betting exchange, and what will happen if I do so? Answers are greatly appreciated before I finally start my data stream :slightly_smiling_face:

---

## 2021-11-04 10:46:13 - general channel

**captainonionhead**

Morning, if I have a simple strategy to allow recording of data (as recommended multiple times here), do I need to bet in all the market types that I've subscribed to in order to avoid upsetting betfair?  E.g. if I've subscribed to both "win" and "place" horse racing markets for recording do I need to bet in both of those, or is it OK to just bet in one of them (e.g. win).

Also, from watching markets, I think my initial strategy will only bet in about 10% of the markets (or only 5% of those subscribed if it is OK to subscribe to two markets per event).  I'm guessing this will be just a handful of bets per day - is this too few or should I be OK?

Thanks!

---

## 2021-11-03 07:53:23 - general channel

**Alex Morton**

`mcf = betfairlightweight.filters.market_filter(`

    `market_betting_types=["ODDS"],` 

    `race_types= ["Flat"],`

    `market_countries=['AU'],`

    `event_type_ids=['7'],`

    `market_type_codes=["WIN"],`

    `market_start_time={`

            `'to': (datetime.datetime.utcnow() + datetime.timedelta(days=0.25)).strftime("%Y-%m-%dT%TZ")`

        `}`

    `)`



`market_catalogues = trading.betting.list_market_catalogue(`

    `filter=mcf,`

    `max_results="40",`

    `sort = "FIRST_TO_START")`

---

## 2021-11-01 13:59:03 - random channel

**Oliver Varney**

I just think its way to complex to model and get anything trustworthy out of. As I suggested in the second message, using the odds relative to a benchmark / entry point probably the route to go.

---

## 2021-11-01 13:36:48 - random channel

**Michael**

Are you looking to use this in some kind of fundamentals pre-off model?

---

## 2021-11-01 10:22:16 - betfair-news channel

**Neil T (Betfair)**

Hi [@U01U24AG35W](@U01U24AG35W) - See the answer from our API dev team -  "_This would be an artefact of settlement kicking off that moves the bets away from trading db into the longer-term store. Any price change notifications triggered during this process will result in attempts to reconstruct the market view based on no bets being available and would result in this kind of notification being sent. There is no straightforward way to suppress this end of market clear-out messages, so not sure yet how to signal this to customers. It can be classified as a bug, but it’s a behaviour that has existed for some time. We'll have  a think about if there is a definitive way to stop this or at least signal it appropriately to customers"_

---

## 2021-11-01 07:18:03 - strategies channel

**Štefan**

[@U011VL3CA2Y](@U011VL3CA2Y) my app has such bot strategy I called it [http://bfexplorer.net/Articles/Search?text=Be%20the%20first%20in%20queue|Be the first in queue](http://bfexplorer.net/Articles/Search?text=Be%20the%20first%20in%20queue|Be the first in queue) you can test it or just reverse engineer it, or if you develop your strategy on .net you can directly use it

---

## 2021-10-28 17:03:20 - strategies channel

**JazzMan**

So if your strategy is not unique would you be able to run it on 10 different machines and make 10 times the profit?

---

## 2021-10-28 16:21:36 - strategies channel

**Aaron Smith**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) regarding your strategy that lost money on live: just as a strategy can be lucky during a backtest and indicate that its good even though its not, it may just be unlucky when live and be good even though its current results arent. It may be worth to keep that strategy in mind and once you got another good batch of data, throw another backtest at it. If it performs well again in that backtest you may give it another shot at live, or in case you want to be more cautious, ask yourself where and why it could perform better during the backtest than live.

---

## 2021-10-28 15:40:11 - strategies channel

**Aaron Smith**

I dont agree here. The goal of backtesting is to replicate as good as possible what would have happened if you had the strategy running live. There is no need for it to be very unique. I m rather sure goats problem was (and the problem he is warning of) that he just threw so many strategies into the backtest machinery until he got a positive results by chance. Even if you were to throw the same strategy in the backtest machinery and always give it a different patch to backtest on, assuming its not horribly bad, it will eventually show you good results, even though its not a good strategy.

---

## 2021-10-28 14:22:13 - general channel

**liam**

Maybe we should add some code to handle multiple filters, if you create an issue we could add it, e.g:



```framework.add_strategy(

    strategy=StrategyOne(

        market_filter=[

            streaming_market_filter(

                event_type_ids=["1"],

                market_types=["MATCH_ODDS"],

                country_codes=["GB", "DE"],

            ),

            streaming_market_filter(

                event_type_ids=["1"],

                market_types=["MATCH_ODDS"],

                country_codes=["ES", "IT"],

            ),

        ]

    )

)```

---

## 2021-10-28 12:30:02 - general channel

**Lee**

You can just have two market_filters, flumine will create two connections and handle this for you

```framework.add_strategy(

    strategy=StrategyOne(

        market_filter=streaming_market_filter(

            event_type_ids=["1"],

            market_types=["MATCH_ODDS"],

            country_codes=["GB", "DE"],

        ),

    )

)



framework.add_strategy(

    strategy=StrategyTwo(

        market_filter=streaming_market_filter(

            event_type_ids=["1"],

            market_types=["MATCH_ODDS"],

            country_codes=["ES", "IT"],

        ),

    )

)```

---

## 2021-10-28 11:24:39 - general channel

**EJono**

Does this require two instances of flumine running? More specifically, two seperate trading objects with distinct login sessions that you then run the exact same strategy on barring the country code filter?

---

## 2021-10-28 11:10:11 - strategies channel

**JazzMan**

To make money from a live strategy you have to be doing something unique. If you’re doing the same as everyone else then you’re all waiting in line to place the same bet. This maybe the problem with everyone using the same backtesting program. Backtesting works fine for me but I’ve taken a long time writing my own.

---

## 2021-10-28 09:08:50 - issues channel

**liam**

Ah, it temporary converts the datetime back to the 'real' datetime rather than the backtest datetime, I am not sure if you can use an s3 path because of this unless smart open caches the file, does this work?



```with mock.patch("builtins.open", smart_open.open):

    with framework.simulated_datetime.real_time():

        framework.add_strategy(strategy)

    framework.run()```

---

## 2021-10-27 22:09:45 - strategies channel

**AndyL**

[@U01S1VB9X9P](@U01S1VB9X9P) just being reading your posts, you sound like you're doing what i was, ie.making a pure backtest created strategy work, they don't!!

I had a backtest dog betting strategy, worked great over the 3months/3000selections, 6.5%ROI, went live.....lost money....

I think what works is come up with a strategy based on your experience of how the market works, then backtest to validate

---

## 2021-10-27 16:58:31 - issues channel

**JC**

managed to get it to work by adding the context manager in source code before line `for event in stream_gen():` in backtest.py. Using more standard context manager, e.g.

```with framework.simulated_datetime.real_time():

    with mock.patch("builtins.open", smart_open.open):

        framework.add_strategy(strategy)

        framework.run()```

, results in errors.

---

## 2021-10-26 16:11:50 - general channel

**Lennart**

Hi everyone, wondering if anyone here can recommend a live data provider for NBA games or Basketball in general? Of course, ideally, I'd love a free one. Also wondering - anyone else here trading on Basketball markets?

---

## 2021-10-24 07:11:18 - general channel

**liam**

strategy.context 

---

## 2021-10-23 12:17:37 - strategies channel

**Peter**

I'd recommend taking a look at the strategy examples in the flumine repository and then trying to get the lowest layer strategy working using

```client = clients.BetfairClient(trading, paper_trade=True) ```

so that you can be confident that you're not risking real money.

---

## 2021-10-23 11:16:15 - strategies channel

**Newbie99**

In terms of docs, the best places are:



Betfair docs: [https://docs.developer.betfair.com/pages/viewpage.action?pageId=4392320](https://docs.developer.betfair.com/pages/viewpage.action?pageId=4392320)



Betfair Lightweight (API wrapper): [https://github.com/liampauling/betfair](https://github.com/liampauling/betfair)



Flumine (Betfair 'Trading' Framework): [https://github.com/liampauling/flumine](https://github.com/liampauling/flumine)



Other than that, there are plenty of experts to ask on here!

---

## 2021-10-23 10:22:09 - strategies channel

**Adrian**

yeah for this one strategy i have been working on. i mean, i make a profit, it's just not as big

---

## 2021-10-22 16:52:55 - betfair-news channel

**Neil T (Betfair)**

There is room for a more in-depth &amp; definitive technical article on this, so I’ll see if our dev team will consider writing something to be included on our Technology blog ([https://ppb.technology](https://ppb.technology)). We might not be able to provide the full and more explicit technical details you want though :slightly_smiling_face:



In the meantime, here’s a high-level summary:

 

• For performance reasons, all bet matching takes place in a bulk betting matching cycle, each of which takes ~100 m/s. 

• All bets within a single cycle are queued (matched/unmatched) on a FIFO basis. 

• Cross-matching occurs both at the market and event level. 

• There is no concept of exactly the same time, one bet will always be picked up before another even if one is microseconds before the other.



---

## 2021-10-22 15:40:30 - betfair-news channel

**Newbie99**

A while back there were a few users on here that got blocked and didn't seem to know why, obviously Betfair have certain legal obligations that can't be avoided and have to adhere to these, but aside from that, when permissible by local laws (i.e. when its not AML related basically), it would be good if users were given a warning if their betting behaviour would be likely to cause them to be blocked (e.g. an e-mail warning saying you are making an excessive number of REST API calls without placing sufficient bets or something to that effect).



In essence it would hopefully be mutually beneficial to allow people to change behaviour, rather than taking the nuclear option and closing down accounts without warning.



I should stress I have no idea what actually happens/happened in these situations personally, I'm just going on what people have posted.



So I guess the question is, would it be possible to have a slightly more formalised / structured approach to this type of occurrence to provide piece of mind that no-one is going to get shut down without just cause?

---

## 2021-10-22 10:01:30 - strategies channel

**Oliver Varney**

I think it depends on your approach to strategy design, what you are trying to predict and the type of market (for example I would think modelling pre off vs inplay would be different approaches). For me at least backtesting (in the sense of simulating matches) is the last stage, knowing prices available at entry vs benchmark is the fastest way to iterate I find.

---

## 2021-10-21 23:32:51 - strategies channel

**Adrian**

I should have been more specific - do you analyse historical data separately from backtesting? I know how to backtest. I just dont really know how to approach the historical data.

I guess I'm just looking for a more reliable approach to what I've been doing, which is identify a strategy (from observed market behaviour), backtest, adjust parameters, validate.

So far the validations have fallen down. So I have a more fundamental issue.

Liam said start with a known strategy and adjust to make it work. So how does historical data analysis work with that? It's not just adjusting the backtest, right?

---

## 2021-10-21 13:23:36 - betfair-news channel

**Neil T (Betfair)**

*Section 1: Betting - General Conditions*

Betfair provides a platform upon which you can enter into various betting transactions in relation to the markets available on our site ("Markets").

Where customers bet with each other on the Exchange, Betfair acts as a facilitator and does not act as a counterparty. However, Betfair may act as a counterparty on the Exchange but only in the following limited situations:

• for wagers between Australasian Customers. Betfair also offers Tote bets, as well as singles (which we call "˜Fixed Odds") and "Multiples" bets at odds fixed by us.

• for Betfair's Starting Price ('SP' or 'Betfair SP') on the Exchange. The Betfair SP is calculated by Betfair, by balancing all SP bets and other Exchange bets when the market is suspended at the 'off' of the relevant event. Betfair group may act as risk counterparty to SP bets if necessary to ensure a fair SP. The Betfair personnel involved in determining the SP in such circumstances will have no undeclared personal or other interest in the SP in question. When you place a bet at SP you are betting against other Betfair customers. However during the reconciliation of the Betfair SP, Betfair acts as counterparty in order to balance liabilities between Betfair SP bets and other Exchange bets; and

• occasionally (and such bets represent a tiny fraction of the overall volume of betting activity on the Exchange), in one of the two following circumstances:

    ◦ on less liquid markets to improve “liquidity” and stimulate market activity (“liquidity” is the amount of money available for you to bet on each selection). We may do this on ancillary markets (particularly when the market is first made available) or on markets on less popular events. The rationale for providing this liquidity is to enhance the betting proposition for our customers; and

in order to reduce the Betfair group’s liability against a particular outcome. We may do this on a high-profile event where our sportsbook has a very large exposure to that outcome.

---

## 2021-10-21 12:57:55 - betfair-news channel

**Oliver Varney**

*Derivative style products on the exchange (Apologies for the long winded question / paragraph im not sure the best way to phrase this):*

*[@UNW8Q88EL](@UNW8Q88EL)* I think ive mention this to you at the meetups.



Sports like horse suffer from largely inactive markets apart from big meets, up until very close to the off (like the last 5 mins). The exposure imbalance of laying vs backing is a big contributor to this. Why would someone who is willing to lay a horse at 100 lock up all that exposure for large amount of time (lets say 2+ hours) with the current betting products we have available to us. This is probably one of the reasons you are forced to market make and the early markets are dire.



Furthermore there is a large "trading" community out there that mainly care about "trading" the price difference and want no exposure on the result. These "traders" are currently getting screwed over when the exchange goes down as they cant ditch their exposures and there is no voiding under the current exchange rules.



These two reasons combined scream out for a betting option more akin to a contract for difference (CFD) from the finance world.



*Is Betfair thinking about / would betfair consider something like this?*



Thinking about horses, I could see a massively popular product being a CFD style contract where the final value comes from the entry price being settled to BSP, thus only requiring one trade instead of the current two (entry + hedge). Users could also trade in and out of this contracts similar to current hedging with actual bets. In combination with a stop loss settlement mechanism, whereby the entry price is compared to the current market price, we could improve the imbalance of lay side exposure vs back side.



With the example of laying at 100, a CFD contract could be striked with an entry price of 100, closing price of whatever BSP is, and an automatic stop loss settlement if the current market price goes below 10 lets say. In this example the lay side would only require 10x exposure instead of 100x exposure due to the maximum loss being ten times smaller.



A product like this could lead to much more active markets and could boost volumes offered and matched.

---

## 2021-10-21 12:31:43 - general channel

**Mike Walpole**

In a way, this strategy kinda likes when prices of my horse soften (“the worse the fill the better” as Soros once said) 

---

## 2021-10-21 12:24:13 - betfair-news channel

**Mo**

Thanks Neil. Fair enough if there is indeed interest in this older data. I take your points but just wanted to highlight a couple of things I think we (as the "cyberpunks") consider canonical:



1. Anything other than PRO is a waste of time

2. You need at least a year's worth of data to have confidence in a strategy

So although there are some free months of PRO available, I would still argue for a contiguous year - and not one that was affected by COVID!



(I realise - mainly through the hackathon participation - that there is still a demand for ADVANCED data from Harold)

---

## 2021-10-20 13:04:29 - issues channel

**Laing Clark**

```trading = betfairlightweight.APIClient(username=my_username,

                                       password=my_password,

                                       app_key=my_app_key,

                                       certs=certs_path)



print(trading.login())```



---

## 2021-10-20 13:01:15 - issues channel

**Laing Clark**

Hey guys, im new and trying to jump into this betfairlightweight module. I have successfully plugged in the right data to the initial  python code provided by betfair with the command trading.login() successfully loging into my account and returning the expected LoginResource response. However, my issue is that If I do anything else, such as use the code provided in the next step of the tutorial I get an error code to the affect of INVALID_APP_KEY. Not what I was expecting considering the bindings to the variable 'trading' work with the initial login function. I know I'm a noob but can somebody point my in the right direction.

---

## 2021-10-19 12:10:15 - strategies channel

**James T**

Sounds like you’re overfitting, but the real problem is that it’s just not enough bets to confirm whether the strategy works or not. 



Over a 2 month period really you need to be aiming for 10 or 100 times that number of bets. Otherwise you’re just not going to be able to scale it unless you have some massive edge. 

---

## 2021-10-19 11:50:33 - strategies channel

**Adrian**

I have a strategy that performs really well over 2 months of backtesting data. Looks great on the MC analysis as well. However it performs dismally on the verification/test data, to the point od only breaking even. I can't figure out if I'm overfitting (I don't want to look at any of the verification data so I dont overfit that too), but i dont think my parameters are overly complicated (only 4 variables). Is it normal that this happens or could something else be going wrong? Thanks

---

## 2021-10-18 18:57:08 - general channel

**rjj**

Question what would be the most appropriate place in a strategy to place a 'sibling' bet on another exchange like smarkets or matchbook. I've tried doing it in process_market_book but if the other exchange is slow in responding then the whole framework complaina of latency. If I try and background the call in a separate thread this seems to cause all manner of difficult to see issues. Any ideas?

---

## 2021-10-17 08:49:50 - random channel

**Oliver Varney**

Morning, im looking for some advice on hosting platforms, mainly AWS vs the rest. I am just about to start re-writing some of my services and was just wondering what peoples thoughts are on the best way to go. From what I understand if I go with AWS (rather then something like linode) im getting a large product/ feature set but in return paying higher costs and potentially slightly slower performance (from what ive read thus far). Is there any specific things around AWS and Betfair/betting that are also advantages of using it. From my understanding betfair are hosted on AWS? im pritty clueless when it comes to this stuff so would be interested in the techy guys thoughts.

---

## 2021-10-16 08:05:40 - random channel

**Paul**

For example, you might start with “identify a profitable trading strategy for horse racing markets 2 minutes before official start time” (which is tough enough already). To do that you will need to:

• Download historical data

• Understand it, perhaps do some cleaning and so on

• Get it into a format that you can use for your strategy building

• Run some tests

• Visualise the test results

…

---

## 2021-10-15 06:14:52 - random channel

**Van**

Well, I’m thinking solo project.. not even a trading bot but any solo project..

---

## 2021-10-14 15:36:40 - general channel

**Aaron Smith**

[@U016TGY3676](@U016TGY3676) not sure if i fully understand, but the selection_exposure only considers orders on this specific selection, as it only loops over

```for order in self.strategy_selection_orders(strategy, *lookup[1:]):```

therefore it will give you the exposure for this selection if this selection was the only selection with any orders to it.

---

## 2021-10-14 13:34:50 - general channel

**birchy**

`"""Returns strategy/selection exposure, which is the worse-case loss arising

        from the selection either winning or losing. Can be positive or zero.

            positive = potential loss

            zero = no potential loss

        """`

Seems obvious that it returns the "worst-case" loss for the runner winning or losing, but in my example above, the worst-case loss is £0 and not the £5 I'm seeing? Maybe I'm overlooking something obvious?

---

## 2021-10-13 14:58:42 - general channel

**Jono**

Related to a flumine based question i asked a while back, ive recently got the streamable market limit increased from 200 to 1000 and off the back off advice from [@ULDAVFDRP](@ULDAVFDRP) kept my market filter wide for my startegy. I then work out which markets to place on using logic inside check_market_book, and in middleware etc beyond the initial strategy set up which specifies the only the event_type=1 and market_type=MATCH_ODDS. I was wondering the best way to manually stop market books being streamed from markets i am not interested in, after framework.run() and prior to them closing automatically at market close. At the moment i am capping the number markets desired for placing to a fixed number currently 20 and then using



self.remove_market(market.market_id)



inside check_market_book to halt the streaming information correlating to these excess markets. However i can still see in a background worker using len(flumine.markets) that there still remains ~600 markets and so I was wondering if im actually correctly removing them, and if im not what is the best way to do so? and best location ie inside middleware, worker, etc as opposed to in check_market_book? Furthermore if i wanted to start up streaming a new market post run() how would i go about this?



Thank you!

---

## 2021-10-12 15:15:34 - general channel

**Javier Martín Pérez**

stream = trading.streaming.create_stream(listener=listener)

---

## 2021-10-11 10:19:28 - issues channel

**liam**

this not work?



```def callback(flumine, event):

    for market in flumine.markets:

        for strategy in flumine.strategies:

            # do something```

---

## 2021-10-11 10:00:10 - issues channel

**JC**

I am wanting to place a bet in the CustomEvent callback function and need the strategy argument for the Trade object, how do I get this? Would it be more standard to update the context and have a trigger in the process marketbook function?

---

## 2021-10-11 09:58:01 - random channel

**Finn**

[@UPMUFSGCR](@UPMUFSGCR) have you looked into this? [https://github.com/fmfn/BayesianOptimization](https://github.com/fmfn/BayesianOptimization) I used to use it to tune hyperparameters, not sure if its a good fit for your purpose.

---

## 2021-10-11 09:02:20 - general channel

**thambie1**

No clue. [@U0128E7BEHW](@U0128E7BEHW) is the only person I'm aware of that does fundamental football modelling. Perhaps he has a better answer.

---

## 2021-10-10 20:31:17 - random channel

**Jonjonjon**

In essence,  have a dataframe of 3 columns:



• forecasted return

• actual return

• market variable (e.g. time, volume, volatiliy etc...)

My strategy enters a trade if the forecasted return is greater than some threshold.



That threshold is a function of the market variable.



I'm trying to fit a piecewise linear function to the threshold.



So the dimensions are the knots on the piecewise linear function.

---

## 2021-10-08 14:38:20 - issues channel

**Oliver Varney**

this is a typical use:

```def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

    if market.market_type == self.strategy_market_type:

        if (market.seconds_to_start &lt;= self.max_seconds_to_off) and (market.seconds_to_start &gt;= self.min_seconds_to_off):

            if market_book.status == "OPEN":

                return True

    return False```



---

## 2021-10-08 13:59:30 - issues channel

**liam**

So few things,



• the market / order streams are in separate threads and main handles the market updates/processing so a slow strategy won’t cause conflation

• workers are also threads so don’t impact anything else (unless they are CPU heavy / bound)

• 100 markets is small and will be very light on cpu 

• check your clock is correct 

• lines are meaningless, it will be what you are doing 

• what are you doing?

• cprofilev is very good at finding slow code 

---

## 2021-10-08 11:43:52 - issues channel

**Aaron Smith**

So to many bets placed at once is the issue? This could make sense with the new strategy i added. Any solutions for this?

---

## 2021-10-08 11:32:08 - issues channel

**Aaron Smith**

I m getting a lot of

```{"asctime": "2021-10-08 10:15:59,227", "levelname": "WARNING", "message": "High latency between current time and OrderPackage creation time, it is likely that the thread pool is currently exhausted", "trading_function": "place", "session": "&lt;requests.sessions.Session object at 0x7f6c242e3450&gt;", "latency": 0.128, "order_package": {"id": "bb7959ae-2820-11ec-8a2b-0a13a1974215", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f6c4037dc90&gt;", "market_id": "1.188799555", "orders": ["138529809590672740"], "order_count": 1, "package_type": "Place", "customer_strategy_ref": "run_dogs", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}, "thread_pool": {"num_threads": 32, "work_queue_size": 0}}```

today

---

## 2021-10-08 11:02:42 - issues channel

**EJono**

Im experiencing high latency warnings at ~100 markets on flumine. I was wondering best practices broadly speaking for strategy logic so I can improve what I have in my thus far so I can best scale up 



Should not in use market id stand be removed from the strategy?



Is the best way of timing a strategy simply a datetime time stamp comparison at the beginning and end of the process market book function?



I currently have all long running requests executing in workers, but do these effect runtime if executing too often. I have 5 running polling various APIs every 20-30 second. 



For code executing in process market book and process orders should the length of this be limited to 100 lines for example after which conflation is necessary?



Sorry for question dump, any other general pointers to improve speed would be also be greatly appreciated. Cheers!

---

## 2021-10-01 17:03:47 - issues channel

**Jack**

Betfair have temporarily upped my connections to 15 so I can get my strategy running over the weekend.



I don't see how I could have - I even destroyed my old digital ocean server yesterday and moved everything over to AWS so it should all be in one place now. :confused:

---

## 2021-10-01 16:52:18 - issues channel

**Jack**

Hi all :wave:



I am still having issues bringing my live strategy back up. Logs are telling me that I have too many connections open (10 apparently).

I know that I shouldn't be using any more than 4 (5 with this strategy) but old unused connections seem to be persisting forever.



Does anyone know of a way to see what connections are open and terminate them manually?

Is manual termination of connections something that people do when they pull strategies/streams down?

---

## 2021-10-01 13:37:29 - issues channel

**Peter C**

Thanks! This resolves a problem I've been experiencing since I added a second strategy

---

## 2021-10-01 13:36:14 - issues channel

**liam**

Same, `strategy.context` is what you would want

---

## 2021-10-01 13:35:24 - issues channel

**Peter C**

If I add two strategies to one flumine instance, is market.context per strategy or do the two strategies share one context?

---

## 2021-10-01 09:44:16 - general channel

**Oliver Varney**

[@U4H19D1D2](@U4H19D1D2) how does the event linking work in market.event? I want to link a WIN market to a PLACE market (essentially know the market id and a few other bits). Does this work by default or do I need certain setting on filters? Im guessing I need to have both a strategy with a WIN streaming filter and a place streaming filter?

---

## 2021-10-01 09:13:52 - issues channel

**Finn**

Is the best place to access marketbooks as they come in a strategy?

---

## 2021-10-01 09:00:02 - issues channel

**liam**

If you want the book you would need another dummy strategy which isn't a recorder, why do you want the book?

---

## 2021-10-01 08:54:37 - issues channel

**liam**

So this uses the raw data stream where we don't create the books, you need a normal strategy if you want access to the book

---

## 2021-10-01 08:52:55 - issues channel

**Finn**

With MarketRecorder as my strategy, yes

---

## 2021-09-30 20:04:19 - strategies channel

**Beeblebrox**

Because `place_reset_seconds`  is being compared to `placed_elapsed_seconds` here  [https://github.com/liampauling/flumine/blob/bae349672f543d1973b706e5efb72f6bc05fd5e5/flumine/strategy/strategy.py#L154](https://github.com/liampauling/flumine/blob/bae349672f543d1973b706e5efb72f6bc05fd5e5/flumine/strategy/strategy.py#L154)



and `reset_seconds`  is being compared to `reset_elapsed_seconds`[https://github.com/liampauling/flumine/blob/bae349672f543d1973b706e5efb72f6bc05fd5e5/flumine/strategy/strategy.py#L163](https://github.com/liampauling/flumine/blob/bae349672f543d1973b706e5efb72f6bc05fd5e5/flumine/strategy/strategy.py#L163)

---

## 2021-09-30 11:54:16 - strategies channel

**liam**

strategy dependant and part of the art, anything I deploy live would have been through backtesting yes

---

## 2021-09-30 11:42:55 - strategies channel

**liam**

default strategy [https://github.com/liampauling/flumine/blob/cd1e981c57baef58a529b624a17a7877cc67c676/flumine/strategy/strategy.py#L52|settings](https://github.com/liampauling/flumine/blob/cd1e981c57baef58a529b624a17a7877cc67c676/flumine/strategy/strategy.py#L52|settings) are one live order per runner, you can bump or remove this, but you also have the following on the trade/order itself:



```place_reset_seconds: float = 0.0,  # seconds to wait since `runner_context.reset` before allowing another order

reset_seconds: float = 0.0,  # seconds to wait since `runner_context.place` before allowing another order```

---

## 2021-09-30 11:21:47 - strategies channel

**liam**

you need to be aware of your impact along with feedback from your bets, the latter gets very complicated and impossible to model, ideally you start small and nudge up until your profit levels. Keep stakes as low as possible and instead think outside the box in how you can get more matched, for examples £5+ bets are massive inplay

---

## 2021-09-30 11:15:57 - strategies channel

**Beeblebrox**

:joy: That's good to know! Basically - plot stuff, try and make sense of it, tweak your strategy and see what happens?

---

## 2021-09-30 08:57:12 - general channel

**Jono**

qq whats the best way to limit the number of markets placed on for a strategy in flumine to a set number say 10 over long run times? at the moment im manually selecting a set number of market ids in the streaming market filter but once these games have concluded i have to select more and restart the strat. Im at thte stage where i'd like to keep it running for a few days but on a small number of markets and not on 100s of markets or a whole event_type_id. Thanks

---

## 2021-09-30 00:40:23 - strategies channel

**nthypes**

folks, what kinda of strategy can be develop when you have +60% strike rate in predict (+/-)2% moves in the market

---

## 2021-09-29 13:35:57 - general channel

**Jono**

sorry i dont have anything particularly insightful to hand log wise other then times of different market transactions taking place and a list of the different orders placed . Need to make better use of the logging worker. the documentation has a comment inside the OrderStatus class stating beside VIOLATION definition that # order never placed due to failing controls

could you possibly elaborate on what this means? Is it something that is generated from both failed placings on betfair due to incorrect instructions sent to the api and/or breaches of the strategy variables ie max_live_trade_count?

---

## 2021-09-29 13:12:20 - general channel

**Jono**

Occasionally when altering an order either by cancelling entirely or adjusting the odds in my strategy, something causes the instruction to not run as expected and result in an order of status VIOLATION being produced. It seems to me to be indicative of the original bet being partially matched as i try to submit the cancel request but could very well be something else im not aware of. The new order correlating to the remaining unmatched amount of the original stake tends to be quite small, usually no more than a few tens of pence but then is unable to be cancelled in order to start the strategy cycle successfully again. The strategy heavily relies on making use of the max_live_trade_count = 1 in order to stay in check and not over place but orders of status VIOLATION contribute to this count resulting in progress stagnating until the remaining amount is matched as i cannot seem to cancel it.



Is there a way to deal with orders of status VIOLATION either by forcing cancellation or ignoring them in the max_live_trade_count or some other way i'm missing?



Additionally what tends to cause them so i can avoid generating these awkward orders?



Thank you

---

## 2021-09-29 12:50:59 - strategies channel

**Jack**

I'm logging all my orders into a database by strategy so I'll just watch it closely for a while. I haven't got much in the account to lose anyway :joy::sob:

---

## 2021-09-29 11:03:28 - general channel

**liam**

[https://github.com/liampauling/flumine/blob/cd1e981c57baef58a529b624a17a7877cc67c676/flumine/strategy/strategy.py#L91](https://github.com/liampauling/flumine/blob/cd1e981c57baef58a529b624a17a7877cc67c676/flumine/strategy/strategy.py#L91)

---

## 2021-09-29 11:01:19 - general channel

**Oliver Varney**

Cool so does that mean essentially that it will create a separate stream for the win strategy based markets and then another for place strategy markets. I guess what I want to  double check, is that if I have 3 strategies that are win and 1 that is place that, the 3 win only process market books for win markets and the place strategy only processes market books for the place markets. Or do I need to add code for that ?

---

## 2021-09-29 10:56:17 - general channel

**Oliver Varney**

Is the streaming_market_filter set up at the strategy level (and any necessary streams)? Will having a single flumine instance running strategies with just WIN GB and IRE markets filter and another strategy with PLACE GB and IRE filter cause any issues?

---

## 2021-09-29 09:07:19 - strategies channel

**Jack**

Wanted to go live with a new strategy and protect my main balance on case it starts throwing money away. 

I suppose when it was mentioned before the suggestion was actually just to move money across from main to games wallet to keep it safe.

---

## 2021-09-29 00:14:37 - strategies channel

**Jack**

Hello :wave:  Is there a way to set a strategy to only play out of the games wallet balance? I've heard it mentioned here a few times but never seen how it's done.

---

## 2021-09-25 16:19:46 - general channel

**Unknown**

I was just doing a sanity check over my live strategy to check it was on-course and I just wanted to give a shout-out to how solid the back-testing is in flumine :chart:.

Top graph is actual behaviour over the last couple of weeks, and bottom graph is the results over the same time using back-testing.

---

## 2021-09-24 11:25:03 - issues channel

**Aaron Smith**

I am doing a backtest on InPlay horses and i am getting weird results. I m placing terrible bets on purpose to check its sanity, but i m barely getting matched. I had this strategy running live (with more reasonable prices) and i was getting matched more. Anyone has an idea in what direction to look here?

---

## 2021-09-24 05:06:37 - general channel

**Finn**

Hi everyone! Loved reading back through the chat. I've just started using BFLW, and I was wondering what the strategy is for filtering streams. Even if I filter (streaming_market_filter) to the minimum of what I want (Horse Racing, AU, win &amp; place), I still have 317 markets, far over my allowed 200. Should I open one stream for win markets, and one stream for place? Plenty more stupid questions to come I'm sure, cheers.

---

## 2021-09-23 15:13:37 - issues channel

**Peter C**

I'm a bit unsure of how to add multiple strategies to a single instance of flumine and would appreciate going over it. I'm under the impression that I can import my two strategy files, set up two strategy objects as such:

```strategy_1 = strategy_1(

  market_filter=streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE"],

        market_types=["WIN"],

    ),

      market_data_filter=streaming_market_data_filter(fields=["EX_MARKET_DEF", "EX_ALL_OFFERS", "EX_TRADED"]),

      max_order_exposure=1,

      max_selection_exposure=1,

      max_live_trade_count=1,

      conflate_ms=0,

      context={"stake": 2},

)```

     and then call:

```framework.add_strategy(strategy_1)

framework.add_strategy(strategy_2)

framework.run()```

Then I am under the impression these two strategies will run independently on the same market stream. Is this right, and are there any gotchas? Thanks!

---

## 2021-09-22 04:43:37 - general channel

**ThomasJ**

I am storing LTP history at `update_cache &gt; if "ltp" in new_data`...(as I want to minimize looping thru runners on every update in `_process_market_books` to see if a price change occurred) but I'm darned if I can find a reference to the flumine instance at that point (in order to get the strategy context).

---

## 2021-09-21 21:32:24 - issues channel

**gbettle**

Evening all. I have hacked-together a bit python to fetch Horse Racing today\tomorrow - see attached.



It's been working for several weeks. Until tonight, when I'm suddenly getting the following error. Is 503 an issue with my network?



PS C:\Users\garry\betfair\examples&gt;  &amp; 'C:\Users\garry\AppData\Local\Programs\Python\Python38\python.exe' 'c:\Users\garry\.vscode\extensions\ms-python.python-2021.9.1246542782\pythonFiles\lib\python\debugpy\launcher' '51302' '--' 'c:\Users\garry\betfair\examples\temp_racecards.py'

2021-09-22 1300 Redcar Try Racing Tv For Free Now Nursery Handicap (4) £9500.00 1 Gnat Alley, 2 Pneumatic, 3 Iur Cinn Tra

2021-09-22 1315 Goodwood Ryan Canter Club Future Stayers' Ebf Maiden Stakes (2) £20000.00 1 Age Of Sail, 2 War Horse, 3 Schmilsson

2021-09-22 1330 Redcar Free Month Of Racing Tv Nursery Handicap (6) £6200.00 1 Sweet Madness, 2 Bro, 3 Sunsets Dreamers

Traceback (most recent call last):

  File "c:\Users\garry\betfair\examples\temp_racecards.py", line 84, in &lt;module&gt;

    race_cards = trading.race_card.get_race_card(market_ids=[market_id])

  File "C:\Users\garry\AppData\Local\Programs\Python\Python38\lib\site-packages\betfairlightweight\endpoints\racecard.py", line 64, in get_race_card

    (response, response_json, elapsed_time) = self.request(

  File "C:\Users\garry\AppData\Local\Programs\Python\Python38\lib\site-packages\betfairlightweight\endpoints\racecard.py", line 118, in request

    check_status_code(response)

  File "C:\Users\garry\AppData\Local\Programs\Python\Python38\lib\site-packages\betfairlightweight\utils.py", line 34, in check_status_code

    raise StatusCodeError(response.status_code)

betfairlightweight.exceptions.StatusCodeError: Status code error: 503

---

## 2021-09-21 13:18:59 - general channel

**liam**

You just need to watch out for latency if you are doing anything in the strategy as it is blocking

---

## 2021-09-21 12:31:54 - general channel

**ThomasJ**

OK thank you. Definitely using a strategy. So the context can store miscellaneous 'extra' stuff. Fantastic.

---

## 2021-09-21 12:26:46 - general channel

**liam**

Why not just use a strategy and store the flag in the context? You have the raw streaming_update in the MarketBook 

---

## 2021-09-21 08:53:23 - issues channel

**Jorge**

I found something even weirder: If I call

`trading.betting.list_cleared_orders(bet_status="SETTLED", group_by="MARKET", customer_strategy_refs=['A', 'B'])` , I get some marketIds with customerStrategyRef=NaN and these are different subset than if I call with

`trading.betting.list_cleared_orders(bet_status="SETTLED", group_by="MARKET", customer_strategy_refs=['C', 'D'])`

---

## 2021-09-21 08:34:19 - random channel

**Oliver Varney**

Well the tricky part is trust right, but im sure there are many people on here who could stake someone if there model was half decent and they didnt have the same PC restrictions

---

## 2021-09-21 08:33:51 - issues channel

**Jorge**

It happens rarely but when it occurs, all bets in the marketId have customerStrategyRef=NaN

---

## 2021-09-21 08:19:40 - issues channel

**Jorge**

Hey guys, everytime I place a bet I am providing a *customerStrategyRef* parameter. But when calling *list_cleared_orders*, something like 5% of my bets have customerStrategyRef=NaN. Has anyone had this problem before?

---

## 2021-09-20 09:03:25 - general channel

**liam**

It will be due to the runner_context stopping the second order (the logs would tell you this), you can let two orders go through by



```strategy = LowestLayer(

    market_filter={"markets": markets, "listener_kwargs": {"inplay": True}},

    max_live_trade_count=2

)```

Or putting them under the same trade

---

## 2021-09-18 18:23:45 - issues channel

**Beeblebrox**

customer_strategy_ref isn't it?

---

## 2021-09-18 17:33:58 - issues channel

**Aaron Smith**

since updating to the newest flumine version i keep getting:

```{"asctime": "2021-09-18 16:12:16,204", "levelname": "WARNING", "message": "Order 124457853944 not present in blotter", "bet_id": "124457853944", "market_id": "1.187784281", "customer_strategy_ref": "ip-172-31-34-22", "customer_order_ref": "702e0a7cf78ee-113851274335983961"}

{"asctime": "2021-09-18 16:12:16,204", "levelname": "WARNING", "message": "Strategy not available to create order 113851274335983961", "bet_id": "1244578539445", "market_id": "1.187784281", "customer_strategy_ref": "ip-172-31-34-22", "customer_order_ref": "702e0a7cf78ee-113851274335983961", "strategy_name_hash": "702e0a7cf78ee"}```

any ideas?

---

## 2021-09-17 22:41:26 - issues channel

**Peter**

Have today had some bets confirmed by my logging control as being placed as order type LIMIT with persistence type MARKET_ON_CLOSE be treated by Betfair as order type MARKET_ON_CLOSE. It's a fairly small number (8 out of 10,000+ placed today), but it does screw up my strategy somewhat. Wondered whether anybody else had encountered this.

---

## 2021-09-16 17:40:58 - strategies channel

**birchy**

Anyone got any advice for increasing matching rates? So I have a horses inplay strategy that uses price signals. For post-race analysis, I plot the "what if" cumulative P&amp;L of 100% match rate vs my actual cumulative P&amp;L (which is ~50% match rate). The theoretical 100% match rate gives a lovely straight upwards line, so that does at least show that I'm not pissing _directly_ into the wind. This strategy is right in the thick of the action, so fairly time sensitive.

Obviously increasing the cancellation "age" of the bet is an option, but that does seem to result in increased adverse selection. I'm considering using a more dynamic cancelling procedure (i.e. signal driven rather than a fixed time). The other option is moving my price closer to the middle of the spread, but backtests suggest that's going to reduce my edge closer to 0EV. My signals are fairly optimal, well... they're somewhere in the middle of the high volume/low margin : low volume/high margin range. Soooo many combinations. Doing my head in TBH. :face_with_rolling_eyes:

---

## 2021-09-16 16:36:18 - issues channel

**Beeblebrox**

I thought they were the same too and have often wondered why the market_book needed to be passed to the strategy functions since you could just get it from the market object. Are they different [@U4H19D1D2](@U4H19D1D2)?

---

## 2021-09-16 13:13:54 - issues channel

**Robbie Bennett**

hi guys, I am having an issue seperating out thoroughbred and trots races using the betfairlightweight interface and underlying betfair API and wondering if someone can help, this morning there were a bunch of trots races for AUS that came through and I was pretty sure the event type Ids should be separate. Many thanks in advance and heres some code I thought might help answer:



```trading = betfairlightweight.APIClient(

        username=bf_config["username"],

        password=bf_config["password"],

        app_key=bf_config["app_key"]

    )

    trading.login_interactive()





    # create queue

    output_queue = queue.Queue()



    # create stream listener

    listener = betfairlightweight.StreamListener(

        output_queue=output_queue, lightweight=True

    )

    # create stream

    stream = trading.streaming.create_stream(listener=listener)



    # create filters (Horse Racing Win markets)

    filter = streaming_market_filter(

        event_type_ids=["7"],

        country_codes=[COUNTRY_CODE],

        market_types=["WIN"],

    )

    market_data_filter = streaming_market_data_filter(

        fields=["EX_BEST_OFFERS", "EX_MARKET_DEF"], ladder_levels=1

    )

    # subscribe

    streaming_unique_id = stream.subscribe_to_markets(

        market_filter=filter, market_data_filter=market_data_filter,

    )```

---

## 2021-09-16 12:20:56 - issues channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) maybe I'm missing something here, but is the `market_book` in `process_closed_market()` different to the one in `market.market_book` ? I thought it was the same object?



Have implemented a workaround in my strategy:

```def process_closed_market(self, market, market_book):

    market.market_book = market_book```

---

## 2021-09-16 11:20:44 - issues channel

**birchy**

Regarding backtesting, is there a way to access the runner status ('WINNER', 'LOSER', etc) _after_ the backtest is complete? I know it can be processed via `process_closed_market()` in the strategy itself, but I'm trying to access it after the event, e.g:

```framework.run()



for market in framework.markets:

    print(market.closed)

    results = {r.selection_id: r.status for r in market.market_book.runners}

    print(results)```

which results in:

```True

{38432986: 'ACTIVE', 28095515: 'REMOVED', 38235043: 'ACTIVE', 26817710: 'ACTIVE', 36775362: 'ACTIVE', 37487570: 'ACTIVE', 27207443: 'ACTIVE', 10138440: 'ACTIVE', 38648845: 'ACTIVE', 14037512: 'ACTIVE', 36753881: 'ACTIVE', 12829452: 'ACTIVE', 24075586: 'ACTIVE'}```

---

## 2021-09-15 14:07:47 - strategies channel

**Oliver Varney**

Ah fair, I thought you meant model training

---

## 2021-09-15 14:01:38 - issues channel

**mandelbot**

So I have a general strategy and one where I'm conditioning elapsed in play time to be &gt; than some number. When I compare the filtered results from the general strategy (ie elapsed time &gt; than some number) they would be different from the results conditioned strategy. Same runners, but at different odds and slightly different `date_time_placed`

---

## 2021-09-15 13:57:09 - issues channel

**mandelbot**

I've been backtesting some IP horse racing strategies and found that when I add a condition for InPlayTimeElapsed &gt; X it would place the same bets as without that condition but they would be at slightly different `order.responses.date_time_placed` and different odds also. ie different from when I filter the results on the general strategy for InPlayTimeElapsed &gt; X. Why this would be the case?

---

## 2021-09-15 10:10:45 - strategies channel

**Jonjonjon**

Please note that we recently changed `hostname` to `customer_strategy_ref`, so please check your flumine version before proceeding.

---

## 2021-09-15 10:07:58 - strategies channel

**AndyL**

[@U4H19D1D2](@U4H19D1D2) hi Liam, quick question on a warning message ive seen in logs. I occasionally get Order nnn not present in blotter...followed by Strategy not available to create order...

I have 3 separate strategy processes running, and from the betid ref i can see the order is from one of the other processes. It looks as though all 3 are using the same OrderStream? It doesn't seem to affect things as the orders are unique, but wondering if this is expected in this scenario?

---

## 2021-09-15 07:30:36 - issues channel

**mandelbot**

Any reasons why I wouldn't get matched on a `MarketOnCloseOrder` during a backtest? I'm getting quite a few of these orders return empty in the market.blotter after market closure, even though they were placed. For example:

```{"asctime": "2021-09-15 06:19:58,132", "levelname": "INFO", "message": "Order status update: Executable", "market_id": "1.184881012", "selection_id": 40031632, "handicap": 0, "id": "138509795981320640", "customer_order_ref": "2caf09fd8c57f-138509795981320640", "bet_id": "100000000002", "date_time_created": "2021-07-01 11:44:50.042000", "publish_time": "2021-07-01 11:44:50.042000", "trade": {"id": "f360e1bf-15ec-11ec-917f-5c969d7d9766", "strategy": "strategy", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138509795981320640"], "notes": "", "market_notes": "85,95,100", "status": "Pending", "status_log": "Pending"}, "order_type": {"order_type": "Market on close", "liability": 103.5}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2021-07-01 11:44:50.194000", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Executable", "status_log": "Pending, Executable", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}}```

---

## 2021-09-14 14:46:36 - general channel

**EJono**

Then the regular identification of orders with EXECUTABLE status should take place? Would these be automatically picked up with no middleware intervention? and I only have to look for EXECUTION_COMPLETE bets in the middleware using 



customer_strategy_refs=["jono001"],

order_projection="EXECUTION_COMPLETE",

market_ids=[market.market_id]

---

## 2021-09-14 14:34:10 - general channel

**liam**

Better practice would be to hardcode a ref:



```from flumine import config



config.customer_strategy_ref = "jono001"```

---

## 2021-09-14 14:31:52 - general channel

**EJono**

Occasionally I'm missing executable orders in flumine upon restarting my strategy. I believe this is because the "config.hostname"  changes for me each time I rebuild (I'm running flumine on a cloud service VM and each deployment it changes). I'm wondering if I could use the same middleware method for accessing EXECUTION_COMPLETE orders but substitute in EXECUTABLE to the order_projection field of list_current_orders, would this be viable? I'm also filtering list_current_orders on market id. Other strategies bets being pulled through are not a problem as I'm only placing on this one strategy at the moment



Additionally should the market.blotter be filled with Strategy relevant executable orders at the time of add_market_middleware running?

---

## 2021-09-13 14:14:00 - random channel

**Van**

I would like to see you scale this model

---

## 2021-09-13 14:10:45 - random channel

**Van**

How did people’s models go for Djoko / Medvedev?

---

## 2021-09-13 13:25:46 - strategies channel

**Unknown**

All my bot strategies are implemented with different set of parameters, this allows me to set different strategies just by setting different entry parameters/values, and of course changing the strategy behavior in runtime when bot is actively running on a market. I do not restart my system at all (my app) app manages any problems with betfair api, and is able to re-login and so on. Well yes I restart the app only when hosting server restarted.   Screenshot better explains what I tried to explain.

---

## 2021-09-13 11:20:07 - random channel

**M F**

[@ULDAVFDRP](@ULDAVFDRP) i am a cricket person. i trade on cricket (specifically t20s) for a living. i have never traded any other sport but just to let you know t20 markets are very tough to crack (compared to test matches and ODIs anyway) but it can be worth your time.

as for models you can scrape data online and create a base model (which doesn't include pitch information but this is unlikely to do well). pitch conditions - even in the shortest format have a huge impact on the outcome. i have been gathering pitch data by hand over the last 5 years so i have enough data to model the pitch conditions. but i dont think you can easily obtain this info anywhere.

my 2 cents - its probably worth it but it will require a lot of work. test matches are significantly easier than t20s. happy to chat more about this if youd like

---

## 2021-09-13 10:17:26 - random channel

**D C**

I love cricket and use to play it a lot but T20 doesn't hold my interest as a spectacle but I see the appeal of it from trading perspectives. I used to bet a lot on test matches but based on knowledge, not analytics. For me I would not know where to start modelling it properly as it is essentially more about bowler versus batsman matchups and that in itself holds a lot of variation. It is something I would love to get into though but you have to be wary of the match fixing element - you see some terrible examples at times but I suppose no worse than in tennis.

---

## 2021-09-13 07:46:14 - random channel

**Mo**

However the volumes (for T20) are very compelling and modelling it is certainly intellectual stimulating

---

## 2021-09-13 07:45:33 - random channel

**Mo**

We declined to get involved because:



1. Going to be hard to beat courtsiders

2. Modelling the impact of weather is a nightmare

---

## 2021-09-12 10:46:14 - strategies channel

**Oliver Varney**

I assume we talking about model params also and not stuff like filters

---

## 2021-09-12 10:45:49 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) not sure how that would work in Flumine as most of my settings are specific to my models.

---

## 2021-09-12 10:11:23 - strategies channel

**S G**

In some production softwares, dynamic configuration is read from DB, and we a add a cache time to queries say 5 seconds, meaning your config changes will take a max of 5 seconds to kick in to your strategy. This also means you read config from DB every 5 seconds

---

## 2021-09-11 21:49:35 - random channel

**birchy**

I recently started a new strategy that revolves around how I perceive something might happen within the matching engine. I better check my logs. :flushed:

---

## 2021-09-11 21:41:43 - strategies channel

**birchy**

Does this warrant a worker? I would of thought a simple `load_settings()` in the strategy `__init__()` would suffice? Obviously that would only load when markets are added but would be less likely to cause any issues with any already running strategies. Would be interested to hear what [@U4H19D1D2](@U4H19D1D2), [@UBS7QANF3](@UBS7QANF3), etc do regarding minor parameter tweaking. I suspect they have fully automated models that tweak parameters dynamically?

---

## 2021-09-11 17:28:40 - strategies channel

**birchy**

When needing to change some hard-coded parameters for a "live" strategy, is it best to stop -&gt; change -&gt; restart, or use a more dynamic setup, i.e. have an external settings file which is polled each time a market strategy is initiated?

---

## 2021-09-10 15:36:31 - random channel

**Unknown**

Question for tennis traders.



Emma Raducanu is currently odds on to win the US Open.



A lot of money was previously traded on her at very high prices. Was it the case that the market was accurate when she was trading at around 100, given what was known at the time, or did the data suggest that her chances were far better than the market had thought?

---

## 2021-09-10 12:45:36 - general channel

**liam**

It was but has recently been bumped to [https://github.com/liampauling/betfair/blob/eb08f1c400c0c5d61dacfd618aa93d5aceec15ac/betfairlightweight/endpoints/streaming.py#L26|64s](https://github.com/liampauling/betfair/blob/eb08f1c400c0c5d61dacfd618aa93d5aceec15ac/betfairlightweight/endpoints/streaming.py#L26|64s) to solve another problem, you can reduce this to a value just above your heartbeat value (maybe we should add this dynamically after connection)



```betfair_socket = trading.streaming.create_stream(timeout=11)```



---

## 2021-09-08 21:29:02 - strategies channel

**Jack**

Sorry for the noob question - how would I filter out Hurdle races within a flumine strategy? I was using

```    def process_market_book(self, market, market_book):

        if market.market_definition.race_type == "Hurdle":

            return```

But I have realised it must be added to the market book later on because this is throwing tonnes of errors out.

---

## 2021-09-08 19:56:47 - general channel

**Oliver Varney**

Yes you would also need to update your stored price also (if in Middleware or where ever), and if your capturing historic prices as an input to your model these will also need to be adjusted

---

## 2021-09-08 19:50:40 - general channel

**Ke**

Any drawback to put in middleware if not to share with different strategies? Would it affect latency? My prediction will use not just market data, would it be easier to plug in 3rd part data in strategy directly?

---

## 2021-09-08 19:43:58 - general channel

**Oliver Varney**

I abstract all of my data away from flumine native objects attributes / structures and store it in the strategy. Price prediction is done in a separate process though this may not be worth it

---

## 2021-09-08 19:39:13 - general channel

**liam**

Best practice would be within the strategy itself unless there is latency involved in the prediction itself in which case you want to push this out to a worker or external process (e.g redis)



Middleware would be suitable if lots of strategies require the prediction as it can be calculated once and then shared. 

---

## 2021-09-08 19:34:29 - general channel

**Ke**

i'm trying to plug in my silly price prediction model and trade around it. where is the best place to put the price prediction in? should it be in middleware or strategy directly? any factors should be considered here?

---

## 2021-09-08 18:58:59 - general channel

**Aaron Smith**

How do ppl go about updating their market_filter for a strategy? Do you guys just catch all markets for the day and terminate flumine at the end of the day? Or is it more efficient to update the market_filter regularly over the day?

---

## 2021-09-08 15:02:30 - random channel

**Oliver Varney**

I have a couple of corsair k70s that are decent (I think :joy:) but they are not the cheapest. Not Bluetooth though but im sure they have a Bluetooth model

---

## 2021-09-08 13:09:35 - issues channel

**Peter**

That's the where the market recorder keeps the data, executes the compression and from where it will upload the files when finished. There are two parameters that you can pass into the market recorder: "remove_file" and "remove_gz_file" which by default are set to False. To stop these /tmp subfolders from growing until you run out of disk, you're going to want to set them to True when you start the recorder. For example:



`strategy = S3MarketRecorder(`

    `name="Golf Market Recorder",`

    `market_filter=betfairlightweight.filters.streaming_market_filter(`

        `event_type_ids=["3"],`

    `),`

    `stream_class=DataStream,`

    `context={`

        `"local_dir": "/tmp",`

        `"bucket": "*************",`

        `"force_update": True,`

        `"remove_file": True,`

        `"remove_gz_file": True,`

    `},`

`)`

---

## 2021-09-08 11:25:19 - general channel

**Jono**

so it loops though the markets appending them to generate the full dataframe does

`[http://logging.info|logging.info](http://logging.info|logging.info)("Generating bet dataframe from all markets")`

`for market in flumine.markets:`

    `bet_df = bet_df.append(market.context['bet_df'], ignore_index=True)`



then makes the api call.

Finally my plan would be to loop through them again and clear them, ie something like





`[http://logging.info|logging.info](http://logging.info|logging.info)("Clearing bet dataframe for all markets")`

`for market in flumine.markets:`

    `bet_df = pd.DataFrame(columns=['placed_at', 'external_event_id', 'external_bet_id'])`



The reason i did it this way is i wasnt sureif there was a "strategy.context" of sorts that you can access from all markets and append to the same dataframe. Thus each market has a df that is joined together in the worker

---

## 2021-09-08 08:46:07 - general channel

**Oliver Varney**

If you have plans for doing some big modelling / AI then definitely having large ram / large gpu ram are going to to help. Try and only buy once and go for something decent.  I just got bent over for a 3090 last month :face_with_rolling_eyes:

---

## 2021-09-07 21:24:19 - general channel

**Peter**

The data isn't really the same shape. When backtesting Flumine processes one market at a time by default (unless you ask it to group markets together e.g. by event). With paper trading you're getting all the open markets captured by your filter, at the same time, so the same structure as your live strategy will see. This is especially useful if your strategy crosses markets.

---

## 2021-09-07 19:20:16 - general channel

**Jack**

Thanks [@U01MPC0GUK1](@U01MPC0GUK1)  So I guess next question is what does paper trading offer you that a backtest doesn't?

---

## 2021-09-07 19:10:20 - general channel

**Beeblebrox**

I think the standard process for developing a strategy is: analysis -&gt; backtest -&gt; paper trade -&gt; live...

---

## 2021-09-07 19:07:06 - general channel

**Jack**

Can anyone tell me when and why one would use paper trading in flumine :scroll:?

---

## 2021-09-07 15:04:55 - general channel

**Beeblebrox**

Also, set your logging level to CRITICAL.  You're going to be printing out a lot of messages with it set to INFO, especially as you're not checking the exposure in your strategy, so you're going to get lots of STRATEGY_EXPOSURE messages.

---

## 2021-09-07 15:00:34 - general channel

**Lee**

Or just put your `now = datetime.now()`  after you have instantiated the strategy

---

## 2021-09-07 14:56:40 - general channel

**Jeff Waters**

I've included it in my market filter:



```strategy = TestStrategy(

    market_filter={"markets": get_markets("PRO"),

                   "listener_kwargs": {"seconds_to_start": 61},

                   "market_types": ["WIN"]},

    max_order_exposure=1000,

    max_selection_exposure=105,

)```



---

## 2021-09-07 14:21:44 - general channel

**Jeff Waters**

I don't know if it's relevant, but when I ran the program I got loads of messages like the following:



*{"asctime": "2021-09-07 10:55:53,215", "levelname": "CRITICAL", "message": "Unknown error can only concatenate str (not \"int\") to str in process_market_book (1.145082711)", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\water\\anaconda3\\envs\\bet-project\\lib\\site-packages\\flumine\\utils.py\", line 204, in call_strategy_error_handling\n    return func(market, market_book)\n  File \"C:\\Users\\water\\PycharmProjects\\bet-project\\teststrategy.py\", line 47, in process_market_book\n    print(\"Number of bets placed so far: \" + len(market.blotter))\nTypeError: can only concatenate str (not \"int\") to str"}*



and





*{"asctime": "2021-09-07 10:55:53,215", "levelname": "INFO", "message": "Order status update: Violation", "market_id": "1.145082712", "selection_id": 17069875, "handicap": 0, "id": "138503049532150426", "customer_order_ref": "d0d1ab6db12de-138503049532150426", "bet_id": null, "date_time_created": "2018-07-01 07:42:37.024000", "publish_time": null, "trade": {"id": "2bac1299-0fca-11ec-91ad-00e62d0401a8", "strategy": "TestStrategy", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138503049532150426"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 42, "size": 10, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 10.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "", "market_notes": null}*



and



*{"asctime": "2021-09-07 10:55:53,230", "levelname": "WARNING", "message": "Order has violated: STRATEGY_EXPOSURE Error: Potential selection exposure (410.00) is greater than strategy.max_selection_exposure (105)", "control": "STRATEGY_EXPOSURE", "error": "Potential selection exposure (410.00) is greater than strategy.max_selection_exposure (105)", "order": {"market_id": "1.145082712", "selection_id": 17069875, "handicap": 0, "id": "138503049532150426", "customer_order_ref": "d0d1ab6db12de-138503049532150426", "bet_id": null, "date_time_created": "2018-07-01 07:42:37.024000", "publish_time": null, "trade": {"id": "2bac1299-0fca-11ec-91ad-00e62d0401a8", "strategy": "TestStrategy", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138503049532150426"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 42, "size": 10, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 10.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": "Order has violated: STRATEGY_EXPOSURE Error: Potential selection exposure (410.00) is greater than strategy.max_selection_exposure (105)", "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "", "market_notes": null}}*



I also got loads of 'market closed' and 'market cleared' 'INFO' messages.



Are they to be expected, or do they hint at a problem with the code?

---

## 2021-09-07 13:53:09 - general channel

**Adrian**

maybe something you're adding in your strategy. i've just used all the examples. maybe i'm missing something

---

## 2021-09-07 11:28:56 - general channel

**liam**

100 markets:



```start time = 07/09/2021 11:25:17

Total profit post-commission: 468.04



finish time = 07/09/2021 11:26:44```

Bugfix in the strategy, logging set to CRITICAL and this fix to the get_markets



```def get_markets(data_dir):

    markets = []

    for dir_, _, files in os.walk(data_dir):

        for file_name in files:

            rel_file = os.path.join(data_dir, file_name)

            markets.append(rel_file)

    return markets ```

---

## 2021-09-07 11:22:18 - general channel

**liam**

Change logging to critical to speed things up, error line 47 in the strategy, should be

```str(len(market.blotter))```

---

## 2021-09-07 11:05:17 - issues channel

**Ke**

It works for me perfectly. Trying to add middleware to plug in my model now...

---

## 2021-09-07 11:04:58 - issues channel

**liam**

The add_market func gets called by flumine itself so you just have to..



```framework.add_strategy(strategy)

framework.add_middleware(OrdersMiddleware(framework))

framework.run()```

---

## 2021-09-07 11:03:53 - issues channel

**Peter C**

Sorry for the basic question but I am having trouble understanding how to use some middleware. I'd like to get execution.complete orders on start up. I've got the example file in a file of my own, and can import the ordersMiddleware class into the file which starts the flumine process. I have tried getting the orders like this:

`framework.add_strategy(strategy)`

`order_middleware = OrdersMiddleware(framework)`

`get_orders = order_middleware.add_market()`

`framework.run()`

but this doesn't work because add.market needs to be passed the market, and I don't know how to do this. I'm not even sure whether this is the correct time to try and get the orders. Please would someone help me work this out?

---

## 2021-09-07 10:24:23 - general channel

**ThomasJ**

When an order is placed, the code in `class BetfairExecution(BaseExecution &gt; def execute_place` seems to do nothing when the response order status is "EXECUTION_COMPLETE" and waits for this order status to be processed via the flumine queue; specifically in `process.py &gt; def process_current_order` which sets the order status to `OrderStatus.EXECUTION_COMPLETE`.



Given that the API immediate response is the quickest way to determine an order status, I would have thought that an EXECUTION_COMPLETE order would be set thus in `class BetfairExecution(BaseExecution &gt; def execute_place` so that a strategy knows at the earliest possible time that an order is done'n'dusted.



Caveat: I am learning BFLW and Flumine so that above may be gibberish.

---

## 2021-09-07 09:50:35 - random channel

**Jonjonjon**

Haha. I don't think there are any actual strategy tips here. But the general tips on analysis and technology are of course invaluable.

---

## 2021-09-07 09:49:20 - random channel

**Oliver Varney**

[@U4H19D1D2](@U4H19D1D2) developer series, from basics to advanced betting with flumine and betfairlightwight :joy:

---

## 2021-09-07 09:46:40 - general channel

**Stefan**

Have market data, similar you use with your python library, and what data the strategy is using depends on the strategy

---

## 2021-09-07 09:29:23 - general channel

**liam**

Just give it a handful of markets and see how long it is taking, chances are that something in TestStrategy is slowing it down

---

## 2021-09-07 08:44:23 - general channel

**Jeff Waters**

Thanks [@U01SCPDTV5J](@U01SCPDTV5J). I appreciate that. Just to clarify, will the win command I posted have the effect of only considering win markets?



Before I went to bed last night, I put the following filters in place:



```strategy = TestStrategy(

    market_filter={"markets": get_markets("PRO"),

    "listener_kwargs": {"seconds_to_start": 60},

    "market_types": ["WIN"]},

    max_order_exposure=1000,

    max_selection_exposure=105,

)```

The program is still running (I went to bed before midnight).



I'll  have a go at adding multiprocessing to my code (though it might be beyond my current Python abilities).



For now though, I suspect that my best bet might be to remove all but 1 day of the month of data from the dataset. If I find an approach that yields a profit on one day, I can test it on a larger dataset.

---

## 2021-09-06 23:30:59 - general channel

**Jack**

```strategy = ExampleStrategy(

    market_filter={

        "markets": ["/tmp/marketdata/1.170212754"],

        "listener_kwargs": {"inplay": False, "seconds_to_start": 600},

    }

)```

[@U013K4VNB6D](@U013K4VNB6D) I think [@U4H19D1D2](@U4H19D1D2) is talking about this.



If you are only placing a bet 30seconds before the off then you don't need Flumine to run all the way from the market opening to that point.

---

## 2021-09-06 16:07:12 - general channel

**Jeff Waters**

Thanks Mo.



My code for getting the data and running the tests is as follows:



```def get_markets(data_dir):

    markets = []

    for dir_, _, files in os.walk(data_dir):

        for file_name in files:

            rel_dir = os.path.relpath(dir_, data_dir)

            rel_file = os.path.join(rel_dir, file_name)

            markets.append("PRO\\" + rel_file)

    return markets





strategy = TestStrategy(

    market_filter={"markets": get_markets("PRO")},

    max_order_exposure=1000,

    max_selection_exposure=105,

)



with mock.patch("builtins.open", smart_open.open):

    framework.add_strategy(strategy)

    framework.run()```

Is there a quick and easy way for me to get that code to use multiprocessing, please?

---

## 2021-09-06 13:58:45 - general channel

**Jonjonjon**

Nothing jumps out.



But... How many markets are in your 1.7GB of data?



Given you have no idea what's happening, for future work I'd do some logging.



e.g. in your test strategy, just before (or after) placing orders, make it log a message saying it's placing a bet for market XXX. That way, you can see its progress.

---

## 2021-09-06 13:55:17 - general channel

**Jeff Waters**

Thanks Jon



My code isn't doing a huge amount of bet placing. At the moment, I'm just trying to get something that works, so all I'm doing is offering a bet to the market 30 seconds before the off.



I wonder whether the problem is with the way I'm retrieving the data. I had previously accessed JSON files that I'd manually accessed directly, and my program ran quickly. I'm now using the following code to get data from an extracted WINRAR file:



```def get_markets(data_dir):

    markets = []

    for dir_, _, files in os.walk(data_dir):

        for file_name in files:

            rel_dir = os.path.relpath(dir_, data_dir)

            rel_file = os.path.join(rel_dir, file_name)

            markets.append("PRO\\" + rel_file)

    return markets





strategy = TestStrategy(

    market_filter={"markets": get_markets("PRO")},

    max_order_exposure=1000,

    max_selection_exposure=105,

)



with mock.patch("builtins.open", smart_open.open):

    framework.add_strategy(strategy)

    framework.run()```

Is there anything I'm doing wrong in that code that jumps out at you?

---

## 2021-09-06 13:50:37 - general channel

**Jonjonjon**

[@U013K4VNB6D](@U013K4VNB6D) The time will depend a lot on how much processing your own code does. And how many orders it places.



If you place lots of limit orders, flumine will check them for fills on every market book update. That takes time.



You'll get up to 20 market book updates per second. So if you do time-consuming work in process_market_book, that will increase the time.



It also depends on your CPU and size of data. From memory, on a single-thread, and with a very simple strategy that does virtually nothing, I think my Ryzen 3950x CPU, with a Samsung EVO 970 PRO NVME drive, can process a single GB horse racing WIN file in under 3 seconds. It might even be under 1 second. You can do a crude comparison of your CPU, vs the 3950X, just by comparing the single thread ratings here: [https://www.cpubenchmark.net/cpu.php?cpu=AMD+Ryzen+9+3950X&amp;id=3598](https://www.cpubenchmark.net/cpu.php?cpu=AMD+Ryzen+9+3950X&amp;id=3598)

---

## 2021-09-06 09:07:38 - random channel

**Jonjonjon**

Looking through the sourcecode for flumine, I think `config.hostname` is only used for retrieving orders based on the `customer_strategy_ref`.



Would it be cleaner to rename it to `config.customer_strategy_ref`, to make this behaviour more explicit?

---

## 2021-09-06 08:10:39 - general channel

**Jono**

if the worker is only performing the post request to the db every 30 seconds or so surely if the process only takes 4-5 seconds it shouldn't cause strategy run time issues? Also to clarify the backin up concern that time window 4-5 second window is time spent waiting for a response rather than actually inserting the order information so nothing intensive is actually taking place in the worker, just something with a fair amount of blocking.

---

## 2021-09-06 07:53:43 - general channel

**Jono**

Hey everyone, before using flumine in an older strategy i used to send a pandas dataframe of orders placed along with the ladder information at the time the bet was placed to a database api for cataloging. I would quite like to do this again specifically in a given flumine strategy iteration when a market order is placed make a note of the runner info (available to back/lay etc) for that given market_book and then send it back to my database api every 30 seconds or so. I was wondering the best way to go about this without using messy global variables. After reading up in the flumine docs my current plan is to store a pandas df in the market.context and access it in a background worker, then loop through "for market in flumine.markets:" appending each of the dfs to get all the orders and runner information in one large frame before sending it off to the db. Not had much experience with utilising the market[context] to store information between iterations so wondering if this sound like a plausible way of using it or is there a better way of going about storing odds at time of placing before sending this info off to an external api? Thanks

---

## 2021-09-06 05:40:48 - general channel

**mandelbot**

You have to create a market_filter

```marketsToProcess = betfairlightweight.filters.streaming_market_filter(

           event_type_ids=["4339"],

           country_codes=["GB"],

           market_types=["WIN"]

)```

and then use that in your strategy such as



```strategy = TestStrategy(

    market_filter=marketsToProcess,

    max_order_exposure=1000,

    max_selection_exposure=105,

)```

---

## 2021-09-05 23:59:50 - random channel

**Jonjonjon**

I'm using `systemctl` to run some of my Flumine scripts. it ends up logging a LOT to syslog, such as:



```Sep  5 22:52:38 flumineclient env[1249xxx]: WARNING:flumine.order.process:Strategy not available to create order 138501748xxxx

Sep  5 22:52:43 flumineclient env[1249xxx]: WARNING:flumine.order.process:Order 2433387xxxx not present in blotter```

What's the best way to suppress these sort of messages?

---

## 2021-09-05 22:35:15 - general channel

**Jeff Waters**

I've tried to add filters to only include British races and win races (based on filters used in the the example code at [https://github.com/liampauling/flumine](https://github.com/liampauling/flumine)):



```strategy = TestStrategy(

    market_filter={"markets": marketsToProcess},

    country_codes=["GB"],

    market_types=["WIN"],

    max_order_exposure=1000,

    max_selection_exposure=105,

)```

However, I got an error message:



*TypeError: __init__() got an unexpected keyword argument 'country_codes'*



Presumably, that was because I wasn't using market_filter=streaming_market_filter, as in the example (as I was using historical data rather than live data).



Is there any way of filtering out particular types of races when using historical data, other than putting something like

```if market.country_code != "GB":

    continue```

in the process_market_book method?



Thanks



Jeff

---

## 2021-09-05 17:10:12 - strategies channel

**birchy**

That makes sense [@UGV299K6H](@UGV299K6H) . I've found that level liabilities generally produce inferior results compared to plain old level stakes. As you say, your average punter is likely betting £2/3/5/10 rather than £2.36. The main exception being those using hedging software, cash out, etc.

---

## 2021-09-05 16:39:22 - general channel

**Unknown**

I've now gone with:



```strategy = TestStrategy(

    market_filter={},

    max_order_exposure=1000,

    max_selection_exposure=105,

)



with mock.patch("builtins.open", smart_open.open):

    framework.add_strategy(strategy)

    framework.run()```

I've also unzipped the tar file to the same folder that the code resides in.



However, none of the data files are being read. One of the messages I get is:



{"asctime": "2021-09-05 15:35:38,776", "levelname": "WARNING", "message": "No markets or events found for strategy TestStrategy"}



What am I doing wrong?

---

## 2021-09-05 16:06:22 - general channel

**D C**

Yes that's what I am getting at. It has occurred to me that I need to shift from this single thread event loop model and rework things to a multi-process approach with a shared image of the market - rather like your redis type architecture

---

## 2021-09-05 15:52:47 - general channel

**Jeff Waters**

I've just purchased some historical data from Betfair containing thousands of JSON files. What I've done previously is to manually extract some of the files to a folder called 'Data', and then go:



*from os import listdir*

*from os.path import isfile, join*



*markets = [f for f in listdir('Data') if isfile(join('Data', f))]*

*for i in range(len(markets)):*

    *markets[i] = "Data/" + markets[i]*



*strategy = TestStrategy(*

    *market_filter={"markets": markets},*

*)*

*framework.add_strategy(strategy)*

*framework.run()*



However, that approach isn't viable when there are thousands of files in different folders in a WINRAR file. I've been told I can use match.patch:



*with mock.patch("builtins.open", smart_open.open):*

    *framework.add_strategy(strat)*

    *framework.run()*



However, where do I put the name and path of the tar file? Alternatively, is there a program that extracts all the JSON files to a single folder?



Thanks



Jeff

---

## 2021-09-05 13:09:29 - general channel

**Dave**

(one advantage is that you can have a process per strategy rather than one process for N strategies and be hindered by GIL)

---

## 2021-09-05 12:07:17 - strategies channel

**Aaron Smith**

the 2 main money makers (not talking about any big numbers still, but enough to pay my bills so i can be chill while playing around with different stuff :smile: ) are one market making and the other taking, so both works. Its difficult to say which is easier, as from what i have seen, different ppl have a really different perception of what is easy to find and what isnt. Both strategies i got running without any backtesting (this is surely not best practice, but i was lacking the data at the time). Backtesting is a strong tool, but sometimes i feel like ppl get lost in it. I still have an intentionally very slow backtest (single core), so i focus more on ideas and only use the backtest to validate an already worked out strategy.

---

## 2021-09-05 11:55:28 - general channel

**Jonjonjon**

[@ULDAVFDRP](@ULDAVFDRP) yes using add_strategy would make it easy to batch up a load of strategies into one script. However, if updating code for a strategy, I wouldn't want to disrupt the operation of other strategies.



My strategies trade in and out of positions quite heavily, so if something is interrupted while doing that it could leave me unhedged.



I like [@UBS7QANF3](@UBS7QANF3)'s idea. I'm wondering how easy it would be to make a flumine session point at a centralised component rather than Betfair.

---

## 2021-09-05 11:52:38 - strategies channel

**Ke**

Thanks, Aaron. Your comments give me some confidence which i really need now. Do you mind let me know if your strategy is speculating is more market neutral, i.e. market making?

---

## 2021-09-05 11:38:34 - strategies channel

**Newbie99**

The above was an attempt at some kind of stat arb (its not an active strategy), I think the above was actually something like number of runners and difference between the nth and n+1 runner by odds/volume or whatever

---

## 2021-09-05 11:23:21 - strategies channel

**Oliver Varney**

cool thanks, something Ill look into modelling for sure

---

## 2021-09-05 11:19:45 - strategies channel

**Newbie99**

so although its 1 single flumine strategy

---

## 2021-09-05 11:14:56 - strategies channel

**Oliver Varney**

Maybe a stupid one here (which I probably should of thought about more), but do people take strategies and separate them out into sub strategies (but effectively the same strategy) and partition by lets say odds and provide separate banks. For example if a strategy was partitions by odds, in a month where favourites are winning the shorter odds sub strategy will be able to grow and the longer odds would scale down. Is this optimal?

---

## 2021-09-05 11:11:46 - general channel

**Newbie99**

I'm on a much more basic level than all of you I'd imagine and thats exactly what I do.



I have a json file which has various parameters, then on startup I loop through and add each strategy (this is using Flumine).

---

## 2021-09-05 11:07:41 - general channel

**Oliver Varney**

at a basic level with flumine isnt it as simple as flumine.add_strategy or something? so can you not just add some logic here to batch up strategies if you only have one account currently?

---

## 2021-09-05 11:07:21 - general channel

**Mo**

I'd be shocked if someone is trading &gt;10 strategies where it makes sense to have a connection per strategy. 10 horse racing strategies can be easily served by one connection

---

## 2021-09-05 11:00:33 - strategies channel

**Ke**

I'm doing some simple market making strategy. Which bleeding consistently. I wonder if there are more informed bettor in this market than other markets

---

## 2021-09-05 10:54:35 - general channel

**Jonjonjon**

What do people do if they run over 10 discrete strategies?



Do they have Python scripts that run more than one strategy?



Or do they use some sort of local server, with course filter, and sends the data to individual strategies running on other Python scripts?

---

## 2021-09-05 08:38:43 - issues channel

**Ke**

Do you add all your market in one go? I'm backtesting one month data. Everytime i only run strategy for one day and one track, same file structure as betfair historic data. Maybe it caused the issue? Not sure what is the proper way to load historic data for back testing. I have a feeling maybe my way is not right

---

## 2021-09-05 07:23:47 - issues channel

**Adrian**

So, sorting my list of markets before adding them to the strategy changed the behaviour a bit. It nearly doubled the time it took to hit max transactions. But it's still not clearing

---

## 2021-09-04 21:10:11 - issues channel

**Ke**

The current_transaction_count_total seems to be accumulating all the time. I'm running back testing for 1 month data. The first 20 days are all ok and starts to throw error as current_transaction_count_total&gt;5000, while my strategy should not generate more than 200 orders every hour. Therefore, I'm wondering does current_transaction_count_total only count the transaction in last 1 hour in the simulation?

---

## 2021-09-04 06:19:04 - issues channel

**Peter**

My error logs this morning are full of errors like this:



`ERROR:flumine.worker:_get_cleared_market error`

`Traceback (most recent call last):`

  `File "/home/ec2-user/.local/lib/python3.7/site-packages/flumine/worker.py", line 232, in _get_cleared_market`

    `group_by="MARKET",`

  `File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/endpoints/betting.py", line 434, in list_cleared_orders`

    `(response, response_json, elapsed_time) = self.request(method, params, session)`

  `File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 55, in request`

    `self._error_handler(response_json, method, params)`

  `File "/home/ec2-user/.local/lib/python3.7/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 81, in _error_handler`

    `raise self._error(response, method, params)`

`betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders`

`Params: {'betStatus': 'SETTLED', 'marketIds': ['1.187240733'], 'customerStrategyRefs': ['ip-172-31-5-190'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'}`

`Exception: None`

`Error: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang30b-prd-09020828-000312861c', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}`

`Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang30b-prd-09020828-000312861c', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}`



Latest version of Fumine (1.19.12) and BFLW (2.13.2), and the trades are working fine.



I'm wondering whether anybody else has any idea what could be triggering these "unexpected errors" in the __get__cleared_market() method.



It might be connected to the from and to dates not being set in the API call, but as this is happening internally to Flumine, I'm don't know how to ensure that they get set.

---

## 2021-09-04 03:37:37 - issues channel

**Adrian**

that's a good idea actually, then just adding conditions within the strategy to separate markets

---

## 2021-09-03 22:51:53 - issues channel

**Lee**

If you’re using flumine id look into what’s using so many connections, using a wide market filter thats the same for all strategy’s will reuse the same connection

---

## 2021-09-03 22:30:14 - issues channel

**Lee**

do you have different market filters for each strategy?

what do your logs say for how many streams when you start flumine?

---

## 2021-09-03 14:01:08 - strategies channel

**Beeblebrox**

I've got a strategy that's been running for a few months now and I want to try and see what effect using higher stakes will have.



I'm laying horses in-play up to odds of 5.0 for £2.  I'd like to take Michael's approach of betting with randomly different stakes, but I'm not sure what a sensible range of bet sizes to use is.  Maybe bets in the range £2-£3, with 20p increments?  Maybe a higher range for lower odds?  Anyone got any thoughts?  Or just try it and see?

---

## 2021-09-03 09:54:29 - issues channel

**Adrian**

My csv export from the logging control example keep maxing out before the strategy has finished. Any idea what's causing the limit?

---

## 2021-09-02 20:39:26 - general channel

**liam**

Not currently, it’s assumed anything like that is strategy specific rather than a worker, you could probably hack it with a queue triggered with events from a strategy though 

---

## 2021-09-02 15:08:00 - strategies channel

**Jack**

[@UGV299K6H](@UGV299K6H)/[@U016TGY3676](@U016TGY3676) All makes sense thank you. Out of interest, and without asking you to spill any secret sauce, what kind of additional things would you be looking at to encompass a robust process?



In this case for context this strategy is:

• pre-play

• purely price-driven (that is to say no data is being used outside of the market stream info)

• bet-sizes are fixed minimum stake £2

I have no strategies running so certainly no profits being made just yet :joy: any advice appreciated.

---

## 2021-09-02 14:45:32 - general channel

**liam**

Yeah you can either create some middleware and store in the context, this is handy if you have a few strategies that require the data or just do it in the strategy, worker wouldn't be suitable

---

## 2021-09-02 13:19:28 - strategies channel

**Adrian**

I just can't wrap my head around why you wouldn't go for any strategy that is showing an uptrend, even if it's wonky. You slap a few of those together and it evens itself out. I'm starting to doubt my strategies but if I add more like then the chances of them ALL going to zero diminishes by orders of magnitude. Unless your sample size is so small that it creates issues, or you're worried about your bankroll

---

## 2021-09-02 12:21:03 - general channel

**liam**

Easy to do what you are describing but you just need to do it yourself inside a strategy

---

## 2021-09-02 11:44:46 - strategies channel

**Michael**

Remember that MC won't alert you either to a logical error in your strategy or an overfit on your data. Either one of those will return a fantastic looking result on your MC test and a crushing loss in real life.

---

## 2021-09-02 09:46:39 - strategies channel

**birchy**

[@U01S1VB9X9P](@U01S1VB9X9P) In theory, yes, but match rates, market impact, etc will paint a very different picture in the real world. The MC analysis is just a very basic setup to get a rough idea of how a strategy performs by comparing luck vs skill. Don't over value it.

---

## 2021-09-01 22:43:27 - strategies channel

**Unknown**

It's self-generated from backtesting. This is from backtesting over about 4k recorded markets over the last 6months or so (2.5k which my strategy played on as you can see from this graph - markets x axis).

---

## 2021-09-01 21:22:39 - strategies channel

**Unknown**

Thanks [@U016TGY3676](@U016TGY3676) still at 0% on 10k iterations :+1:

I was also concerned by the 2k loss - but does a spikey graph necessarily mean the strategy needs more work? Or could it just be a strategy with a high variance but a good overall trend?

---

## 2021-09-01 20:56:54 - strategies channel

**Unknown**

Calling all Monte Carlo fans...

I have been developing a strategy and I am running it now over [@U016TGY3676](@U016TGY3676)’s MC analyser (which is great by the way thank you [@U016TGY3676](@U016TGY3676))

I'm getting 0% as a result and I'm wondering whether this is too good to be true or if it is indeed indicating a good strategy?

Any advice would be much appreciated.

---

## 2021-09-01 07:49:08 - general channel

**liam**

As the [https://liampauling.github.io/flumine/quickstart/#event-processing|docs](https://liampauling.github.io/flumine/quickstart/#event-processing|docs) describe you can filter by marketType



```strategy = ExampleStrategy(

    market_filter={"markets": [..], "market_type": ["MATCH_ODDS"]}

)```

This is done before the listener when adding the market, [https://github.com/liampauling/flumine/blob/f0e7e6542942d00685ceb6d72951456684998739/flumine/streams/streams.py#L43|here](https://github.com/liampauling/flumine/blob/f0e7e6542942d00685ceb6d72951456684998739/flumine/streams/streams.py#L43|here).

---

## 2021-08-31 10:57:14 - strategies channel

**Michael**

Whether your back-test results will cross over to real world profits will likely depend on how well thought out your strategy is. If your strategy is well reasoned then you just try it and see.



You know whether you can rely on your plots because you know how much data you have - I picked the plot above out of something that I'm working on because it's a nice typical example: You can see at a glace that the signal is predicting the profit of bets if they matched very nicely (the red line) but you can also see that that's not translating to actual profits quite as well, so maybe there's some pricing optimisation to do or maybe that's just the way it is (it does tend to be that way).

---

## 2021-08-31 09:46:45 - strategies channel

**Adrian**

[@UGV299K6H](@UGV299K6H) thanks for sharing your graphs. I'm still trying to think how I would apply that to my data. I have a strategy that is showing a strong profit on the backtests but I don't know if it means real world results. I haven't identified the the main variable within the set of parameters that is producing the profit, so perhaps that is the next step. How do you know you can rely on your graphs from a glance?

---

## 2021-08-31 07:08:03 - general channel

**Mo**

You seem to be missing something here. The market book is the fundamental collection of data that any strategy works off so of course flumine gives you access to that. I'm not a flumine user but a quick look at the examples shows that to write a strategy you overload functions like `check_market_book` and `process_market_book`. Everything revolves around it. The only reason you might want to convert it to a data frame is if you want to perform operations on it that are easier to do in pandas or more generally with the data in a tabular format

---

## 2021-08-31 07:00:43 - general channel

**Steve Roach**

I'm trying to find my way around the landscape here and some of the terminology is a bit unfamiliar. Please excuse me for asking a lot of dim questions.



The function you gave me (prices_file_to_data_frame) works very well; it takes a historic file and outputs a ladder to a flat file. It needs a bit of processing but it's close enough to do the job, so thanks for that. The next hurdle for me is to build the same ladder (which you call a market book) in real time and use that against any strategy I may have come up with. So, how do I get this market book? You have indicated that Flumine is not the thing for very good reasons, so where do I go for the market book? I have seen some bflw programs that mention it but the documentation is fairly sparse. Are you able to point me to an example program that converts the streaming data in real time in this way?

---

## 2021-08-31 01:00:15 - general channel

**Steve Roach**

Like this from Bet Angel. Not sure it would be practical to feed this in its entirety into a strategy every second or so, but certainly an extract of features from something like this.

---

## 2021-08-30 22:01:04 - general channel

**Steve Roach**

Ok. Out of curiosity, say your strategy relied on knowing the state of the ladder in real time. How would you maintain that data? I’m thinking , each time a streaming record arrived, a process added it to the end of the ladder. Looks like flumine would struggle with this. Is there something else?

---

## 2021-08-29 12:13:13 - strategies channel

**Adrian**

Maybe I just have the parameters wrong. But my strategy goes in one direction for greyhounds and the opposite direction for horses, but they are not really sport dependent. I am talking about strategies close to the off

---

## 2021-08-28 12:26:37 - general channel

**Lee**

yep and just make a strategy dependant on it existing/being set to the correct value

---

## 2021-08-28 12:23:40 - general channel

**Jono**

whats the best way to delay a strategy from starting in order to ensure the market blotter is filled, add_market_middleware have run, and allow workers to first execute? As far as im aware the first two should run prior to the strategy logic starting up but ceratinly with background workers there a few i would to have definietly run once before starting. Delaying the process_market_book and process_orders would also be a perfect solution with something like



If seconds_since_strat_start &lt; 10:

       return

else:

      ....



 but im struggling to get a global timer variable to work. Any help greatly appreciated thanks

---

## 2021-08-28 07:36:55 - general channel

**Mo**

It's the wrong tool for the job. It takes in either the live stream or historic data files and runs a strategy or strategies against that. It's for live trading or backtesting. It's not for data transformation or analysis

---

## 2021-08-27 13:42:42 - general channel

**Steve Roach**

Well, I have a load of streaming files and I would like to run them through Flumine and convert them into a ladder. I'm going to store this in a database for model development.



Of course, it doesn't HAVE to be Flumine, but I would like to use that as my main platform at the moment so as to learn my way around it.

---

## 2021-08-26 14:49:19 - random channel

**Michael**

If it's really vanilla (the sort of thing loads of people try) then I'd say go for it. Worst case you get caught and have to cough up some PC but really that's quite unlikely if it's a generic sort of strategy.

---

## 2021-08-26 14:33:57 - random channel

**Jonjonjon**

Has anyone ever had problems with giving away strategies to friends to manage? I've got a very baseline strategy that I don't have time to research/manage and was thinking of giving to a novice friend to manage and explore. But unsure if the powers at Betfair would take a dim view of it in relation to premium charges

---

## 2021-08-26 08:58:58 - general channel

**liam**

have a look at the [https://github.com/liampauling/betfair/blob/0dbd551272d66ea1e4efe8f8c695b54099567265/betfairlightweight/baseclient.py#L96|code](https://github.com/liampauling/betfair/blob/0dbd551272d66ea1e4efe8f8c695b54099567265/betfairlightweight/baseclient.py#L96|code) every time you set the sessionToken you reset the login time, yes making sure you keep_alive will prevent errors but just don't use that property if you are sharing tokens around trading objects

---

## 2021-08-26 08:48:12 - general channel

**Jono**

you underestimate my past self's ability to write poor code. I hope so anyway, more just a pain in the arse to go back and have to dig through it all but im sure putting in the effort at this stage and properly swapping everything over to bflw will make my life much easier. So just to clarify would carrying out the following actually solve my problem of not having to log in again?



```trading = APIClient([mailto:abc@mail.com|abc@mail.com](mailto:abc@mail.com|abc@mail.com), password, app_key=APP_KEY)

trading.set_session_token(SESSION_TOKEN)```

Just did some quick tests there and it looks as if i dont have to perform either login() or login_interactive() afterwards so it looks as if it just might be doing what i wanted it to

---

## 2021-08-26 08:33:34 - general channel

**Jono**

[@UBS7QANF3](@UBS7QANF3) betfair are getting on at me for logging in too many times and i dont blame them i need to go in and change the stuff i wrote back when i started and had no idea bflw existed. we are talking a session per request sort of business, nothing im too proud of. [@U4H19D1D2](@U4H19D1D2) so if i have the session token to hand would that be enough in a completely new environment to do something like:



trading = APIClient([mailto:abc@mail.com|abc@mail.com](mailto:abc@mail.com|abc@mail.com), password, app_key=APP_KEY, session_token=SESSION_TOKEN)

---

## 2021-08-26 08:28:21 - general channel

**liam**

catch the errors? use flumine? the sessionToken is stored in the trading object (nothing to do with requests) so you would need to persist to disk or similar

---

## 2021-08-26 08:13:41 - general channel

**Jono**

whats the best way to use an existing active login session after a crash or error has caused the most recent code run to fail or timeout? Ive seen you can pass the trading object a requests.Session that should allow for this but im not certain how i can pass this after an error that caused the code to halt and have to start from a blank slate. Is there a straightforward way of using the trading object from betfairlightweight to start things off again utilising an active session from the least information say login details, app_key and the session_token of the last successful login?

---

## 2021-08-25 08:32:15 - random channel

**Jonjonjon**

I read an article about Star Lizard a few weeks ago. In the early days, lots of employees placed their own bets, but it caused issues. I think there's now an internal syndicate that they can all join if they want to bet on the company's strategy (I might be wrong, it might be a different syndicate!).



Anyway, a lot of modelers wouldn't have the risk appetite to bet their own accounts, otherwise they would be already.

---

## 2021-08-25 07:44:12 - random channel

**Peter**

Also, it's unlikely that there's "a modeller" who has access to the whole process. I suspect that there will be a team who manage a significant data pipeilne covering a wide spectrum of data, with all the standardisation and cleansing that goes with it. So the modeller may have insight into the features being used, but not how the data arrives to him (or her). Moreover, if there's deep neural network at the core of this, it may be a black box anyway (though in the ad earlier in this thread, there was clearly a need for solid domain knowledge).

---

## 2021-08-25 01:15:04 - random channel

**Van**

Still doesn’t explain why an modeller couldn’t go and place bets.. bet placing doesn’t sound like a particularly niche job.

---

## 2021-08-24 22:54:45 - random channel

**thambie1**

I'd expect StarLizard has some internal models that they are only exposing the results of to traders, making it difficult for them to leave and replicate their success

---

## 2021-08-24 22:43:07 - strategies channel

**Steve Roach**

If the amount of time into a season is a feature, should it be incorporated into the ML model?

---

## 2021-08-24 22:28:15 - random channel

**Michael**

Anyone work for a bookmaker making models for prices and or risk management? Whats the work like and what type of background do most have?

---

## 2021-08-24 19:22:08 - general channel

**azevedo**

hey guys. testing the flumine market recorder on greyhounds. getting quite a few messages come through after more than an hour after market initially closed. seems to be mostly on FORECAST markets. I've investigated a few manually. Examples messages for one market below. If you have some editor like VS code to compare the two messages, you'll see that the only difference is the "pt" timestamp and that the latter message has "img": true attached to it. Everything else is the same. Any idea why this might be happing? there is of course the "force_update" field for this sort of thing, but seems that too many of these update are just the same initial closure. (no issue on the Flumine side, rather why Betfair might be doing this? and how are people setting the "force_update" and "market_expiration" parameters to tackle these sort of things?



```Initial closure message

{"op": "mcm", "clk": null, "pt": 1629820207534, "mc": [{"id": "1.186741004", "marketDefinition": {"bspMarket": false, "turnInPlayEnabled": false, "persistenceEnabled": false, "marketBaseRate": 5, "eventId": "30826229", "eventTypeId": "4339", "numberOfWinners": 1, "bettingType": "ODDS", "marketType": "FORECAST", "marketTime": "2021-08-24T15:48:00.000Z", "suspendTime": "2021-08-24T15:48:00.000Z", "bspReconciled": false, "complete": true, "inPlay": false, "crossMatching": false, "runnersVoidable": false, "numberOfActiveRunners": 0, "betDelay": 0, "status": "CLOSED", "settledTime": "2021-08-24T15:50:02.000Z", "runners": [{"status": "LOSER", "sortPriority": 1, "id": 38255840}, {"status": "LOSER", "sortPriority": 2, "id": 38255841}, {"status": "LOSER", "sortPriority": 3, "id": 38255842}, {"status": "LOSER", "sortPriority": 4, "id": 38255843}, {"status": "LOSER", "sortPriority": 5, "id": 38255844}, {"status": "LOSER", "sortPriority": 6, "id": 38255846}, {"status": "LOSER", "sortPriority": 7, "id": 38255847}, {"status": "LOSER", "sortPriority": 8, "id": 38255848}, {"status": "LOSER", "sortPriority": 9, "id": 38255849}, {"status": "LOSER", "sortPriority": 10, "id": 38255850}, {"status": "LOSER", "sortPriority": 11, "id": 38255852}, {"status": "LOSER", "sortPriority": 12, "id": 38255853}, {"status": "LOSER", "sortPriority": 13, "id": 38255854}, {"status": "LOSER", "sortPriority": 14, "id": 38255855}, {"status": "LOSER", "sortPriority": 15, "id": 38255856}, {"status": "LOSER", "sortPriority": 16, "id": 38255858}, {"status": "LOSER", "sortPriority": 17, "id": 38255859}, {"status": "LOSER", "sortPriority": 18, "id": 38255860}, {"status": "LOSER", "sortPriority": 19, "id": 38255861}, {"status": "LOSER", "sortPriority": 20, "id": 38255862}, {"status": "LOSER", "sortPriority": 21, "id": 38255864}, {"status": "LOSER", "sortPriority": 22, "id": 38255865}, {"status": "LOSER", "sortPriority": 23, "id": 38255866}, {"status": "WINNER", "sortPriority": 24, "id": 38255867}, {"status": "LOSER", "sortPriority": 25, "id": 38255868}, {"status": "LOSER", "sortPriority": 26, "id": 38255870}, {"status": "LOSER", "sortPriority": 27, "id": 38255871}, {"status": "LOSER", "sortPriority": 28, "id": 38255872}, {"status": "LOSER", "sortPriority": 29, "id": 38255873}, {"status": "LOSER", "sortPriority": 30, "id": 38255874}], "regulators": ["MR_INT"], "venue": "Hove", "countryCode": "GB", "discountAllowed": true, "timezone": "Europe/London", "openDate": "2021-08-24T12:57:00.000Z", "version": 3988988530, "priceLadderDefinition": {"type": "CLASSIC"}}, "_stream_id": 2001}]}



Another message after more than an hour after closure

{"op": "mcm", "clk": null, "pt": 1629825468969, "mc": [{"id": "1.186741004", "marketDefinition": {"bspMarket": false, "turnInPlayEnabled": false, "persistenceEnabled": false, "marketBaseRate": 5, "eventId": "30826229", "eventTypeId": "4339", "numberOfWinners": 1, "bettingType": "ODDS", "marketType": "FORECAST", "marketTime": "2021-08-24T15:48:00.000Z", "suspendTime": "2021-08-24T15:48:00.000Z", "bspReconciled": false, "complete": true, "inPlay": false, "crossMatching": false, "runnersVoidable": false, "numberOfActiveRunners": 0, "betDelay": 0, "status": "CLOSED", "settledTime": "2021-08-24T15:50:02.000Z", "runners": [{"status": "LOSER", "sortPriority": 1, "id": 38255840}, {"status": "LOSER", "sortPriority": 2, "id": 38255841}, {"status": "LOSER", "sortPriority": 3, "id": 38255842}, {"status": "LOSER", "sortPriority": 4, "id": 38255843}, {"status": "LOSER", "sortPriority": 5, "id": 38255844}, {"status": "LOSER", "sortPriority": 6, "id": 38255846}, {"status": "LOSER", "sortPriority": 7, "id": 38255847}, {"status": "LOSER", "sortPriority": 8, "id": 38255848}, {"status": "LOSER", "sortPriority": 9, "id": 38255849}, {"status": "LOSER", "sortPriority": 10, "id": 38255850}, {"status": "LOSER", "sortPriority": 11, "id": 38255852}, {"status": "LOSER", "sortPriority": 12, "id": 38255853}, {"status": "LOSER", "sortPriority": 13, "id": 38255854}, {"status": "LOSER", "sortPriority": 14, "id": 38255855}, {"status": "LOSER", "sortPriority": 15, "id": 38255856}, {"status": "LOSER", "sortPriority": 16, "id": 38255858}, {"status": "LOSER", "sortPriority": 17, "id": 38255859}, {"status": "LOSER", "sortPriority": 18, "id": 38255860}, {"status": "LOSER", "sortPriority": 19, "id": 38255861}, {"status": "LOSER", "sortPriority": 20, "id": 38255862}, {"status": "LOSER", "sortPriority": 21, "id": 38255864}, {"status": "LOSER", "sortPriority": 22, "id": 38255865}, {"status": "LOSER", "sortPriority": 23, "id": 38255866}, {"status": "WINNER", "sortPriority": 24, "id": 38255867}, {"status": "LOSER", "sortPriority": 25, "id": 38255868}, {"status": "LOSER", "sortPriority": 26, "id": 38255870}, {"status": "LOSER", "sortPriority": 27, "id": 38255871}, {"status": "LOSER", "sortPriority": 28, "id": 38255872}, {"status": "LOSER", "sortPriority": 29, "id": 38255873}, {"status": "LOSER", "sortPriority": 30, "id": 38255874}], "regulators": ["MR_INT"], "venue": "Hove", "countryCode": "GB", "discountAllowed": true, "timezone": "Europe/London", "openDate": "2021-08-24T12:57:00.000Z", "version": 3988988530, "priceLadderDefinition": {"type": "CLASSIC"}}, "img": true, "_stream_id": 2001}]}```

---

## 2021-08-24 16:58:45 - random channel

**Pierino S**

Don't think he was gunning for Hugh, but he has posted recently about these tipping people with affiliate links and they get revenues irrespective if the punter wins or loses, think that's more Caan message than the Tipster per se. Because punters may not how these models work and there's a lot of punters you can see who do follow these tipsters, so if they see a winning historical record, but they can never get that price, good someone told them.

---

## 2021-08-24 16:44:09 - general channel

**Jono**

hey everyone ive got a strategy built out in flumine that ive got to a stage where i'd like to increase the number of markets i place on to really test it out. So far ive kept it at one market for testing as this is my first flumine strat and very much needed to take the time to familiarise myself with the basics. I was wondering the following after recently attempting to place on two markets:



Does the process_orders function run independently for each market_id placed on or does it just run whenever there is an update on any executable order across all markets? I am looping through the "orders" list in this func currently and have been assuming only orders in the same market correlating to the update are being included with no check of my own. Will this be an issue if i dont include my own market_id check going forward inside process_orders?



Secondly i currently have the "max_live_trade_count" set to 1 and was assuming this would allow for 1 executable order per runner per market as suggested in the docs but im running into a problem that suggests im going over this from time to time. Am i wrong and does this variable actually apply across the whole strategy or should it function as i initially described?



Lastly, should the limits set up through "max_order_exposure= ", "max_live_trade_count=", "max_selection_exposure=" ... actually stop the placing of orders or cancel bets if their set values are exceeded?



Thanks for any help with the above its greatly appreciated! :grin:

---

## 2021-08-24 09:36:41 - general channel

**Adrian**

I see... so when you say it's a base class, it's still being used by the BacktestLoggingControl? And does that mean base strategy is also the same, it gets used when certain parts of a strategy call it?

---

## 2021-08-24 07:04:55 - strategies channel

**Steve Roach**

Ok, that’s no good. I was hoping to be able to build an initial history without having to pay at this stage. Of course, I’ll pay for access when I get closer to a live system but it’s all analysis and modeling at the moment.



Don’t suppose there’s a free way of building a history of pre-start Aus horse racing data?

---

## 2021-08-23 11:56:37 - strategies channel

**Mo**

You want to use a construct like



```with mock.patch("builtins.open", smart_open.open):

    framework.add_strategy(strat)

    framework.run()```

---

## 2021-08-23 11:02:55 - random channel

**Mo**

Here you go:



[https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723](https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723)

[https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175](https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175)

[https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458](https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458)

[https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522](https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522)

[https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X](https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X)

[https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139](https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139)

[https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975](https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975)

---

## 2021-08-23 08:59:40 - issues channel

**Adrian**

[@U4H19D1D2](@U4H19D1D2) its not critical, just warning but its "Order status update: Violation" so it's not placing bets, from what I can tell.

And i'm working on the better connection :wink::laughing: just want to salvage the data i have

&gt; {"asctime": "2021-08-23 07:23:18,428", "levelname": "INFO", "message": "Order status update: Violation", "market_id": "1.186624929", "selection_id": 35921733, "handicap": 0, "id": "138489961984286210", "customer_order_ref": "c6e3b6551008c-138489961984286210", "bet_id": null, "date_time_created": "2021-08-22 07:20:46.819000", "publish_time": null, "trade": {"id": "fd07dc9a-03e2-11ec-9864-1e0062368792", "strategy": "Backtest", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138489961984286210"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 6.8, "size": 5.0, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 5.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "", "market_notes": null}

---

## 2021-08-23 08:39:09 - general channel

**liam**

Hard to debug this, would have thought you would want this code in `strategy.process_closed_market` as this will be once the market has closed

---

## 2021-08-23 08:36:53 - issues channel

**liam**

Is that giving you a critical error? I (and many) separate data recording and strategy instances to prevent this, regarding the dropouts just get a better connection :wink:

---

## 2021-08-22 14:04:19 - strategies channel

**ShaunW**

If flipping a losing strategy was straightforward then this game would be easy. [@U9JHLMZB4](@U9JHLMZB4) is right about the sample size and like him I have losing days doing 3x that a day.

---

## 2021-08-22 10:10:26 - strategies channel

**Adrian**

it can pick up on micro movements better than a global model

---

## 2021-08-22 09:24:26 - strategies channel

**Oliver Varney**

A model per market doesnt really make much sense to me tbh, not sure what testing or validation would look like. If your enjoying the experience then keep going pal. If its a hobby and keep you interested then no reason to give up in my opinion.

---

## 2021-08-22 09:05:32 - strategies channel

**Unknown**

I'm not one of the top guys on here, but I'd prefer to go back to basics, and try to identify some sort of repeatable pattern manually. ML can be used to optimise the parameters.



I've recently started a new strategy from eyeballed parameters. The signal was clear enough for me to pick the parameters (initially) by hand (it's a 1-dimensional linear regression). The optimal parameters aren't that different to the fitted numbers.



Here's the first few datapoints. Linear regression works.

---

## 2021-08-22 08:57:11 - strategies channel

**Adrian**

100% and that's something i'm slowly coming to realise as i learn form you guys how you approach it. The whole strategy and execution side of things wasn't something I considered as a beginner

---

## 2021-08-22 08:54:36 - strategies channel

**Mo**

Sounds like you've fallen foul of focusing too much on making the predictions and not enough on the entire pipeline of developing a trading strategy. If your model is so computationally intensive you can't use it to backtest then it's not a very good model

---

## 2021-08-22 08:47:52 - strategies channel

**Adrian**

i struggled to build a global model that predicted anything valuable

---

## 2021-08-22 08:46:46 - strategies channel

**Mo**

And what's the theory for needing to do it that way rather than pre-training a global model across markets?

---

## 2021-08-22 08:42:18 - strategies channel

**Mo**

You train a new model for every market?

---

## 2021-08-22 08:38:04 - strategies channel

**Jonjonjon**

One mistake I've made, and that I've seen in many academic papers on trading, is that people throw a bunch of indicators at an ML model and expect it to find good results. Their findings are usually very weak.

---

## 2021-08-22 07:56:23 - strategies channel

**Mo**

I still don’t understand. Are you talking about training the model or making predictions? Surely the latter is very fast?

---

## 2021-08-22 06:26:17 - strategies channel

**Adrian**

Does it just mean my model is rubbish?

---

## 2021-08-22 06:25:39 - strategies channel

**Adrian**

I asked that question once in the BA forum and was told it doesn't necessarily work like that. I've also heard it's not the best place to get informed.



My issue is why would laying in both instances appear to beat BSP when the model is predicting the opposite outcome for each

---

## 2021-08-21 23:37:13 - issues channel

**Jeff Waters**

Thanks Jack.



That's a valid point, but since I wrote my original code, I have added the check_market_book() method, after Lee pointed out that it was missing: [https://github.com/JeffW12345/betfair-backtester/blob/master/teststrategy.py#L26](https://github.com/JeffW12345/betfair-backtester/blob/master/teststrategy.py#L26). Thanks for the suggestion, though.



I wonder whether I need to invoke the FlumineBacktest class, given that it contains an error handling method that calls process_market_book? [https://github.com/liampauling/flumine/blob/6f0541d2ba57ab0cbf9389a560e9a41d1ad01cfc/flumine/backtest/backtest.py#L141](https://github.com/liampauling/flumine/blob/6f0541d2ba57ab0cbf9389a560e9a41d1ad01cfc/flumine/backtest/backtest.py#L141)



I'm going to head in. Thanks for your help and patience, guys. :slightly_smiling_face: Night.

---

## 2021-08-21 23:27:46 - strategies channel

**Jonjonjon**

If you don't already have a working strategy, I wouldn't bother with ML. Human eyeballs are better.

---

## 2021-08-21 23:20:53 - strategies channel

**Adrian**

So my big idea of 3 months work has failed. I've tried multiple angles to get it working. Feelsbadman. I don't know what I can salvage from it, apart from some knowledge of how machine learning works and the general idea bflw/flumine. And being able to read/write Python came from learning all this too.



It was an ambitious project and a cool idea but in the end just didn't work out how i intended. I'm not sure where to go from here, whether to pursue ML from a completely different angle or just drop it altogether and focus on execution. I have some ideas around execution that I've seen while manually "trading" but feel too deflated at the moment to bother.

---

## 2021-08-21 23:11:52 - issues channel

**Jack**

Hey Jeff, this could be happening because you don’t have the `check_market_book()`  function. The role of that function is to decide whether or not you want to run the strategy over that market. If it returns True, `process_market_book()`  will execute and you will see your print statements; if it returns False, then it’s not going to execute.

It might be returning False by default so by not implementing it in your strategy you are saying no to each and every market that gets passed through.

---

## 2021-08-21 20:55:30 - issues channel

**Lee**

No, like this in the strategy class [https://github.com/liampauling/flumine/blob/720eb8168a18bbea62042d3fd0a67a0550b19e9e/examples/strategies/lowestlayer.py#L19|https://github.com/liampauling/flumine/blob/720eb8168a18bbea62042d3fd0a67a0550b19e9e/examples/strategies/lowestlayer.py#L19](https://github.com/liampauling/flumine/blob/720eb8168a18bbea62042d3fd0a67a0550b19e9e/examples/strategies/lowestlayer.py#L19|https://github.com/liampauling/flumine/blob/720eb8168a18bbea62042d3fd0a67a0550b19e9e/examples/strategies/lowestlayer.py#L19)

---

## 2021-08-21 20:53:47 - issues channel

**Jeff Waters**

Thanks Lee.



Do you mean adding it to the bottom of the process_market_books method, as in this example? [https://github.com/liampauling/flumine/blob/6f0541d2ba57ab0cbf9389a560e9a41d1ad01cfc/flumine/backtest/backtest.py#L141](https://github.com/liampauling/flumine/blob/6f0541d2ba57ab0cbf9389a560e9a41d1ad01cfc/flumine/backtest/backtest.py#L141)



I've just tried doing that - I've updated [https://github.com/JeffW12345/betfair-backtester/blob/master/teststrategy.py](https://github.com/JeffW12345/betfair-backtester/blob/master/teststrategy.py) - but I'm still having the same issue.

---

## 2021-08-21 20:30:26 - issues channel

**Lee**

Try adding the `check_market` method to the strategy

---

## 2021-08-21 15:15:43 - strategies channel

**S G**

```strategy = MarketRecorder(

    name="MATCH_ODDS",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["2"],

        country_codes=["GB"],

        market_types=["MATCH_ODDS"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/data",

        "force_update": False,

        "remove_file": False,

    },

)```



---

## 2021-08-20 20:26:14 - issues channel

**Jack**

That would be in the strategy Class. Example here of the order being created [https://github.com/liampauling/flumine/blob/720eb8168a18bbea62042d3fd0a67a0550b19e9e/examples/strategies/lowestlayer.py#L57](https://github.com/liampauling/flumine/blob/720eb8168a18bbea62042d3fd0a67a0550b19e9e/examples/strategies/lowestlayer.py#L57)

Your conditions will go in `process_market_book()` and it's up to you to bring into that whatever you need for your logic.

I'd recommend just taking a look at the LowestLayer example and if you know how, use the debugger in VSCode or Pycharm (other IDE's are available) to step through the code line by line. It's the best way to get a feel for what's actually happening.

---

## 2021-08-20 17:44:28 - general channel

**Unknown**

Thought I’d been lurking here long enough and about time to contribute something. Just got multiprocessing working over backtests quite nicely and though I would share.

It should figure out how many cores you’re on and pick a good amount of markets for each process.

Implemented a counter as well so you can track progress in a memory safe way across processes (`check_market_book()` in the strategy file) :+1:

---

## 2021-08-20 16:46:00 - issues channel

**Jeff Waters**

Thanks Jack - Much appreciated.



I am currently inheriting from BaseStrategy, but I think that inheriting from FlumineBacktest could work (though I could be wrong - Python isn't my forte, to put it mildly! :slightly_smiling_face:).

---

## 2021-08-20 13:32:08 - issues channel

**Jeff Waters**

In the flumine example code at [https://github.com/liampauling/flumine](https://github.com/liampauling/flumine), what is it that calls the _'process_orders(self, market: Market, orders: list)'_ method in the ExampleStrategy class?



I have created a strategy object as shown in the example, and tried to call the method using:



strategy.process_market_book(market, market_book)



However, I get told that 'market is not defined'. How do I create Market and MarketBook objects from the JSON data files that I'm using, so that I can pass them to this method?



Thanks



Jeff

---

## 2021-08-20 12:13:21 - general channel

**Jeff Waters**

Fair point, thanks.



From the responses, it sounds like stuff that isn't represented in the stats - such as a player having a high price because he's just come back from a period of injury or sacked his coach - doesn't account for all deviations from the model prices, and there is still value to be had?

---

## 2021-08-20 12:02:29 - general channel

**Mo**

More fruitful to think - "OK, this market is being priced up by Elo. What does Elo miss that I can capture with my own model?"

---

## 2021-08-20 11:52:46 - general channel

**thambie1**

[@U013K4VNB6D](@U013K4VNB6D) Yes, it's possible. If there's a good fundamental reason why the market deviates, then maybe you should incorporate that reason into your model...

---

## 2021-08-20 11:51:54 - issues channel

**Jeff Waters**

I have written a .py file, which I am trying to run.



I took the import statements from sample code on GitHub:



from flumine import BaseStrategy

from flumine.order.trade import Trade

from flumine.order.order import LimitOrder, OrderStatus

from flumine.markets.market import Market

from betfairlightweight.filters import streaming_market_filter

from betfairlightweight.resources import MarketBook

from flumine import FlumineBacktest, clients



I've also tried adding 'import flumine' to the top of that list, but that makes no difference.



I'm running the file by opening it using IDLE and then going Run &gt; Run Module.



Thanks

---

## 2021-08-20 11:48:04 - general channel

**Jeff Waters**

It is possible to profit based on models of what a market's price 'should' be - for example, 'based on Elo ratings, this tennis player is x% likely to beat that tennis player'? Or is it the case that there is generally a good fundamental reason when the market deviates from where the models say it 'should' be at?

---

## 2021-08-20 08:10:01 - issues channel

**Unknown**

Hi



I've written a program that imports flumine. However, when I try to run it, I get an error message:



*Traceback (most recent call last):*

  *File "C:\Bet-Project-Code\backtest.py", line 9, in &lt;module&gt;*

    *from flumine import BaseStrategy*

*ModuleNotFoundError: No module named 'flumine'*



I definitely have flumine installed, as when I go 'pip install flumine' via CMD, I get told that I have (see screenshot). Also, I've checked my Python version number using the powershell, and I am on version 3.8.10 (in case that's relevant).



What do you guys suggest?



Thanks in advance.



Jeff

---

## 2021-08-20 07:10:16 - issues channel

**Van**

Thanks.. interesting maybe I’ll look at tennis models instead of football.. I’m sure they both equally competitive markets by now.

---

## 2021-08-20 03:05:03 - issues channel

**Van**

&gt; I recently resurrected a strategy I started using in 2010. It’s looking good, on course for multiple six figures this year 

Wow! You trade racing I presume?

---

## 2021-08-19 20:27:44 - issues channel

**Mo**

I recently resurrected a strategy I started using in 2010. It’s looking good, on course for multiple six figures this year

---

## 2021-08-19 19:00:14 - issues channel

**Atho55**

[@UBS7QANF3](@UBS7QANF3) Your strategy must be too Gouda to be true

---

## 2021-08-19 18:56:09 - general channel

**Peter**

I achieve this by limiting both country and market types e.g.



```MAJOR = [

    "GB", # Great Britain

    'DE', # Germany

    'ES', # Spain

    'FR', # France

    'IT', # Italy

   ]



MINOR = [

    'BE', # Belgium

    'CH', # Switzerland

    'DK', # Denmark

    'FI', # Finland

    'GR', # Greece

    'IR', # Ireland

    'NL', # Netherlands

    'NO', # Norway

    'PL', # Poland

    'PT', # Portugal

    'RO', # Romania

    'RU', # Russia

    'SE', # Sweden

    'TR', # Turkey

    'AR', # Argentina

    'BR', # Brazil

    'MX', # Mexico

    'US', # United States

    'AU', # Australia

    'CN', # China

    'JP', # Japan

]



MARKET_TYPES =  ['MATCH_ODDS', 'HALF_TIME', 'CORRECT_SCORE', 'HALF_TIME_SCORE', 'BOTH_TEAMS_TO_SCORE', 'OVER_UNDER_15', 'OVER_UNDER_25', 'OVER_UNDER_35']



strategy = S3MarketRecorder(

    name="Minor Soccer Market Recorder",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["1"],

        country_codes=MINOR,

        market_types=MARKET_TYPES,

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/tmp",

        "bucket": "betfair-flumine",

        "force_update": False,

        "remove_file": True,

    },

)```



---

## 2021-08-19 15:55:30 - issues channel

**Mo**

Your sample size is 1. I'm running the same strategy now as in 2018

---

## 2021-08-19 11:20:51 - general channel

**mandelbot**

Also the strategy was on a different thread, perhaps this is why?

---

## 2021-08-19 10:37:08 - general channel

**mandelbot**

I was trying to use that but was getting 0 for

```sum(

    [o.size_matched for o in market.blotter if

     o.selection_id == runner.selection_id and o.side == "BACK"])```

even though there were bets in the market, i thought maybe because I was trying to pull orders from a different strategy?

---

## 2021-08-18 21:39:13 - general channel

**mandelbot**

How do I grab all orders across all strategies on a single market in a separate strategy?

---

## 2021-08-18 16:50:42 - general channel

**Jack**

on further investigation this seems to work just fine:

```with mock.patch("builtins.open", smart_open.open):

    framework.add_strategy(strat)

    framework.run()```

---

## 2021-08-18 16:28:12 - general channel

**Jack**

Has anyone found a nice way to pass *.gz market files straight to the market_filter for backtesting a strategy?

Wondered if I could get around decompressing and deleting markets as I backtest them using smart_open or something similar.

---

## 2021-08-18 13:39:42 - random channel

**Newbie99**

Orders appear to be clearing correctly and I'm just simply trying to verify the event is coming through correctly at the mo, not even trying to do anything clever yet.



Here are the logs:



```INFO:flumine.markets.market:Market 1.186458391 closed

{"asctime": "2021-08-18 12:01:04,265", "levelname": "INFO", "message": "Market 1.186458391 closed", "market_id": "1.186458391", "event_id": "30801039", "event_type_id": "7", "event_name": "Ballarat (AUS) 18th Aug", "market_type": "WIN", "market_start_datetime": "2021-08-18 11:57:00", "country_code": "AU", "venue": "Ballarat", "race_type": "Flat", "orders_cleared": false, "market_cleared": false, "closed": true}

INFO:flumine.baseflumine:Market cleared

{"asctime": "2021-08-18 12:01:04,266", "levelname": "INFO", "message": "Market cleared", "market_id": "1.186458391", "order_count": 31, "client": {"id": "78382e88", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 4, "transaction_count_total": 31, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x0000028CAC6449A0&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": true}, "markets": {"market_count": 249, "open_market_count": 240}, "streams": ["&lt;SimulatedOrderStream(SimulatedOrderStream, started daemon 20980)&gt;", "&lt;MarketStream(MarketStream, started daemon 1276)&gt;"], "logging_controls": ["&lt;ClosedMarketLogging(CLOSED_MARKET_LOGGING_CONTROL, started daemon 26460)&gt;"], "threads": ["&lt;_MainThread(MainThread, started 24220)&gt;", "&lt;Thread(Thread-1, started 24048)&gt;", "&lt;BackgroundWorker(get_live_orders, started daemon 12544)&gt;", "&lt;BackgroundWorker(get_price_change, started daemon 22728)&gt;", "&lt;BackgroundWorker(terminate, started daemon 26972)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 24260)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 8088)&gt;", "&lt;BackgroundWorker(poll_account_balance, started daemon 24856)&gt;", "&lt;BackgroundWorker(poll_market_closure, started daemon 25208)&gt;", "&lt;ClosedMarketLogging(CLOSED_MARKET_LOGGING_CONTROL, started daemon 26460)&gt;", "&lt;SimulatedOrderStream(SimulatedOrderStream, started daemon 20980)&gt;", "&lt;MarketStream(MarketStream, started daemon 1276)&gt;", "&lt;Thread(MarketStream_output_thread, started daemon 19184)&gt;", "&lt;Thread(ThreadPoolExecutor-0_0, started daemon 9736)&gt;", "&lt;Thread(ThreadPoolExecutor-0_1, started daemon 11932)&gt;", "&lt;Thread(ThreadPoolExecutor-0_2, started daemon 20068)&gt;", "&lt;Thread(ThreadPoolExecutor-0_3, started daemon 18468)&gt;", "&lt;Thread(ThreadPoolExecutor-0_4, started daemon 27360)&gt;"]}

INFO:flumine.baseflumine:Market closed

{"asctime": "2021-08-18 12:01:04,267", "levelname": "INFO", "message": "Market closed", "market_id": "1.186458391", "client": {"id": "78382e88", "exchange": "Betfair", "betting_client": "APIClient", "current_transaction_count_total": 4, "transaction_count_total": 31, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x0000028CAC6449A0&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": true}, "markets": {"market_count": 249, "open_market_count": 240}, "streams": ["&lt;SimulatedOrderStream(SimulatedOrderStream, started daemon 20980)&gt;", "&lt;MarketStream(MarketStream, started daemon 1276)&gt;"], "logging_controls": ["&lt;ClosedMarketLogging(CLOSED_MARKET_LOGGING_CONTROL, started daemon 26460)&gt;"], "threads": ["&lt;_MainThread(MainThread, started 24220)&gt;", "&lt;Thread(Thread-1, started 24048)&gt;", "&lt;BackgroundWorker(get_live_orders, started daemon 12544)&gt;", "&lt;BackgroundWorker(get_price_change, started daemon 22728)&gt;", "&lt;BackgroundWorker(terminate, started daemon 26972)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 24260)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 8088)&gt;", "&lt;BackgroundWorker(poll_account_balance, started daemon 24856)&gt;", "&lt;BackgroundWorker(poll_market_closure, started daemon 25208)&gt;", "&lt;ClosedMarketLogging(CLOSED_MARKET_LOGGING_CONTROL, started daemon 26460)&gt;", "&lt;SimulatedOrderStream(SimulatedOrderStream, started daemon 20980)&gt;", "&lt;MarketStream(MarketStream, started daemon 1276)&gt;", "&lt;Thread(MarketStream_output_thread, started daemon 19184)&gt;", "&lt;Thread(ThreadPoolExecutor-0_0, started daemon 9736)&gt;", "&lt;Thread(ThreadPoolExecutor-0_1, started daemon 11932)&gt;", "&lt;Thread(ThreadPoolExecutor-0_2, started daemon 20068)&gt;", "&lt;Thread(ThreadPoolExecutor-0_3, started daemon 18468)&gt;", "&lt;Thread(ThreadPoolExecutor-0_4, started daemon 27360)&gt;"]}```

Here is the code:



```import logging

from flumine.controls.loggingcontrols import LoggingControl

from flumine.events import events



logger = logging.getLogger(__name__)



class ClosedMarketLogging(LoggingControl):

    NAME = "CLOSED_MARKET_LOGGING_CONTROL"



    def __init__(self, *args, **kwargs):

        super(ClosedMarketLogging, self).__init__(*args, **kwargs)



    def _process_cleared_markets(self, event: events.ClearedMarketsEvent):

        [http://logging.info|logging.info](http://logging.info|logging.info)(event)

        for cleared_market in event.event.orders:

            [http://logging.info|logging.info](http://logging.info|logging.info)(cleared_market.profit, cleared_market.commission)```

I'm really hoping I'm unintentionally just doing something weird (which lets face it is normally the case)!!!

---

## 2021-08-18 10:00:03 - random channel

**Jonjonjon**

The chunking idea is probably good. I usually just apply a model to everything in the dataset.

---

## 2021-08-18 09:42:15 - random channel

**Jonjonjon**

Tom's got good knowledge. Yet another person telling me not to look at fundamental models.

---

## 2021-08-18 02:42:16 - strategies channel

**Adrian**

You don't need any theory if you can create a model that predict actual odds vs market odds. This is where my experimenting has taken me, from initially trying to predict price movements to now just predicting value. But I guess you have a different approach - top down vs bottom up

---

## 2021-08-18 02:31:40 - strategies channel

**Van**

I think this might be similar to slippage, which is relevant to algo (financial) trading. Not getting the quoted price. Some suggest adding 0.15% fee to model it, which might turn a strategy from profitable to lossmaking

---

## 2021-08-18 02:29:47 - strategies channel

**Van**

[@U01S1VB9X9P](@U01S1VB9X9P) I am actually a CS nerd in general :wink: What I’m missing is statistical modelling and gambling theory - i.e how to go about converting historical data into a probability.

---

## 2021-08-18 01:51:27 - strategies channel

**Van**

I think I see what you are saying. You need a model to output a probability in order to determine what is a good bet, and to find value between similar situations. In addition your model needs to be close to the true probability (i.e has ‘alpha’).. correct?

---

## 2021-08-17 15:45:03 - strategies channel

**D C**

The issue is this: what do you mean by "likely" ? You need to get a probability from that. Once you have a probability estimate you can use that to assess +/- EV. Now if you want to model the same thing only on games that are 0-0 at half time, then do that but the principle is the same. You need to decide what you mean by likely. You see this kind of stuff from people selling ebooks and "systems" where you won't hear or see the word "value" anywhere.

---

## 2021-08-17 15:38:01 - strategies channel

**Van**

[@UEA14GBRR](@UEA14GBRR) Sorry, I don’t quite understand what I’m missing.  I thought this is a common strategy that is/was profitable for beginners. Say I had a model that told me one of two teams are likely to score,  which would also be confirmed by inplay stats, why wouldn’t laying the draw at half-time and cashing out when a goal is scored (to lock in a profit) by a +EV bet? I guess I’m trying to reconcile gambling theory with googled material :wink:

---

## 2021-08-17 12:58:53 - issues channel

**Lee**

I'm guessing that's probably something todo with the listener_kwargs from whichever strategy is first

---

## 2021-08-17 12:52:35 - issues channel

**Jack**

On another note I did notice some odd behaviour when adding multiple strategies to one framework. If I run the below code and call `add_strategy()` twice, it seems to only run the first strategy that is added.

```...

# first strat should take longer

strategy = LowestLayer(

    market_filter={"markets": markets},

    max_order_exposure=1000,

    max_selection_exposure=105,

    context={"stake": 2},

)

# second strat should be faster

strategy2 = LowestLayer(

    market_filter={"markets": markets,

	"listener_kwargs": {"inplay": False, "seconds_to_start": 600}},

    max_order_exposure=1000,

    max_selection_exposure=105,

    context={"stake": 2},

)



# add both strats

framework.add_strategy(strategy)

framework.add_strategy(strategy2)



# run framework

start = time.process_time()

framework.run()

end = time.process_time()

...```

when adding the strategies in this order it takes 20seconds (same time as only running ‘strategy’)

```framework.add_strategy(strategy)

framework.add_strategy(strategy2)```

however in this order it takes 10seconds (same time as only running ‘strategy2’)

```framework.add_strategy(strategy2)

framework.add_strategy(strategy)```

---

## 2021-08-17 12:27:17 - issues channel

**Jack**

Hi everyone, I hope that this is the right place for this question.



I believe that my backtests are running much slower than they are supposed to after reading some of the posts here. [@U4H19D1D2](@U4H19D1D2) mentioned that Flumine is capable of running 1000's markets a minute out of the box, and I am getting something more like 1 market per second or worse.



To check what was is going on I am running a slightly modified flumine example `backtest.py` (added `"listener_kwargs"` and removed logging to speed things up).



```import time



from flumine import FlumineBacktest, clients

from strategies.lowestlayer import LowestLayer



client = clients.BacktestClient()



framework = FlumineBacktest(client=client)

markets = ['data/1.181018785', 'data/1.181018790', 'data/1.181018780', 'data/1.181018795']



strategy = LowestLayer(

    market_filter={"markets": markets,

	"listener_kwargs": {"inplay": False, "seconds_to_start": 600}},

    max_order_exposure=1000,

    max_selection_exposure=105,

    context={"stake": 2},

)



framework.add_strategy(strategy)



start = time.process_time()

framework.run()

end = time.process_time()



print("time taken: ", end-start)```

Output:

`time taken:  10.760373999999999`



I have run this on two machines now, one is a 2017 Macbook Pro, the other is a pretty beefy Desktop rig with an intel 9600k CPU and 16GB of RAM. Both have similar results.



Appreciate if anyone knows whether this is expected or if I am not set up correctly. Thanks!

---

## 2021-08-17 11:07:28 - strategies channel

**jp**

For a strategy to be profitable you need to take +EV bets. Why do you believe that laying 0-0 half time for these matches (at any price?) is a +EV bet? Why do you believe that trading out after the first goal is a +EV bet?

---

## 2021-08-17 11:00:56 - strategies channel

**Van**

Would this be a viable strategy?

1. Use ML or other method to determine fixtures to predict high likelihood of one or both teams scoring.

2. If 0-0 at half time, lay the draw.

3. Trade out as soon as the first goal is scored.

---

## 2021-08-17 09:20:52 - strategies channel

**Van**

No.. I’m very new.. My initial idea was a trading bot that

1. consumes football stats

2. analyses price time series

3. ???

4. Profit… :sweat_smile:

---

## 2021-08-17 09:11:46 - strategies channel

**Jonjonjon**

Do you do much price action trading on football? I've found the price movements a bit too smooth for my models.

---

## 2021-08-17 09:04:21 - strategies channel

**Van**

[@UPMUFSGCR](@UPMUFSGCR) I’m in the same position, except with football. I want to start algorithmic betting. I’m reading up on football models like dixon-coles, etc. There was a thread above which indicates most people use price, which is interesting..

---

## 2021-08-17 08:54:23 - strategies channel

**liam**

Depends, some have entire teams on each individual part, infra/data/model/execution and some are one man bands doing it all themselves and not far off syndicate levels. I personally think experience is the most important factor in how long something like this would take.



But tbh play to your strengths, if you aren't an expert in fundamental modelling do you really want to try and compete with those that are?

---

## 2021-08-17 08:43:00 - strategies channel

**Jonjonjon**

Suppose someone new to fundamental modelling wanted to start on UK Horse Racing.



How much of a project would it be to:



• Get historical form data and odds, for developing a model.

• Getting up-to-date data, feeding that into a model, lining up that data with Betfair markets/selections, then placing bets?

---

## 2021-08-17 04:06:09 - strategies channel

**Adrian**

i've got `trading.betting.list_cleared_orders` but i don't know how to implement it

---

## 2021-08-16 23:10:23 - strategies channel

**admiral**

Would you not need a stream of live data to keep the data your feeding into your model for predictions up to date?

---

## 2021-08-16 17:13:46 - strategies channel

**Jonjonjon**

How would someone running a horse racing model actually decide when to place a bet? Would they need to rely on technicals at that point?

---

## 2021-08-16 15:42:40 - strategies channel

**Van**

What type of models do you employ and for what sport? Care to share an example ?

---

## 2021-08-16 15:04:38 - issues channel

**Will**

Thanks Liam. Seems better now. It does raise the problem (my problem) of not having a timeout in place for `trading.login()` - curious to know what others do in these situations

---

## 2021-08-16 12:01:07 - strategies channel

**Van**

Dumb question, are you all trying to model outcomes of sports, or making bets based on the flow of market data..?

---

## 2021-08-16 10:51:18 - issues channel

**liam**

[@U01U24AG35W](@U01U24AG35W) this is now fixed in the latest releases, depending on the data package used, bflw:

```listener = StreamListener(

    calculate_market_tv=True,

    cumulative_runner_tv=True,

)```

flumine:

```strategy = LowestLayer(

    market_filter={"markets": markets, "listener_kwargs": {"calculate_market_tv": True, "cumulative_runner_tv": True}},

)```

---

## 2021-08-16 06:37:19 - strategies channel

**Adrian**

yeah if i feel like it's worth it to keep going i will. i've got a feeling looking at the post-commission versions of these graphs is going to tell me exactly why my balance is going down not up, and that's going to put a real dent in my motivation since this is the only strategy i have left that's going up before commission

---

## 2021-08-16 06:04:29 - strategies channel

**Unknown**

Second question, I'm struggling to get my balance heading in the right direction with this one strategy. Even though these graphs are promising. They are my actual results over 10 days and it's only using $5 stakes so there's lots of potential. But every time I try and scale it up it heads in the wrong direction.



You can see in the first graph (backing) the last couple of days where I tried to increase the stakes it went against the trend, also the biggest dip in the middle. I haven't really touched the laying side of things (second graph). With commission, these profits basically evaporate and I've had trouble implementing hedging. Any pointers how I can scale this up? I've thought maybe being more selective with my bets so I'm not paying commission so often? Any tips/help/pointers appreciated :hugging_face:

---

## 2021-08-15 05:41:23 - issues channel

**mandelbot**

Are you using BFLW to place bets or Flumine? You have to specify a liability and some maximum odds you want to be matched at for a LimitOnCloseOrder. Some sample code if placing a bet in BFLW



                     `limit_on_close_order = filters.limit_on_close_order(`

                            `liability=500, price=100)`

                     `instruction = filters.place_instruction(`

                            `order_type="LIMIT_ON_CLOSE",`

                            `selection_id=runner.selection_id,`

                            `side="LAY",`

                            `limit_on_close_order=limit_on_close_order,`

                        `)`

                     `place_orders = trading.betting.place_orders(`

                            `market_id=market_id, instructions=[instruction]  # list`

                        `)`

---

## 2021-08-15 01:38:27 - issues channel

**AR**

Hi

I am trying to place my first set of bets through the API, using  BFLW, and am getting a failure response. The error code is:

placeBackBet(trading, market_id, selection_id, 5, min_odds)

Bet Place on selection 22511750 is FAILURE

```{'elapsed_time': 0.7760229110717773, '_datetime_created': datetime.datetime(2021, 8, 14, 22, 19, 1, 765910), '_datetime_updated': datetime.datetime(2021, 8, 14, 22, 19, 1, 765910), '_data': {'status': 'FAILURE', 'errorCode': 'BET_ACTION_ERROR', 'marketId': '1.186418033', 'instructionReports': [{'status': 'FAILURE', 'errorCode': 'INVALID_ODDS', 'instruction': {'selectionId': 22511750, 'limitOnCloseOrder': {}, 'orderType': 'LIMIT_ON_CLOSE', 'side': 'BACK'}}]}, 'market_id': '1.186418033', 'status': 'FAILURE', 'customer_ref': None, 'error_code': 'BET_ACTION_ERROR', 'place_instruction_reports': [&lt;betfairlightweight.resources.bettingresources.PlaceOrderInstructionReports object at 0x00000150A20C8DC0&gt;]}```

seems the error is INVALID_ODDS - however I have used code from the  github to do the rounding, and I can physically place bets on the

website using the price increments I have rounded to. Also, I can run this as a LIMIT order with no issues - so seems I am doing something wrong in specifying a Limit On Close. Does anyone have some example code of placing a LIMIT_ON_CLOSE order?

---

## 2021-08-14 21:35:10 - random channel

**Michael**

You might be in a better position than you think [@UEA14GBRR](@UEA14GBRR), if you've been running a relatively low margin strategy without many changes on a lot of markets you should have a great data set. You'll have a good mix of -EV to +EV bets to work with and not too many strategy changes to confound your analysis. I'm a big believer in working with your bets and refining/developing what you have - you'll have a potential treasure trove of new ideas hidden in the learning you can take from your betting history.



You've got routes in too - let's say you know that you do better in AUS markets (for example) well why? Ok you might say it's thinner volume but that's not really the answer - why exactly does that make a difference? There must be some market characteristic that is more common in those AUS markets that's making the difference. Is it wider spreads? Is it that more of your bets match as offers? Something to do with differential match rates at different odds? Something else? What is it? If you can identify that you'll understand your betting much better and you're sure to be able to develop new approaches from what you find. For an easy start you could find the niches in UK racing that share that critical characteristic and you could cut out all the junk bets where those circumstances don't pertain. Ditching your bad bets is always the lowest fruit.



Quite often people who've had small scale success* either don't understand WHY their strategies make money or they think they understand but they're wrong. That's the key to greater success - (well one of the possible keys). If you can unlock the mechanisms that have returned your profit the the doors really open.



*I don't know you so please forgive me if I'm miss-describing you, I'm just going by my sense from your posts and I mean no dis-respect, small success is far more than the vast majority achieve.

---

## 2021-08-14 17:03:53 - random channel

**ShaunW**

[@UGV299K6H](@UGV299K6H) I realise I'm probably too far towards the similarities. I'd do well to spend more time looking at asset species. :slightly_smiling_face:  I do try to break things down of course to see what's working it just seems with my little strategy I can't make the differences pay. I've been in maintenance mode too long really, enjoying the small fruits, it's time for some new thinking or ideally rehashing other people's thinking.

---

## 2021-08-14 14:34:47 - random channel

**Michael**

Yeah [@UEA14GBRR](@UEA14GBRR) I'm also not interested in the sport - what I really meant was that AUS and UK markets aren't the same in the same way that a horse market isn't the same as a greyhound market. Yes you can treat them the same and if your strategy is generic enough you might win on both but you're not making the most of either. You're doing better on thin markets right? So that shows you that thin markets aren't just scaled down liquid markets. I guess you're working to understand why you're finding that?

---

## 2021-08-14 12:12:23 - random channel

**Laybot McBackbot**

[@UGV299K6H](@UGV299K6H) I would define that consistently profitable with a strategy that a couple of losing bets wouldn't wipe the entire or large amount of the profit made. In other words, if you can confidently do this as your only source of income -- then you've probably cracked it.

---

## 2021-08-14 11:31:28 - general channel

**Michael**

I guess then, in terms of volume how much are you guys all betting / day / week? Guess its dependent on strategy

---

## 2021-08-13 22:27:31 - random channel

**Gazuty**

Cracked aus racing from the getgo. Took me almost 10 years to figure out uk/ire racing :flushed: - for me different strategy than aus racing. Cracked aus and uk dogs about 5 years ago. Used to do US racing but the market moved on the edge that I had. 

---

## 2021-08-13 20:19:28 - random channel

**Michael**

....I'm thinking of a whole other strategy where you use your pre-off model to predict the value of in-running prices, nothing to do with your existing positions.

---

## 2021-08-13 17:13:17 - general channel

**Michael**

Is there a minimum amount of betting activity I need to do in order to stream and collect data? Obviously I imagine there is some minimum as I doubt they will just let me scrape data, if so, how much do i need to do? All my models are crap but can't stomach paying for pro data lol

---

## 2021-08-13 09:07:50 - general channel

**Unknown**

Hi Mo Yes there must be some documentation online that explains these specific errors. Anyway you can still login without the certificate if you want to keep working on your code. Just use the `trading.login_interactive()`  function instead of  the `trading.loogin()`  function and comment out `certs=certs_path` in the

```betfairlightweight.APIClient( username=my_username,

password=my_password,

app_key=my_app_key,

#certs=certs_path

)    ```

 function. See screenshot image attached. Screenshot image is take from: [https://github.com/liampauling/betfair](https://github.com/liampauling/betfair)

---

## 2021-08-13 09:07:26 - general channel

**Unknown**

Hi Mo Yes there must be some documentation online that explains these specific errors. Anyway you can still login without the certificate if you want to keep working on your code. Just use the `trading.login_interactive()`  function instead of  the `trading.loogin()` * *function* *and comment out* *`certs=certs_path` in the

```betfairlightweight.APIClient( username=my_username,

password=my_password,

app_key=my_app_key,

#certs=certs_path

)    ```

* *function. See screenshot image attached. Screenshot image is take from: [https://github.com/liampauling/betfair](https://github.com/liampauling/betfair)

---

## 2021-08-13 06:40:45 - random channel

**Adrian**

[@UGV299K6H](@UGV299K6H) thanks for the reality check. This is my conscience on one hand, telling me there are greener pastures. My problem is, I think, quitting too often and not following through. Which is why I haven't given up on this thing.



[@UQL0QDEKA](@UQL0QDEKA) thank you for the word of encouragement. 2007 sure is ahead of my time. I heard the profits were pretty easy to find back then. My strategy is well thought out. I think it's cutting edge, but it's like a solution looking for the right problem.



[@UPMUFSGCR](@UPMUFSGCR) I enjoy learning new things and trying what others won't, so yeah better than World of Warcraft, which embarrassingly was what I was doing before this :joy: I think I started with the manual trading around 18 months ago. With python 6 months. Given the length of time others have been around I guess that means I'm still new so I should lower my expectations.



Thanks everyone, I feel better about what I'm doing. I've noticed this tendency of mine to have a moan right at the pivotal moment when a breakthrough is imminent. Had a good night and today is looking good too. I might have turned things around :crossed_fingers:

---

## 2021-08-12 11:27:09 - random channel

**PeterLe**

I honestly said that if I were to ever start losing money, i would stop immediately. I only put £2k into my account in 2007 and never added to it and Ive done very well on it overall.

I was very lucky really that I got off to a flyer and made a fair bit of money and i have a sense of ‘using betfair money’ so im not too worried if I have a losing day. (nor am I reliant on it as an income)

I think it would be a completely different scenario if I had never made any money and i had a coupe of children to support and a big mortgage though.

The only thing id say [@U01S1VB9X9P](@U01S1VB9X9P) is dont give up too soon though. If you have a well thought out strategy, and offering to the market, you wont lose too much even betting at random in my experience.

---

## 2021-08-12 11:04:56 - general channel

**Oliver Varney**

```import betfairlightweight

from flumine import Flumine, clients



trading = betfairlightweight.APIClient("username")

client = clients.BetfairClient(trading)



framework = Flumine(client=client)```



---

## 2021-08-11 13:49:02 - issues channel

**birchy**

Ok, so let's say that someone (not me) was developing a semi-automatic strategy where they initiate trades manually and then have a Flumine/bflw strategy hedging their bets, would there be a way for them to also load the manually placed orders?

---

## 2021-08-11 11:41:12 - strategies channel

**Michael**

Whilst [@UEA14GBRR](@UEA14GBRR)'s approach isn't strictly optimal I can see why it might make sense for where he's at. However once you've reached a point where you're more consistent paying to minimise comm is markedly disadvantageous which is why it's not generally advocated. Comm naturally minimises itself as you improve your betting and as the winnings stack up that can become a problem in itself. I don't think anyone should pile up comm for the future at the cost of taking money home in the here and now but if you're thinking ahead it doesn't make sense to reduce it either.

---

## 2021-08-11 08:17:54 - strategies channel

**Peter**

[@ULDAVFDRP](@ULDAVFDRP) Might I gently suggest that you're confusing Greening Up with hedging. Hedging is just about removing risk. So my strategy returns mostly zeros. A few positives and fewer negatives (if the BSP moves against) so overall a small profit with minimal risk.

---

## 2021-08-11 08:12:20 - strategies channel

**Peter**

Oh yes, there's that. I have one strategy that uses hedges and had to constrain it to only work withi odds ranges where the hedge was actually possible. So sorry, don't know of a way around it.

---

## 2021-08-10 17:49:13 - general channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) does Flumine have a flag to tell us when the market orders have been loaded? Or is there a way to pause strategy calls until the orders have been processed?

---

## 2021-08-10 16:39:31 - general channel

**Newbie99**

Maybe I'm missing the obvious here, but if the blotter was genuinely 0 length (i.e. had no orders), then wouldn't the above mean the strategy never initialises?

---

## 2021-08-10 16:16:35 - general channel

**birchy**

Could run that in any of the functions that have the market object as an input. I would probably stick it in `check_market_book` and return False until blotter is initiated, then set a strategy flag like `self.initiated=True` or whatever.

---

## 2021-08-10 16:06:25 - random channel

**birchy**

If you need me to verify the strategy code, please send it over [@UQL0QDEKA](@UQL0QDEKA). :smiling_face_with_3_hearts: :rolling_on_the_floor_laughing:

---

## 2021-08-10 15:21:31 - general channel

**Jono**

bit of a strange one i would like to perform a single run of the logic in my "process_orders" function at the start of the flumine strategy run in order to perform some actions involving "EXECUTION_COMPLETE" orders. The reason being ive managed to get the logic of the strat im testing in a semi working condition and a large part of it involves placing follow up bets inside the process_orders func. However when im restarting the strat very often the orders that came before are matched and are therefore no longer causing this function to run. Additionally none of these bets are of the "EXECUTABLE" status so i cant rely on the 0.25s auto run. In essence this means no other follow up bets are placed for the strat. Any ideas how best to go about fixing this problem either through an initial sort of forced run of "process_orders" or otherwise? Cheers!

---

## 2021-08-10 13:50:28 - random channel

**birchy**

Hopefully be ok and not what I call a "WM" strategy. :grinning:

---

## 2021-08-10 13:27:02 - strategies channel

**gbettle**

Yes, I've found another flaw already in the strategy. Hope I'm not taking up too much of your time - I really appreciate the comments \ input. It's a brilliant script

---

## 2021-08-10 13:25:13 - strategies channel

**birchy**

Either way, that strategy has no edge.

---

## 2021-08-10 12:00:17 - strategies channel

**birchy**

Tidy. That strategy needs some work. It's currently worse than random betting. :grinning:

---

## 2021-08-10 10:50:06 - general channel

**Peter**

Another pattern that works well for me is when strategies are similar, I parameterise them and pass the parameters in the context dictionary passed to each strategy when it's instantiated.

---

## 2021-08-10 10:48:03 - general channel

**Peter**

Not sure is this is answering your question, but I have a strategy that encapsulates some code patterns that I use repeatedly. It inherits BaseStrategy and is in turn inherited by my individual strategies.

---

## 2021-08-09 20:29:55 - strategies channel

**S G**

Am I missing something here, I created a simple strategy with market filter for a specific market id

---

## 2021-08-09 19:21:37 - general channel

**mandelbot**

there's a marketrecorder strategy you could use to do just that [https://github.com/liampauling/flumine/tree/master/examples](https://github.com/liampauling/flumine/tree/master/examples)

---

## 2021-08-09 17:42:34 - general channel

**Aaron Smith**

if you dont inherit BaseStrategy, you ll just end up having to write way more code to bascially write it yourself again

---

## 2021-08-09 17:42:08 - general channel

**Aaron Smith**

this can easily be done while inheriting BaseStrategy

---

## 2021-08-09 17:41:43 - general channel

**S G**

is there any genericstrategy that supports configuration

---

## 2021-08-09 17:41:24 - general channel

**S G**

instead of inheriting BaseStrategy class everytime for a new strategy

---

## 2021-08-09 17:31:54 - general channel

**S G**

instead of writing code for every strategy

---

## 2021-08-09 17:31:43 - general channel

**S G**

With Flumine is it possible to configure strategy rules?

---

## 2021-08-09 16:27:52 - general channel

**Peter**

Betfairlightweight is a wrapper around the Betfair API. flumine is a trading framework that uses betfairlightweight to interact with Betfair.

---

## 2021-08-09 16:21:29 - general channel

**Mo**

Continue to adjust in my opinion (as someone whose original trading platform was written in Java and is now in Python)

---

## 2021-08-08 22:52:58 - strategies channel

**birchy**

MC is as simple as comparing your actual P&amp;L to what it would be if you had no strategy and simply bet on random runners. I'm awaiting this to be release: [https://www.amazon.co.uk/dp/B093BDGHXT/ref=cm_sw_r_cp_apa_glt_AGBPESG0VJBT2WGZGFG7|https://www.amazon.co.uk/dp/B093BDGHXT/ref=cm_sw_r_cp_apa_glt_AGBPESG0VJBT2WGZGFG7](https://www.amazon.co.uk/dp/B093BDGHXT/ref=cm_sw_r_cp_apa_glt_AGBPESG0VJBT2WGZGFG7|https://www.amazon.co.uk/dp/B093BDGHXT/ref=cm_sw_r_cp_apa_glt_AGBPESG0VJBT2WGZGFG7)

---

## 2021-08-08 20:22:49 - strategies channel

**Jonjonjon**

I didn't do microstructure stuff, but I traded futures via a basic model and staring at the limit order book. There's not much difference.

---

## 2021-08-08 13:31:16 - strategies channel

**Oliver Varney**

It looks from that chart that someone "model" said the price was too short they they laid heavily probably taking it in a few big matches from the bars.

---

## 2021-08-08 13:29:41 - strategies channel

**Dave**

Also, what if your model says fair value at the moment is 1.7? (Unlikely given how tight and deep this market is, but you might be smart)

---

## 2021-08-08 13:26:41 - strategies channel

**Jonjonjon**

Why would certain games cause a big loss? I tend to have a max risk per strategy and like to keep it small.

---

## 2021-08-08 13:25:34 - strategies channel

**thambie1**

Modelling edges usually have variance. I make bets and stick with them. Can lose big on some games

---

## 2021-08-08 13:24:45 - strategies channel

**Jonjonjon**

What sort of consistency can those models deliver? Is it possible to be profitable every day of the week?

---

## 2021-08-08 13:22:12 - strategies channel

**thambie1**

From a price action stand point, I imagine it would be a tough market. Both me and [@U0128E7BEHW](@U0128E7BEHW)  have some kind of modelling edge

---

## 2021-08-08 11:49:36 - strategies channel

**Dave**

&gt;  would be great to see the results if you created two models, your normal one, then one including these and just set the stakes to minimum.

hmm yeah, or even a model including friendlies _only_ if I can source some more historical data as there are very few samples currently, or bring in some league-invariant features from other leagues and let it loose on small stakes.

---

## 2021-08-08 11:47:56 - strategies channel

**Unknown**

these Friendly games are dying out, they're roughly 2.5% of games currently and excluding them from the model also means excluding them from betting so it's as if they never happened (and the hypothesis is that the presence of them does not have some predictive ability on performance in competitive leagues). The top chart is total number of games per day across all competitions in my dataset, and the bottom is Friendlies only

---

## 2021-08-08 11:44:04 - strategies channel

**Oliver Varney**

would be great to see the results if you created two models, your normal one, then one including these and just set the stakes to minimum.

---

## 2021-08-08 11:38:22 - strategies channel

**Dave**

I will just exclude them and see how my models fare, it's unlikely to have a significant effect on margins on turnover/pnl volatility, and hopefully any effect is positive :smile:

---

## 2021-08-08 11:24:38 - strategies channel

**Dave**

Yeah that's a good question for me - nope I don't model individual player performance. I guess the real question is what should I expect to be similar between team A vs B in a friendly league when compared to team A vs B in a competitive league. I don't follow football enough (or much at all really) to know this nuance, but perhaps it might be more common domain-specific knowledge for more religious football followers.

---

## 2021-08-08 11:11:14 - strategies channel

**Mo**

I suppose an equivalent question would be do you model individual player performance

---

## 2021-08-08 11:08:23 - strategies channel

**Dave**

[@UBS7QANF3](@UBS7QANF3) - yup. I guess similar principles apply in tennis - I currently do not have much intuition on the usefullness of data from friendly matches, but they do seem to have some adverse effect on my models (at least given my current feature set).

---

## 2021-08-08 10:33:36 - strategies channel

**birchy**

So the 18% is basically how many times you would of won more than £1k by betting on random runners. It's also an indication of how many times you _wouldn't_ of ended up with that profit. The lower the %, the better as that indicates skill vs luck. Ideally it should be &lt; 5% and preferably &lt; 1%. It's not uncommon for a good strategy to be 0% over a large sample of bets.

---

## 2021-08-08 10:04:45 - strategies channel

**thambie1**

As far as I can tell, you and I are the only ones doing football on this slack. And the type of modelling I'm doing, a few odd matches here or there doesn't matter.

---

## 2021-08-08 09:50:44 - strategies channel

**Dave**

those trading football - are you doing anything to your models to exclude any performance from the recent international friendlies matches?

---

## 2021-08-07 23:18:45 - strategies channel

**John**

Hi [@U016TGY3676](@U016TGY3676) many thanks for the MC script. I just ran it for my bet history file of the past 7 days (happen to have a +£1000 P&amp;L). The result says the MC beats strategy 1800 times in 10,000 runs (18%). Sorry I haven't worked on MC before. Not sure how to interpret it. Does it mean my +£1000 is sitting at the right handside of the P&amp;L distribution (82 percentile = 1-18%), so I am pretty lucky (as it's not at the mean or median)? Any handy way I could output P&amp;L distribution of the 10K runs quickly I wonder?

---

## 2021-08-07 18:48:49 - strategies channel

**S G**

Any github repos worth mentioning about specific sport strategy like tennis etc?

---

## 2021-08-07 15:12:16 - random channel

**Jonjonjon**

Any idea what would happen if a strategy was sold to a syndicate, in terms of PC? The strategy would be turned off on the original account and turned on, from another account?

---

## 2021-08-07 15:04:28 - random channel

**Jonjonjon**

If 3 different accounts run the same strategy, would Betfair notice, and subsequently put them on the higher PC rate after they've made £250k each, or as a group?

---

## 2021-08-07 11:56:24 - random channel

**azevedo**

To add to Mo’s on Pinnacle topic, you have the behaviour where Pinnacle shows you a maximum amount for a single bet at any given time, and if you take that max you would move their lines. And Pinnacle are very good at setting those limits and margins depending on time to event/activity/their models etc. For example, from Marco Blume’s description, they would be open to take much larger bets in the middle of a baseball season as they more confident with their models vs earlier in the season. So I’d imagine there is a combination of all these factors that they optimise and set appropriate limits and margins throughout the event lifecycle.

---

## 2021-08-07 11:48:01 - random channel

**Oliver Varney**

They sound like a pretty good pricing model for other bookies to copy (adding in a higher margin)

---

## 2021-08-07 11:44:52 - random channel

**Oliver Varney**

interesting, I can see why they dont do horses with this model (assuming its not regulatory)

---

## 2021-08-07 11:44:52 - random channel

**Mo**

From listening to Marco Blume speak they probably also have good models so they're close to that true price to begin with

---

## 2021-08-07 11:38:46 - random channel

**Oliver Varney**

kinda off topic of the original thread, but could someone explain pinnacles business model? Ive herd people say they can bet very large amounts without getting banned or limited, but is this true in reality?

---

## 2021-08-07 11:28:45 - strategies channel

**Michael**

It totally depends on what kind of markets you're betting in. For what [@U4H19D1D2](@U4H19D1D2) and I do every penny counts, in other scenario's it'll be different scales but the mechanisms are the same. As a broad brush: If you have a big modelling, speed or data edge then you'll be a bit less stake sensitive because you'll be taking all you can get whereas if you're more about betting off market dynamics phenomena you'll be more so.

---

## 2021-08-07 11:23:16 - strategies channel

**PeterLe**

Yea that was an extreme example! I know for instance that you can get different results running a second instance using exactly the same program (Stakes etc) on the same system. I guess this is why is is so difficult to model and understand completely. I was surprised that £2 to £4 would be so significantly different though?

---

## 2021-08-07 10:59:29 - random channel

**Mo**

Some advice regarding the banking situation:



1. If you can organise your betting activity such that each individual has their own betting account and earns their own betting profits this greatly simplifies matters. To distribute profits you can rotate the account being used or use all accounts simultaneously. There are bound to be some imbalances in individual profit earned but hopefully these will even out over time and require much more modest balancing payments at the end of the year

2. You _may_ have more success using an e-money provider (e.g. Revolut) rather than an actual bank (with a banking license)

3. If you do use a bank, probably better to distribute by withdrawing cash but the individuals may have problems with their own banks when depositing

---

## 2021-08-07 10:38:36 - random channel

**Mo**

You don't need to go through any kind of formal setup procedure. The biggest question is how are you going to distribute profits? Will you have one account doing the betting or will each member have their own account?

---

## 2021-08-06 18:48:23 - strategies channel

**Michael**

[@U016TGY3676](@U016TGY3676) As far as I'm concerned optimising execution is mostly just deciding what prices and sizes to bet at. There are a couple of little tricks that can help but price and size is most of it. Some people look for speed edges but that's a specialist thing and honestly beyond most of us - it's certainly beyond me so I choose my battles. The basics of it are totally obvious - if you lay too long you lose on the price and if you lay too short you don't get matched so it's finding the optimum. Mostly I try to do that with graphs and I use quite a bit of randomisation but it's always rather unsatisfactory. Likewise stakes. Similarly obvious dynamics and similar strategy. It's not unusual for beginners to assume that they can take a model that makes a bit of money on small bets and scale it in a linear way to make life changing returns but it should be quite obvious to a moderately smart person that that's not how it works. I don't think anyone who's ever posted on here would make such a moronic mistake and if they did I certainly wouldn't point and laugh.



The other sorts of questions you're thinking about would be whether to spread your bets over a range of prices, whether there's a back equivalent for your lays on another runner, that sort of thing. There are some tricks to do with delaying bets and there are some other sprinkles but that's most of it.

---

## 2021-08-06 17:39:29 - strategies channel

**birchy**

I'm probably asking this question on behalf of others who are too scared to ask because they don't want to appear foolish...but how would someone (myself included) go about learning how to "optimise execution", "model EV", etc? For me, it may just be the terminology that's confusing, but I also feel like I'm somehow overlooking market fundamentals that I _should_ know already...

---

## 2021-08-06 15:06:07 - strategies channel

**liam**

[@UGV299K6H](@UGV299K6H) going back to what you are saying, I agree, however your style/scenario is very specific where modelling EV and your execution are intrinsically linked, from what you describe to me I would say you are 100% execution and the +ev is a byproduct :joy:

---

## 2021-08-06 14:39:20 - strategies channel

**liam**

Would make a good section in the strategy FAQ :wink:

---

## 2021-08-06 14:37:20 - strategies channel

**gbettle**

I googled and found this [https://www.pinnacle.com/en/betting-articles/Betting-Strategy/how-to-analyse-your-betting-history-with-monte-carlo-simulation/W2M2YAWJHUW5LUZ5](https://www.pinnacle.com/en/betting-articles/Betting-Strategy/how-to-analyse-your-betting-history-with-monte-carlo-simulation/W2M2YAWJHUW5LUZ5)

---

## 2021-08-06 14:16:23 - strategies channel

**Michael**

[@UPMUFSGCR](@UPMUFSGCR) the question for me is: How are you deriving your fair value? You can just assume that ltp == 0EV and bracket that price with offers, you'll certainly be posting value bets. Then your task is to understand in what circumstances you'll get enough noise to get matched at a rate sufficient to overcome adverse selection. Fine - but is that the best you can do? If you can improve your estimate of 0EV you'll do a lot better even if the 'bracketing' is the essence of your strategy.

---

## 2021-08-06 13:45:27 - strategies channel

**Dave**

It's difficult to generalise this I think. For example, in football you have new leagues starting every few weeks in all sorts of regions....I spend a fair bit of time maintaining models for so many leagues, investigating if a model is ready to be deployed for a recently started league etc. Per-league effort is probably quite small but it adds up, and then you need time for execution optimization, and r&amp;d into new features. Maybe racing markets are more stable in this regard (idk). This is coming from a truly fundamental approach.

---

## 2021-08-06 11:51:52 - strategies channel

**Oliver Varney**

I do take alot, my journey I feel is still relatively young and that optimisation will hopefully happen over the winter into next year. I wouldnt recommend anything I do as something to follow! :joy: initially my focus was on modelling yes, now its shifted more into designing a faster, more scaleable architecture (probably at the slight harm of the models), which is a working progress

---

## 2021-08-06 11:45:30 - strategies channel

**Michael**

I think of you ([@ULDAVFDRP](@ULDAVFDRP)) as being an example of the sort of person who priorities modelling value over anything complicated execution wise - as I recall you're basically taking available money a lot? So you really need an accurate price and you've got to out perform the market but once you've done that you're filling your boots. Or have I got that wrong?

---

## 2021-08-06 11:42:16 - strategies channel

**Oliver Varney**

I think on the "model" building side (coming from a ML perspective), id partially agree with the statement that its easy, but thats once you got it working in the first instance. Im sure no matter of everyones current size most peoples first model didnt work. Once you finally cracked it variations are easy yes, but I wouldnt describe an new original idea (that completely changes the way you go about it) isnt exactly easy.

---

## 2021-08-06 11:25:21 - strategies channel

**Michael**

Hmmm. I'm gonna half agree - I mean whatever you do you have to get matched or it's all pointless but different types of approach might or might not depend on clever models. Knowing that a value price has just matched for someone else isn't the same as getting one matched for yourself, so in that sense modelling is easy but then what are you trying to model?

---

## 2021-08-06 11:11:43 - strategies channel

**liam**

talk to any of the syndicates, model building is easy

---

## 2021-08-06 11:10:53 - strategies channel

**liam**

execution is the most important part of any strategy, yeah iceberg is one type

---

## 2021-08-06 11:04:24 - strategies channel

**liam**

I think it is very dependant on where your edge lies, my weak link is strategy development so my focus is on execution, infra/ease of deployment, rt analysis and speed (probably in that order)

---

## 2021-08-06 10:17:09 - strategies channel

**PeterLe**

I think there are many on here in the same boat [@U01S1VB9X9P](@U01S1VB9X9P); ie not having any experience in programming (nor Python)

Going off at at tangent slightly but keeping on the topic of being new to python, Ive been lucky in that Ive had a quiet time at work, so ive been able to invest some time in learning python, which I have enjoyed doing.

What Ive found is that people are very open to helping others (thanks [@U016TGY3676](@U016TGY3676) and [@UUCD6P13J](@UUCD6P13J) in my case and [@USYQKE5HN](@USYQKE5HN) explanation of OOP using a teapot analogy :grinning:), but only when you have put some effort in yourself and put some 'spade work in'

Quite often you will see a .."how do I do this"..and the response is "what have you tried so far and have you looked at the examples". That is a very fair comment.

(Im not saying this is true in your case by the way; I'm just talking in general)

Ive finally got a working strategy going about a week ago and bolted a few new bits onto it. Its not doing as well as my main stuff but its working and making money, so to anyone who's completely new; you CAN do it, but it isnt going to happen overnight

Just one last thing; Im sure there are some super complex programs out there, but in my experience a well though out simple one can be just as effective so you dont need to be a python guru, good enough is good enough

---

## 2021-08-05 19:11:01 - strategies channel

**S G**

I m a newbie for flumine and betfairlightweight. I would like to setup a simple strategy, any ideas on where to start?

---

## 2021-08-05 15:12:43 - random channel

**Jonjonjon**

Could be useful for models based on trading prices just before the race starts.

---

## 2021-08-05 11:50:37 - random channel

**liam**

logic [https://github.com/liampauling/flumine/blob/4f6fa1b9a2ab4c70f6bcec5888a012c17d47a3c0/flumine/controls/tradingcontrols.py#L168|here](https://github.com/liampauling/flumine/blob/4f6fa1b9a2ab4c70f6bcec5888a012c17d47a3c0/flumine/controls/tradingcontrols.py#L168|here), quick lookup using this function:



```current_exposures = market.blotter.get_exposures(

    strategy, lookup=(market_id, selection_id, handicap), exclusion=exclusion

)```

---

## 2021-08-04 14:17:21 - strategies channel

**Jono**

If a stream ending error is encountered during a flumine strategy, should restarting the same strategy in the same environment allow for it to pick up exisitng bets where it left off? for example i am currently holding a partially matched back position in a market and part of the strategy is to either lay this same selection/cancel remaining amount but a crash (not related to flumine) occurred. Im wondering how to incorporate this back bet into the strategy from the earliest point proceeding the restart, as previous testing i have performed have shown that flumine starts from a blank slate upon starting up again.



Additionally is it safe to open a seperate thread within process_market_book/process_orders or is this best to do with a background worker? Id like to send requests to a separate api every minute or so

---

## 2021-08-04 09:57:11 - strategies channel

**Adrian**

how long should you let a losing strategy run before you cut it off?

---

## 2021-08-04 07:06:36 - strategies channel

**Unknown**

here is a diagram of my latest strategy:

---

## 2021-08-03 09:50:39 - random channel

**Oliver Varney**

in the example of a horse stat, when its null it just means it hasnt run, so in a model a default value for runs = 0. I can also see other cases where maybe it doesnt make sense though

---

## 2021-08-03 09:46:30 - random channel

**liam**

But doesn't that then make error handling harder? As I assume its easy to send a null value through to a model but if the entire class is null you would have to handle?

---

## 2021-08-03 09:40:51 - random channel

**Peter**

My philosophy on this sort of thing is that your objects are models of something happening in real-life, and so should broadly follow the real-life structure. Thus if you discover that an object or attribute of an object doesn't exist, mark it as None at that level, rather than constructing lower levels reflecting what would be there if it existed. This has the advantage of potentially saving some CPU cycles by catching no-existence higher up the tree.

---

## 2021-08-03 08:22:14 - general channel

**thambie1**

Depends. If you're strategies require any kind of model building, I think it's worth paying pretty early on. Assuming you value your time, and are taking this seriously. I regret not spending the money sooner, would have saved me many weeks if not a month or two.

---

## 2021-08-03 08:10:05 - general channel

**Mo**

I wouldn’t recommend someone just starting out to dump thousands on a load of PRO data for backtesting. Just put together a simple strategy so you are actually placing live bets then record the data yourself. This seems to be the canonical way to get started 

---

## 2021-08-03 03:31:54 - strategies channel

**ShaunW**

It was [@U01LD279D16](@U01LD279D16) (i think :slightly_smiling_face:)..but I'm not sure I said much you probably didn't already know.   The trouble with charts is that they can be like fractals, you never quite know what part you're looking at and at what zoom level. Even grim times lived in real-time can be not much more than a ripple after a year or two.  I once saw an interview with a quant, and worked with a few too back in another life, strategy death despite being the subject of plenty of research is very much a finger in the wind job, and that inexplicable 'feel' you get from experience. Taking on a comment from [@UGV299K6H](@UGV299K6H) and my own limitted experience, they tend to fade rather than do an about turn so maybe that's just a bit of random weirdness. Good luck with it, no easy anwsers that I know of.

---

## 2021-08-02 22:52:49 - general channel

**Michael**

And other than officially from betfair, there are no other ways I can get this data? Also, if you don't mind how many months of data did you require in order to backtest your strategy

---

## 2021-08-02 21:35:59 - strategies channel

**Unknown**

[@U01LD279D16](@U01LD279D16) my MC simulation will give you basic stats, P&amp;L graphs, ROI, etc but more importantly, it'll tell you how your strategy fairs compared to picking random runners. Given that the markets are generally efficient over a large sample, then picking at random should be roughly = 0EV pre-commission. It's very basic, but does the job it was intended for. [@UQL0QDEKA](@UQL0QDEKA) loves it, if you hadn't guessed already. :grinning:

It just needs to be pointed at a BetHistory.csv file of settled bets, which you can download from your Betfair account.

---

## 2021-08-02 19:25:44 - strategies channel

**Peter C**

That's really cool. I'm impressed you held your nerve through that but it gives me some reassurance to let my strategy run. I'm sure you were pleased to see it return to normal!

---

## 2021-08-02 19:16:26 - strategies channel

**Peter**

It had been thoroughly analysed and then backtested before going live, so I was pretty confident that it was a solid strategy and the first 20k of bets rather backed that up. Couldn't see anything in the market that had changed fundamentally, so kept the faith that it was just a bad run, and it's back doing what I would generally expect it to do.

---

## 2021-08-02 18:55:48 - strategies channel

**mandelbot**

Down about 1k on this strategy for the last 3 months

---

## 2021-08-02 18:24:35 - strategies channel

**Jonjonjon**

No. A back-to-lay strategy. But I had a deployment issue and it stopped laying the long odds.

---

## 2021-08-02 18:24:32 - strategies channel

**mandelbot**

I'm in the same boat although maybe a bit in the deeper end. Sitting on 2k losses this month on a strategy with on average 1.8% better than SP. It can be definitely be hard to eat the losses but I find it hard to let go of a strategy that's been backtested heavily + beating SP.

---

## 2021-08-02 18:18:36 - general channel

**Michael**

From a newbies perspective, seems like a large investment to make up front without understanding whether you have a strategy which will perform. How do you self record? I've got experience with web scraping but I imagine since betfair sell the data they would be against this and proxies etc can be just as expensive

---

## 2021-08-02 17:29:43 - strategies channel

**Peter C**

When I say lost 10% of expected value I mean 10% of the total value since strategy start calculated as ((price_matched / sp) -1) * matched_size. I have been closing at SP since I am relatively new so my loss in profit is the same 10% of total. When I say that the strategy hasn't taken value I mean in comparison to SP it has been behind, whereas before it was ahead. The last 150 bets have been 25% worse against sp than the preceding 1000

---

## 2021-08-02 17:27:58 - strategies channel

**Michael**

Assuming you haven't changed your strategy it doesn't really make sense to say that your bets before had value and your recent ones don't.

---

## 2021-08-02 17:18:55 - strategies channel

**Peter C**

That's not a bad idea. I have backtested over approximately 6000 recorded markets so I'm not sure whether I feel that further backtesting would change my opinion of the strategy or not to be honest, unless I get my hands on enough data to make a sensible comparison

---

## 2021-08-02 17:11:57 - strategies channel

**thambie1**

When I first started and was concerned about my strategy's performance, I'd just buy more backtest data :sweat_smile:. Can never have too much data

---

## 2021-08-02 17:09:28 - strategies channel

**Jonjonjon**

I'm not one of the top guys here. So maybe my advice won't be the best. But I tend to bet very small relative to my bank and have several parameterizations of similar models, so it is quite rare to have downturns that significantly impact my overall PnL.

---

## 2021-08-02 16:55:30 - strategies channel

**Peter C**

Hi all. I've been running a horse racing strategy pre-off. It's placed ~1000 bets over almost as many markets at a healthy edge against sp, and had been remarkably consistent. However, over the last three days the strategy hasn't taken any value at all. Although in total the strategy is still ahead, this 'correction' has cost about 10% of total expected value. I'm concerned that I have fallen into the trap of 'it looks like it works for a month then blows up in your face'. I'm not really sure what my question is but I'm curious about other people's experiences in similar situations. I suppose I will have to wait and see if the strategy resumes positive returns.

---

## 2021-08-02 13:34:56 - general channel

**river_shah**

Second [@UBS7QANF3](@UBS7QANF3) I wasted plenty of time with advanced data. Don’t do it. For any serious modelling work you will need `PRO` or self recorded

---

## 2021-07-31 09:04:44 - issues channel

**Jonjonjon**

There might be a variable along the lines of strategy_selection_orders in the blotter, which could be faster than looping over all orders.

---

## 2021-07-30 16:24:16 - issues channel

**Dirk**

Hey guys. A couple of days ago I tried to login to the API for the first time. I am using Python on windows and used XCA to make the certificates. At the moment of logging in, using the following code, I get an error:



`trading = betfairlightweight.APIClient(username=my_username,`

                                          `password=my_password,`

                                          `app_key=my_app_key,`

                                          `certs=certs_path)`

`trading.login()`



The error I get is (this is only the last part of the error code, it is way bigger than this):

`APIError: None` 

`Params: None` 

`Exception: HTTPSConnectionPool(host='[http://identitysso-cert.betfair.com|identitysso-cert.betfair.com](http://identitysso-cert.betfair.com|identitysso-cert.betfair.com)', port=443): Max retries exceeded with url: /api/certlogin (Caused by SSLError(SSLError(9, '[SSL] PEM lib (_ssl.c:4022)')))`



I've heard from others that it might have to do with the certificates, but I redid the full process like it is prescribed on the manual. Is there anyone with any tips/followup questions?

---

## 2021-07-30 13:05:12 - issues channel

**liam**

yeah use a proper IDE for strategy / dev and jupyter for modelling / data analysis

---

## 2021-07-30 09:40:06 - issues channel

**Peter**

It's a balance between searching in your editor / IDE and understanding the structure of the code so knowing where to look. As you work more with the code, you move progressively from the former to the latter. A good place to start to understand all the data available are the classes in BFLW's bettingresources.py script.

---

## 2021-07-30 09:33:55 - general channel

**Peter**

No widely accepted way. It has been discussed in the past, and people broadly fall into three camps:

1. reverse engineer the website's cash out endpoint and hit that

2. write your own, not difficult and I believe that code has been posted here in the past

3. "never green up" (not really relevant to your strategy).

but nothing built into BFLW or Flumine.

---

## 2021-07-30 09:17:24 - issues channel

**Andy B**

I had the same thing a couple of days ago.  Some markets don't have place betting and throw this same error when you try.  Is it possible that you tried to place a bet type that doesn't exist?

---

## 2021-07-30 07:55:13 - general channel

**Peter**

This sounds like a scalping strategy, which would be low risk, but relies on the pairing of back and lay bets to keep it that way. Placing the back bet first keeps the risk down as the liability is smaller on anything with odds &gt; evens.

---

## 2021-07-30 07:20:05 - general channel

**Jono**

What constitutes a live order in flumine - is it an order that has a unmatched amount on a market yet to resolve? As i want to place a follow up bet each time the previous one is matched in the order back, lay , back, lay, back.... so on i was wondering will i have to adjust the max_live_trade_count to something very high in order to do this?



And are orders retrieved in the process_orders function listed in a p[articular way consistently eg placed time descending? Additionally if there is some consistent ordering does this also apply to selection_orders/strategy_orders orders retrieved via the market.blotter so i know when iterating? Thanks for any help everyone :grin:

---

## 2021-07-29 19:30:57 - general channel

**PeterLe**

incoming newbie question..Took a while, but my first full day of running Flumine on an account :grinning: (small profit too). If I wanted to run the same strategy (slightly different triggers) on a second account , would I simply copy the program; give it a different file name and then run that separately? (the way I ran the file was : I just pointed to the relative file path and pasted it in file manager and it opened a terminal C:\windows\Py.exe. Im not sure if this is the correct way to do it (Seemed to work OK)? Sorry for the very basic question. Thanks in advance

---

## 2021-07-28 08:38:13 - general channel

**bb**

[@U01J98RDHRN](@U01J98RDHRN) Another good way of getting a bit of insight into what is going on in "black box" models calculating/looking at the SHAP values. It gives a bit more of a detailed view than looking at the feature importances.



This library is a pretty good start for getting up and running



[https://github.com/slundberg/shap](https://github.com/slundberg/shap)

---

## 2021-07-28 07:15:34 - general channel

**Adrian**

applying the model in other words

---

## 2021-07-28 07:09:45 - general channel

**Adrian**

[@U01J98RDHRN](@U01J98RDHRN) i'm in a similar camp. i think the hardest part about any ML is figuring out what it's trying to tell you. Building the models, feature engineering and all that is the easy part

---

## 2021-07-27 22:30:54 - general channel

**Sam Asin**

In terms of "right" thing to do I'm not sure about best practice for modeling etc. with xgboost and all that, but for me as like a personal development "best practice" to be able to do a good job in general with these things and also get satisfaction out of doing them, I wanna have some idea what's going on I think. I'm sure there's plenty of room for people to have success in whatever way though :slightly_smiling_face:..

---

## 2021-07-27 22:29:43 - general channel

**Sam Asin**

For what it's worth, I did just run predictions, and then spot checked two points, and it does seem to me like the final prediction just has a constant/intercept term added of .5. Just in case others run into similar problems or get curious about how these things work. So, my model has all these negative leaf values, but the predictions are ultimately all of those + .5

---

## 2021-07-27 22:26:56 - general channel

**Dave**

The "right" thing to do is to interpret your models of course and disect them, but unfortunately XGBoost doesn't make it easy. If you are keen on interpretable tree models, maybe look at Random Forest? Generally given the same set of features, a RF model and a XGB model will have similar predictive ability. It is quite easy to plot trees from RF though and visualize them with graphviz. Maybe it could be a good first step before moving onto xgb

---

## 2021-07-27 22:12:15 - general channel

**Dave**

There are a billion and one tutorials written by kagglers which give decent tips on hyperparameter tuning and measuring model performance

---

## 2021-07-27 22:10:58 - general channel

**Dave**

I have generally accepted that if you have, say, more than 10 features then you might as well consider your XGBoost model a black box and it becomes quite difficult to interpret. I'd lump it in with neural nets with multiple hidden layers etc. Idk if anyone else here spends time interpreting their trees but IMO if it does well out of sample and you've been clean with your modelling approach then you are probably good to go. With that being said, the sklearn api for XGBoost exposes "feature importances" - I'd definitely analyse these and ensure they somewhat make sense.

---

## 2021-07-27 18:54:17 - general channel

**PeterLe**

Folks, quick question please..First time I ran a live strategy (Whoop!)...but placed a bet deliberately low at 1.03..If I stop the program to edit the code and then restart it, does it somehow keep a live connection (ie am I in danger of  having too many connections if I stop and start it regularly? Thanks

---

## 2021-07-27 12:29:47 - strategies channel

**liam**

To answer your question the orders are in the blotter, so you can get them by either



```selection_orders = market.blotter.strategy_selection_orders(self, selection_id, handicap)```

```strategy_orders = market.blotter.strategy_orders(self)```

---

## 2021-07-27 12:26:03 - strategies channel

**Jono**

I am working on bringing a strategy to flumine which involves backing then laying. What would be the best way to place the follow up bet once the first one has been matched? Would it be from the "process_orders" function once the back order is no longer of executable status and fully matched or from the "process_market_book" routine (but cant think how i would determine if the first order is matched from this func)? Or is there some other better way i havent considered? Any help is greatly appreciated. Cheers :grin:

---

## 2021-07-26 23:13:37 - general channel

**Unknown**

Hi [@UBS7QANF3](@UBS7QANF3), thanks for your reply. I changed 3 things in the script (so I used the downloaded script and didn't add my own strategy): 1) added `from multiprocessing import Process, freeze_support` at the top; 2) added

```if __name__ == '__main__':

    freeze_support()```

at line 65; and 3) pointed `root_folder` to my data folder with the 3 bz2 files and removed (at line 77 ) `if x.endswith('.bz2')` . The error message I have from pycharm is:

`The above exception was the direct cause of the following exception:`



`Traceback (most recent call last):`

  `File "C:\betfair\API\bf_betting\backtest_multi_orig.py", line 96, in &lt;module&gt;`

    `all_dfs.append(future.result())`

  `File "C:\Users\User\AppData\Local\Programs\Python\Python39\lib\concurrent\futures\_base.py", line 438, in result`

    `return self.__get_result()`

  `File "C:\Users\User\AppData\Local\Programs\Python\Python39\lib\concurrent\futures\_base.py", line 390, in __get_result`

    `raise self._exception`

`UnicodeDecodeError: 'charmap' codec can't decode byte 0x81 in position 41: character maps to &lt;undefined&gt;`



If I switched to the folder with decompressed files, it is working fine (placing orders from the laylowest example strategy). So I asssume the file format/compression is the problem (I could well be wrong). Any pointers will be highly appreciated.

---

## 2021-07-26 20:48:02 - strategies channel

**Aaron Smith**

This feels a lot like my experience with In-Play. I also was able to place bets that would be profitable once in the market, but getting them in the market was a pain. Say the odds where shown at back 5; 6 lay and i would place a back bet at 8 (which is obviously, according to the market, value at this moment), but in that second the bet takes to be placed, a lot can happen, so i had like 5%-10% of bets just being utterly terrible once they ve reached the market turning the whole thing in a +/- 0 strategy

---

## 2021-07-26 20:47:59 - strategies channel

**Beeblebrox**

[@U4H19D1D2](@U4H19D1D2), no I'm going to look at other factors to see if they point to why they're bad bets. It's a fairly simple strategy, it just takes the current prices to work out a fair price for each runner, so there's certain to be room for improvement.  The fact it's actually in profit though is a start.

---

## 2021-07-26 20:40:45 - strategies channel

**thambie1**

Is there an in-play delay for horse racing? If not, I'd suspect that someone's taking strategy may be firing upon seeing your bets

---

## 2021-07-26 20:34:31 - strategies channel

**Unknown**

Hi, I have an in-play market making horse racing strategy which has been running for 75days now and placed bets in 1500 markets. It's my first one in in-play, so it's fairly selective in what it bets on and was really just a way to get some bets in the market to see what happened.



It's in profit, but if I plot time executable v cumulative profit you can see from the graph that bets which get matched in less than 0.1seconds are unprofitable.  I'm trying to work out what makes those bets unprofitable, but is the 0.1 seconds significant in some way, as it seems suspicious to me that it's pretty much bang on 0.1 seconds where it flips from unprofitable to profitable?  Or is it just randomly at 0.1 that it occurs and I shouldn't read too much into it?

---

## 2021-07-26 20:14:09 - general channel

**Matthieu Labour**

Here is my use case. On disk, I have market book data that look like `{"op": "mb", "clk": null, "pt": 1626986519.301084, "mc": [{"id": "1.185558123..."` . Please, do note pt. When replaying them w/ flumine/backtest, `publish_time` will be None [https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L587](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L587). I tested the change above and it fixes the issue.

---

## 2021-07-26 12:35:14 - general channel

**liam**

well its a fully functional trading framework, bflw is just an API wrapper

---

## 2021-07-24 11:41:28 - general channel

**Jono**

Is flumine set up to be able to pick up orders already placed in the event of a stream ending error? Similarly is there a way of using it to process generic orders placed ie bets placed through the api not placed using flumine for a strategy or those placed on the exchange manually

---

## 2021-07-24 11:34:24 - general channel

**Jono**

Traceback (most recent call last):

pythonbbauto-skrimming_1  |   File "/usr/local/lib/python3.9/site-packages/flumine/utils.py", line 233, in call_process_orders_error_handling

pythonbbauto-skrimming_1  |     strategy.process_orders(market, strategy_orders)

pythonbbauto-skrimming_1  |   File "/usr/src/app/syndicate_middleware/syndicateMiddlewareMain.py", line 232, in process_orders

pythonbbauto-skrimming_1  |     market.cancel_order(order)

pythonbbauto-skrimming_1  |   File "/usr/local/lib/python3.9/site-packages/flumine/markets/market.py", line 84, in cancel_order

pythonbbauto-skrimming_1  |     return t.cancel_order(order, size_reduction)

pythonbbauto-skrimming_1  |   File "/usr/local/lib/python3.9/site-packages/flumine/execution/transaction.py", line 69, in cancel_order

pythonbbauto-skrimming_1  |     order.cancel(size_reduction)

pythonbbauto-skrimming_1  |   File "/usr/local/lib/python3.9/site-packages/flumine/order/order.py", line 314, in cancel

pythonbbauto-skrimming_1  |     raise OrderUpdateError("Current status: %s" % self.status)

---

## 2021-07-24 09:22:41 - general channel

**Jono**

i was wondering the best way/practice to cancel any unmatched bets on a market using flumine? The reason i am asking is that although i am aware that the runner context should only allow 1 active bet per market per selection, upon running the strategy i am currently testing out it seems to place another order. Thus i would like to cancel the unmatched bet placed previously by the strategy so i dont unnecessarily increase my exposure whilst getting to grips with flumine. Below is the codfe i belived should have cancelled any outstanding orders i have but this is causing errors at "market.cancel_order(order)". Any help very much appreciated thank you!



`def process_orders(self, market, orders):`

`        [http://logging.info|logging.info](http://logging.info|logging.info)("Processing orders: %s"%(orders))`

        `for order in orders:`

`    `

            `try:`

`                [http://logging.info|logging.info](http://logging.info|logging.info)("Order: %s"%(order.__dir__))`

                `for key, value in order.__dict__.items():`

`                    [http://logging.info|logging.info](http://logging.info|logging.info)("%s : %s"%(key, value))`

            `except:`

`                [http://logging.info|logging.info](http://logging.info|logging.info)("Couldn't log order dict in method above")`





            `if order.status == OrderStatus.EXECUTABLE:`

`                [http://logging.info|logging.info](http://logging.info|logging.info)("Order executable")`



            `market.cancel_order(order)`                

`            `

`            [http://logging.info|logging.info](http://logging.info|logging.info)("Order cancelled supposedly")`

---

## 2021-07-23 15:20:46 - random channel

**Mo**

This model has 100% accuracy

---

## 2021-07-23 07:35:39 - general channel

**Adrian**

for my models

---

## 2021-07-23 07:20:18 - general channel

**Mo**

I'm also really confused by the reference to market recorder and real time but note that there is a `streaming_update` field on the MarketBook: [https://github.com/liampauling/betfair/blob/6991a6a51363bae5fe5940f647b5cf7a4e7113cb/betfairlightweight/resources/bettingresources.py#L566](https://github.com/liampauling/betfair/blob/6991a6a51363bae5fe5940f647b5cf7a4e7113cb/betfairlightweight/resources/bettingresources.py#L566). This contains the raw message

---

## 2021-07-22 22:39:37 - strategies channel

**Dave**

Oh I just remembered... The bayes_opt package is kind of a stepping stone in between basic regression and ML. You can define a custom optimization target as a function, and provide a search space of parameters and it will optimize for you. [https://github.com/fmfn/BayesianOptimization](https://github.com/fmfn/BayesianOptimization) (usual data science practices apply ofc to avoid overfitting etc).

---

## 2021-07-22 14:36:59 - general channel

**liam**

```stream = trading.streaming.create_stream(listener=listener)



stream.stop()```

---

## 2021-07-22 14:32:59 - general channel

**Oliver Varney**

are you talking about actual trading or just recording prices ? Is this bflw or flumine?

---

## 2021-07-22 11:45:40 - general channel

**Mo**

Look at the definition of the MarketBook class: [https://github.com/liampauling/betfair/blob/6991a6a51363bae5fe5940f647b5cf7a4e7113cb/betfairlightweight/resources/bettingresources.py#L542](https://github.com/liampauling/betfair/blob/6991a6a51363bae5fe5940f647b5cf7a4e7113cb/betfairlightweight/resources/bettingresources.py#L542)

---

## 2021-07-22 10:52:07 - strategies channel

**liam**

I plug in matching rates for price/win/loss when modelling this so it gets me half way before confirming with backtesting and then live

---

## 2021-07-22 08:32:05 - strategies channel

**Adrian**

my models fit better with non-linear regression

---

## 2021-07-22 08:13:04 - strategies channel

**liam**

Stupid question alert, historically my modelling (inplay racing) involves cowboy regression where I have a signal and optimise for profit/roi. However I have been working on something this week with 2 signals that both have a relationship with the price. So this then becomes a 3 variable problem, without using the word ML how can I optimise these?

---

## 2021-07-21 12:24:32 - random channel

**Jonjonjon**

The modelling channel?

---

## 2021-07-21 10:41:05 - random channel

**Jonjonjon**

It was kind of Bruno to share his knowledge, but the talk didn't really convince me that advanced modelling/quant work is the way forward.

---

## 2021-07-21 10:32:32 - issues channel

**liam**

Happy to look into this if an issue is created / strategy to replicate etc.

---

## 2021-07-21 09:02:52 - issues channel

**Adrian**

&gt; \nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retries exceeded with url: /exchange/betting/json-rpc/v1 (Caused by NewConnectionError('&lt;urllib3.connection.HTTPSConnection object at 0x7fc7002636a0&gt;: Failed to establish a new connection: [Errno 65] No route to host'))"}

---

## 2021-07-21 08:54:35 - issues channel

**Adrian**

[@U01DVUAE2G1](@U01DVUAE2G1) yes i have 4 flumine instances, 2 with 2 strategies and 2 with one strategy. I'm not versed in how the blotter works. Maybe I have too much going at once? I'm also hitting 10 connection limit if there are too many dropouts

---

## 2021-07-21 08:27:20 - issues channel

**Aaron Smith**

If it cant find that strategy, the 2nd warning is printed

---

## 2021-07-21 08:26:47 - issues channel

**Aaron Smith**

[@U01S1VB9X9P](@U01S1VB9X9P) if the order is not present in the blotter, flumine tries to manually add the order to the blotter. For this, it needs to grab the strategy that placed this order (using the strategy_hash that is saved within the order)

---

## 2021-07-21 03:33:06 - random channel

**Peter**

[@U01S1VB9X9P](@U01S1VB9X9P) for me it's a point of principle not to load Flumine strategies up with a ton of my own code. I view my strategies as infinite loops executing the same code over and over, so want that code to be as lightweight as possible. Whenever Flumine has a helper that does what I need, I use it in preference to writing my own as they often deal with edge cases that I might not have thought of, and moreover, it makes the code more maintainable for when future me comes back to it later needing to make adjustments. That doesn't mean I don't have some quite complex processing, but when it starts to get too complex, that's often a sign that I'm overthinking the strategy itself.

---

## 2021-07-20 23:02:41 - issues channel

**Adrian**

Good morning. Could someone please enlighten me to what this message means?

&gt; "WARNING", "message": "Strategy not available to create order

it is often accompanied by this message:

&gt; "WARNING", "message": "Order .... not present in blotter"

It doesn't seem to be impacting my bots but just thought I'd ask incase it is is having some effect that I don't know about.

---

## 2021-07-20 11:08:23 - general channel

**liam**

`process_market_book`  will execute if True is retired on the check, the update itself comes from either an update from the market stream or a snap based on the strategy `streaming_timeout` which is handy on low update/liquidity markets



`process_orders` will be executed if there is an update through the order stream or is executed every 0.25s if there are live orders, see logic [https://github.com/liampauling/flumine/blob/a7aff28371b1a7a30122dfd76a1effcee4ddc127/flumine/streams/orderstream.py#L67|here](https://github.com/liampauling/flumine/blob/a7aff28371b1a7a30122dfd76a1effcee4ddc127/flumine/streams/orderstream.py#L67|here)



Order count is controlled by the runner context in the strategy, the default is a single live order per selection per market, var [https://github.com/liampauling/flumine/blob/a7aff28371b1a7a30122dfd76a1effcee4ddc127/flumine/strategy/strategy.py#L52|here](https://github.com/liampauling/flumine/blob/a7aff28371b1a7a30122dfd76a1effcee4ddc127/flumine/strategy/strategy.py#L52|here). And logic for validating that is [https://github.com/liampauling/flumine/blob/a7aff28371b1a7a30122dfd76a1effcee4ddc127/flumine/strategy/strategy.py#L138|here](https://github.com/liampauling/flumine/blob/a7aff28371b1a7a30122dfd76a1effcee4ddc127/flumine/strategy/strategy.py#L138|here) and executed on each place. Currently designed to be as safe as possible by default to prevent what you are describing. But you have backtesting and paper trading available to validate your strategy won't shit itself before you execute live :slightly_smiling_face:

---

## 2021-07-20 10:30:42 - general channel

**KG**

very true, I think it comes down to a) do you want an identical view to what the Exchange is showing with virtual bets on, if that's relevant to your strategy and b) can you reliably recreate that yourself and if so then c) can you do it faster than by simply getting the same data from the API (my opinion is that yes, you should be able to replicate more efficiently yourself).

---

## 2021-07-18 13:42:57 - general channel

**Juha Kiili**

Answering my own question. For now I think I'm going to...



In `inplayservice` callback

```for strategy in flumine.strategies:

    strategy.context["score"][market.market_id] = { #whatever score data }```

And in `MarketRecroder.process_raw_data()` i'm injecting it into the saved json

```json.dumps({"op": "mcm", "clk": None, "pt": publish_time, "mc": [data], "score": self.context["score"][market_id]})```

Then in my actual strategy backtesting, I need to parse it back somehow, but haven't looked at it yet.

---

## 2021-07-18 11:51:13 - general channel

**Juha Kiili**

I'm trying to implement a custom "market recorder" in Flumine that also records the relevant `inplayservice` events (or status) and is back-testable for a strategy that also uses the `inplayservice` data?



How would you approach this on a high-level?



I apologize for the vague question, but I'm not quite in-depth with the codebase and need a push to the right direction.

---

## 2021-07-16 09:29:52 - random channel

**river_shah**

I really don't think this is a good metric at all. It is super dependent on strategy and market. Better metrics are value at risk or variance adjusted stakes. A better question could be what is user mean / variance profile per month.

---

## 2021-07-16 09:26:45 - random channel

**Jonjonjon**

Would we expect stake/traded volume to go up much with years of experience? It could easily decline at some point, if a user's strategy stopped working. :disappointed:

---

## 2021-07-15 08:03:44 - strategies channel

**Oliver Varney**

[@U01S1VB9X9P](@U01S1VB9X9P) is it a pre-off horses strategy? if so you can compare whether your bets (entry) are beating BSP.  This is normally the fastest feedback, especially if your bets are at the higher ends of the odds scale.

---

## 2021-07-15 06:31:17 - general channel

**KG**

hey guys, just a head's up that we have our next online ANZ analytical meet up next week, Wednesday AM your time, with a focus on greyhound modelling - you're welcome to join if you're keen :dog: [https://www.eventbrite.com.au/e/betfairs-digital-analytical-meet-up-greyhound-edition-tickets-160463756415](https://www.eventbrite.com.au/e/betfairs-digital-analytical-meet-up-greyhound-edition-tickets-160463756415)

---

## 2021-07-15 01:44:52 - strategies channel

**Adrian**

[@ULDAVFDRP](@ULDAVFDRP) i haven't run a closing strategy long enough to know. I may need to though because the variance of my latest strategy is too high for testing purposes

---

## 2021-07-14 11:05:00 - general channel

**Newbie99**

This is an incredibly dumb question...but I can't figure out the syntax...how can I adjust the market_filter to include market_start_time (as its not include in the streaming_market_filter)?



So for example (I can't filter out after startup as there are &gt;1000 markets and I don't think I bring enough to the party to get unlimited!!!):



```strategy = ExampleStrategy(

    market_filter={**streaming_market_filter(event_type_ids=["2"]), **{'market_start_time':{"to": "{0}T23:45:00Z".format(datetime.today())}}},

)

framework.add_strategy(strategy)```

---

## 2021-07-14 08:06:16 - strategies channel

**Adrian**

Haha yes I did, wasn't sure how appropriate it was :woozy_face: I think my commission percentage is pretty high, since I was running a breakeven strategy for a few months with big turnovers. Couldn't give a figure though.

---

## 2021-07-13 23:09:44 - strategies channel

**Andrew**

Why? Why not a fan? Bootstrapping reveals shape of distributions and more importantly the length of that dreaded left tail, which tells me “how likely is this strategy good”. I think drawdown (and distribution thereof) is a good metric to have, unless you have an unlimited bank then don’t bother.

---

## 2021-07-13 22:08:22 - strategies channel

**thambie1**

Initial incarnation of the strategy with the latest downswing started ~5 months ago

---

## 2021-07-13 20:55:26 - strategies channel

**Michael**

Generally if you write a good strategy the first question to arise isn't _"is this drawdown normal?"_

---

## 2021-07-13 20:13:37 - strategies channel

**Michael**

The real question isn't what type of 'drawdown' (hate that word) to expect, it's; _"how likely is it that this strategy is good given that I'm losing money"_. You might ask yourself how someone else would address answering that question.

---

## 2021-07-13 18:33:25 - strategies channel

**AndyL**

So it's interesting the affect "random" variation can have psychologically. You can think blimey this strategy is just awful...but you could just be looking at random variation.

I suspect knowing what might expect in terms of drawdown and amplitude of noise in a strategy helps.

To say the least I was looking at my current down trend thinking crap! When it's hopefully just normal variation.

---

## 2021-07-11 14:03:53 - strategies channel

**Dave**

As always, you'll want the assumptions inherent to the modelling technique to make some sense with regards to the values you're feeding in.

---

## 2021-07-11 14:02:50 - strategies channel

**Unknown**

For this kind of thing where you have interactions between features that don't necessarily have a totally linear relationship, you may also want tree-based models such as Random Forests (ancient) or XGBoost (the usually better replacement).

---

## 2021-07-10 07:50:44 - general channel

**Andrew**

Thanks for clarification. That’s probably what I was referring to.



And so a follow up simulation related question is for a rule of thumb for proportion of volume matched? It can’t be necessarily assumed you’d match against all traded volume in the historical record, even ignoring market impact effects, nor assume you’d always make top of the queue. Financial market modellers apply assumptions of a trade share as non-impacting and wondering what considerations may be made in this instance (obviously not in flumine).

---

## 2021-07-10 07:33:00 - random channel

**Scott**

Morning all, if one of the football guys wouldn’t mind could they run a calc on how many games go over 1.5 goals but fail to go over 2.5? Ideally in top 5 leagues and CL. Not for a strategy of my own. Just intrigued at some o1.5 prices in relation to o2.5

---

## 2021-07-10 03:43:53 - general channel

**Andrew**

Hi. I’m a non bflw user at the moment. My coding strength is C# and happily use the API - variations of that provided by Betfair. But I have a question on considering trying some bflw implementation. On RunnerChange trd is aggregate volume at price since start of market. I think I’m right. I can handle that OK but curious if bflw does that already to deliver change in trade volume at each change point? Simulating trading (how I do it) needs to know volume executed at a time point so how does bflw handle this?

---

## 2021-07-09 08:39:44 - general channel

**liam**

pretty much, think it was the strategy and then sending that marketBook through to logging control

---

## 2021-07-08 10:38:59 - general channel

**Ivan Zhou**

not sure if I am doing something wrong im running

```import logging



import betfairlightweight





# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# create trading instance (don't need username/password)

trading = betfairlightweight.APIClient("username", "password")



# race card login

trading.race_card.login()

# update

market_id = "1.185112813"



# race card request (provide list / returns list)

race_cards = trading.race_card.get_race_card(market_ids=[market_id])

print(race_cards)```

---

## 2021-07-07 23:45:22 - general channel

**Peter**

There's no option in the Betfair API to do this, so no way to include the functionality in Flumine. However you can include code in your strategy's check_market_book method to ignore markets that you're not interested in.

---

## 2021-07-07 23:30:38 - general channel

**Matthieu Labour**

Can we add and remove dynamically at runtime markets to a strategy market filter?

---

## 2021-07-07 16:56:07 - issues channel

**Mons___das**

Hey guys! I m rather new to flumine and am trying to wrap my head around everything. Amazing stuff from what i can see, big thanks to [@U4H19D1D2](@U4H19D1D2)

I am currently trying to build up a database with that i can do backtests and filter markets (for the backtest), and down the road maybe also track the orders i have placed per strategy. First step i wanted to get an idea of the general structure of how all of this is going to look like. I see flumine comes with a market_recorder (and an s3recorder on top) and a backtest function, so basically all i need is being provided, i just have to connect the puzzles pieces :smile: The s3recorder seems to throw out some zip files (1 per market), which i am supposed to store in a s3bucket. Are these the files i am supposed to feed into the backtest machinery? Assuming thats how its done, i need to know which files i throw into the backtest for a certain strategy, so i need a way to filter these markets. I was thinking that this one be one job of a database, which for example has basic information for each market_id, like what event_type it is, time of the event, runners, etcetc. How would i go about building such db? Can the market recorder also be used for this? or would i extract this info straight from the files in the s3 bucket?

---

## 2021-07-06 10:45:55 - general channel

**ThomasJ**

I'm trying to understand *[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions|StartingPrices ](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions|StartingPrices ) &gt;*[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions|backStakeTaken](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions|backStakeTaken) ('spl' key in Runner Change msg.) using the Description in the Betting API but getting nowhere.

• The Type is a List

• The Description says "The total amount of back bets matched at the actual Betfair Starting Price."

• This implies that there is only ever 1 &lt;PriceSize&gt; as there is only 1 BSP per runner.

But I assume that to not be the case as the type is List AND betfairlightweight uses the same Available.update() method that is used for processing say ExchangePrices &gt; availableToBack  ('atb' key) which is definitely a list.



Can someone please de-befuddle me.

Thanks

---

## 2021-07-06 10:08:30 - random channel

**Newbie99**

and unless I'm being dumb (which is quite possible) I can't figure out a smart way to filter it out



In the end, I used this approach you suggested, which appears to do the job:



```        if market.market_book is None:

            market_book = self.flumine.client.betting_client.betting.list_market_book(market_ids=[market.market_id])[0]

        else:

            market_book = market.market_book



        runner_list = [(str(runner.selection_id), str(runner.handicap)) for runner in market_book.runners if runner.status == 'ACTIVE']



        for current_order in resp.orders:

            if (str(current_order.selection_id), str(current_order.handicap)) in runner_list:```

---

## 2021-07-06 10:07:34 - random channel

**Newbie99**

Very true about the debt!



In this case, the order status doesn't help, this is the order:



`{'bet_id': '223920989477', 'average_price_matched': 17.0, 'bsp_liability': 0.0, 'handicap': 0.0, 'market_id': '1.160740937', 'matched_date': datetime.datetime(2021, 2, 12, 23, 10, 17), 'order_type': 'LIMIT', 'persistence_type': 'LAPSE', 'placed_date': datetime.datetime(2021, 2, 8, 23, 32, 3), 'regulator_auth_code': None, 'regulator_code': 'GIBRALTAR REGULATOR', 'selection_id': 25205104, 'side': 'LAY', 'size_cancelled': 0.0, 'size_lapsed': 0.0, 'size_matched': 2.0, 'size_remaining': 0.0, 'size_voided': 0.0, 'status': 'EXECUTION_COMPLETE', 'customer_strategy_ref': None, 'customer_order_ref': None, 'price_size': &lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x00000229D309F880&gt;, 'lapsed_date': None, 'lapse_status_reason_code': None, 'cancelled_date': None}`

---

## 2021-07-04 17:47:41 - strategies channel

**Unknown**

That's an equity curve from a fill or kill strategy.

---

## 2021-07-04 13:36:05 - strategies channel

**Andrew**

Or Prices is a fundamentals model of punter behaviour

---

## 2021-07-04 12:27:23 - strategies channel

**Dave**

I think it's quite difficult to classify as fundamental OR price driven. I would say market prices/depth etc become extremely important if you pay attention to your execution, even if your triggers/forecasts are derived from a fundamental model.

---

## 2021-07-04 12:12:02 - strategies channel

**D C**

TLDR: NO



I think the biggest problem for me until quite recently (until I started dabbling in crypto tbh) was that everything I tried was based on traded prices alone without consideration of volume or what's on the order book. Groups like this slack were just not around when I started off and at the time I only know one other person who even know what Betfair was.  I recall one website [http://fred77.co.uk|fred77.co.uk](http://fred77.co.uk|fred77.co.uk) which was a forum where a few botters chatted about strats and bots but that was it. When I started I basically had tunnel vision - I wanted to use data to predict market movement over next X seconds and that was it. It never occurred to me that you could use market data to model value at all. So I looked at financial TA and MACD started to crop up a lot so I started off there. Obviously I widened my knowledge of software languages (back then bots were Perl and data was mysql) but I can honestly say that I did not extract anything useful from MACD, RSI, Bollinger bands etc. and moved on to US sports and logistic regression.

---

## 2021-07-04 11:29:58 - strategies channel

**Mo**

Already I am surprised by the results. I voted just fundamentals. Obviously I pay attention to what the market prices are but like you I struggle to see how to make money without a fundamental model. My advice to [@U01PJ5YMFBJ](@U01PJ5YMFBJ) was going to be that maybe he is another one for which price action alone is simply not going to work but the current poll results weaken that argument

---

## 2021-07-04 11:12:37 - strategies channel

**D C**

This is the trouble with trying to use purely market data and knowledge of how the exchange works. I've admitted to many that I am only in the green now because of the GPS feed. I still am at a loss as to how to price the market purely off the order book and trade history but I hope one day to get there. I've not worked flat out on things but I have been playing around with bots and the API since the mid 2000s. For me the only "obvious" way to get somewhere is through fundamentals. As a (former) mathematician, I am quite at home with the idea of using statistical models to spit out probability estimates using fundamental data but this is hard graft and is going to be close to impossible these days as a one man band without access to some bespoke high cost data because professional sports analytics is now such a big area. I can't say for sure why the modelling value from price action eludes me after so long. Could be just that I am not clever enough, could be that my brain just hasn't seen the alternative angle to view things from. My point is that there are no guarantees that you WILL become successful. Even if someone tells you the right area to look in, you still might lack the thought processes or intelligence to find the answers. That is just part of the landscape. Just because someone else is successful it doesn't mean you will be. Not meant to demotivate you [@U01PJ5YMFBJ](@U01PJ5YMFBJ) just trying to be realistic.

---

## 2021-07-02 23:55:53 - strategies channel

**ShaunW**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) Strip it back to basics, if you were a punter backing blind would you be a winner, and if you weren't a winner who'd would be taking your money? And with your strategy, if it's not a winner then who's got your cash?

---

## 2021-07-02 22:14:02 - strategies channel

**Atho55**

I`m not sure why you picked Aus racing because even if you produce the best strategy ever, I`m sure there are some limitations on the Back bets you can place.

---

## 2021-07-02 17:28:32 - strategies channel

**AndyL**

I made up a Flumine strategy using a bit of logic and ran it while I was working, came back with -0.2% with not a lot of effort so -1% is crap :grinning:

---

## 2021-07-02 16:40:42 - strategies channel

**AndyL**

I found a 1% edge from my data mining setup, created strategy in Flumine ran it over night took 4 hours on 6weeks of aus horses, returned -1%, not happy with mining on market snapshots, looks like ill have to use Flumine and 4hours per iteration...

---

## 2021-07-01 15:10:26 - random channel

**Javier Martín Pérez**

I am giving my first steps with a greyhound strategy built on top of betfairlightweight. I can place bets but not sure how to check if the bets have been matched?  Do you have to actively check it all the time or do you receive some sort of notification on the stream? Can´t find anything if it's not matched straight away.

---

## 2021-07-01 13:40:53 - strategies channel

**Stefan**

Actually using ML is very easy, so if you have trouble to find your way, you maybe should spent some time on building your framework for strategy bot execution, as it seems you are skilled developer. This way you will not waste your time and build something reusable when your ML is ready. For instance I have got just one such bot using different ML models as trigger to execute bet placing, trading or dutching. Any ML model gives me as result dedicated selection/s, bet type and optionally price.

---

## 2021-07-01 12:52:41 - strategies channel

**D C**

Trouble is that when you are researching something that from your personal perspective you don't know much about, how do you know when "enough is enough" ? I mean you could hammer away at a shit idea for too long if you don't know when to stop. It's not like parameter selection in a model where fitting will tell you what parameters are significant and which you can throw away. How is someone new to the game supposed to know what is too little/much time?

---

## 2021-07-01 07:49:28 - strategies channel

**AndyL**

[@UEA14GBRR](@UEA14GBRR) as eluded to in methods, used ALL mined variations by spike height, WoM, price bands, time bands, vwap diff, relative volume increase, relative volume increase selection volume ratio, relative selection volume to market volume ratio, and others..

Accurate means results agree with building a strategy and putting through Flumine over same data

---

## 2021-06-29 20:48:06 - strategies channel

**AndyL**

Ill fit my mining with Flumine strategy

---

## 2021-06-29 20:44:02 - strategies channel

**AndyL**

Hmm, got further but hit an issue, i tried creating a strategy to backtest based on a pattern from the data mining, and the results are totally different.....

The reason being bet selection in my data mining differs, doesn't take much fir strategy to be totally different, so projected profit is typically wrong...

---

## 2021-06-29 01:41:33 - general channel

**Adrian**

[@U4H19D1D2](@U4H19D1D2) big shoutout to you dude. Thank you for all your hard work with this library. Incredible stuff. I have now ported over my strategy from another software and have this one up and running completely automated. So cool! Cheers. :clap::beers:

---

## 2021-06-29 01:07:46 - general channel

**Adrian**

How can I exclude a single country from the strategy?

I tried: `country_codes=[not "GB"]` and `country_codes!=["GB"]`

---

## 2021-06-28 23:45:38 - strategies channel

**Andrew**

It doesn’t need to be art. You need to add in a dimension to the analysis. How does it look at different times until the off? And also consider filtering by price range. So, is the behaviour different at different price levels and at different times before start? You may be looking for a strategy that only works for a period of the market.

---

## 2021-06-28 21:50:48 - random channel

**PeterLe**

Just watching the France Switzerland game, how do you football traders model that!:open_mouth:

---

## 2021-06-28 20:19:17 - general channel

**liam**

Just pass the trading object? Or am I misunderstanding your question 

---

## 2021-06-28 10:30:44 - strategies channel

**Atho55**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) your PC Enigma model?

---

## 2021-06-28 09:26:21 - issues channel

**liam**

[https://github.com/liampauling/betfair/blob/060f0fd2e8c4a975bac7a972941d54995a18e0fc/betfairlightweight/resources/bettingresources.py#L339](https://github.com/liampauling/betfair/blob/060f0fd2e8c4a975bac7a972941d54995a18e0fc/betfairlightweight/resources/bettingresources.py#L339)

---

## 2021-06-28 08:18:25 - general channel

**Andrew**

Where there is an offsetting effect I view it as “gross” commission per strategy. That’s important in the event a specific strategy is ceased.

---

## 2021-06-28 07:33:02 - general channel

**Peter**

When you say unmodified, the example strategy  is filtered to a specific market, which will be long closed and then to a specific runner in that market. So it wouldn't be expected to do anything.

---

## 2021-06-28 07:32:48 - general channel

**liam**

I calculate locally off bets grouped per market/strategy in sql 

---

## 2021-06-28 07:31:32 - general channel

**Oliver Varney**

with list_cleared_orders, what is the appropriate params / approach to attribute commission to each individual strategy assuming you run multiple strategies on one sub account. customer_strategy_ref in flumine is set to the host name I believe and customer order ref is None (with group by set to MARKET). The goal is to attribute the correct commission to each strategy. Do people just calc it off individual bets or am I having a blonde moment and missing the obvious?

---

## 2021-06-28 07:20:10 - issues channel

**Adrian**

```order_type=LimitOrder(lay, self.context[\"stake\"]),\nKeyError: 'stake'"}```

I get this error when running lowest layer. Is "stake" supposed to be declared somewhere in the strategy?

---

## 2021-06-28 00:16:59 - general channel

**Adrian**

Does the ExampleStrategy do anything? When I run it unmodified it seems to just get the market details and nothing more. Is it suppose to be placing bets?

I've changed the market id and runner id to an active market but still the same outcome

---

## 2021-06-28 00:14:13 - strategies channel

**Andrew**

Life is very non-linear, and quite multi-dimensional. Here’s by tip for you [@U01PJ5YMFBJ](@U01PJ5YMFBJ): What is your theory? What hypothesis are you testing? Read up on data mining. Success, in my view will come from accurately modeling behaviour of either runners or punters. If you don’t have a view on what behaviour you are examining you’ll be staying on that bicycle.

---

## 2021-06-27 23:43:05 - strategies channel

**Unknown**

[@UBS7QANF3](@UBS7QANF3) so not sure i understand, here is a plot of a linear regression model applied a selection, generated model is essentially p=0.91×price10secago

---

## 2021-06-27 20:32:03 - general channel

**Sam Asin**

i was wondering lately as i started to look at fighting, and rreading stuff written before the fight, to what extent a huge chunk of pro gramblers were basically betting whatever they are comfortable risking, and I was missing out on those sorts of things because i was ignorant and focused on (arguably harder) problem-spaces.

---

## 2021-06-27 19:51:00 - strategies channel

**Mo**

Absolutely nothing wrong with learning pandas, it's a great move that has applications far beyond sports betting

---

## 2021-06-27 13:27:01 - issues channel

**Ewan**

The AUS team are awesome, very helpful.

About ten years ago I tried a strategy on a delayed app key thinking it was mere seconds but it can be 30-90 seconds so what could have been a profitable strategy got shelved :cry:

---

## 2021-06-26 23:54:56 - strategies channel

**AndyL**

So that was a fun bit of programming..

Now i realise im back to where i was,in trying to figure what independent variables might be an indicator of a better  fair value............

I guess I now have the advantage i can try some assumptions run a model and compare predicted accuracy across different data

---

## 2021-06-26 22:26:49 - general channel

**Dave**

Majority of my strategies are passive so tighter markets make it more challenging to offer an attractive price to other participants. And for my taking I really only run it on leagues I have extremely good models for and Euros definitely ain't one of them

---

## 2021-06-26 15:50:27 - general channel

**Ivan Zhou**

Hey everyone. I have been working on a horse racing model and I am ready to give it a punt and automate the model. I am completly new to the betfair api and betfairlightweight. I'm asumming there is a beginner guide, if someone could point me that direction so I can have a go.

---

## 2021-06-26 12:05:02 - general channel

**Mo**

Add [https://github.com/slundberg/shap](https://github.com/slundberg/shap) to your learning list if you want to understand how a ML model came up with the number generated

---

## 2021-06-26 11:47:40 - general channel

**birchy**

Question for the stats guys here...

So I want to build a preplay model in order to create my own prices/book using historical data for each runner. Let's say I have calculated a handful of feature probabilities for each runner and have also manually given those features a weighting. For example, one of the features may be the bookie price, to which I might give a weighting of 0.20.

I'm assuming that all of the features for each runner would somehow need to be combined to create a single probability, then the probability for each runner would need to be normalised to create a 100% book.

So my question is... in layman's terms, what's the best way to combine all of this independent data to create a final probability for each runner?

---

## 2021-06-26 09:19:07 - random channel

**Dave**

Flumine is a bit magical in this sense. The code you need to write can be from the perspective of trading a single market, however this logic is executed on every market, seamlessly, that you allow via the return value from `check_market_book`

---

## 2021-06-26 08:17:01 - random channel

**Oliver Varney**

worth checking out this function. It may be abit obscure if your new to python but in plain English ignoring most of it, basically a market_book update will come through and need to be processed. To save processing time, a function was created strategy.check_market_book (it looks like in newer versions of flumine it gets called via strategy.check_market  ) to throw away any updates that are not required. If the function strategy.check_market_book return True then strategy.process_market_book will be called. If strategy.check_market_book return False it will not be called.

---

## 2021-06-26 07:51:48 - random channel

**Adrian**

Thanks [@U9JHLMZB4](@U9JHLMZB4). It's simply monitoring when an event is within, say 5 minutes of starting and if it is then turn on the automation for that market. If I am looping through the markets checking the times, how would it be possible to run a strategy from within that loop without interrupting the loop, so that it can continue to monitor the other markets.

---

## 2021-06-26 07:47:24 - random channel

**Peter**

My gut says option 2, but I'm not entirely clear what you're trying to do here.



Are you trying to work out when specific events go in-play, or using a population of markets to try to build a model to predict start times, that you would then use to initiate actions.



Either way, Flumine is rather good at running multiple strategies from a single script (and therefore limiting the number of connections needed) and the each strategy's `check_market_book` method allows you to control which are active at any point in time.

---

## 2021-06-26 07:37:29 - random channel

**Adrian**

Can I ask the opinion of you more seasoned python warriors... I have a script cycling through the markets created by marketrecorder monitoring the start time so that at the correct time i can execute a strategy. I need to know my choices with regards to calling that strategy. My first inclination is call a separate script through os, because I may have to run multiple strategies at once if markets overlap. The second way is probably the correct way and a bit over my head, that would be to run multiple strategies from within that same monitoring script without using os and without calling other scripts. Any pointers?

---

## 2021-06-26 03:02:27 - strategies channel

**Andrew**

And stop this “pandas model” talk. Pandas is just data structure. It’s Pythons implementation of a dataframe.  But I may be wrong that as I don’t use Python

---

## 2021-06-26 00:34:29 - general channel

**Javier Martín Pérez**

Thanks! I have worked in several bookmakers as an odds compiler and now I am learning coding with python to try to automate some strategies. As an odds compiler I was doing football but to try to trade football on Betfair looks a bit complicated without paying for a Runningball feed so I am giving a go to greyhound trading at the moment.

---

## 2021-06-25 20:06:59 - strategies channel

**Dave**

For example, suppose you have a strategy that bets on BSP, some time before the off. Suppose you also have some knowledge as to how presence of pending BSP orders impact the eventual uncrossing price. You can factor this logic into how the BSP uncrossing goes. Flumine on the other hand would not consider this market impact (nor should it as a general framework).

---

## 2021-06-25 19:29:42 - strategies channel

**Dave**

I think something that really helped me was making a simulation environment that closely matched real betting as much as possible. Backtest done poorly = worthless, backtest done well = can be very powerful.

---

## 2021-06-25 19:13:29 - strategies channel

**AndyL**

Say you come up with a pandas model that predicts a fair value at time 'now' based on a set of historical values. Which way would people play it...if the actual price now is "out" say 5% higher then that value so back.. or would you set an offer target say 8% out from now fair value with fillnkill say 10seconds...? The assumption being in 10seconds fair value won't change too much, so 8% will most likely be +EV

---

## 2021-06-25 18:49:25 - strategies channel

**AndyL**

[@U01LD279D16](@U01LD279D16) fyi as your question is quite apt for what ive experienced in the last couple of days. My greyhound bot had a 41 bet losing streak yesterday in live betting, i then ran the streams last night through the same strategy in bactest and backtest only had a 26 bet streak as it missed 15 matches...

My strategy has a 10 second fill or kill, and from comparing logs live matched quite a bit more often than backtest 

So as [@UGV299K6H](@UGV299K6H) says dont just rely on backtest, just shame I've not worked anything else out yet..!?!

---

## 2021-06-25 16:14:34 - strategies channel

**Mo**

Possibly. But hopefully the newbies can take something away from this:



1. It’s hard

2. Sometimes you work on a strategy for six months and by the end you have the square root of fuck all to show for it

---

## 2021-06-25 15:49:14 - strategies channel

**Michael**

I'm not saying it's not useful, just that I think you have to ask yourself what you're hoping to get from it and that I think forecasting your profits is a poor application. It's better applied to (say) the optimisation of execution prices, in which case you're comparing back-test to back-test and the comparison between real and simulated results doesn't really arise.



Certainly the type of strategy will make a difference to how simulated and real results compare but even if the simulated matching was perfect it and couldn't possibly accommodate your effect on the market. Every participant alters the market and the more you're betting the bigger your effect. Although overfitting is a separate issue it's worth remembering that even a perfect matching simulation will do absolutely nothing to help you with that. For most newer players the over-fitting errors are likely to eclipse anything to do with simulated matching.

---

## 2021-06-25 15:05:39 - strategies channel

**birchy**

My personal experience has been that live betting P&amp;L is significantly _better_ than Flumine backtests, i.e. one particular strategy has been matching a lot more bets than the backtests suggested. IMO the _type_ of strategy makes a difference.

---

## 2021-06-25 13:14:17 - general channel

**liam**

Just return False and process doesn’t get called on the strategy 

---

## 2021-06-25 13:13:59 - general channel

**liam**

[https://github.com/liampauling/flumine/blob/6d7ed2eed5a1a111949d0feb4ffe11f9be28efec/flumine/strategy/strategy.py#L108|https://github.com/liampauling/flumine/blob/6d7ed2eed5a1a111949d0feb4ffe11f9be28efec/flumine/strategy/strategy.py#L108](https://github.com/liampauling/flumine/blob/6d7ed2eed5a1a111949d0feb4ffe11f9be28efec/flumine/strategy/strategy.py#L108|https://github.com/liampauling/flumine/blob/6d7ed2eed5a1a111949d0feb4ffe11f9be28efec/flumine/strategy/strategy.py#L108)

---

## 2021-06-25 13:12:40 - general channel

**Joe**

Is it possible to add/remove markets from a strategy in flumine whilst it is running? I want to be able to manually enable/disable specific markets but not sure how to do it

---

## 2021-06-25 12:07:12 - strategies channel

**Beeblebrox**

Say if you've got a strategy that's returning 0.5% where you were aiming for 4%, you might deem it unsuccessful, but for someone who's not got any profitable strategies, they might count it as a success.

---

## 2021-06-25 12:04:56 - strategies channel

**Beeblebrox**

I guess the success rate is going to depend not only on who's devising the strategy, but what you're trying to do and how you define success.

---

## 2021-06-25 11:50:23 - strategies channel

**Michael**

The notion of a 'strategy' isn't usually that applicable to me because most of the time I'm just adding some new bit of insight into my primary operation so the better question might be: How frequently do my changes improve results? I guess that's about 75% of the time but it's hard to say because there's a lot of feeling around for an optimum.



I do try completely new things and if I get as far as betting on them they always make profits but they're not always as good as I hoped for. Assuming something works well I take the learning from it and absorb that into my main operation so I don't have an accumulation of strategies on one sport.

---

## 2021-06-25 11:40:27 - strategies channel

**Beeblebrox**

As someone who started less then a year ago, so relatively new, I always assume that any strategy I design will fail when it goes live! It helps to have realistic expectations.



[@UGV299K6H](@UGV299K6H) as someone with a lot of experience what is your success rate like for new strategies you design? Do the majority of them succeed or is it closer to 50/50?

---

## 2021-06-25 11:28:30 - strategies channel

**Michael**

As a general point not specifically addressing [@U0155J92A7Q](@U0155J92A7Q) or [@U01LD279D16](@U01LD279D16) - I think people often don't ask the right questions with regard to this sort of thing, or else they ask them for the wrong reasons. The best predictor of the success of a strategy is very likely the person who designed it. How successful is strategy X likely to be? How successful is strategy Y (designed by [@UBS7QANF3](@UBS7QANF3)) likely to be? If you've got a bit of sense you apply that logic to yourself.



In any case why do you want to know? So that you can fantasize? Always a bad idea. So that you can scale before your returns justify it? Always a bad idea.



Of course back-testing can be an important part of design and development but it's usually a mistake to look to it for confidence or money management.

---

## 2021-06-25 11:08:19 - strategies channel

**Jorge**

My strategy only places bets in max. one runner per event, even though it places many bets in the same runner. So I assume the bets are independent from each other and then I can apply resampling to them

---

## 2021-06-25 10:48:16 - strategies channel

**Michael**

The answer to your question is 'it depends'. However, since you've made this decision: _'Ultimately I will run this strategy live either way and find out for myself!'_ it doesn't really matter does it?

---

## 2021-06-25 10:33:33 - strategies channel

**Peter C**

Apologies, I know this has been discussed before, but I'm searching through the slack and I can't find what I'm looking for. I'm backtesting a strategy that is putting up offers and am pleased with the results. Since this is my first attempt at offering prices I am keen to understand how the flumine backtest might translate into real life betting. I'd really appreciate anyone's insight into how I might expect my strategy to translate from backtest to real life. Ultimately I will run this strategy live either way and find out for myself!

---

## 2021-06-25 06:22:18 - general channel

**Peter**

It's controlled by injecting an appropriate client when you instantiate the framework

`framework = Flumine(client=client)`



If you inject the BetfairClient

`client = clients.BetfairClient(trading)`

that's designed to log you into Betfair and keep the connection alive. But if you're backtesting on previously recorded data, you inject the backtestclient,

`client = clients.BacktestClient()`

for which external login is disabled.

---

## 2021-06-24 11:12:24 - general channel

**Adrian**

ok got it! Thank you! I had to create a new py file in the same directory as my script and pasted the market recorder strategy code in there. phew! I am now seeing a stream of data coming through

---

## 2021-06-24 09:44:31 - general channel

**Adrian**

Ohhhhhhhh my gawddd. I've been looking at the MarketRecorder.py strategy.. didn't realise there was a separate marketrecorder.py module.. :man-facepalming: only noticed it because of that link you shared. Man do I feel dumb

---

## 2021-06-24 09:18:57 - general channel

**liam**

So you would create your own strategy for that although recommend having some historical data for testing / prototyping 

---

## 2021-06-24 09:01:11 - general channel

**liam**

What do you mean? The marketrecorder is a strategy that records market data (streaming) for playback later 

---

## 2021-06-24 03:22:23 - general channel

**Adrian**

Hi it's me again. Just looking for some direction now that I can login. I've been working with historical data the last few months so if I can get the data in roughly the same format I'm golden. Wondering how does MarketRecorder output data and in what format? Also, what command should I use to call it? I'm thinking `framework.add_strategy(strategy)`  then point strategy at MarketRecorder? That way the parameters (country, event and type) are set via the strategy variable? TIA!

---

## 2021-06-23 14:55:25 - random channel

**Aaron Smith**

yea, greening (so laying) obviously makes no sense in this strategy (cus bigger the price, bigger the loss)

---

## 2021-06-23 13:31:55 - random channel

**Dave**

Can I have a strategy that backs the runner with the largest price (cus bigger the price, bigger the win), and then greens up for a guaranteed profit at SP???? and don't enter the market if it isn't guaranteed

---

## 2021-06-23 11:48:37 - random channel

**PeterLe**

Yea thanks Lee, I had a strategy that [@U016TGY3676](@U016TGY3676) kindly coded up for me and Ive been going through that line by line. Its a pity we dont have more examples to go off. I know people wont want to post up their strategies but its easy to disguise the real 'secret sauce'

Just enjoying learning it to be honest

---

## 2021-06-23 11:32:31 - random channel

**PeterLe**

Sorry very basic question..Ive got the marketrecorder running just fine and its set up on an account that Im using my own program on. That program places plenty of bets during the day. (So no issues with recording and not placing bets...)

My question is: Given that Im using my ownprogram during the day on that account, I only want Flumine to record and not place any bets. Am I correct in thinking that Flumine doesnt automatically include any strategy (such as Lowest Later etc)?

Im fairly sure it doesnt but just want to double check . many thanks and sorry for basic question

---

## 2021-06-23 09:58:27 - issues channel

**liam**

I think there might be an issue already? If you can create a strategy to replicate would be helpful 

---

## 2021-06-23 09:29:51 - issues channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2) I've noticed something else about the Replace function (I'm guessing most people just cancel and place a new order, which perhaps I should do!), below the replace fails as the bet has already had an action on it, that error makes sense, however after this the order is never removed from the blotter and the status remains as OrderStatus.REPLACING until I kill the process. This of course means no further orders can be placed on this runner as the blotter thinks there is 1 order remaining. This is obviously a pretty rare occurrence, but I've noticed it a few times and I think the below shows the process flow, but at the end presumably a better outcome would be that the order is removed (i.e. set to EXECUTION_COMPLETE) instead?



This is going to be very tricky to replicate, but if you agree its a bug I'll raise an issue (this is in live btw not simulation).



```{"asctime": "2021-06-22 18:50:10,695", "levelname": "INFO", "message": "execute_replace", "trading_function": "replace", "elapsed_time": 0.05340576171875, "response": {"customerRef": "abcf9b20d38a11ebbbac02054918c7c6", "status": "FAILURE", "errorCode": "BET_ACTION_ERROR", "marketId": "1.183248116", "instructionReports": [{"status": "FAILURE", "errorCode": "BET_TAKEN_OR_LAPSED", "cancelInstructionReport": {"status": "FAILURE", "errorCode": "BET_TAKEN_OR_LAPSED", "instruction": {"betId": "236404314713"}}, "placeInstructionReport": {"status": "FAILURE", "errorCode": "RELATED_ACTION_FAILED"}}]}, "order_package": {"id": "abcf9b20-d38a-11eb-bbac-02054918c7c6", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f148822e790&gt;", "market_id": "1.183248116", "orders": ["236404314713"], "order_count": 1, "package_type": "Replace", "customer_strategy_ref": "ip-172-31-4-105", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}

{"asctime": "2021-06-22 18:50:10,701", "levelname": "INFO", "message": "Trade status update: Pending", "id": "511443a4-d388-11eb-bbac-02054918c7c6", "strategy": "politics_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["236404314713"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Pending", "status_log": "Pending, Live, Pending, Live, Pending, Live, Pending"}

{"asctime": "2021-06-22 18:50:10,707", "levelname": "INFO", "message": "Order status update: Executable", "market_id": "1.183248116", "selection_id": 5191378, "handicap": 0.0, "id": "236404314713", "customer_order_ref": "3203239236f2d-236404314713", "bet_id": "236404314713", "date_time_created": "2021-06-22 18:33:19.422805", "publish_time": null, "trade": {"id": "511443a4-d388-11eb-bbac-02054918c7c6", "strategy": "politics_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["236404314713"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Pending", "status_log": "Pending, Live, Pending, Live, Pending, Live, Pending"}, "order_type": {"order_type": "Limit", "price": 1000.0, "size": 0.09, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.09, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Executable", "status_log": "Executable, Replacing, Executable, Replacing, Executable, Replacing, Executable, Replacing, Executable", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "", "market_notes": null}

{"asctime": "2021-06-22 18:50:10,718", "levelname": "INFO", "message": "Order status update: Replacing", "market_id": "1.183248116", "selection_id": 5191378, "handicap": 0.0, "id": "236404314713", "customer_order_ref": "3203239236f2d-236404314713", "bet_id": "236404314713", "date_time_created": "2021-06-22 18:33:19.422805", "publish_time": null, "trade": {"id": "511443a4-d388-11eb-bbac-02054918c7c6", "strategy": "politics_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["236404314713"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Pending", "status_log": "Pending, Live, Pending, Live, Pending, Live, Pending"}, "order_type": {"order_type": "Limit", "price": 1000.0, "size": 0.09, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.09, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Replacing", "status_log": "Executable, Replacing, Executable, Replacing, Executable, Replacing, Executable, Replacing, Executable, Replacing", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "", "market_notes": null}

{"asctime": "2021-06-22 18:50:10,718", "levelname": "INFO", "message": "Trade status update: Live", "id": "511443a4-d388-11eb-bbac-02054918c7c6", "strategy": "politics_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["236404314713"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Live", "status_log": "Pending, Live, Pending, Live, Pending, Live, Pending, Live"}

{"asctime": "2021-06-22 18:50:10,719", "levelname": "INFO", "message": "Thread pool submit", "trading_function": "execute_replace", "session": "&lt;requests.sessions.Session object at 0x7f144b600050&gt;", "latency": 0.0001, "order_package": {"id": "abdbd200-d38a-11eb-bbac-02054918c7c6", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f148822e790&gt;", "market_id": "1.183248116", "orders": ["236404314713"], "order_count": 1, "package_type": "Replace", "customer_strategy_ref": "ip-172-31-4-105", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}, "thread_pool": {"num_threads": 32, "work_queue_size": 1}}

{"asctime": "2021-06-22 18:50:10,719", "levelname": "CRITICAL", "message": "Execution unknown error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/execution/betfairexecution.py\", line 243, in _execution_helper\n    response = trading_function(order_package, http_session)\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/execution/betfairexecution.py\", line 214, in replace\n    instructions=order_package.replace_instructions,\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/order/orderpackage.py\", line 152, in replace_instructions\n    return [order.create_replace_instruction() for order in self]\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/order/orderpackage.py\", line 152, in &lt;listcomp&gt;\n    return [order.create_replace_instruction() for order in self]\n  File \"/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/order/order.py\", line 394, in create_replace_instruction\n    bet_id=self.bet_id, new_price=self.update_data[\"new_price\"]\nKeyError: 'new_price'", "trading_function": "replace", "exception": "'new_price'", "order_package": {"id": "abdbd200-d38a-11eb-bbac-02054918c7c6", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f148822e790&gt;", "market_id": "1.183248116", "orders": ["236404314713"], "order_count": 1, "package_type": "Replace", "customer_strategy_ref": "ip-172-31-4-105", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}}

{"asctime": "2021-06-22 18:50:10,719", "levelname": "INFO", "message": "1 order packages executed in transaction", "market_id": "1.183248116", "order_packages": [{"id": "abdbd200-d38a-11eb-bbac-02054918c7c6", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f148822e790&gt;", "market_id": "1.183248116", "orders": ["236404314713"], "order_count": 1, "package_type": "Replace", "customer_strategy_ref": "ip-172-31-4-105", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0, "async": false}], "transaction_id": 10}

{"asctime": "2021-06-22 18:50:10,722", "levelname": "INFO", "message": "Deleting requests.Session", "sessions_created": 14, "session": "&lt;requests.sessions.Session object at 0x7f144b600050&gt;", "session_time_created": 1624387784.7466655, "session_time_returned": 1624387810.701893, "live_sessions_count": 0, "err": true}```



---

## 2021-06-23 08:39:13 - general channel

**Adrian**

Success! I got it to run. Got this output:

```starting strategy 'ExampleStrategy'```

Not sure what it's doing but it's a start! Thanks for your help everyone. Obviously BFLW and Flumine have their own login sessions/processes independent of each other

---

## 2021-06-23 08:20:40 - general channel

**Adrian**

[@UQL0QDEKA](@UQL0QDEKA) Yes I have 2FA set up so that it adds the code to the end of my password. This works for `trading.login()` so perhaps Flumine is setup for non-2FA?

---

## 2021-06-23 01:42:31 - general channel

**Adrian**

Hi - hope this is the right place to ask. Don't want to fill up the chat with my newbie questions. I have an active login with BFLW as per:

`trading.session_expired`

```False```

But when I run the example Flumine strategy as per:

`framework.run()`

```LoginError: API login: CERT_AUTH_REQUIRED```

That's the error I get. Is there a separate login class or function I'm not aware of? I'm using this for my credentials:

`trading = betfairlightweight.APIClient(username=user.name,`

                                       `password=user.password,`

                                       `app_key=user.key,`

                                       `certs=user.certs)`



`client = clients.BetfairClient(trading)`

`framework = Flumine(client=client)`

Which logs me in fine but not with Flumine. I am only using the demo API not the paid one so that's maybe affecting it since the Flumine example is trying to place a bet but the demo API doesn't have that functionality.

Thoughts?

TIA!

---

## 2021-06-22 22:40:34 - general channel

**Paul**

I make more trading on exchange games than I do on sports at the moment. Hope to get some time at screen to fix that at the weekend.

---

## 2021-06-22 17:15:41 - general channel

**liam**

yep it will be available here [https://github.com/liampauling/flumine/blob/6d7ed2eed5a1a111949d0feb4ffe11f9be28efec/flumine/strategy/strategy.py#L122](https://github.com/liampauling/flumine/blob/6d7ed2eed5a1a111949d0feb4ffe11f9be28efec/flumine/strategy/strategy.py#L122)

---

## 2021-06-22 14:15:06 - issues channel

**Betbot Coder**

Hi all! First off big thanks to Liam and all for writing and maintaining these functions, very much appreciated! So issue at the moment is, I'm trying to run the trading.historic.get_file_list function but getting a JSONDecodeError: Expecting value: line 2 column 1 (char 1). It has previously worked fine but I haven't run it for a few weeks and now it's just not working, and I can't see why from the documentation. I found [https://github.com/liampauling/betfair/issues/144|this page](https://github.com/liampauling/betfair/issues/144|this page) with comment from Liam saying it's when Betfair is playing up - is that still the case or am I doing something wrong on my code?

---

## 2021-06-22 11:29:24 - general channel

**Daniel Giannini**

May need to tweak my models to incorporate most recent prices in the EX_ALL_OFFERS as opposed to BSP !!

---

## 2021-06-22 10:02:35 - strategies channel

**Michael**

I need to qualify the above by saying that it's only part of the process, ultimately I do re-price the whole market and I don't think you can do that with line data in Pandas. I use Pandas for what you might call 'signal discovery' as well as for analysing my actual betting. For the former I do a line for each runner at each interval with a 0 or 1 for the win and then pretend that they're all independent for the purposes of the exercise. Obviously that's wrong but it's adequate for the job I need to do. I then take that learning and look for a way to incorporate it into my pricing model.

---

## 2021-06-22 08:44:16 - strategies channel

**AndyL**

It does make me think if there's a few 100 of you on here running pandas models, i wonder how similar each is..? Do we end up fighting thresholds, you put orders in at +6.4%, Liam at +5.8%, Peter at +4.8% gets in first.....! (Just made those up!) ?

---

## 2021-06-22 07:32:18 - general channel

**Adrian**

`runner.ex.available_to_back`

```[&lt;betfairlightweight.resources.bettingresources.PriceSize at 0x7fe4a0094af0&gt;,

 &lt;betfairlightweight.resources.bettingresources.PriceSize at 0x7fe4a0094a60&gt;]```

`runner.ex.available_to_back[0]`

```&lt;betfairlightweight.resources.bettingresources.PriceSize at 0x7fe4a0094af0&gt;```

`runner.ex.available_to_back[0]["prices"]`

```TypeError: 'PriceSize' object is not subscriptable```

What am I doing wrong?

---

## 2021-06-22 06:44:31 - general channel

**Adrian**

Hi all,

I'm just starting out with bwl, trying to wrap my head around it. Was hoping if someone could point me in the right direction.

In particular, I run this:

`available_to_back = runner.ex.available_to_back`

`print(available_to_back)`

and I get :

&lt;betfairlightweight.resources.bettingresources.PriceSize at 0x7fe4a0094af0&gt;

How do I turn that into price/amount?

Even better- how do I get the LTP?

Thanks in advance!

---

## 2021-06-21 11:28:35 - strategies channel

**Peter**

2) Flumine's backtesting strategy includes a pretty good simulator to help assess whether the orders your strategy identifies will be matched or not and assesses profitability. Unless you're simply taking the prices on offer, that's vital to understanding whether your strategy has a chance when it comes into contact with an actual market.

---

## 2021-06-21 11:28:14 - strategies channel

**Peter**

1) Pandas is very good at handling huge amounts of data. But a single market file also contains a huge amount of data, so if I'm developing a strategy with a year's worth of GB greyhound data, that's 40,000 x huge = overwhelming. So I work initially in Pandas with data from representative points in time from the start, just to make the process manageable.

---

## 2021-06-21 08:22:58 - strategies channel

**Mo**

Broadly speaking I would prefer not to apply any transformations and use an appropriate model for the data as is

---

## 2021-06-20 23:01:43 - strategies channel

**Michael**

Hmm. So I certainly do regression separately on individual variables as part of the process but I wouldn't base a strategy off just one.... Once I've come to an understanding of each I look at how they interact because a lot of the time they're highly correlated so you'd just be duplicating your bets if you bet on each of them in isolation. The regression part is simple, but the whole business of putting a strategy together well is much more than that, you need to know the underlying value of the bets you might post, whether you can expect to get matched at a rate sufficient to overcome adverse selection, what price is optimal and maybe in which circumstances to cancel. All of those things are indicated by different variables all of which have relationships to each other. It ends up being quite multi-dimensional. In the midst of all that complexity I can't help thinking that just feeding my entire betting history into a ML box might not be such a bad idea even if it does move me the wrong way (or perhaps the right way) on [@U01B8031PM1](@U01B8031PM1)'s IQ plot.

---

## 2021-06-20 22:25:10 - strategies channel

**AndyL**

[@U9JHLMZB4](@U9JHLMZB4) thank you for the very concise answer, makes sense except for one query, you indicate at the end backtesting  ... and running against a large  number of market files... This sort of implies by the way you say that a pandas db does not have a large amount of data. Im was sort of thinking create a strategy to pump the market data files all into DB/panda, but thinking you're implying something more subtle?

Thanks

---

## 2021-06-20 21:43:32 - strategies channel

**Peter**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) Completely agree with [@U4H19D1D2](@U4H19D1D2) re: Pandas. It's like a cross between a spreadsheet on steroids and a database without all the overhead, but with the added benefit of transparently supporting parallel processing across however many CPU (or GPU) cores are available to it. If you've not used it before, investing some time there would dramatically speed up your analyses, making it easy to load and analyse data and then keep tweaking your parameters as you home in on finding value. Backtesting general revolves around a strategy about which you already have some confidence and running it against a large number of market files - a much slower process.

---

## 2021-06-20 20:44:43 - random channel

**Newbie99**

For live, I use the sep parameter to insert a code (i.e. order type a, b, c etc.), however I noticed in paper trading, it appears to ignore the sep parameter and just appears to have the 2 hashes joined together without a separator. Is there a way to replicate the live functionality here, so I can insert my order code without messing around with flumine source code (or if that is the only option, which bit should I be looking at, as I couldn't work it out)?



All I'm doing is this:



```order = trade.create_order(

        side=order_direction, order_type=LimitOrder(price=price, size=stake, persistence_type=persistence_type), sep=sep

    )```

---

## 2021-06-20 11:48:18 - strategies channel

**PeterLe**

Yes, that question _"Thinking about it though, for people who are regularly updating their fair price models, you would be happy for a +EV price to sit in the market until such a point in time that it becomes a -EV price?",_ It only takes a few milliseconds to cancel them; I do an element of that too (as do others on here), but thats a whole different ball game :slightly_smiling_face:

---

## 2021-06-20 11:19:57 - strategies channel

**D C**

Thinking about it though, for people who are regularly updating their fair price models, you would be happy for a +EV price to sit in the market until such a point in time that it becomes a -EV price?

---

## 2021-06-20 11:11:43 - strategies channel

**PeterLe**

Yes its given me a good idea and ive stuck with those settings for a long while now. Once I found what I thought was the best fit, I would then turn to the next variable, lets say bet position and then go through the same process. Then onto the next etc. In my mind a logical methodical approach.

I was wondering how some of you guys go about using linear regression to model rather than the blunt/slow  approach that I have taken.

---

## 2021-06-20 11:01:00 - strategies channel

**PeterLe**

Morning [@UUE6E1LA1](@UUE6E1LA1) , Thanks for your reply. Yes I have tried something similar, Ie lets say, placing a £2 real bet at say 1 sec F/Kill, £2.01 at 1.1 sec, £2.02 at 1.2 sec etc and then testing over a period of time to see what is optimum by seeing which stake was the most successful over time..  I was more asking how you might use linear regression to model it.I was just wondering if this is how you would use the back test model.  Over the last week or so, its been said that just trying random things in backtest wouldnt work, but I was thinking that if you had a known profitable system, then you would simply run the backtest and then vary the single variable you were interested in (fill/kill in this case).

---

## 2021-06-20 09:37:07 - strategies channel

**river_shah**

```[...I joined a hedged fund, Renaissance Technologies, I'll make a comment about that. It's funny that I think the most important thing to do on data analysis is to do the simple things right. So, here's a kind of non-secret about what we did at renaissance: in my opinion, our most important statistical tool was simple regression with one target and one independent variable. It's the simplest statistical model you can imagine. Any reasonably smart high school student could do it. Now we have some of the smartest people around, working in our hedge fund, we have string theorists we recruited from Harvard, and they're doing simple regression. Is this stupid and pointless? Should we be hiring stupider people and paying them less? And the answer is no. And the reason is nobody tells you what the variables you should be regressing [are]. What's the target. Should you do a nonlinear transform before you regress? What's the source? Should you clean your data? Do you notice when your results are obviously rubbish? And so on. And the smarter you are the less likely you are to make a stupid mistake. And that's why I think you often need smart people who appear to be doing something technically very easy, but actually usually not so easy.]```

---

## 2021-06-19 23:40:54 - strategies channel

**Ke**

Where are your main data source to build up a betting model? Do you collect your data manually or from some api provider? I'm looking for the dog weight just before the game start, but seems those data is not public available on internet until the race finishes

---

## 2021-06-19 21:39:08 - strategies channel

**Unknown**

This is something I recently plotted, where edge="entry price" / "exit price" - 1.0.



The y-vs-x relationship is obviously a bit unclear. And shows that I need to normalise it in some way. Linear regression won't be useful for modelling it, in its current form.



A pearson correlation on the data will give spurious results.



However, it has a spearmans rank correlation of 32%. So there's definitely something in it. I just need to sit in my chair and think for a bit.

---

## 2021-06-19 13:44:24 - strategies channel

**Unknown**

Okay, a few wines in down under but here is my book vs sum profit for a strategy, is this what you're talking about [@UPMUFSGCR](@UPMUFSGCR)?

Look like I should stick to $6.60 chances in this zone!

---

## 2021-06-19 09:07:05 - strategies channel

**Jonjonjon**

You could start by plotting your profit Vs book. Do that for a few features. And then ML will be useful for combing a few of those features together. If you understand the individual relationships first, it can help you fit the model more successfully.

---

## 2021-06-19 08:20:07 - strategies channel

**birchy**

I really must get my ass into gear and look at this ML malarkey. While my `if book &gt; x and ltp &lt; y...`  type triggers do generate some profits, it's not really a "model" per se. My notepad is rammed with ideas for potential features similar to the kind of thing [@U9JHLMZB4](@U9JHLMZB4) mentions above. So my question is...where would a layman start with ML, given that they are familiar with Python but a complete luddite regarding statistics, ML, NN, etc? I've looked at some tutorials online, but they all seem to assume that the reader already uses sklearn/pandas/etc...which I don't. YET.

---

## 2021-06-19 07:00:38 - strategies channel

**Peter**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) As an example, ML can be useful for detecting systemic bias in the crowd. So if the question being asked was "are soccer teams with large followings overbet?" you might use ML to build a model with fundamental features such as differences in home attendance, ground size, number of twitter followers, size of supporters club, shirt sales between two opponents. Or if you were wondering whether favourites or longshots are overbet / underbet in certain types of race, you could build a model using technical price data from the type of markets that you suspect could be prone to this.

---

## 2021-06-18 23:28:54 - strategies channel

**Paul**

But can you imagine how algorithms that allows you to make classifications or that could predict prices can help as an input to trading problems?

---

## 2021-06-18 23:27:10 - strategies channel

**Paul**

I’m diving into some reinforcement learning work but am some way off from having a viable model

---

## 2021-06-18 20:52:34 - strategies channel

**Oliver Varney**

Model stacking / ensemble also an option

---

## 2021-06-18 20:46:18 - strategies channel

**Dave**

Yeah...this is what I do actually when I do my retraining, I rerun my old model on the same out of sample set and assert performance at least doesn't degrade

---

## 2021-06-18 20:44:24 - strategies channel

**Mo**

Run backtests with yesterday’s and today’s model and assess agreement

---

## 2021-06-18 20:43:23 - strategies channel

**Dave**

Yeah - automation there is the way to goooo. You're right, could do it daily, altho it's difficult to then spot if you've broken your model or it's just today's variance

---

## 2021-06-18 20:41:26 - strategies channel

**birchy**

General question...what libraries do you guys prefer for modelling/training?

---

## 2021-06-18 20:39:45 - strategies channel

**Oliver Varney**

I guess if the whole process of cross validation , grid searching parameters, model selection and deployment is all automated there no reason why you couldn't do it daily

---

## 2021-06-18 20:27:03 - strategies channel

**Dave**

Yeah, I retrain about once or twice a month. My training set is never older than past 4 months, but I hate retraining the model and re-deploying even though out of sample results are still as good as before. Maybe an unreasonable fear that things won't continue like they did on the older model

---

## 2021-06-18 20:21:54 - strategies channel

**Oliver Varney**

If you have a model with like 10 years of data , retraining every week I doubt would change too much unless you add huge bias to recent samples

---

## 2021-06-18 20:21:05 - strategies channel

**Oliver Varney**

Most likely that depends on the learning task and how much data you include in each model

---

## 2021-06-18 20:03:55 - strategies channel

**Dave**

To anyone running ML models - how often do you retrain?

---

## 2021-06-18 11:22:58 - general channel

**Mo**

I don't know about recently but late suspensions killed off our football strategy

---

## 2021-06-17 22:24:10 - strategies channel

**D C**

Shape of a PnL chart will surely depend on what you are doing. A strategy looking for overpriced longshots will be very jagged compared with a scalping bot for example.

---

## 2021-06-17 22:09:30 - strategies channel

**Aaron Smith**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) variance gets lower when bet count goes up (assuming they are independent). Succesful players probably have a handful of strategies running at the same time, also those charts are generally over a longer period of time than any strategy you may have had running

---

## 2021-06-17 21:45:28 - random channel

**Paul**

It’s an interesting strategy. If you were to do this on BF you overcome the weak middle of laying to liability and the third or fourth in the market landing and laying to payout across the book where you flatten returns but you end up needing to match £1k a runner to make £10 profit

---

## 2021-06-17 16:08:02 - general channel

**D C**

Probably, but one of the issues to contend with when LAYING at 1.01 is the queue position. Sometimes you see a loser matched for just a few hundred and sometimes tens of thousands. Even if you found some edge, you might never be able to guarantee getting matched yourself even if the runner was gubbed at 1.01 and for something with a low chance of happening, missing out on a few races like that could knobble the strategy completely. Same risks apply to anything with low risk/ massive reward payoffs. Even when the markets first open you see a few grand available to lay at 1.01 on all runners so it would always be tricky and that alone would make me look elsewhere.

---

## 2021-06-17 12:52:23 - general channel

**Matthieu Labour**

Hi, what is the reason there is `process_market_book()`  and`process_raw_data()` strategy callbacks. What would be some cases one would use`process_raw_data` over `process_market_book`? Thank you!

---

## 2021-06-17 07:39:01 - strategies channel

**birchy**

To add to the above, that strategy took several months to develop but is built upon market knowledge I've gained over the years and was NOT a "backtest today, go live tomorrow" strategy. As with all strategies, it started with a sensible idea but then I had to implement it and overcome lots of anomalies, execution issues and unforseen bugs. And then, when it worked as I wanted, I simply WAITED. I didn't touch anything, I didn't start "tweaking" parameters and I didn't obsessively check my P&amp;L every 5 minutes. Doing nothing is the hardest part. Learn that level of patience and everything else will fall into place.

---

## 2021-06-16 21:44:54 - strategies channel

**Unknown**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) just to clarify what I suggested, although low margin strategies are not ideal, they ARE easy to find and with sufficient quantity of bets produce returns like the attached graph. That's one of my strategy's last 10K actual bets, over ~13 days. ROI is 0.6% and my Monte Carlo analyser that I posted on this group a while ago says that there is a 0.03% chance this was a lucky streak. You should be able to find something like this fairly easily if you have the right mindset.

---

## 2021-06-16 17:07:14 - strategies channel

**Mo**

Depends on the model

---

## 2021-06-16 17:01:38 - strategies channel

**Unknown**

basically you can predefine the models you want to try. mlp, xgboost, and most of sci kit learns one. in the preprocessing you can try various ways to make it less sparse. group features etc. but as it often uses one hot encoding it is not very good if you have &gt;1000 teams...

---

## 2021-06-16 10:04:45 - strategies channel

**Beeblebrox**

Yeah, I have a couple of strategies that are working, one in the pre-race win market, which I put together using a genetic algorithm to determine the 'best' parameters to use for the strategy. Its been pretty consistent since last August, but I don't really know _*why*_ it works because of how it was put together!



The other one places bets in a couple of derivative football markets and was conceived via a logical thought process and it's returning between 5-10% since January, so I'm quite pleased with that one.  There's still room to scale it up I think, but it's not going to make me a millionaire!



I've got others that I'm testing now in the horse in-play market, but they're break-even at best at the moment.

---

## 2021-06-16 09:47:25 - strategies channel

**Michael**

Truthfully I'm not sure what the best mathematical way of doing it is. For my own part it's a 'lick of the finger' thing, I know what the difference has been in the past so I go with that. You always have to assume a bit of adverse selection, but what you're really looking for here is an overfit bias - which doubtless has a proper mathematical name but I don't know what it is.



There are statistical ways of estimating over fit that others can elucidate better than I can, my own approach would be more about evaluating the process and one's own level of experience. You can simply step back and ask yourself honestly _'what's the probability that I did this right?'_



Having done that; if you have promising results I'd still usually advocate a very slow and cautious switch on starting only with your best bets - i.e. those bets where your signals are strongest. Impatience never pays, if your strategy is sound there's no reason to rush and if it's not sound you'll be glad you didn't.

---

## 2021-06-16 09:44:34 - issues channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2) it wasn't the 1000 orders (but have built a function to handle that now, based your BFLW example), but I added this line (under line 26 in your example) and it appears to work (have tried locally and on AWS and it seems to pick up orders placed on either and importantly not duplicate, which seemed to be happening previously, it appeared the middleware and flumine were both adding the orders placed via the current host without the line below):



```if current_order.customer_strategy_ref != config.hostname or current_order.status != 'EXECUTABLE':```

---

## 2021-06-16 07:52:43 - strategies channel

**Michael**

0.1% ? Yeah maybe you can work with that if you are experienced but you've got so little room for error that you really can't afford any mistakes or fudges. Any strategy you design WILL have less edge in real life than in testing because all testing tends toward over-fitting, you should build the assumption of an over-fit into your process. The more experienced you are the less allowance you need, with no disrespect I'd suggest you make a big allowance.

---

## 2021-06-15 20:12:02 - issues channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2) is there a tidy way to get current (executable) orders placed on a different host (with Flumine), presumably via middleware?



For example, I've placed orders with Flumine on my local machine and I'm moving this strategy onto AWS, but I want to pick up the existing live orders when I re-start the strategy on AWS.



I've been playing around, adapting your middleware example, trying to pull in ALL order types, but there's a step I'm missing, as it doesn't pick up the orders from the other host:



```order = self._create_order_from_current(current_order, market)

            if order:

                order.update_current_order(current_order)

                if current_order.status == "EXECUTION_COMPLETE":

                    order.execution_complete()

                else:

                    if order.bet_id not in market.blotter:

                        order.executable()```

---

## 2021-06-15 19:31:19 - strategies channel

**AndyL**

What are peoples views on these 2 ends of the spectrum?

1) A strategy that has a return of 1% and a trigger rate of 100 trades in say 1week

2) A strategy that has a return of 0.1% and a trigger rate of 1000 trades in 1week 

??

---

## 2021-06-15 16:43:39 - general channel

**Scott**

Yeah it was just to stop me from getting banned, Not sure where I would start without any data.. going to download some historic data, use that and then I’ll take your advice and try and come up with my own strategy when I understand python a little better. 

---

## 2021-06-15 16:34:26 - general channel

**river_shah**

lowest layer is just an example strategy. considering that you need to get your python skills up to speed first, my recommendation is don’t worry about recording data just yet. “buy” some of the free pro data and see if you replay back a market file. go into flumine github repo and follow the examples.



put a breakpoint after `def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:`see if the data structures make sense to you. get a good ide or editor such as pycharm or vs code. bring up python skills first and then the code will make a lot more sense.

---

## 2021-06-15 11:32:33 - issues channel

**Scott**

Just a script that logs in. So details into trading = bflw.api

trading.login

then print(trading.session_expired)

If this was false (log in successful) I would then use the shell just to get used to what commands give me what data 

---

## 2021-06-13 19:09:59 - strategies channel

**AP**

I backtested a strategy on IP AUS racing using flumine. It had a reasonable number of bets and based on 12 months of back testing the expected ROI was 6%, now after roughly 6 months of real betting the ROI is at 4% so I would say it’s reasonably accurate but you may want a buffer in case. 

---

## 2021-06-13 15:31:01 - strategies channel

**Mo**

I have a strategy where I would like to lay at BSP.



I want to size each bet so that my prospective win amount is 1 unit. In other words, for each bet the backer's stake will be 1 unit.



My understanding is that for a Market On Close order, I can only specify the liability not the backer's stake. This makes sense as you don't know what price you will get filled at.



From discussions with [@U4H19D1D2](@U4H19D1D2), I've realised it is possible to place a Limit On Close order which would let me cap the maximum BSP I would lay at (with the bet being cancelled if BSP is above this price). I am thinking that I can use this to achieve my goal as follows:



1. Look to execute bets a small number of seconds before the market start time, e.g. 10 seconds before

2. Roughly predict what the BSP would be. I am thinking to use the near SP field

3. Take the near SP and add a few ticks to allow for some movement. This will be the `limit_price`

4. Work out `liability` as `unit_size * (limit_price - 1)`

5. Place a Limit On Close order at `limit_price` with liability `liability`



Thoughts? Anyone already doing something similar?

---

## 2021-06-12 01:42:14 - strategies channel

**birchy**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) I've been sat on the sidelines reading the various threads on here and feel your frustration with this whole "easy money" malarkey. I've been interested in gambling for over 30 years. For the first couple of years, I was a typical "mug" punter who did a 25p EW Lucky 15 every Saturday and watched the horse racing on TV. It was great entertainment and not a particularly expensive hobby, because I was pretty decent at reading form and had a lot of "unusual" insights that gave me a slight edge. During that time, my father and I decided to put £10 each into a pot and we both picked a few horses every Saturday. I always placed mine as single bets, ranging from £1 to £10 depending on how strongly I felt about the horse's chance of winning. He always did a Lucky 15 or a 3 horse Patent. From that point onwards, I no longer did Lucky 15s or any other kind of multiple bet beyond a (very) occasional EW double. And that was because I realised quite early on, that when I had 1 or 2 winners out of the 4, that backing them as singles paid out far more often, albeit at the cost of missing out on "the big one". But more crucially, I also realised that you could build a bank by taking lots of small profits rather than waiting for occasional bigger payouts. After 18 months, we had just over £1000 in the pot, most of which came from my bets. We split it 50/50 because I'd just discovered beer and women. The money didn't last long.

Several years later, I started looking at betting again and developed many strategies, writing them all in a notepad. Around 1999/2000, I bought my first laptop and discovered spreadsheets. And porn. One pixel at a time, because internet was dial-up back then. I learnt VBA because Excel just wasn't cutting it. Then VB6 because VBA was too slow. Then I discovered Flutter, who were bought out by Betfair shortly after. While watching the markets in bewilderment, I noticed that the books would occasionally go the wrong side of 100%. Knowing how bookies made their money, I attempted to catch these spikes manually. It didn't go well. So I made it my mission to automate it. It took me the best part of a year to learn how HTTP, HTML, Ajax, etc worked. It was hard going as I was never academically minded. But I never gave up. Finally, I had a home-made web browser spoofing, 50 times a second polling, page scraping, data collecting, bet placing API that (so I thought) was totally unique. Another year or so of tweaking and testing followed. I made a few grand from that strategy, but it took me several years to get there. Then competition started to grow and finally, it died a long, slow death, particularly when cross-matching was introduced.



Roll forward to the present.... I still have lots of "wacky" strategy ideas that I need to test but rarely have enough time to give them the devotion they need. The markets are far more efficient nowadays than they were years ago, BUT small edges (&lt;=0.5% ROI) are still fairly easy to find and can make reasonable long-term profits with lower variance. The biggest issue with these is getting large quantities of bets matched. You won't become a millionaire overnight, but it's a step in the right direction.



To put things in perspective, the professionals on here are generally peaking at 4% or 5% ROI over millions of bets. Mere mortals like us can't even get close to that level without a LOT of work. Or a lucky find.



So my suggestion is: go right back to basics. Pick an obvious strategy like laying 3 runners at &lt;3.0, backing both players in 2-player markets to achieve a book &lt;100% or even laying any runner&lt;2.0. If executed correctly, all of these will make a small profit. And it's obvious why. Then work on increasing your match and hit rates. Pick ONE strategy and do everything you possibly can to make it work. Avoid shooting off at a tangent when you think of something else. Write it down. You can work on that next year.



Above all, never attempt to build a "trading" strategy where you are intentionally hedging your bets. Trading is for mugs. There's nothing wrong with hedging bets in order to reduce volatility, but, as [@UGV299K6H](@UGV299K6H) has already said, if your initial bets are not profitable, then your hedge bets certainly won't be.

---

## 2021-06-11 23:40:36 - strategies channel

**AndyL**

[@UEA14GBRR](@UEA14GBRR) optimsed my python strategy, now runs in half the time... note im goatIwish !

---

## 2021-06-11 13:18:40 - strategies channel

**thambie1**

Yeah. If you're going off price action, it's a whole different ball game. Personally, I wouldn't be put off at all by only one side of a price action strategy working. Price action is in a way exploiting human psychology and patterns, which you could imagine tons of reasons why a given strategy of that style only works in one direction.

---

## 2021-06-11 13:09:39 - strategies channel

**thambie1**

It would be better if the inverse strategy works, but it a strategy can still be useful if it doesn't. It just means that there's some bias in your predictions that's pushing your odds in one direction. So when betting in the opposite direction of your bias, you're fine, you're going to make money. But if for example, you're biased to lower odds AND laying, you're going to have a problem. I have some strategies where I haven't fully resolved the bias, so I'm only betting on one side.

---

## 2021-06-11 12:11:23 - strategies channel

**Michael**

It would certainly be better if the inverse of a lay strategy worked and if you're re-pricing the whole market then you would expect it to. On the other hand if you're not re-pricing everything it might not be easy to say quite what the inverse of a lay strategy is in a multi runner market. So it's not great but I wouldn't despair.

---

## 2021-06-11 11:43:42 - strategies channel

**mandelbot**

So I've been toying with a few LAY pre-off horse racing strategies which are shown to be profitable in backtests, but I've found that the BACK versions of them are not profitable. This has casted a bit of doubt in these strategies, should it? Should a strategy and it's inverse both be profitable?

---

## 2021-06-11 10:40:44 - general channel

**Mo**

Generating a data frame from the prices files is simple though:



```from typing import Union



import betfairlightweight

import pandas as pd

import seaborn as sns

import smart_open

from betfairlightweight.resources.bettingresources import MarketBook

from betfairlightweight.streaming import StreamListener

from unittest.mock import patch





def market_book_to_data_frame(market_book: Union[MarketBook, dict]) -&gt; pd.DataFrame:

    if type(market_book) is MarketBook:

        market_book = market_book._data



    return pd.DataFrame(

        {

            'market_id': market_book['marketId'],

            'inplay': market_book['inplay'],

            'selection_id': runner['selectionId'],

            'side': side,

            'depth': depth,

            'price': price_size['price'],

            'size': price_size['size'],

            **({'publish_time': market_book['publishTime']} if 'publishTime' in market_book else {})

        }

        for runner in market_book['runners']

        for side in ['Back', 'Lay']

        for depth, price_size in enumerate(runner.get('ex', {}).get(f'availableTo{side}', []))

    )





def file_to_data_frame(path_to_betfair_price_file: str) -&gt; pd.DataFrame:

    trading = betfairlightweight.APIClient(username='', password='', app_key='')

    stream = trading.streaming.create_historical_generator_stream(

        directory=path_to_betfair_price_file,

        listener=StreamListener(max_latency=None, lightweight=True)

    )



    with patch("builtins.open", smart_open.open):

        g = stream.get_generator()

        return pd.concat(market_book_to_data_frame(mbs[0]) for mbs in g())```

---

## 2021-06-11 09:23:00 - strategies channel

**Aaron Smith**

i assume he means you should try and come up with a strategy first and only if you believe you ve got something good, you use the backtest to confirm your belief, as opposed to throwing random strats into the backtest-machinery.

---

## 2021-06-10 23:27:00 - strategies channel

**Unknown**

So ive just done a dual backtest of my current strategy hedge vs theoretical BSP hedge of same strategy, and it shows im quite poor +0.06% v +0.34%, so a -0.28%, of course might be variance, but here's how it looks:

---

## 2021-06-10 23:21:52 - random channel

**Unknown**

As the commission is mentioned here, I can see a strategy on AU horse races I have been doing for the past 12 months is profitable (mostly a straight line), IF the commission is 0-1% (unfortunately), but you know the often 6% (sometime 10%) commission completely destroys any profit. I was wondering if you [@UBS7QANF3](@UBS7QANF3) or anyone have any advices on how to deal with it (get some profit out of it), if possible at all. Thanks in advance!

---

## 2021-06-10 18:39:28 - random channel

**Sam Asin**

Not sure if Mo is being sarcastic or not but yeah I think it'd be hilarious if this could add even a little value to an already profitable strategy. Some situation where you have a profitable strategy, but you can up your belief about your edge slightly when betting against a fast sounding horse, and lower it slightly when betting against a slow sounding horse, and improve your bet sizing or something.

---

## 2021-06-10 18:36:19 - random channel

**Sam Asin**

haha maybe i'm too trusting but not gonna lie, if I were interested in trading horses I'd at the very least be testing whether or not to include it in my model, and/or reading the details of the paper to see if it's messed something up badly.

---

## 2021-06-10 18:29:10 - random channel

**Mo**

Yeah sounds like a great strategy to me

---

## 2021-06-10 18:19:17 - random channel

**Sam Asin**

"A simple trading strategy of betting against all horses classified as fast-sounding yields a return of approximately 2.9% before the commission but a negative return of −1.6% after deducting the standard commission of 5% from Betfair. This finding could be bracketed under the “limits of arbitrage” argument of Gromb and Vayanos (2010) because the mispricing is not large enough to overcome the transaction costs; thus, potentially misleading or false information is not fully eliminated from prices."

---

## 2021-06-10 18:16:45 - random channel

**Sam Asin**

Not sure if any of you guys read Matt Levine, but he mentioned this article and it seems pretty funny/applicable to your models

---

## 2021-06-10 15:00:44 - strategies channel

**Michael**

Yes - If you decide to hedge every bet then your hedging will inevitably be -EV so if your underlying strategy doesn't generate enough value you can turn it negative.

---

## 2021-06-10 14:33:05 - strategies channel

**AndyL**

With my current strategy i have a sub optimal hedge at schedules off, mainly just offering a hedge bet at reverse price with market_on_close 

But I'm thinking i need to more comparison with bsp, as the auction can change the price to a certain extent and im not achieving full value i may have ascertained with the original bet

---

## 2021-06-10 14:04:13 - strategies channel

**Oliver Varney**

I'll go against the grain, but with the condition that you are a newbie, I think all newbie should hedge. In the long run its a no no. When you are learning it will help you focus on beating bsp and you are very very likely to make mistakes which are amplified massively when betting

---

## 2021-06-10 14:00:13 - strategies channel

**Scott**

Regarding hedging, I assumed before coming here that most 'traders' were looking for models that got in and out of bets (best case laying below true odds and backing above), from reading back and the last couple of days talk it appears thats not the case, so when backtesting are the majority testing against the races result? (placing x number of bets that meet their criteria pre off and ‘letting them ride’) Im interested in the pre off guys as thats where I will be starting.

---

## 2021-06-10 09:29:03 - general channel

**Jono**

ah right perfect that makes sense [@ULDAVFDRP](@ULDAVFDRP) thanks for clarifying the specifics of your earlier comment. On a tangential note Is there an upper limit to the number of markets able to be streamed and placed on using flumine? if say for instance i wanted to run a strategy on all 300 soccer matches listed on the exchange would this be feasible using flumine or is there a limit caused by something like overuse of the trading object, or thread cap or something else entirely

---

## 2021-06-10 09:07:35 - strategies channel

**Unknown**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) I can`t help feeling that on your journey you have missed out taking some fundamental steps to understand how the market works and think that coming up with a horse racing model(s) is the solution. This is what helped me, setting up BA to display just money moving and how it looks as a %. Just a case then of recording a load of races, look when the odds move, rewind a few secs to see what caused the move and write it down. Then look for some links in what you have scribbled. Rinse and repeat then test and tweak. This was the template I used. Model at the end not the beginning.

---

## 2021-06-10 05:43:44 - strategies channel

**Mo**

1. Maybe pay more attention to the genuinely successful professional gambler trying to help you than a random article on the internet?

2. What are the requirements for wisdom of the crowd and do they apply to Betfair?

3. Are you betting with bookmakers? Because both of the academic papers referenced analyse bookmaker data and that's what the article focuses on

4. If you want to explore this idea further then go and read the two academic papers referenced in the article ([https://link.springer.com/article/10.1007/s12197-020-09507-7](https://link.springer.com/article/10.1007/s12197-020-09507-7) and [http://www.reading.ac.uk/web/files/economics/emdp201910.pdf](http://www.reading.ac.uk/web/files/economics/emdp201910.pdf)) yourself rather than relying on this guy's biased summary. Then reproduce their analysis. Then adapt it for Betfair data

5. Engage your brain more

---

## 2021-06-10 00:10:07 - strategies channel

**AndyL**

So basically I need to come up with a horse racing model that works better than the wisdom of the crowd...?

Not sure that will ever happen!

---

## 2021-06-09 23:32:50 - strategies channel

**Michael**

I know you're getting a lot of suggestions [@U01PJ5YMFBJ](@U01PJ5YMFBJ) but here's mine: Forget about back tests and see if you can answer that question - either go and find out how you evaluate the efficiency of a set of markets or invent your own way of doing it. At the trivial level it looks easy: Do half of all bets at 2 win? But when you think about it it's not that simple. Work that shit out until you understand it and at the end of that maybe you will have understood something about probability or the workings of markets that you didn't before and maybe you'll have had some kind of original idea or bit of insight that you can use to make a proper strategy.

---

## 2021-06-09 23:02:51 - strategies channel

**V**

Your strategy is probably slow

---

## 2021-06-09 22:15:29 - strategies channel

**V**

Backtests are important tools, but they should be as realistic as possible. Latency is quite important (depending on what you’re doing) you can quite easily find a great backtest with 0 latency but it’s for good reason… it’s impossible to trade it in real life! Or maybe the strategy is too slow for the message throughout and your queue gets backed up, so you can’t trade on all price updates in practice… the backtest won’t show the latter, production will.

---

## 2021-06-09 20:07:16 - strategies channel

**liam**

My problem with ‘sports trading’ is the idea sold around trading sports by opening and closing positions whilst completely ignoring how value makes it profitable. It seems that 95% of the BA forum (even those who are profitable) simply don’t understand this

---

## 2021-06-09 16:16:37 - strategies channel

**river_shah**

Most players will have a blend of both skills and they should hedge accordingly. There are PC considerations too and there are also sharp money considerations (typically sharp money will put you in positions that will be -EV if you hold to end so may make sense to green up; you have to model this yourself because if you do it right you could be the sharp money in which case you want to keep all the risk on)

---

## 2021-06-09 16:13:05 - strategies channel

**river_shah**

If you have good fundamental models, never green up

---

## 2021-06-09 16:12:46 - strategies channel

**river_shah**

Depending on your strategy you should green up or not. There is not one blanket thing that is correct. If you are super good at predicting the next tick but have crap long term modelling skills, by all means green up.

---

## 2021-06-09 16:11:10 - strategies channel

**D C**

The school of thought on the greening up seems to be that if you are on the winning side of an entry/exit trade, your entry will be value because the market prices have a tendency to correct themselves to where they "should" be. Therefore, if you are entering your position at value, why green up as you should be +EV. Furthermore, that greening up is seen as -EV. Obviously this requires vastly different bankroll management to what most punters see as manual trading with much higher percentage of their bankroll. I am just summarising how I understand the argument as presented by others on here, so as always someone else will correct this if it is wrong.

---

## 2021-06-09 16:03:50 - strategies channel

**Jonjonjon**

Isn't it standard to green up? I'm not trolling. I usually green up, and believe that for my strategy it's the right thing to do.

---

## 2021-06-09 15:32:41 - strategies channel

**AndyL**

Ive even had BA members dm me offering to sell me a profitable strategy for £1k :rolling_on_the_floor_laughing: :rolling_on_the_floor_laughing: :rolling_on_the_floor_laughing:

---

## 2021-06-09 07:08:41 - random channel

**Mo**

If you’re starting from scratch then use flumine. You can use it to collect Betfair price data and do backtesting and any strategy you develop using it can be trivially switched from backtest to live

---

## 2021-06-09 03:05:08 - random channel

**thambie1**

NG is the api version, though I'm not sure what the actual letters stand for. Bflw is a simple tool to access the Betfair API using python. Flumine is a full framework for trading, which notably includes backtesting. Flumine uses blfw.

---

## 2021-06-08 18:56:39 - general channel

**Peter C**

Is this what I need to be looking at?

```{"asctime": "2021-06-08 17:54:42,433", "levelname": "INFO", "message": "Starting historical market '/recordings/1.183683101'", "market": "/recordings/1.183683101"}

{"asctime": "2021-06-08 17:54:42,435", "levelname": "INFO", "message": "[Register: 1000]: marketSubscription"}

{"asctime": "2021-06-08 17:54:42,438", "levelname": "INFO", "message": "[MarketStream: 1000]: \"MarketStream\" created"}

{"asctime": "2021-06-08 17:54:42,440", "levelname": "INFO", "message": "[MarketStream: 1000]: 1.183683101 added, 1 markets in cache"}

{"asctime": "2021-06-08 17:55:39,023", "levelname": "INFO", "message": "Market 1.183683101 closed", "market_id": "1.183683101", "event_id": "30546561", "event_type_id": "7", "event_name": null, "market_type": "WIN", "market_start_datetime": "2021-05-23 14:15:00", "country_code": "IE", 

"venue": "Curragh", "race_type": "Flat", "orders_cleared": false, "market_cleared": false, "closed": true}

{"asctime": "2021-06-08 17:55:39,028", "levelname": "INFO", "message": "Market cleared", "market_id": "1.183683101", "order_count": 0, "client": {"id": "ac3d1f03", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x000001DC498CB130&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}, "markets": {"market_count": 1, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 14988)&gt;", "&lt;WriterThread(pydevd.Writer, started daemon 14100)&gt;", "&lt;ReaderThread(pydevd.Reader, started daemon 13280)&gt;", "&lt;_TimeoutThread(Thread-4, started daemon 1112)&gt;", "&lt;PyDBCommandThread(pydevd.CommandThread, started daemon 1512)&gt;", "&lt;CheckAliveThread(pydevd.CheckAliveThread, started 11800)&gt;"]}```

---

## 2021-06-08 18:53:02 - general channel

**Peter C**

```{"asctime": "2021-06-08 17:50:21,445", "levelname": "INFO", "message": "Adding strategy PriceRecorder"}

{"asctime": "2021-06-08 17:50:21,449", "levelname": "INFO", "message": "Creating new HistoricalStream (1000) for strategy PriceRecorder", "strategy": "PriceRecorder", "stream_id": 1000, "market_filter": "/recordings/1.183683101", "event_id": "30546561", "event_processing": false}

{"asctime": "2021-06-08 17:50:21,463", "levelname": "INFO", "message": "Starting flumine", "client": {"id": "926cb2e8", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x0000015AA2F2A130&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}, "markets": {"market_count": 0, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 13600)&gt;", "&lt;WriterThread(pydevd.Writer, started daemon 10536)&gt;", "&lt;ReaderThread(pydevd.Reader, started daemon 4432)&gt;", "&lt;_TimeoutThread(Thread-4, started daemon 12796)&gt;", "&lt;PyDBCommandThread(pydevd.CommandThread, started daemon 12004)&gt;", "&lt;CheckAliveThread(pydevd.CheckAliveThread, started 4428)&gt;"]}```

I can't see any mention of it in there - maybe I'm not adding it correctly?

---

## 2021-06-08 17:51:24 - general channel

**liam**

strategy init var 

---

## 2021-06-08 16:19:52 - general channel

**Peter C**

I've got a quick question - Is it possible to add conflate_ms to a strategy based on the price recorder example so that I don't write every book update, or do I need to remove the unwanted rows from my file after I have written everything?

---

## 2021-06-08 11:19:24 - strategies channel

**AndyL**

It's poluted my head though! For example when [@U4H19D1D2](@U4H19D1D2) mentions model the data i have, I don't really understand what that means other than basic aspects of manual traders and betangel videos...

---

## 2021-06-08 10:59:14 - strategies channel

**Jonjonjon**

I do horses pre-event. I'm currently taking your prior advice of going back to basics, and re-working my pricing model. It's been making a London software developers' salary for a few years, but when I revisited it, I found that due to a bug, the code doesn't actually produce a number a lot of the time, so once that is fixed I will return to my IP quest.

---

## 2021-06-08 10:49:15 - strategies channel

**Michael**

Actually this conversation and others like it have made me somewhat re-think my advice to new players. In the past I've told people just to write almost any strategy, get some bets on and then work on the results. Although that's right for some people it's obviously not right for everyone.

---

## 2021-06-08 10:48:45 - strategies channel

**Michael**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ): The likelihood of your random strategy succeeding is vanishingly small.

---

## 2021-06-08 09:44:45 - strategies channel

**liam**

You have data, use that to model normal, no thinking involved at this point

---

## 2021-06-08 08:40:45 - strategies channel

**AndyL**

So yes, been trying normal models, but normal is based on what I think is normal, and ive found backtesting those don't seem very good, in fact doing the opposite of what I think would work is better!

---

## 2021-06-08 08:31:59 - strategies channel

**liam**

I think you need to change your attitude first, I have been doing this for about 10 years now, many on here have been doing it longer, it takes more than a few months of part time work. Random is a waste of time (as I thought you had already learnt) have you tried modelling what is normal and then going from there?

---

## 2021-06-08 08:04:53 - strategies channel

**Aaron Smith**

You probably dont have to be the very first to come up with the general idea behind your strategy (if you do that could be some nice money i guess, but its not necessary). Chances are you ll execute it slightly diffrent or maybe combine it with something else.

---

## 2021-06-07 16:49:28 - general channel

**John**

Many thanks both [@UFTBRB3F1](@UFTBRB3F1) and [@U4H19D1D2](@U4H19D1D2). What the strategy does is mostly based on the the example strategy: 1) calculate the trigger price - an arithmetic function of the bsp, to place an order; 2) calculate the stake size: another arithmetic function of the best available price. everything else is the same as the example strategy. I was trying to get lots of logs in a file, but found the log file size slows the script down a lot, so I removed the logs and comment out most of the print/logging I added.

---

## 2021-06-07 16:14:32 - general channel

**liam**

50% would mean your cpu is maxed, what is this strategy doing? There is a leak in it 

---

## 2021-06-07 15:41:14 - general channel

**John**

Hi on the just past 15:15 Lingfield race, I could see my testing script (using flumine) was running like crazy, even after the race had ended, it kept running for a minute, with some of the warning saying high latency, counting down from 45 seconds to finally 2 seconds when the script stopped... I have only one script running, the CPU usage is OK (about 50% with 2 CPUs), and this high latency happened only on some markets, not all. This high latency happens less in AU races. In the script (based on the flumine example strategy), I changed a little by adding a few lines for working out trigger prices, and calculating the stake sizes, so not too complicated. Does it mean there are too many stream events for the UK races (due to higher betting volume) to be coped by my script/VPS. Should I get a better VPS (with faster CPU), or I am missing something? Any comments will be appreciated.

---

## 2021-06-04 18:19:33 - random channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2), I've found out what is happening with regards to these replaced orders, although I haven't had a chance yet to have a full look at the logic.



Using the middleware example, I thought I'd just check a hunch that the replaced order is removing the original one from the blotter, including any matched portion of it and it seems that is what is happening, so by doing the following:



```count = 0

        for current_order in resp.orders:

            [http://logger.info|logger.info](http://logger.info|logger.info)(

                "OrdersMiddleware: Processing order {0}".format(current_order.bet_id),

                extra={

                    "bet_id": current_order.bet_id,

                    "market_id": current_order.market_id,

                    "customer_strategy_ref": current_order.customer_strategy_ref,

                    "customer_order_ref": current_order.customer_order_ref,

                },

            )

            order = self._create_order_from_current(current_order, market)

            if order:

                order.update_current_order(current_order)

                order.execution_complete()

                print(count, [o for o in market.blotter])

                count +=1```

It produces:



```9 [Order 234495806779: Execution complete, Order 234495806780: Execution complete, Order 234496199746: Execution complete, Order 234519003980: Execution complete, Order 234519007090: Execution complete, Order 234561895209: Execution complete, Order 234596897945: Execution complete, Order 234606983431: Execution complete, Order 234835647854: Execution complete, Order 234837496317: Execution complete]

10 [Order 234495806779: Execution complete, Order 234495806780: Execution complete, Order 234496199746: Execution complete, Order 234519003980: Execution complete, Order 234519007090: Execution complete, Order 234561895209: Execution complete, Order 234841458352: Execution complete, Order 234606983431: Execution complete, Order 234835647854: Execution complete, Order 234837496317: Execution complete]```

Order 234596897945 is the original one (which had £2.87 matched out of £3.00), however additionally later on the remaining 13p was replaced with Order 234841458352, this then matched later on (both prior to shutdown of course).



As you can see from the above, when the second order appears in the blotter the first one is removed and the already matched portion is taken out too.



This appears to be something very specific to orders where a portion has later been replaced and I'm guessing is to do with the way the orders are linked, but I haven't had a chance to look at that yet.



Hopefully that is helpful, but I'll keep on digging away too!

---

## 2021-06-04 10:58:45 - issues channel

**James McKenzie**

I removed the strategy that pushes to redis and just ran a market recorder. I got the following when scraping GB races:





```{"asctime": "2021-06-04 05:02:46,633", "levelname": "WARNING", "message": "_get_cleared_market StatusCodeError", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/flumine/worker.py\", line 228, in _get_cleared_market\n    cleared_markets = betting_client.betting.list_cleared_orders(\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/betting.py\", line 432, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 48, in request\n    check_status_code(response)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/utils.py\", line 34, in check_status_code\n    raise StatusCodeError(response.status_code)\nbetfairlightweight.exceptions.StatusCodeError: Status code error: 503", "trading_function": "list_cleared_orders", "response": "Status code error: 503"}

{"asctime": "2021-06-04 05:03:01,545", "levelname": "ERROR", "message": "get_account_details error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/flumine/clients/betfairclient.py\", line 50, in _get_account_details\n    return self.betting_client.account.get_account_details()\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/account.py\", line 54, in get_account_details\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 48, in request\n    check_status_code(response)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/utils.py\", line 34, in check_status_code\n    raise StatusCodeError(response.status_code)\nbetfairlightweight.exceptions.StatusCodeError: Status code error: 503", "error": "Status code error: 503"}

{"asctime": "2021-06-04 05:03:02,638", "levelname": "ERROR", "message": "get_account_funds error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/flumine/clients/betfairclient.py\", line 56, in _get_account_funds\n    return self.betting_client.account.get_account_funds()\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/account.py\", line 35, in get_account_funds\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 48, in request\n    check_status_code(response)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/utils.py\", line 34, in check_status_code\n    raise StatusCodeError(response.status_code)\nbetfairlightweight.exceptions.StatusCodeError: Status code error: 503", "error": "Status code error: 503"}```

the process is currently hanging

---

## 2021-06-03 10:38:19 - issues channel

**James McKenzie**

Hi guys, I have a Betfair account that's been set up by a client who is based in Asia. I have been told that all betfair code needs to be ran from a Hong Kong server. I am running into connection problems when I run some flumine based price scraping code from an AWS server in HK. I see a huge ramp up in the latency and then a fairly nasty connection error message:



```{"asctime": "2021-06-02 12:37:54,900", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 0.5828690528869629"}                                                                        

{"asctime": "2021-06-02 12:40:35,503", "levelname": "INFO", "message": "[MarketStream: 2001] 1.184035567 removed, 139 markets in cache"}                                                                    

{"asctime": "2021-06-02 12:45:32,223", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 5.051729917526245"}                                                                         

{"asctime": "2021-06-02 12:46:17,490", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 50.812371015548706"}                                                                        

{"asctime": "2021-06-02 12:46:55,148", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 88.5535352230072"}                                                                          

{"asctime": "2021-06-02 12:47:41,872", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 133.0834095478058"}                                                                         

{"asctime": "2021-06-02 12:48:34,090", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 182.7278220653534"}                                                                         

{"asctime": "2021-06-02 12:50:47,754", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 297.83341121673584"}                                                                        

{"asctime": "2021-06-02 12:56:28,947", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 664.3587987422943"}                                                                         

{"asctime": "2021-06-02 12:57:00,334", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 695.7359499931335"}                                                                         

{"asctime": "2021-06-02 12:58:46,348", "levelname": "ERROR", "message": "get_account_details error", "exc_info": "Traceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/urllib3/connec

tion.py\", line 159, in _new_conn\n    conn = connection.create_connection(\n  File \"/usr/lib/python3/dist-packages/urllib3/util/connection.py\", line 61, in create_connection\n    for res in socket.geta

ddrinfo(host, port, family, socket.SOCK_STREAM):\n  File \"/usr/lib/python3.8/socket.py\", line 918, in getaddrinfo\n    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\nsocket.gai

error: [Errno -3] Temporary failure in name resolution\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages

/urllib3/connectionpool.py\", line 665, in urlopen\n    httplib_response = self._make_request(\n  File \"/usr/lib/python3/dist-packages/urllib3/connectionpool.py\", line 376, in _make_request\n    self._v

alidate_conn(conn)\n  File \"/usr/lib/python3/dist-packages/urllib3/connectionpool.py\", line 996, in _validate_conn\n    conn.connect()\n  File \"/usr/lib/python3/dist-packages/urllib3/connection.py\", l

ine 314, in connect\n    conn = self._new_conn()\n  File \"/usr/lib/python3/dist-packages/urllib3/connection.py\", line 171, in _new_conn\n    raise NewConnectionError(\nurllib3.exceptions.NewConnectionEr

ror: &lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7f7c3bde0c10&gt;: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution\n\nDuring handling of the above exception,

 another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/requests/adapters.py\", line 439, in send\n    resp = conn.urlopen(\n  File \"/usr/lib/python3/d

ist-packages/urllib3/connectionpool.py\", line 719, in urlopen\n    retries = retries.increment(\n  File \"/usr/lib/python3/dist-packages/urllib3/util/retry.py\", line 436, in increment\n    raise MaxRetr

yError(_pool, url, error or ResponseError(cause))\nurllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retries exceeded with url: /exchange/account/json-rpc/v1 (Ca

used by NewConnectionError('&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7f7c3bde0c10&gt;: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution'))\n\nDuring handli

ng of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 

36, in request\n    response = [http://session.post|session.post](http://session.post|session.post)(\n  File \"/usr/lib/python3/dist-packages/requests/api.py\", line 116, in post\n    return request('post', url, data=data, json=json, **kwargs)\n  File \"/usr/l

ib/python3/dist-packages/requests/api.py\", line 60, in request\n    return session.request(method=method, url=url, **kwargs)\n  File \"/usr/lib/python3/dist-packages/requests/sessions.py\", line 533, in 

request\n    resp = self.send(prep, **send_kwargs)\n  File \"/usr/lib/python3/dist-packages/requests/sessions.py\", line 646, in send\n    r = adapter.send(request, **kwargs)\n  File \"/usr/lib/python3/di

st-packages/requests/adapters.py\", line 516, in send\n    raise ConnectionError(e, request=request)\nrequests.exceptions.ConnectionError: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retrie

s exceeded with url: /exchange/account/json-rpc/v1 (Caused by NewConnectionError('&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7f7c3bde0c10&gt;: Failed to establish a new connection: [Errno -3] Te

mporary failure in name resolution'))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages

/flumine/clients/betfairclient.py\", line 50, in _get_account_details\n    return self.betting_client.account.get_account_details()\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/betfairlightwe

ight/endpoints/account.py\", line 54, in get_account_details\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.8/site-packages/

betfairlightweight/endpoints/baseendpoint.py\", line 43, in request\n    raise APIError(None, method, params, e)\nbetfairlightweight.exceptions.APIError: AccountAPING/v1.0/getAccountDetails \nParams: {} \

nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retries exceeded with url: /exchange/account/json-rpc/v1 (Caused by NewConnectionError('&lt;urllib3.connection.VerifiedHTTPSConnection o

bject at 0x7f7c3bde0c10&gt;: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution'))", "error": "AccountAPING/v1.0/getAccountDetails \nParams: {} \nException: HTTPSConnection

Pool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Max retries exceeded with url: /exchange/account/json-rpc/v1 (Caused by NewConnectionError('&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7f7c3bde0c10&gt;: F

ailed to establish a new connection: [Errno -3] Temporary failure in name resolution'))"}             

{"asctime": "2021-06-02 12:58:46,360", "levelname": "WARNING", "message": "[FlumineStream: 2001]: Latency high: 801.6888477802277"}

Killed```

Does anyone have any ideas about the cause of the problem and how I might resolve it. Much appreciated.

---

## 2021-06-02 19:33:31 - general channel

**Taking Value**

Regarding the issue I had this morning regarding `r.totalmatched`  I am still trying to solve a raft of other issues associated with the problem. Gone over a few of the pro files I purchased from BF and they seem to have more than a few anomalies.

1. The first market update in each event seems to indicate money is already matched on the market. More odd is that no money appears to be matched on any of the runners

2. Whenever money is matched on a runner that delta is not what's added to the total amount matched on the market, which always goes up but by a different amount. 

3. Sometimes total amount matched on the market goes up without any runner receiving a delta. 

Very hacked off, its pro data that cost me some trading revenues. Wasn't expecting this, useless in its current form for what I have in mind. I have run the same code over files recorded with flumine and there are no issues. Also looking through flumine recorded files and the values for total matched on the market accurately reflect the sum of the amounts matched on each runner.

---

## 2021-06-01 22:32:45 - general channel

**Sam Asin**

My understanding is that the R-squared is capturing in general what percentage of your variance is captured by your model, by doing something like 1 - (rmse / var(y) ) , so if two different regressions have the same y, then r-squared increasing is essentially analogous to rmse going down. Am I missing something here? Or am I right about the relationship between rmse and R-squared and there has to be some problem with my code somewhere?

---

## 2021-06-01 22:28:19 - general channel

**Sam Asin**

So I got a random little modeling query if anyone is feeling helpful! I'm looking to experiment with some ML and so on, but before I do, I'm going back to basics with some manual linear regressions.

---

## 2021-06-01 18:34:56 - issues channel

**liam**

Was it an order that was replaced by any chance? Can you create a strategy to replicate the issue

---

## 2021-06-01 13:56:53 - strategies channel

**Aaron Smith**

Its obvious that this is not an easy task. Just by how betting works (being 0 sum - commission) its impossible for it to be easy, as then everyone would be making money, which goes against the 0-sum nature of it all. Also note that the hints you get here, while most likely ppl really want to help you and get you to look into the right directions, will never be the full story. Noone is going to just give away their working strategies.

---

## 2021-06-01 12:12:22 - general channel

**Phil Anderson**

I'm sure this is something really simple - but I can't get list_current_orders to work. I've placed a few, some matched, some unmatched but when I use trading.betting.list_current_orders() the process completes but shows nothing.

From what i can see it should be as simple as this:

```trading = betfairlightweight.APIClient(username=my_username, password=my_password, app_key=my_app_key,

                                       certs=certs_path)



trading.login()



trading.betting.list_current_orders()```

Can anyone help out please?

---

## 2021-06-01 10:27:19 - random channel

**Jonjonjon**

I saw that on LinkedIn. Is the salary for a senior quant modeller really that low?

---

## 2021-05-31 20:31:54 - strategies channel

**Kai**

That's an interesting question. If you have inferred a function that gives you an edge depending on stake size, then you could use Kelly to choose the size that gives you highest log wealth growth.

However if your bankroll is very large compared to the maximum possible +EV stake then the outcome should be "take everything with value" as your risk of ruin (or of reducing your bankroll to a tiny amount) is negligible.

So you could use it to balance risk vs +EV turnover, but if you have maxed out for market capacity already then Kelly obviously couldn't help you increase the market capacity.

In reality the problem would probably be more murky as you have a region where you don't know exactly at which size your bets start to leak value. I'm not sure how much Kelly could help you with that as it is ultimately about risk control and can't tell you where you reach the -EV region (it is always assumed that you know your edge).

I would love to have such a magic function for edge vs stake size for my strategies btw.

---

## 2021-05-31 16:00:38 - strategies channel

**MacrcoPolo**

Kelly boils down to maximizing your log-wealth growth, that function is pretty flexible and you can adapt it a lot, provided you can do the maths for the maximization.

---

## 2021-05-31 15:59:43 - strategies channel

**MacrcoPolo**

I think that yes you can make adaptions - the fact you managed to get filled does indeed adjust your estimate of your edge, but you would just need to model your edge as as function of the size you're filled at.

---

## 2021-05-31 15:58:33 - strategies channel

**thambie1**

No, Kelly can't do that for you. The trade off curve you allude to is specific to the market you trade on, so there is no way for kelly to do it for you. You'd just have to perform your own estimate, and then adjust the inputs to kelly accordingly.

---

## 2021-05-31 15:55:45 - strategies channel

**Michael**

Or let me put it another way: Say you submit a huge bet at a random price and have no estimate of EV. If none of it matches it must have been +EV, if it all matched -EV and something in-between gives you central values. So you can infer value from a size matched (to a degree). Can you factor that into Kelly such that your optimum stake takes account of that adverse selection?

---

## 2021-05-31 15:50:17 - strategies channel

**Michael**

Many of us will have worked out value/stake trade off curves from data, but can you adapt Kelly to serve this function?

---

## 2021-05-31 15:48:54 - strategies channel

**Michael**

That's not what I mean. Say you estimate your edge at X then submit a bet with infinite stake, the amount that you get matched would cause you to revise your estimate of that bet's edge. So your Kelly optimal would be Y% of your bank, but if you could match that much then your edge estimate would be revised down and you'd have staked too much.

---

## 2021-05-31 15:43:50 - strategies channel

**thambie1**

Yeah it's possible to perform kelly calculations given existing positions, and you'd just adjust your edge as it changed and incorporate your already existing stakes

---

## 2021-05-31 15:19:35 - strategies channel

**thambie1**

By stake value trade off do you mean some model accounting for adverse selection based on available sizes?

---

## 2021-05-31 15:10:36 - strategies channel

**Michael**

I doubt that Kelly has much practical application for most of us but it is interesting.

---

## 2021-05-31 15:09:57 - strategies channel

**Michael**

Could Kelly be adapted to account for a stake/value trade off? What would that look like? For what I do estimating edge  is quite easy if you're content with an estimate of your edge at the point of execution, it's the matching that messes it up.

---

## 2021-05-31 14:32:44 - strategies channel

**thambie1**

Kelly does work in high odds scenarios

---

## 2021-05-31 14:17:52 - strategies channel

**Dave**

`The hard part is estimating your true edge` - yup this has been a primary concern for me in terms of using Kelly. I usually take quite a generous margin over my forecast, so consider a relatively large margin of error essentially.

---

## 2021-05-31 14:01:08 - strategies channel

**Ewan**

More than likely! Always been my question with Kelly; what to input as the edge?

I would have thought pot would be an okay substitute but maybe not. I think in this particular dataset the profit was all in the higher odds runners (probably coincidence) and in that scenario Kelly didn’t work. 

Do you think that Kelly works in situations with high odds and high odds-ranges?

---

## 2021-05-31 13:35:09 - strategies channel

**MacrcoPolo**

Kelly is mathematically optimal. The hard part is estimating your true edge. Kelly also assumes you're not at market capacity. If you are, then kelly doesn't matter - you're limited by the size you can execute in the market. Other staking systems are fine, and a simple, conservative, fractional system will get you most of the same benefits (no risk of ruin being the primary one, but you also don't need to reclaculate your bet-size). The issue is that your capital growth isn't as rapid as with kelly, which sizes your bets appropriately. But again, you need to know what your edge is. One of the reasons people use fractional kelly is because estimating this is hard, and fractional kelly gives you more wiggle room to be wrong without negatively affecting your log growth rate. Just as a final point, If you bet &gt; 2x true full kelly, your capital growth is actually negative and your bankroll will -&gt; 0 over the long run (but it will never actually hit zero because you're wagering fractionally).

---

## 2021-05-31 13:23:54 - strategies channel

**Unknown**

So, this was a 1370 bet sample with average odds of $8, didn't seem to suit Kelly (graph is half Kelly, 10% edge assumed, was about 10% pot) Y axis scale is different.

---

## 2021-05-31 13:17:10 - strategies channel

**Ewan**

Using Kelly and to what fraction vs other staking plans really depends on your approach and results I've found.

Generally Kelly is good for lower-odds and say, percent-of-bank is better for larger odds.

Proportional staking can be used but might sacrifice overall profit for reduced draw down.

All I can suggest is graphing the plans out on your results and see what you like the look of?

I'll find some examples I did a while back

---

## 2021-05-30 10:05:42 - strategies channel

**Dave**

Ah cool cool. I'm fairly happy with the vol of my returns (in fact could probably handle more vol if absolute return was larger), so I'll just continue to stake as a function of market capacity and my own risk limit, and introduce Kelly once I exhaust these and find I don't like my pnl path

---

## 2021-05-30 09:47:50 - strategies channel

**PeterLe**

Re Kelly; I’m with [@U0135SLHQBW](@U0135SLHQBW) on that one. As I’m in play only, I have my own version of Kelly ie it performs the same function BUT it only applies it on the fly on races where I believe I have a bigger edge. It recirculates some of the profits back in, in real time. 

On the odd occasion it triggers you can have some spectacular results

So you don’t think you need to think of a Kelly like principle as a binary, you can choose when and if to use it.

I’ve named this system ‘my ratchet system’ :smile:

---

## 2021-05-30 09:10:12 - general channel

**liam**

Logging is weird, this needs to be moved out of the strategy and into your main file (entry point) 

---

## 2021-05-29 23:23:25 - general channel

**John**

Thanks [@U4H19D1D2](@U4H19D1D2). Here is the init function of my strategy class



```class strategy_test(BaseStrategy):





    def __init__(self, *args, **kwargs):

       BaseStrategy.__init__(self, *args, **kwargs)



       # date time

       now = datetime.now()

       dt_string = now.strftime("%Y%m%d")



       # setup logging

       path_file_log = os.path.abspath(os.path.join(cwd, "../log/", strategy_id + f"_{dt_string}" + ".log"))

       logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%Y-%m-%d %I:%M:%S | ', level=logging.DEBUG,

                           filename=path_file_log)

       [http://logging.info|logging.info](http://logging.info|logging.info)("Log file: " + path_file_log)```

Any pointer to output a log file to a local drive will be appreciated.

---

## 2021-05-29 19:54:12 - general channel

**AndyL**

If i am paper_trade'ing a strategy, is there a way to check simulated order results like after a backtest run?

---

## 2021-05-29 13:03:30 - strategies channel

**thambie1**

Yeah, but no-one sane uses full kelly

---

## 2021-05-29 12:51:32 - strategies channel

**MacrcoPolo**

(Your chance of doubling your bankroll before halving is ~2/3rds ... so at full kelly you will halve your bankroll 1/3rd of the time)

---

## 2021-05-29 12:50:55 - strategies channel

**MacrcoPolo**

No no... full kelly dramatically increases swings

---

## 2021-05-29 10:55:27 - strategies channel

**thambie1**

This can be especially helpful if swings/variance is the limiting factor preventing you from scaling up your strategy

---

## 2021-05-29 10:54:01 - strategies channel

**thambie1**

Kelly reduces variance in returns. If you look at your profit graph and see huge swings and are not happy about it, you could use Kelly to reduce the swings.

---

## 2021-05-29 10:40:25 - strategies channel

**Dave**

Bit of an open question maybe...suppose you have a history of bets, how could one ascertain that one should have used Kelly for staking? My scaling up to date has been generally market-capacity based (i.e. if the market looks like I can accumulate larger positions without significant impact then I will, regardless of my perceived EV on this position), but I cannot tell how much "better" my results would be if I took advantage of Kelly criterion.

---

## 2021-05-28 22:44:17 - random channel

**thambie1**

I pay PC, I have occasionally deposited. I don't like keeping much more than I need to on my account. So if I have a significant downswing, scale up trading, launch a capital intensive strategy, etc; I will need to deposit.

---

## 2021-05-28 16:15:59 - issues channel

**Phil Anderson**

Hi. Can anyone help me with the MARKET_ON_CLOSE function? I did post before but never got a reply.

I have code set up to place bets, but if I switch persistence type from LAPSE or PERSIST to MARKET_ON_CLOSE, I get FAILURE. I thought it could be because i was using delayed key, but am using live key now and still same.



Code below:



```limit_order = filters.limit_order(

    price=12.5, size=2, persistence_type="MARKET_ON_CLOSE"

)

instruction = filters.place_instruction(

    order_type="LIMIT",

    selection_id=runner.selection_id,

    side="BACK",

    limit_order=limit_order,

)

place_orders = trading.betting.place_orders(

    market_id=j.market_id, instructions=[instruction], # list

)```



---

## 2021-05-28 10:38:40 - general channel

**Beeblebrox**

I have a strategy that in backtesting works slightly better with best price execution turned off.  Is there a way to turn it off when running the strategy live, so that it only applies to that strategy?  I take it there isn't as it's an account-wide setting.  Is the only option to run it in a sub-account with the option turned off?  If so, how do I go about setting one up?

---

## 2021-05-27 14:06:45 - issues channel

**liam**

so for bflw you would

```trading.login_interactive()```

as per the [https://liampauling.github.io/betfair/quickstart/|docs](https://liampauling.github.io/betfair/quickstart/|docs)



and for flumine its

```client = clients.BetfairClient(trading, interactive_login=True)```

---

## 2021-05-27 11:33:27 - random channel

**Dave**

[@UPMUFSGCR](@UPMUFSGCR) [https://priomha.com/documentation/](https://priomha.com/documentation/) found it after one of their guys (founder maybe) was on the business of betting podcast

---

## 2021-05-26 23:34:50 - general channel

**AndyL**

Ive been running marketrecorder for 4days now a single flumine instance with 3 strategies, uk horses, au horses and uk greyhound, and as far as I can see and checking logs it's not hit the 200 limit which somewhat surprises me.. is the 200 limit on each strategy? And because each has not breached 200... eg.155 markets in cache 

So am I just teetering on the brink?!

---

## 2021-05-25 12:59:39 - random channel

**Mo**

A flag in the market book is troublesome because often the damage will already have been done (you want existing bets voided, not future bets avoided). It also might encourage _more_ betting as people try to get the right side of the fix

---

## 2021-05-25 12:25:52 - random channel

**Oliver Varney**

isnt it just a sad fact of gambling (edit: and anything where large sums of money are involved)? our model are build on historical data where it most likely occurred in a handful of matches and is already built in to our expected return? not that legitimises it at all

---

## 2021-05-25 07:24:26 - random channel

**Mo**

Here are three examples of why it doesn't feel like Betfair is my "partner".



Firstly, I think Betfair should be doing a lot more to protect customers from match fixing. There have been some blatant tennis match fixes recently which hurt us. I reported them to my account manager who has passed them on to the "integrity team" but nothing ever comes of this. Their policy is not to void markets based on allegations alone which I think is dangerous and may ultimately cost them as by keeping the market open they are facilitating the match fixing:



&gt; Ultimately we don’t suspend betting as customers use the product with the expectations that they will be able to manage their positions. Market suspension would be detrimental to this, especially in the cases where the volume is substantial.

The volume is substantial because you have organised crime syndicates using your product!



&gt; The difference between this and the sportsbook is that we choose not to offer bets on the Sportsbook if we suspect a problem, whereas on the Exchange it’s up to customers to make that judgement for themselves. It may be obvious in some cases, but obvious isn’t enough to go by until it has been proven after investigation by the governing body. 

This seems like madness to me. It's not hard to notice that every other bookmaker has stopped taking bets on a match and to suspend and void the market in these situations. I think it's far better to err on the side of caution rather than risk supporting organised crime.



There is the particular case of Teymuraz Gabashvili, a player who is so bent that Betfair has not offered markets on his matches for years. Recently, they had markets on one of his matches, it was a fix and it cost us 5 figures. Well, they are back to not offering markets on his matches but did they void the market and refund our loss? No. My suspicion is that someone in market ops fucked up in creating that market in the first place. I didn't think it was necessary to have our own filter to prevent trading his matches because it's been Betfair policy for YEARS not to offer his matches. Was there any communication they would change that policy? No.



Secondly, we've had so many problems recently with Betfair being late to create tennis markets, sometimes missing matches completely, other times only creating them once they've turned in play which inevitably means they end up having poor liquidity. It seems to me that it essentially boils down to:



1. Poor integration with data feed providers. These have been WTA matches and the provider for these changed this year. Something with the integration is preventing these markets from being automatically created

2. Lack of coverage from the market ops team. The problems normally happen on a Saturday morning; Saturdays tend to be days with lots of qualfiiers being played for the upcoming tournaments for the week. The schedule for the day typically gets published in the early hours of Saturday but if there are any issues with the automatic creation of markets it's not until around the middle of the day that these actually get resolved by which time some matches will have been missed. Seems like it's driven by whenever the guys working on Saturday get into the office

3. Some weird regulatory issue where only the Australian team can create Australian markets. But the Australian team doesn't have 24/7 coverage so when they've failed to create the markets but it's the middle of the night for them all we can do is twiddle our thumbs

My point here (aside from concerns about their technical capabilities re: integration) is that I have no problems making sure our systems are working at 7 am on a Saturday so I bloody well expect Betfair to be doing the same. Yeah, I get it, not everyone has the same work life balance as me but for an organisation the size of Flutter it's well within their capabilities to provide 24/7 coverage on these teams. There's always sport being played somewhere.



Thirdly, site outages. We've all been hurt by these. Betfair can have a meltdown over multiple days but you can be damn sure they won't have any problems taking your premium charge.



In summary, if this was something resembling a true partnership I would expect:



1. Betfair to care more about protecting its (premium) customers. They don't care (enough) if you get hurt for 5 figures in a match fix because they still get their juicy commission/PC on the increased volume

2. Betfair to pursue the same technical excellence that I aspire to. They don't care (enough) if I miss out on trading a few tennis markets because what could be hundreds of pounds in EV for me is a drop in the ocean for them

3. Betfair technical teams to provide 24/7 coverage

4. Some compensation when their services fail

---

## 2021-05-24 19:39:22 - random channel

**PeterLe**

My wife was using a very similar strategy to me years ago. I emailed betfair and told them of my intentions and that we would essentially be trading from the same IP Address with different usernames. She did a KYC and betfair confirmed that there was no problems. that was the end of it.

I think as long as you are upfront and you are genuinely not trying to circumnavigate the rules, you will be OK.

[@UBS7QANF3](@UBS7QANF3) why do you feel you’re treated so badly?

---

## 2021-05-24 16:37:59 - random channel

**Mo**

Yes strategies can be doing similar things but I think their fingerprints are a lot more unique than you might think. Your predictions might be similar but maybe your staking is totally different. Maybe you run your strategy on AWS, someone else runs their strategy on Azure. You use bflw, someone else uses C# (this will show up in the HTTP user-agent strings). Maybe you make keepAlive requests for your session tokens at different frequencies. Maybe you scrape settled orders once an hour, someone else does it every 15 minutes etc. etc.

---

## 2021-05-24 16:27:58 - random channel

**Oliver Varney**

what constitutes the same strategy. A model can have different inputs and come up with the same output ?

---

## 2021-05-24 16:21:48 - random channel

**Mo**

If you run the same strategy on their account then yes

---

## 2021-05-24 11:26:31 - random channel

**Jonjonjon**

I went to the Bognor Butlins with my family 2 years ago. It was awesome, and I wrote some pretty awesome pricing models while I was there.

---

## 2021-05-24 09:58:51 - general channel

**Scott**

Good Morning All! I was pointed this way by D C, If its the same person here as Twitter.. EXTREME Newbie to automation. Thrown together some python for very small programs, only to get them to produce the results I'm after. Starting Year 2 of a Data Science degree in September through the open uni as a side to creating my own betfair models. Never worked with an API before so as a complete beginner what Programming Fundamentals would you recommend diving into before even attempting to use bflw to automate my trading?

---

## 2021-05-22 15:05:34 - general channel

**PeterLe**

apologies for the very basic question again; If I wanted to set the market recorder to only record the inplay (horseracing win) data, is that easy to do?

I can see that this is already in the code:

strategy = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE"],

        market_types=["WIN"],

    ),

So that is OK.

I thought it may be by changing the in_play_only: bool value in filters.market_filter?

Or am i completely looking in the wrong place! (more lIkely)

Thanks

---

## 2021-05-22 13:25:35 - general channel

**PeterLe**

Just a general question please about running the market recorded in the examples folder.

If I were to run it it on a live sub account (by that I mean an account that is already running a strategy not using Bflw/Flumine). This other program is submitting and matching thousands of bets a day.

the combined amount of markets subscribed to by both my own program and Bflw/Flumine would be less than 200.



Would this be seen in a bad light by Betfair, the fact that Im connecting to a single account by more than one program?

Thanks in advance

---

## 2021-05-21 23:16:22 - strategies channel

**Paul**

This paper describes a betting exchange simulator that simulates a large number of events and agents to help train ML. The theory has a long track record in fiscal markets but it still feels… odd… maybe useful to train and then use actual historical data for testing &amp; validation? [https://arxiv.org/pdf/2105.08310.pdf|https://arxiv.org/pdf/2105.08310.pdf](https://arxiv.org/pdf/2105.08310.pdf|https://arxiv.org/pdf/2105.08310.pdf)

---

## 2021-05-21 20:42:54 - issues channel

**Newbie99**

```import time

from datetime import timedelta, timezone, datetime

import logging

import betfairlightweight

import argparse

from betfairlightweight.filters import streaming_market_filter

from pythonjsonlogger import jsonlogger

import racing_functions as rf

import non_streaming_functions as nsf

from flumine import Flumine, clients, BaseStrategy, markets

import account_info as ai

from simple_book import simple_book

from flumine.worker import BackgroundWorker

from marketrecorder import MarketRecorder

from flumine.streams.datastream import DataStream

# from race_card import get_racecard

from price_comparison import get_price_comparison

from terminate import terminate

from cross_market import get_markets

from orders_worker import get_live_orders

from flumine.controls.loggingcontrols import LoggingControl

global snapshot



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = [logging.StreamHandler(), logging.FileHandler(ai.log_folder_path + '/' + datetime.now().strftime("%m-%d-%Y_%H_%M_%S") + '.log')]

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime



for l in log_handler:

    l.setFormatter(formatter)

    logger.addHandler(l)

# logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



rc = rf.open_json(ai.racing_config)



parser = argparse.ArgumentParser()

parser.add_argument("--c", default=None, type=int, help="Conflate messages in ms")

parser.add_argument("--s", "--strategy-list", nargs='+', default=[])

parser.add_argument("--p", default=False, type=bool, help="Paper or real world trading")



args = parser.parse_args()



paper = args.p

# paper = True

if paper == True:

    print('Paper Trading Enabled')

else:

    print('Live Trading Enabled')



market_recorder = False

if market_recorder is True:

    print('Market Recorder Enabled')



strategy_names = args.s

strategy_names = ['politics_test']

conflate = args.c



start_time = datetime.now(timezone.utc)



settings = [setting for setting in rc if setting['on'] == 'True' and setting['strategy_name'] in strategy_names]



trading = betfairlightweight.APIClient(ai.accname, ai.accpass, ai.acckey, certs=ai.path)

# min bet validation temporarily added to stop the min size replace issue

client = clients.BetfairClient(trading, paper_trade=paper) #,  min_bet_validation=False)



framework = Flumine(client=client)



for s in settings:

    country_codes = s['country_codes'] if nsf.true_or_false(s['country_codes']) != False else None

    market_types = s['market_types'] if nsf.true_or_false(s['market_types']) != False else None

    race_types = s['race_types'] if nsf.true_or_false(s['race_types']) != False else None

    venues_to_include = s['venues_to_include'] if nsf.true_or_false(s['venues_to_include']) != False else None

    print({'strategy_name': s['strategy_name'], 'strategy_type': s['strategy_type'], 'event_type_ids': s['event_type_ids'],

           'country_codes': country_codes, 'market_types': market_types, 'race_types': race_types, 'venues': venues_to_include})

    if s['strategy_type'] == 'simple':

        strategy = simple_book(start_time=start_time, settings=s,

            market_filter=streaming_market_filter(

                event_type_ids=s['event_type_ids'],

                country_codes=country_codes,

                market_types=market_types,

                # market_types=['WIN', 'OTHER_PLACE'],

                # country_codes=['AU'],

                # market_types=['WIN','PLACE', 'EACH_WAY'],

                race_types=race_types,

                venues=venues_to_include



            ),

            streaming_timeout=2,

            max_selection_exposure=s['max_selection_exposure'],

            max_order_exposure=s['max_order_exposure'],

            conflate_ms=conflate,

            name=s['strategy_name'],



        )



        framework.add_strategy(strategy)



worker_settings_list = [

    {'function_name': 'get_markets', 'function': get_markets, 'func_kwargs': {"stake": 2, "margin": 0, "exposure_limit": 60}, 'interval': 0.25, 'start_delay': 30},

    {'function_name': 'terminate', 'function': terminate, 'func_kwargs': {"today_only": True, "seconds_closed": 600}, 'interval': 60, 'start_delay': 60},

    {'function_name': 'get_price_comparison', 'function': get_price_comparison, 'func_kwargs': None, 'interval': 60 - rf.randomiser(15), 'start_delay': 30},

    # {'function_name': 'get_live_orders', 'function': get_live_orders, 'func_kwargs': {'snapshot':snapshot}, 'interval': 5, 'start_delay': 30},

    # {'function_name': 'get_racecard', 'function_name': get_racecard,'func_kwargs': {"event_type_ids": 7, 'market_types': 'WIN', 'source': 'Racecard'}, 'interval': 30, 'start_delay': 30}

]



for f in rf.get_worker_functions(settings):

    function_setting = [ws for ws in worker_settings_list if str(ws['function_name']) == f['function_name']]

    if len(function_setting) &gt; 0:

        function_setting = function_setting[0]

        print(f, function_setting)

        framework.add_worker(

            BackgroundWorker(

                framework,

                function_setting['function'],

                func_kwargs=function_setting['func_kwargs'],

                interval=function_setting['interval'],

                start_delay=function_setting['start_delay']

            ))



if market_recorder is True:

    recorder = MarketRecorder(

        name="WIN",

        market_filter=streaming_market_filter(

                event_type_ids=[7],

                country_codes=['GB','IE','US','CA'],

                market_types=['WIN','PLACE'],

            ),

        stream_class=DataStream,

        context={

            "local_dir": ai.unprocessed_data,

            "bucket": "fluminetest",

            "force_update": False,

            "remove_file": True,

        },

    )



    framework.add_strategy(recorder)



framework.run()```



---

## 2021-05-21 20:26:58 - general channel

**ian mcneill**

Thanks [@U4H19D1D2](@U4H19D1D2) - one area I am looking at, IR, is when there is a build up of money on the back side of a runner at an XO during a particular relative % of time in the race, sustained over a few frames (in my head, a frame is 20ms) - there's more to the strategy than that but would be a good starting point for me to understand the framework and build up the rest from that.

---

## 2021-05-21 19:33:28 - general channel

**ian mcneill**

Evening all - I've been using bflw/flumine for around a year recording data and analysing to develop potential strategies. So very simple stuff so far - basically following the examples. I'm now beginning to dig into leveraging the "execution" side of flumine. I am struggling to fully understand but will keep digging and trying to ascertain what needs to be done. In the meantime, I wonder if anyone would be able to check my thinking. I'm looking at the example strategy at [https://liampauling.github.io/flumine/](https://liampauling.github.io/flumine/)

My current reading of this is:

• don't run the strat if the market is closed

• check every runner, if the ltp is less than 1.5, prepare a lay order at 1.01, for £2 (not liability, so .01 *2) 

• execute the orders, then every x millisecond (20?) reduce the order by 0.02 if it is still 2.00 and move it up a tick to 1.02

Apologies if that is way off the mark - will continue to read and experiment but if anyone has examples of hypothetical strategies and how that looks in even pseudo code, would be greatly appreciated.

---

## 2021-05-21 18:21:55 - issues channel

**Newbie99**

Ooops sorry didn't paste very well, but you can see the strategy_name + processid is different!

---

## 2021-05-21 18:21:24 - issues channel

**Newbie99**

`{"id": "bf189146-ba58-11eb-91bf-2016d8944b85", "strategy": "politics_test20216", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138409103890878791"], "offset_orders": [], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 1.86, "size": 17.44, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 17.44, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Pending", "status_log": "Pending", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}, "notes": "", "market_notes": null}`

INFO:flumine.order.order:Order status update: Pending

{"asctime": "2021-05-21 17:19:49,088", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.160683973", "selection_id": 25181943, "handicap": 0, "id": "138409103890878791", "customer_order_ref": "e6e7ee3f26f23-138409103890878791", "bet_id": null, "date_time_created": "2021-05-21 17:19:49.087879", "publish_time": "2021-05-21 17:19:47.488000", "trade": {"id": "bf189146-ba58-11eb-b280-2016d8944b85", "strategy": "politics_test10376

---

## 2021-05-21 18:14:41 - issues channel

**liam**

can you change the strategy name to name+os.process_id

---

## 2021-05-21 18:12:26 - general channel

**Lee**

You could get away with multiple streams (a strategy per country) if you didn't raise the limit, but AU has a lot of markets so you hit the limit quite quickly

---

## 2021-05-21 18:05:39 - general channel

**Lee**

Ask Betfair support to increase your number of markets per a connection and have the one strategy recording all countries for horse racing WIN market type.

---

## 2021-05-21 17:56:32 - general channel

**Lee**

Are you asking about adding the MarketRecorder strategy twice, once for each country?

---

## 2021-05-21 17:47:35 - issues channel

**Newbie99**

(all those order not found in blotter are of course because there are live orders from the previous strategy name on this market)

---

## 2021-05-21 17:46:51 - issues channel

**Unknown**

Ok so:



strategy name changed

only 1 strategy running

only 1 instance running locally

AWS horse racing instance killed before running

---

## 2021-05-21 17:41:01 - issues channel

**Newbie99**

I have a horse racing strategy on AWS running, that only looks at event_type_id = 7 though, I can kill it to see, but surely with these filters it couldn't possibly interfere could it?



```market_filter=streaming_market_filter(

    event_type_ids=s['7'],

    country_codes=['GB','IE','US'],

    market_types=['WIN','PLACE', 'EACH_WAY'],```



---

## 2021-05-21 17:37:30 - general channel

**AndyL**

If i am running marketrecorder for GB and AU horse racing, what's the general opinion on running 1) one python process and flumine client with 2 strategies 

2) run 2 python processes, presume flumine client can allow that?

3) run all in a single strategy 

Or other?

---

## 2021-05-21 17:34:46 - issues channel

**liam**

Are you sure you have nothing else running? Try again but change the name of the strategy to confirm 

---

## 2021-05-21 17:32:22 - issues channel

**Newbie99**

just replicated with the one strategy running, very odd. Just grabbing the logs...

---

## 2021-05-21 17:27:57 - issues channel

**Newbie99**

both orders have to have come from the lay strategy

---

## 2021-05-21 17:27:38 - issues channel

**Newbie99**

sorry strategy_x_lay for the second

---

## 2021-05-21 17:27:23 - issues channel

**Newbie99**

strategy_x_back and strategy_x_y

---

## 2021-05-21 17:26:54 - issues channel

**Newbie99**

the strategy names are unique

---

## 2021-05-21 17:26:26 - issues channel

**liam**

Yeah, is has no way to differentiate them as flumine uses the strategy name which isn’t unique, if you need two change the name on initialisation 

---

## 2021-05-21 17:06:53 - issues channel

**liam**

Are you sure your not running two instances of a bot on this market? Because order 233925456353 appears from somewhere else after you cancel, I can see it was placed by your strategy and by flumine but it wasn't from this running instance

---

## 2021-05-21 11:30:54 - issues channel

**liam**

premature optimization imho, keep it simple, 1-2k orders per market is normal for me (on every uk horse race)

---

## 2021-05-21 10:36:30 - issues channel

**Newbie99**

```def populate_existing_positions(trading, market=False, group=True, order_status='ALL', flumine=True):



    ''' current order BFLW object properties '''

    '''

        betId: str,

        averagePriceMatched: float,

        bspLiability: float,

        handicap: float,

        marketId: str,

        orderType: str,

        persistenceType: str,

        placedDate: str,

        selectionId: int,

        side: str,

        sizeCancelled: float,

        sizeLapsed: float,

        sizeMatched: float,

        sizeRemaining: float,

        sizeVoided: float,

        status: str,

        priceSize: dict,

        regulatorCode: str = None,

        matchedDate: str = None,

        customerStrategyRef: str = None,

        customerOrderRef: str = None,

        regulatorAuthCode: str = None,

        lapsedDate: str = None,

        lapseStatusReasonCode: str = None,

        cancelledDate: str = None,

    '''

    '''

    Betfair Order type structure

    

        t = [{'market_id': '1.182015190', 'selection_id': 38378512, 'handicap': 0, 'id': '138378879025142090',

          'customer_order_ref': '0e6bc4bda0c6d-138378879025142090', 'bet_id': '230289893583',

          'date_time_created': '2021-04-16 17:45:02.514251', 'publish_time': '2021-04-16 17:45:02.504000',

          'trade': {'id': '78b5d6de-9edb-11eb-b72a-02f9e1e2dd3a', 'strategy': 'each_way_arb',

                    'place_reset_seconds': 0.0, 'reset_seconds': 0.0,

                    'orders': ['138378879025142090'], 'offset_orders': [],

                    'notes': '', 'market_notes': '4.9,5,4.9', 'status': 'Complete',

                    'status_log': 'Pending, Live, Complete'},

          'order_type': {'order_type': 'Limit', 'price': 4.3, 'size': 2,

                         'persistence_type': 'PERSIST', 'time_in_force': None,

                         'min_fill_size': None, 'bet_target_type': None, 'bet_target_size': None},

          'info': {'side': 'BACK', 'size_matched': 0.0, 'size_remaining': 0.0, 'size_cancelled': 0.0, 'size_lapsed': 2,

                   'size_voided': 0.0, 'average_price_matched': 0.0},

          'responses': {'date_time_placed': '2021-04-16 17:45:02.776941', 'elapsed_seconds_executable': None},

          'runner_status': None, 'status': 'Lapsed',

          'status_log': 'Pending, Lapsed', 'violation_msg': None,

          'simulated': {'profit': 0.0, 'piq': 0.0, 'matched': []}}]

    

    '''



    if flumine is True:

        completed_order_list = get_current_orders_flumine(self=trading, order_status=order_status, market=market)

    else:

        completed_order_list = get_current_orders(trading, order_status)



    order_list = []

    back_amount = 0

    lay_amount = 0

    for current_order in completed_order_list:

        if current_order.size_matched &gt; 0:

            if group is True:

                # order_bet_id = str(current_order.side) + '_' + str(current_order.market_id) + '_' + str(current_order.handicap) + '_' + str(current_order.selection_id)

                order_bet_id = str(current_order.side)[0] + str(current_order.market_id)[2:] + str(current_order.selection_id)

                # print(order_bet_id)

                customer_order_ref = config.hostname

                order_type = "LIMIT"

                persistence_type = "PERSIST"

            else:

                order_bet_id = current_order.bet_id

                customer_order_ref = current_order.customer_order_ref

                order_type = current_order.order_type

                persistence_type = current_order.persistence_type

            if order_bet_id not in [t.bet_id for t in order_list]:

                # print(order_bet_id)

                s = CurrentOrder(

                    order_bet_id,

                    current_order.average_price_matched,

                    0,

                    current_order.handicap,

                    current_order.market_id,

                    order_type,

                    persistence_type,

                    current_order.placed_date,

                    current_order.selection_id,

                    current_order.side,

                    current_order.size_cancelled,

                    current_order.size_lapsed,

                    current_order.size_matched,

                    current_order.size_remaining,

                    current_order.size_voided,

                    current_order.status,

                    {'price': current_order.price_size.price, 'size': current_order.price_size.size},

                    current_order.regulator_code,

                    current_order.matched_date,

                    None,

                    customer_order_ref,

                    current_order.regulator_auth_code,

                    None)

                order_list.append(s)

            else:

                for t in order_list:

                    # seems to keep pulling in same order on repeat, makes no sense

                    if order_bet_id == t.bet_id:

                        t.average_price_matched = ((t.size_matched * t.average_price_matched) - t.size_matched) + \

                                                  ((current_order.average_price_matched * current_order.size_matched) - current_order.size_matched) \

                            if t.average_price_matched is not None and current_order.size_matched &gt; 0 else None

                        t.size_cancelled += current_order.size_cancelled

                        t.size_lapsed += current_order.size_lapsed

                        t.size_matched += current_order.size_matched

                        t.size_remaining += current_order.size_remaining

                        t.size_voided += current_order.size_voided

                        t.matched_date = current_order.matched_date

                        t.average_price_matched = 1 + (t.average_price_matched / t.size_matched) if t.size_matched &gt; 0 and t.average_price_matched is not None else None

                        t.price_size.price = t.average_price_matched # Given the order has been executed, the price is set to the average price matched



    return order_list```



---

## 2021-05-20 18:18:01 - issues channel

**Newbie99**

the place function is literally this:



```

def place_new_order(self, market, market_book, selection_id, handicap, price, stake, persistence_type, order_direction):

    trade = Trade(

        market_id=market_book.market_id,

        selection_id=selection_id,

        handicap=handicap,

        strategy=self,

    )

    order = trade.create_order(

        side=order_direction, order_type=LimitOrder(price=price, size=stake, persistence_type=persistence_type)

    )

    market.place_order(order)```



---

## 2021-05-20 17:57:07 - issues channel

**liam**

Latency shouldn’t impact, yeah logs would help, I assume the strategy is using a simple place_order only 

---

## 2021-05-20 17:38:54 - issues channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2) should this scenario be able to occur (as I've replicated it a few times, but didn't think it could):



1. Order placed via Flumine on runner x for market y (market.place_order)

2. Order cancelled manually in Betfair GUI

3. Identical replacement order placed via Flumine  on runner x for market y (market.place_order)

4. Duplicate identical replacement order placed via Flumine on runner x for market y (market.place_order)

Ignoring whether my logic is dodgy or not, surely the in-built Flumine logic shouldn't allow that scenario as it only allows 1 live order per runner per strategy?



Obviously if that is by design I can add some logic to stop it when not desired, but I thought that scenario should not be able to occur due to the 1 order per runner per strategy limit?

---

## 2021-05-20 17:20:47 - strategies channel

**Kai**

I don't know if this is stating the obvious, but if you have variable odds and increase positions then Proebsting's paradox should become relevant.

I'm not sure what exactly that implies but it might mean that not all results from classical Kelly carry over.

---

## 2021-05-20 11:50:02 - random channel

**D C**

I hear what you are saying there and obviously the market seldom moves smoothly (one team dominates etc.) but it just scares because of the suspensions. Unless of course you are simply looking at taking value bets at various points inplay which is a very different thing to "trading". I don't know I am not looking down on it but I just think that the word "trading" gets overused in this area. If you are taking value it doesn't matter if the market suspends as you will just get your order cancelled. If you are looking to enter at event X then exit at event Y you just can't guarantee that you will be able to do it because of how the suspensions are handled. And this is exactly the kind of strategy I see called trading by many online.

---

## 2021-05-20 09:39:49 - random channel

**Dave**

Not sure how one forecasts price from order flow without having a model really. $20 per race is pretty good tbh, pretty sure that works out to mean London wage lol.

---

## 2021-05-20 09:24:10 - random channel

**liam**

I don't doubt its possible, it seems these guys have learnt to see trading flow, however I would rather have an automated strategy that earns 50% less if it means I can do other things...

---

## 2021-05-20 00:05:56 - general channel

**Unknown**

Thanks [@UUCD6P13J](@UUCD6P13J). I am using the default value for _market_data_filter_ in the BaseStrategy class, so EX_MARKET_DEF is added. I added it anyway when init my strategy class, but the the name is still a None.  Do I miss anything?

---

## 2021-05-19 20:57:15 - strategies channel

**Paul**

I’ve been digging through some papers and notes from last year to answer original question. Short version: I couldn’t find a paper with an answer and settled at the time (but have not had reason to implement) a solution that calcs what the bets would be right now, then look at the delta and move positions accordingly and optimise toward new liability limits (i.e. make sure not overbetting, even if that means not being able to maximise profit based on new Kelly calcs). No proofs, no papers, just me and my not very sophisticated maths

---

## 2021-05-19 20:08:00 - strategies channel

**MacrcoPolo**

Maybe you can get a near-exact approximation, but your objective is maximizing the log-wealth function, and in general that's a numerical optimization

---

## 2021-05-19 20:07:28 - strategies channel

**MacrcoPolo**

You won't get something exact - the wiki algo is just a numerical optimization recipe

---

## 2021-05-19 13:09:29 - strategies channel

**Ewan**

Hey Guys, first post. Lots of info in that paper but no great conclusions?

As I see it, Kelly tries to optimise the holy trinity that is edge, bank and stake. In my experience it works better at &gt; 30% probabilities. Certainly no magic formula?

Not sure if I would apply it to multiple selections but maybe more the intent?

---

## 2021-05-19 11:57:54 - strategies channel

**Michael**

Questions about international racing and now complex Kelly stuff? Surely he can't be hitting Betfair with that. Looks like [@UBS7QANF3](@UBS7QANF3) is planning something epic.

---

## 2021-05-19 11:34:11 - strategies channel

**Mo**

Can anyone point me in the direction of material on using Kelly with multiple outcomes *when you already have a position on one or more runners?* So an extension to: [https://en.wikipedia.org/wiki/Kelly_criterion#Multiple_outcomes](https://en.wikipedia.org/wiki/Kelly_criterion#Multiple_outcomes)

---

## 2021-05-19 09:58:41 - random channel

**Mo**

I’m sure I’ve had one of the most successful betting _careers_ out of everyone on here but I’m certain that [@UGV299K6H](@UGV299K6H) beats me for lifetime profits, I suspect [@U4H19D1D2](@U4H19D1D2) does as well (and I think it's fair to say that none of us are close to the likes of Benter, Bloom or Benham). I think that’s probably down to having always done my betting activities as part of a team rather than getting the whole pie to myself but on the flip side there are advantages to working as part of a team and it’s given me a breadth of industry knowledge that is probably close to unparalleled. Having had some of my profits stolen by the IRS also doesn’t help. I certainly don't feel well off in the London property market...



For example, I'm pretty sure if 11 years ago I went to work for a hedge fund instead of a new betting syndicate I would have more money today.

---

## 2021-05-19 09:48:29 - random channel

**Jonjonjon**

I think I'm about 0.01-0.1% of the horse markets I trade. So there can't be that many people running the same strategy as me.

---

## 2021-05-19 09:30:06 - random channel

**Jonjonjon**

Startup costs for Betfair trading are very cheap. It only cost me £2.5k to get started. I could have started with less on my bread and butter strategy. But I did not have it at the time.

---

## 2021-05-19 00:37:32 - random channel

**KG**

Anyone who's keen to start their day with insights into modelling football you're welcome to join us online tomorrow morning  :soccer: [http://bfhub.co/SoccerEdition|bfhub.co/SoccerEdition](http://bfhub.co/SoccerEdition|bfhub.co/SoccerEdition)

---

## 2021-05-18 10:21:50 - issues channel

**Newbie99**

```print(market.blotter._strategy_selection_orders[(self, runner.selection_id, runner.handicap)])```



---

## 2021-05-18 08:29:50 - general channel

**Oliver Varney**

hes trying to get his hong kong model ready for happy valley tomorrow :stuck_out_tongue_winking_eye:

---

## 2021-05-18 01:55:21 - random channel

**ShaunW**

Syndicates reduce the per head fixed costs like curating data sources, and splits the ancilliary dev like monitoring and reporting. So it's not just a case of setting up in your back bedroom when you see their model because the cost of running it on your own might well outstrip what it earns, even if you have the time do all it involves. Being a one-man-band at any job is tougher than having a team, especially balancing doing the work and looking for the next work, probably where syndicates excel. We'd all like someone else to do the stats and the coding so we can muse all day, Voila! A business is born, but it's sports betting so let's call it a syndicate.

---

## 2021-05-17 22:54:01 - issues channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2) when running that middleware example I get a ton of these errors (is it possible there is no error catching if there are no completed orders for that market/strategy combo as that appears to be the case, but I could be wrong)?



```{"asctime": "2021-05-17 21:51:02,008", "levelname": "CRITICAL", "message": "Unknown error  in &lt;middleware_example.OrdersMiddleware object at 0x000001D04E45E580&gt; (1.180015935)", "exc_info": "Traceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\flumine\\utils.py\", line 220, in call_middleware_error_handling\n    middleware(market)\n  File \"D:\\Python38\\lib\\site-packages\\flumine\\markets\\middleware.py\", line 16, in __call__\n    raise NotImplementedError\nNotImplementedError"}

INFO:flumine.baseflumine:Adding: 1.180957876 to markets

{"asctime": "2021-05-17 21:51:02,011", "levelname": "INFO", "message": "Adding: 1.180957876 to markets"}

CRITICAL:flumine.utils:Unknown error  in &lt;middleware_example.OrdersMiddleware object at 0x000001D04E45E580&gt; (1.180957876)

Traceback (most recent call last):

  File "D:\Python38\lib\site-packages\flumine\utils.py", line 220, in call_middleware_error_handling

    middleware(market)

  File "D:\Python38\lib\site-packages\flumine\markets\middleware.py", line 16, in __call__

    raise NotImplementedError

NotImplementedError```

---

## 2021-05-17 16:04:24 - issues channel

**Newbie99**

Ah thats much better than my way! I just called list_current_orders and got a net exposure from that!



Are there likely to be any performance issues here if you have 1000's of orders (I'm thinking a use case for this could be say Wimbledon - Tournament Winner, so you could have a strategy running that market for potentially weeks)?

---

## 2021-05-17 14:23:05 - issues channel

**Newbie99**

[@ULDAVFDRP](@ULDAVFDRP) I have made progress here:



```    def process_market_book(self, market, market_book):

        # process marketBook object



        ''' Adds existing market orders (from a previous session) into the current strategy  '''

        for order in self.existing_orders:

            if order.customer_order_ref is not None and order.market_id == market.market_id:

                if order.bet_id not in [o.bet_id for o in market.blotter._live_orders]:

                    print('Adding Bet_id: ', order.bet_id, ' to blotter for market: ', market.market_id)

                    trade = Trade(order.market_id, order.selection_id, order.handicap, self)

                    order_id = order.customer_order_ref[STRATEGY_NAME_HASH_LENGTH + 1:]

                    order = trade.create_order_from_current(order, order_id)

                    order.status = OrderStatus.EXECUTABLE

                    market.blotter.__setitem__(customer_order_ref=order.customer_order_ref, order=order)



        print(market.blotter._live_orders)```

So by trying that approach it adds the order that was created in a previous session into the blotter...however it also then adds a duplicate into the blotter....but importantly does not send a request to try and place this on the exchange (at least from what I can see...it definitely hasn't placed any and I'm not seeing any errors to suggest its trying to).



So it feels like this approach is close, by chance [@U4H19D1D2](@U4H19D1D2) can you see what I might need to tweak here to pick up the previous session order and not create a duplicate in the current live blotter?

---

## 2021-05-17 11:34:15 - random channel

**Mo**

I think it works for SmartOdds and Star Lizard. Obviously it is strategy dependent but often having the model is only half the battle. If you don't have the Asian bookmaker connections required to execute the bets and if you don't have the bankroll or the risk tolerance required to go down that route...

---

## 2021-05-17 11:31:40 - random channel

**Oliver Varney**

Does that play out in the real world well? If they have 15 guess doing modelling then what if one guy discovers something that could pay way more then his salary and they are not getting profit share

---

## 2021-05-17 11:28:10 - random channel

**Oliver Varney**

I guess one question I had which maybe I missed is, how do you scale up and bring people in without giving away your model. How do you incentivize and prevent them from leaving and doing it themselves?

---

## 2021-05-17 11:12:29 - random channel

**liam**

[@UBS7QANF3](@UBS7QANF3) I think you mentioned something before about syndicates and minimum profit/roi being required for a marketType/strategy to even be considered. I see that as an advantage for me, a team of 15 might sound scary but thats 15 pay checks each month :wink:

---

## 2021-05-17 06:29:40 - general channel

**Aaron Smith**

[@U012PA3M7ST](@U012PA3M7ST)

placing a lay order (copied from flumine example):

```trade = Trade(

                    market_id=market_book.market_id,

                    selection_id=runner.selection_id,

                    handicap=runner.handicap,

                    strategy=self,

                )

                order = trade.create_order(

                    side="LAY", order_type=LimitOrder(price=1.01, size=2.00)

                )

                market.place_order(order)```

Here price is just set to 1.01 as an example. If you want to place at the current available to back price, you can retrieve it beforehand and fill it in.

```best_atb = runner_book.ex.available_to_back[0]['price']```

and now you could put this in as `price = best_atb` .

`runner_book.ex.available_to_back`  is a list, with the first element being the best price and then going through the ladder of all available prices (or limited by how many you are requesting). So if you wanted to lay at the second best back_price, its  `runner_book.ex.available_to_back[1]['price']`  etc. This is not necesarrily the next best tick, as theoretically the next best available back price could jump over one tick as nobody placed any bet there, but that is no problem. The `get_nearest_price`  function does exacltly what it says, but may not actually be the perfect fit for what you are looking for. Instead you should maybe check `price_ticks_away` , which is also in utils.py

---

## 2021-05-17 02:12:48 - general channel

**Sam Asin**

Right now i'm having fun with some models where I'm gonna do my best to linear regression and see how good I can predict various stats, and then see about applying the ML stuff I never messed with. Curious what the "criteria" should be, if that makes sense.

---

## 2021-05-17 02:11:40 - general channel

**Sam Asin**

i.e. if i have two different models that try to predict the number of crosses a footballer will hit in a game, and then they predict stuff out of sample, and i can take mod1_prediction mod_2prediction and the actual crosses, anything fun I should do other than correlate them to the crosses?

---

## 2021-05-17 02:10:35 - general channel

**Sam Asin**

kinda embarassing question to ask since I've been a "data" person for so long, but when you're comparing different models against each other to predict some sort of numeric value, do people look at other stuff other than the correlation between the predicted number and the actual number?

---

## 2021-05-16 16:35:02 - general channel

**Peter**

+1 for final integration. I find it useful as the markets arrive as they will for live trading, i.e. in a giant heap rather than neatly ordered in sequence. This can be especially significant when acting on signals from another market as backtesting's event_processing groups related markets nicely, but live data doesn't always exhibit the same helpful structure, especially when you can't rely on event_id as your group index.

---

## 2021-05-16 15:03:45 - general channel

**birchy**

Can anyone comment on how Flumine paper trading compares to backtesting? I'm just wondering whether to go from backtesting straight to live or run paper trading for a short while first?

---

## 2021-05-16 14:48:25 - issues channel

**Newbie99**

..going back to something that comes up quite a lot, but am looking at a slightly different approach...regarding existing orders post a shutdown.



So, assuming orders were created in the past (but importantly via Flumine) and the system has been shutdown, lets say yesterday and re-started today.



Upon startup, you run this:



```print(market.blotter.strategy_orders(self))```

It shows an empty list.



When the first order is placed, it then comes up with messages like this:



```WARNING:flumine.order.process:Order 233484712267 not present in blotter

{"asctime": "2021-05-16 13:41:06,704", "levelname": "WARNING", "message": "Order 233484712267 not present in blotter", "bet_id": "233484712267", "market_id": "1.160683973", "customer_strategy_ref": "BlueOcean", "customer_order_ref": "d0df7e7076e65-138404651686586786"}

INFO:flumine.order.process:Order 233484712267 added to blotter```

and from that point onwards everything works as expected.



So all that makes sense, however, in reality I don't want that first order to be placed as its effectively a duplicate. So how can I get the above to run before an order is placed (at which point Flumine won't place the order as it will see 1 already exists)?

---

## 2021-05-15 06:35:24 - general channel

**Oliver Varney**

for me I use a trade level exposure (derived from strategy +predictions strength etc), wtih the trade containing the logic to fire additional orders

---

## 2021-05-15 06:07:40 - general channel

**liam**

Set [https://github.com/liampauling/flumine/blob/8c69f49f28c145c9f4ca4d0130067e4277975c4e/flumine/strategy/strategy.py#L51|this](https://github.com/liampauling/flumine/blob/8c69f49f28c145c9f4ca4d0130067e4277975c4e/flumine/strategy/strategy.py#L51|this) to one when initialising the strategy 

---

## 2021-05-14 18:19:38 - issues channel

**Phil Anderson**

Hi, can someone help me with MARKET_ON_CLOSE persistence type please?

I keep getting failed placement when I change from LAPSE or PERSIST to MARKET_ON_CLOSE.

I'm still testing on delayed key. Could this be the problem? I couldnt find anything to say I shouldnt be able to.

Below is code I've been using, and only changinh persistence type



```limit_order = filters.limit_order(

    price=12.5, size=2, persistence_type="MARKET_ON_CLOSE"

)

instruction = filters.place_instruction(

    order_type="LIMIT",

    selection_id=runner.selection_id,

    side="BACK",

    limit_order=limit_order,

)

place_orders = trading.betting.place_orders(

    market_id=j.market_id, instructions=[instruction], # list

)```



---

## 2021-05-14 17:20:11 - issues channel

**Peter**

Returning to yesterday's issue - ~MATCH_ON_CLOSE~ MARKET_ON_CLOSE bets being lapsed. It turned out not to be a liquidity issue. Instead it was that I was calculating and rounding (2 decimal places) the transaction size and storing it in market.context, but when I pulled it out again, floating point precision being what it is, very occasionally what I received back would be different by 0.00000000000000001, which Betfair doesn't like and the order would be rejected. I suspect that my logging control log csv was showing the order as lapsed because it believed the order to have been placed, but didn't receive a settlement when the market cleared. Nevertheless, I learned valuable information about how far I can push backtesting, so thanks for the help with that, and I'll still be investigating the risks of not being able to fully match these orders , since that's still likely to be relevant when I start looking at scaling this strategy.

---

## 2021-05-14 16:47:54 - strategies channel

**D C**

Yeah agreed. But I would really like to get a model that spits out probabilities of each runner winning given the current (and previous) states of the GPS info as this would give me a lot more confidence in my ask prices being value.

---

## 2021-05-14 16:42:21 - strategies channel

**D C**

What I have now is crude compared with a ML or a statistical model and its doing ok. Maths is intersting and its useful but I'll not turn down profit because my approach is less sophisticated thats for sure.

---

## 2021-05-14 16:36:59 - strategies channel

**Mo**

Also [@U4H19D1D2](@U4H19D1D2)’s model is a series of if statements so ML is hardly required

---

## 2021-05-14 16:34:21 - strategies channel

**Mo**

I will say it's not their own model

---

## 2021-05-14 16:33:11 - strategies channel

**D C**

Yeah that was pretty much the only thing I could think of. Never used MLR in anger before so I will try it out. I've no idea if the TPD ML model is any good and its no use to me anyway but I was just aware of it and I would be surprised if they are the only one with such a model. I do know though that not everyone on here goes down the ML path

---

## 2021-05-14 16:30:33 - strategies channel

**Mo**

Two things [@UUE6E1LA1](@UUE6E1LA1). Firstly, I don't think you should put much stock in TPD's ML model. Secondly, regarding your uncertainty about different numbers of runners per race, you can just train different models for each number of runners

---

## 2021-05-14 14:54:24 - general channel

**Jono**

so thats the problem. Threading has significantly improved run time, now i want increase it further by having independant record keeping of the bets outside the strategy script entirely.

---

## 2021-05-14 14:51:04 - general channel

**Jono**

ok payload might be the inccorect term its just a json of basically the current order information, bet_parts, and strategy ids. - These are easy to keep track of inside the actual strategy script during run time but independently deducing which strategy and bet part an order is associated with is proving a difficult task

---

## 2021-05-14 14:43:01 - general channel

**Jono**

ok currently i have a things set up so that at the end of each strategy iteration a new thread is generated which sends a payload to the db and is then killed. I thought this would be the best thing to do in the likely scenario where the strategy has completed the next iteration before the previous thread is finished receiving a response from the db api for the previously sent payload. In the event i keep them in a queue to be dealt with in a single thread this will still result in rapidly growing queue of payloads that i imagine will cause problems down the line.

---

## 2021-05-14 14:24:25 - general channel

**Jono**

for the purposes of filling in an orders to database that an app then uses to display bets, strategy performance etc. Sending the payloads to db directly during the stragey was slowing runtime quite so moving things to this other independent script seemed like a prefereable avenue

---

## 2021-05-14 14:19:57 - general channel

**liam**

```this will allow a seperate script to run independently making a note of the orders without having to bother doing it in the actual strategy bot```

why the added complication? This isn't very scalable

---

## 2021-05-14 14:19:55 - general channel

**D C**

You can supply a strategy string to filter listCurrentOrders so get all bets under that strategy.

---

## 2021-05-14 14:18:45 - general channel

**D C**

So for me with each distinct strategy I will generate a unique strategy string which forms part of the customer order ref for each bet placed under that strat - like your example. I then parse that customer order ref to identify which strategy the order belongs to.

---

## 2021-05-14 14:16:34 - general channel

**Jono**

ok maybe ive been using the wrong field - and its the rest api at the moment. I want to keep note of what strategy part each bet corresponds to. i want to do that by appending a string to the order saying basically the strategy id and bet part something like    "id:123 bet_part:69 ". this will allow a seperate script to run independently making a note of the orders without having to bother doing it in the actual strategy bot. is there any way to retriving  all current orders along with their references - so not filtering for them actually retrieve all strings. what is the best field to use in order to do something like this

---

## 2021-05-14 14:15:09 - general channel

**D C**

I don't think placeOrders actually returns the strategy ref in the response

---

## 2021-05-14 14:14:47 - general channel

**D C**

customerStrategyRef applies to ALL bets supplied to a single call of placeOrders whereas customerOrderRef is applied PER bet.

---

## 2021-05-14 14:08:07 - general channel

**Jono**

sorry to clarify: just iterate through all current bets printing bet_id, size_remaining etc and customerRef/strategyRef

---

## 2021-05-14 14:03:25 - general channel

**Jono**

Im currently getting to grips with the customerRef and strategyRef fields. After an order has been successfully placed whats the best way to display all current orders along with their associated references? i can see they arent in the standard current order response in the docs. Thanks

---

## 2021-05-14 10:19:07 - strategies channel

**D C**

I've written a lot of software GUI tools that allow me to "replay" inplay data and this is where I have got most of my initial ideas from. All I am willing to say really is that I have not yet got what I suppose most of the other TPD guys here have (and what TPD sell to bookies) and that is a ML (or not ML) model that models a probability for each runner at each point in time. I have tried this but my knowledge of ML is just not advanced enough. What I have is more simple than that but in some ways also more complicated. That sounds strange probably but hard to explain further without giving the game away.

---

## 2021-05-14 10:09:55 - strategies channel

**PeterLe**

[@UUE6E1LA1](@UUE6E1LA1) Sorry to hear about the health issues, hope you're on the mend soon. Its interesting about what you said about TPD (my best month is march too but not incorporating TPD). Ive had the feeds for a while now and whilst my normal bread and butter stuff is coming on leaps and bounds, I'm embarrassed to say that my TPD is yet to bear fruit. (In fact it hindered my results if anything)

I'm only recently been able to start recording the TPD data and building on that, but without giving away the crown jewels, could you give an idea about how you would approach modelling it in general?

We all work hard for our edges, so I dont expect you to give anything away as such, just a common sense approach and a sense of direction would help me! Thanks

---

## 2021-05-14 08:55:01 - issues channel

**Peter**

I suspect that this is impacting time to placement, which happily isn't a big deal for the strategy that's encountering the issue at the moment. But if you have strategies running where this is more significant, you might want to check that they're OK.

---

## 2021-05-13 16:08:47 - issues channel

**Peter**

I'm inclined then to settle on insufficient liquidity, especially since available to lay exceeds available to back in the SP portion of the market. Bummer though since that would constrain the strategy's scalability. Many thanks for the insight.

---

## 2021-05-13 15:59:52 - issues channel

**Peter**

Running into an odd problem that I'm hoping somebody here can provide some insight into. I have a strategy running where some of the bets placed are MARKET_ON_CLOSE, placed near the off time. Most work fine, but a small proportion are LAPSED. I'm trying to reason as to why. So far I've confirmed that they're not non-runners, not below £2 min bet size and not placed too late.  To make this still more difficult, when backtesting the markets the bets work fine, which would seem to argue against my latest hypothesis (insufficient liquidity to balance the SP book).

---

## 2021-05-12 21:00:50 - strategies channel

**AndyL**

Its also somewhat to get my engineer head into rather than frustrating over a strategy!

---

## 2021-05-12 20:54:40 - strategies channel

**birchy**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) definitely get Flumine up and running with [@U4H19D1D2](@U4H19D1D2)'s marketrecorder example (it pretty much works straight out of the box). That will give you ALL of the market data for each race. Also setup a basic strategy to avoid account suspension for leeching. Again, [@U4H19D1D2](@U4H19D1D2)'s lowestlayer example will suffice, but I'd suggest setting the price trigger to something like 1.80. You won't lose much laying odds on runners.

You can also run backtests in Flumine once you have a month or 3 of recorded data. What I would suggest is to use this ability to parse the data files to gather statistics rather than run full backtests. From there, you may find some useful patterns, upon which you could run a few backtests to prove they work as a strategy. And then.... assuming that you've done all of the above and backtests show that your ideas are sensible, you can port the Flumine strategy to live betting, which will give you "real world" data to analyse.

---

## 2021-05-12 20:51:25 - strategies channel

**D C**

This is very good advice, but I should point out that most of the losses were simply from recreational gambling rather than losing shitloads trying to invent systems and strategies. I spent years analysing and gathering market data but instead of waiting for something profitable to transpire and saving the money I would bet like a mug at the same time. Now I have documented a lot on twitter that at times I have been close to having a problem with gambling - always at bad personal times in life. While there is nothing wrong with having a bet with money you can afford to lose, I would always deter someone from betting to try and "beat" other problems in life. When chasing a system or trying out some automated strategies I have never really lost a lot of money, it is just the recreational betting that dragged that down. That and betting during "bad times". For example, one day while being a Phd student I was having some personal issues in life - debt, lack of self belief (something any phd student knows all about) topped off with some relationship issues. Basically spanked £4.5K of money off a barclaycard in a single afternoon making self destructive bets in-running. I'll never be able to explain why it happened - and thankfully you can no longer use credit cards to deposit. But for me this is the dark side of what we do and every day I make a profit I am really hoping that there is not someone on the other end of it in that same dark place I was that afternoon. This experience has always grounded me and was a low point. It is also the reason that I will only ever consider automated gambling now because there is always a part of my mind that questions if I can trust myself.

---

## 2021-05-12 20:15:46 - strategies channel

**Mo**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) something I wanted to suggest based on a comment you made is that maybe you should focus more on writing software if that is what you enjoy. For example, build a dashboard or some other tool, something that is not directly strategy development but that lets you engage with the data and get the creative juices flowing while also being more enjoyable and less pressure

---

## 2021-05-12 20:13:44 - strategies channel

**ShaunW**

There might only be a finite of set of parameters but each can be viewed in many ways. Eg time, is that the time frame you're active, time between refreshing bets or time to measure price moves or acceleration. And price, is that %implied chance or relative to others, and is that touch price or one of the many fair pricing models (vwap vpoc MA WoM type things). There's more than enough permutations to last a lifetime. And more you're involved the more variations you find but like a lot of complex problems look for the elegant simple solutions.    Don't waste money using trial and error in live, you can be pretty sure before you commit cash.

---

## 2021-05-12 19:21:32 - strategies channel

**Beeblebrox**

I don't think everyone who is trying is spending years losing money though.  You don't need to be betting to work out if a strategy you're proposing to use has any legs, you can paper trade or backtest or do any of the other things [@UGV299K6H](@UGV299K6H) has suggested.  You do seem overly keen to bet, and then as soon as it goes wrong after a few days, you move on to the next idea.  I don't think success comes that easily - it takes time, but you don't have to be losing lots of money whilst you're trying to find what works.

---

## 2021-05-12 19:01:08 - strategies channel

**D C**

For many it is the allure of "beating the system". Don't forget that in this space there are lots of false traders selling the "dream" because they want you to buy their crap e-book that purports to show you how to be a successful "trader". Lot of people buy into that narrative, others are addicts. For others it can be a refusal to give up. That was the case for me - I thought I had the right mix of education and programming skill to beat the markets (initially through modelling).  I had limited success on american sports many years ago when the bookies prices were utter shit but they caught up with my relatively "simple" models after a few years and I was a student at the time and could only afford to bet pennies. I lost about £50K at Betfair alone and proably the same again (if not more) at bookies but it was only recently that I turned the tide on that one and started making profits. Small time compared with many here but profit nonetheless. But you would need to ask everyone here as to why they still try because everyone has a different backstory and life experience.

---

## 2021-05-12 11:04:46 - strategies channel

**Michael**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) I wasn't suggesting that you use WOM, I was just using  that as an example to illustrate how you could investigate a theory without getting bogged down in back-tests or losing money. Any strategy is made of a series of conjectures like _'signal X indicates back value'_ and _'this effect is stronger at shorter odds'_ (or whatever). There's more than one way to develop a strategy but the way I go about it is to look at each of those conjectures, check if they're true in isolation and see how they interact. Then I stitch them all together the best I can. That way you end up with a well reasoned strategy with little risk of overfitting. That approach also lends itself to adding in new signals into your strategy as you find them rather than ending up with a proliferation of strategies and no overview of how they relate to one-another. Shotgun back-testing with made up parameters will inevitably over-fit.

---

## 2021-05-12 10:23:16 - strategies channel

**AndyL**

Ok that is pretty much what my recent-£90 strategy was doing, my fair value was the 30sec SMA of mid price, when 6% above i would offer a Back, -6% Lay

---

## 2021-05-12 10:11:02 - strategies channel

**AndyL**

So ive used vwap for that sort of strategy,  waiting for price to be a certain distance above or below vwap as a trigger then entering on theory of reversion to vwap, but that alone was not profitable, so i added all sorts of filters, race type, price of other horses etc..but this seemed to be back fitted, although it may have legs with time..not sure

---

## 2021-05-12 09:25:11 - strategies channel

**Jonjonjon**

[@U01DPK9PGMC](@U01DPK9PGMC) That's quite a great suggestion. I've recently been having problems with slow backtests, as my strategy recalculates "fair value" with every market book update. But I could probably just calculate "fair value" at a single fixed time (e.g. 5 minutes before the race), and then start analysing the performance of the fair value signals.

---

## 2021-05-11 19:49:48 - strategies channel

**Michael**

My suggestion would be that you forget about back testing for a bit and just try to think through the logic of what you are doing - what is the critical bit of insight that's going to find you your +EV bets? Then research, check and prove (or disprove) your thinking. Let's imagine you'd just 'invented' weight of money; you wouldn't have to back test some strategy to see if that was predictive, you could just take every instant of every market and see if more WOM = more value to back, 0 wom = 0 value and -WOM = lay value. No wishful thinking, no _'only maidens on a Tuesday'_ no money down the drain. Just a nice graph that tells you 'yes' or 'no'. If your strategy isn't well reasoned and proven to the greatest extent possible then you don't need to test it, I can tell you right now that your bets will be -EV.

---

## 2021-05-11 19:28:39 - strategies channel

**Michael**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ): As a new player you're very likely to have a lot of variability as your edge (if you have any edge at all) is likely very thin, so in your position 5 days of racing is almost nothing. Just step back a little bit and ask yourself if you're being sensible: Is the logic of your strategy sound? Have you done everything you could to research and validate your thinking - not just back-testing but looking at your strategy and trying to stand up your various conjectures with data? Are you betting at sensible odds? Are you betting with minimum stakes? Have you set the thresholds beyond which bets are triggered nice and high? Are you placing minimal bets per event? If you can't answer all that in a well reasoned way then stop and reassess.

---

## 2021-05-11 19:09:52 - strategies channel

**liam**

No rush in this game, what did your back tests say on this strategy? £90 draw down expected?



Ignoring the hedge you can calculate your EV using a simple formula however make sure your sample size is large enough 



[https://betfairlightweight.slack.com/archives/CTPL3R3FU/p1618859325404000|https://betfairlightweight.slack.com/archives/CTPL3R3FU/p1618859325404000](https://betfairlightweight.slack.com/archives/CTPL3R3FU/p1618859325404000|https://betfairlightweight.slack.com/archives/CTPL3R3FU/p1618859325404000)

---

## 2021-05-11 18:59:22 - strategies channel

**Dave**

Many people here are successful from modelling off of price action alone I believe - I am not one of them (entirely fundamental) so I probably cannot help. Generally it is safe to assume that at current time fair value lies somewhere between the best back and best lay. A shift in the best back and best lay itself doesn't signal to me anything other than a move towards a 0EV price (in general). I guess the game is to guess when it has moved towards fair value, or has moved away (but a move itself in some direction without context of full market observations can hardly signal this to you I think)

---

## 2021-05-11 18:58:37 - strategies channel

**AndyL**

Must agree when people say dont trade in a bad mood, after losing £90, realising a stupid strategy and frustrated... i cant think straight...

---

## 2021-05-11 18:56:32 - strategies channel

**AndyL**

Can you have a model on price action alone? Or do I need to scrape form from some website...?

---

## 2021-05-11 18:42:29 - strategies channel

**AndyL**

So what is efficiency? I am assuming an efficient market wont deviate much, [http://ie.it|ie.it](http://ie.it|ie.it) has found neutral value and any deviation   reverts very quickly..? It's difficult to trade because prices offer little value..

So let's go the other end, 10am in the morning 4hours before a race, market volume total maybe 10k if lucky, so prices  meander and move a lot as the market is not efficient, which means noone knows where neutral value is, which also means you cant pick a value bet as neutral value is not known...so how can you trade it other than a fundamental model?

---

## 2021-05-11 10:17:42 - strategies channel

**Peter C**

I am not the person best placed to answer but the favourite/longshot bias is talked about extensively in 'efficiency of racetrack betting markets' from both a tote pool/fixed odds perspective. I think in terms of a tote pool it is talked about in terms of punters preferring high risk/high reward bets and so over betting on those horses. Not sure why it persists in a fixed odds environment

---

## 2021-05-11 10:01:30 - strategies channel

**Greg**

I often used to wonder if my 5-600 odd manual bets/trades in one week, when I can be bothered but when I want to manually top up my balance, mess with efficiency models in Aus.I might do it twice one month and four the next.Guess it is a relative drop in the ocean though :grin:

---

## 2021-05-11 09:32:14 - strategies channel

**Mo**

There’s a lot to unpack here but a couple of quick points. Firstly, using the win market to price the place market is a well trodden strategy. It works but is also likely to be very competitive. Secondly, you can’t just say the pre-off win market is largely efficient. There’s a huge difference between the market five minute before the race starts and five hours before

---

## 2021-05-11 09:29:26 - strategies channel

**Peter C**

Really enjoyed a lot of the recent conversation - it kind of inspired me to have a go at modelling pre-off horse racing using market info. My model is trash, but it's been a good learning experience so far. I've been reading back through this slack and wanted to ask about using price data to fit a market.



I'm not quite sure what my thinking is - I have a few thoughts but I'm not sure. I have thought that maybe the win market is largely efficient - and therefore I could use price data to model a projected sp that I could then take to eg the place market.

I've also thought that perhaps I could use features that aren't derived from the current market price to fit my model - eg the sp far price, and then 'return' to the market (the current price) to amalgamate information a la Will Benter.

I've also thought that maybe I should include features that are derived from the current runner price to fit my model, with the intent of coming up with a projected sp interval that I could use to place bets when I see an edge - but I'm not sure how feasible this is given my assumption that the pre-off win market is largely efficient - I'm also not sure it makes sense to take the current price and +/- a bit to come up with an sp.



Not necessarily looking for specific answers to my questions but I would be interested in people's ethos surrounding this or perhaps someone is able to point me to some resources where I can learn more? I feel like I am missing a huge chunk of understanding on this topic. (I'm reluctant to go straight to google with 'price action' because I suspect there's a lot of bullshit out there; I've read the majority 'efficiency of horse track betting markets').

 [@UBS7QANF3](@UBS7QANF3) the other day you used the example of using bsp to come up with an implied distribution of runner's speeds for inplay betting. I understand this example but am not sure how this would be achieved within a single market - I need to think about it further, maybe this is the understanding I'm missing

---

## 2021-05-11 02:25:35 - issues channel

**Greg**

Hi all. Having a go (be gentle -have only been studying Python for 3 months-so here come the very dumb questions:laughing:) at logging in with the delayed key/Flumine. Managed to login  run the example strategy (using AU markets-[https://liampauling.github.io/flumine/](https://liampauling.github.io/flumine/)) I have set paper trading to True but that, changing the price entry (see LimitOrder below) point, changing _runner.last_price_traded &lt; 10_ and setting the filter to AU instead of GB are about the only changes I have made. Unfortunately I get not output at all-or errors. 'Couple of questions to kick off with : *1*.I have seen references on this channel to the delayed key (despite mine being created after April 8th 2020 so should have access to streaming )being utterly useless and I wondered if this is the problem? i.e.: is the delayed key pointless and does it effectively prevent anything from working? *2*. Does Flumine (being a fully featured/ backtesting platform) effectively supersede BFLW (I know BFLW is a dependency for Flumine) ? *3*. The example strategy has an (LAY) order parameter of _order_type=LimitOrder(price=1.01,size=2.00)_ I tried to change the price to &lt;10 for example but get an error. How do you set a price range for multiple runners in Flumine using limit orders? Thanks in advance.Apologies for the basic questions and I'll try limit them as I go. Cheers

---

## 2021-05-09 18:33:16 - strategies channel

**birchy**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) I'm a bit late to the party, but have you compared what the P&amp;L outcome would of been if all of your bets were placed at BSP instead of your actual matched prices? Essentially, you need to:

a) prove that your bets are being matched at prices better than the BSP

b) determine if you were simply unlucky on your bets so far

I posted a Monte Carlo simulator a while ago that will give you a result that tells you if your strategy is better than picking random selections. Will repost when I find it...

---

## 2021-05-09 16:53:37 - general channel

**Dave**

&gt;  And i should probably just focus more on the other markets.

If you have a decent edge in To Score then there's no reason not to focus on it! It seems pretty illiquid so easy to be top of book while maintaining large margin over your model price

---

## 2021-05-09 06:50:37 - strategies channel

**Peter**

Any time I get a positive EV, I'm happy as that's an indicator hat there might be something there. But it's just a starting point. The next step is to look for other signals with which it could be combined to push the EV up and bring the variance down. But you need way more data that a handful of days of experience. I typically backtest several months worth of data (usually circa 10,000 active bets) to obtain data for training and development and then run the candidate strategy against as much again to validate that it holds up on previously unseen data. Only then does it get launched onto the exchange with small stakes to see how it performs in the real world.

---

## 2021-05-08 23:35:50 - strategies channel

**thambie1**

Backtest your strategy over a long enough period and you'll get an idea of what downswings you can expect. If you're unhappy with the risk profile, you can always work on it. For example employing the kelly criterion.

---

## 2021-05-08 13:36:48 - strategies channel

**Unknown**

Just happened to notice this one :grinning: Can we have a strategy for catching them every time :grinning:

---

## 2021-05-08 11:56:58 - strategies channel

**liam**

Ignoring TPD I am 100% price action of which 90% is based purely off single updates but I am a cowboy when it comes to strategy development where my edge is in execution 

---

## 2021-05-07 23:18:39 - strategies channel

**Michael**

It's a question of your style of play. Ignoring TPD based betting I believe [@U4H19D1D2](@U4H19D1D2) and I illustrate the two extremes. I like to get my bets matched so I'm up at about 80% match rate, but I place comparatively few bets. [@U4H19D1D2](@U4H19D1D2) leans more towards a lot more bets with a lower match rate. I wait until I can see a bucket load of edge on a runner and then ask for only a portion of it, hence the high match rate whereas Liam is (presumably) requesting a lot of edge all the time. You can do either, both or something in between. The one thing I recommend that you avoid is posting a lot of bets with only a little bit of edge - that will go badly wrong.

---

## 2021-05-07 22:23:23 - general channel

**John**

Hi I was trying to do paper trading for a strategy with a range of parameters values (e.g. context{"a": 0.1}, 0.2, and 0.3) in flumine. I was using only one script to run all three systems by adding 3 strategy objects to the flumine framework. Since they were using the same strategy class, when writing the logs at the logging control (using the flumine example),  I was not able to differentiate these three systems. I wonder if there is a way for me to pass those parameter values (a=0.1, 0.2 and 0.3) from the BaseStrategy class to the LoggingControl class so I can differentiate these 3 systems? Any pointer will be highly appreciated!

---

## 2021-05-07 09:32:41 - issues channel

**liam**

forseen at one point :face_palm:  [https://github.com/liampauling/flumine/blob/4924616d3764ab5ea861a21a72054dc93d812d61/flumine/controls/tradingcontrols.py#L122](https://github.com/liampauling/flumine/blob/4924616d3764ab5ea861a21a72054dc93d812d61/flumine/controls/tradingcontrols.py#L122)

---

## 2021-05-06 14:40:25 - random channel

**Oliver Varney**

haha so actually my 19/1218 is an underestimate most likely, hmm interesting. Was only looking because I have been massively on the wrong side of them recently and thought id do some digging not that it would change anything (nothing for strategy thinking ill leave that to the IP guys)

---

## 2021-05-06 14:34:10 - random channel

**Oliver Varney**

hmm i guess what im struggling to understand is who is the fool in this situation and why are they running a loss making strategy, or is it just joe bloggs with betangel and a trigger finger putting his mortgage on

---

## 2021-05-06 14:31:07 - random channel

**D C**

On paper laying the field at 1.01 is profitable - if you can get front of the queue. This is where the "strategy" falls apart for cases where not a lot is matched there on a losing runner

---

## 2021-05-06 13:22:31 - strategies channel

**Misha**

I have been in this field for about 11 years. As a software engineer I spent the first 10 working for two large clients where I was given "carte blanche" to develop systems based on rough ideas with absolutely no specification as to what technology to use. This is the holy grail for an experienced software engineer - the ability to research, trial, and implement using anything I wanted, as long as it worked. The first client was nuts and the second client moved his whole operation overseas, so about 18 months ago, after 30 years working, I was trying to work out what to do. I had a good maths background, dabbled in tennis with Betfair right at the start, and had seen the obscene amounts of money it was possible to make (and had a friend from University start a hedge fund based on his algorithms and make $200M AUD), so I thought, let's have a go (with one other partner). The goal is simple: develop a fully automated system that ensures I never have to earn a single dollar from anyone else for the rest of my life (i.e, make enough money to cover living from age 52 onwards, with a family). My view was that I was almost certain I could get there, but not sure of the timeframe. So far so good. As of right now, I am returning about double my best ever monthly earnings. But to get to the level I need, I really have to increase that by a factor of 5, because nothing lasts forever. Fortunately we chose in-play tennis, which if you bet after points, has ample liquidity to get there and more (if the model works). We are a long way from finished, and the trajectory is in no way a line straight upwards. We had our worst day ever yesterday, when we lost $60K AUD, $48K in the last 14 matches. But that happens if you are betting on an outcome, not trading to hedge (nothing like a huge amount +/- coming down to a third-set tiebreaker). Not sure as a risk-averse person I was really cut out to do this, but the potential reward is just too big not to have a go

---

## 2021-05-06 13:06:12 - strategies channel

**liam**

:thumbsup: you can still get the result of a market if you make a marketBook request (normally cached for 2/3 months) or just ask on here :wink:



Your test shouldn't have scared you off not hedging but scared you off the strategy itself! If the initial order isn't making money (value) on its own then adding another that crosses the spread certainly isn't. As [@ULDAVFDRP](@ULDAVFDRP) mentions you have the BSP as your base price to try and beat, if you aren't beating that then it is likely you won't make money.

---

## 2021-05-06 13:00:17 - strategies channel

**AndyL**

[@U4H19D1D2](@U4H19D1D2) you're spot on, i fell for the back fitting attempt at automating manual strategies, although the BA forum being mostly manual traders it sort of inevitable push that way. But i'm learning now... I've also I think finally understood the "crossing the spread" cost, as that 2nd hedge bet has no strategy, so it is just a "cost" to keep pnl less volatile, and it is quite a cost, although not sure I quite understand how people figure the value 3-4 ticks suggested? But anyhow, with the sort of stuff I was looking at that was probably taking all my miniscule profit!

My backtest data covers &gt;2k UK races now, but because I was filtering so much that reduced to about 400 with the filter!

The other glaring omission now with my backtest data, is I just recorded (using BA) up to the scheduled start of each market, so I don't know which horse won!!  So I can't actually backtest with no hedge, i'm feeling very dumb now!

You may have seen in my thread I tried a while back a strategy with no hedge, but it very quickly went negative big time, so scared me off!

---

## 2021-05-06 11:29:07 - strategies channel

**Michael**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ): From where I am now I look back on when I started betting and I can see how much I benefitted from not really caring too much about it. I was fairly broke but I didn't really mind, I had other stuff on and it wasn't like I had any expectation of making significant money. I just tried some experiments out of curiosity, it was interesting and fun and winning a few quid was the cherry, not the cake. That left me free to learn without pressure which is the best way to learn anything. Had this channel existed then I don't think it would have helped me, I wouldn't have understood any of the maths or programming stuff (a lot of it still goes over my head), I would have just been overwhelmed and put off. So here's my advice: Look to get something out of this that isn't money - like learning programming or just having fun. If the enjoyment or the learning or whatever you're getting from it become not worth the cost in time, money or stress then consider doing something else that will reward you more. Most winners (especially the individual types) have their own special bits of proprietary Mojo, if you're going to be a winner you'll need to find yours so be curious, explore, and go your own way. Above all: Don't have a shitty time, in the end this is just gambling, it's worthless, it's pointless, it's a drain on humanity. It doesn't matter.

---

## 2021-05-06 06:40:15 - strategies channel

**liam**

Agreed, but you come at this from knowing the above and knowing where you value is. Lots of people try and automate/analyse/make money from hedging being part of the strategy rather than the execution.



But yeah as you mentioned it comes down to market impact, I tiny change in matching rates can make or break a strategy (I get burnt weekly :joy:)

---

## 2021-05-06 06:38:04 - strategies channel

**liam**

```Just been doing some "inplay" thinking... take this scenario:

- Typical flat 10 horse 1m race

- 2furlongs left horse1 is 6 lengths clear, price is 1.2

Is that "value" or not?

The answer has to be you haven't got a clue! Unless you really know how good horse2,3,4,5 are doing and have left in them from "fundamentals"

You could assume 1.2 is neutral value and offer 1.5 for 5 seconds, but 5seconds later horses 2,3 may close sharply, and at that time 1.5 is now no longer value.... So with my "crystal ball" 1.2 was in fact great Lay value, as fundamentally horses 2,3 had it in them...

So it all comes down to "fundamentals" really...?```

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) my thoughts on the above:



Ignoring TPD it is very tricky to accurately calculate the number of furlongs left, however you can estimate the time length. See [https://medium.com/@paulingliam/using-ml-to-predict-horse-race-time-duration-6340776536e4|here](https://medium.com/@paulingliam/using-ml-to-predict-horse-race-time-duration-6340776536e4|here) for a post I did on using ML to calculate horse race duration, I use this all day and everyday and it can be very powerful. Calculating the distance between two horses is not possible, if you are automated you only have the odds to go off (which is enough :wink:)



Personally I Ignore the horse, ignore the fundamentals, ignore the jockey, I don't have the skills to race read or understand how a horse will run so neither will my models. Tbh I have found that once a race starts everything goes out the window anyway to the point that I ignore BSP as I find it more of a hindrance in model developing (I believe [@UGV299K6H](@UGV299K6H) mentioned the same recently)



In your post what you are missing is that value is a function of time and that all of the odds you have mentioned are most likely value. For example your horse 1 is trading at 1.2|1.3, if I had to bet on this I would want my lays matched at 1.2 and backs matched at 1.3, due to the spread it is likely the true price at that *time* is somewhere between 1.2 and 1.3. Now if the price suddenly jumps to 1.3|1.5 because of something that has happened on the track I would get stuck in to laying between 1.2/1.3 taking advantage of what you describe as a crystal ball. Everyone is reacting and not everyone is as quick as everyone else, its what makes inplay so volatile and brilliant. The real trick is getting matched.

---

## 2021-05-06 06:34:14 - strategies channel

**Oliver Varney**

Looking back at my naive hedging I am still glad I did it when starting. It gave me the possibility to daily compound on returns that were realised over at day at more then 10% on small stakes. It also focused the mind into beating BSP which sometimes can be lost if you leave the money on.  The instant feedback I think is more important for someone at the starting of there journey then that 1-2% assuming youve got strategies that can run greater then that. So many times in this slack ive seen the same message saying it worked for a month then collapsed but bsp was always show slight negative so was destined to fail. These days my hedge would take out upwards of 3-5 ticks jumping across the spread so its a no go. One part I still need to learn / improve on is offering more. Its far faster for me to build models can jump the spread for guaranteed value (in the models mind) then risk missing the good ones and getting picked off on the bad ones.

---

## 2021-05-06 06:22:19 - strategies channel

**liam**

[@U01PJ5YMFBJ](@U01PJ5YMFBJ) it certainly sounds like you are falling into the trap of back fitting coupled with applying manual type 'trading' styles and filters. Sports betting might look similar to financial trading with its fancy graphs but it's very different and to [me] it should be treated very differently. You are correct in saying you need to be wired differently but I do believe it can be learnt assuming you are open to it.



First off to make money in sports betting you need to get value, there is no compromise to this, if you are not getting value then you are not going to make money. It doesn't matter if you are market marking, scalping, swing trading, auto betting, manual betting etc. it's mathematically impossible to make money without getting value. Write 'value' on something in front of your computer and anytime you do something think about whether it makes sense to do from a value point of view.



For example you mention 'hedging', lets say you develop a signal that you believe gets value 60-10mins out from start time at around 2% ROI, unless you are limited by bankroll (I doubt it in sports) there is no planet where randomly crossing the spread in order to hedge is going to make you money long term. It is likely that you will either completely remove that 2% ROI or go negative. Does randomly crossing the spread at post time give me value? No. However assuming you are getting a decent chunk of value in the initial order and hedging allows you to even out your pnl / take advantage of as much of your bankroll as possible etc. then I can see its benefits (aka [@ULDAVFDRP](@ULDAVFDRP)) But this is under the assumption that you know where the value is and you are taking the hit, this second order should not form part of your analysis when trying to find a profitable strategy.



If you developing an automated strategy that works pre race but find yourself having to filter on race types, fave odds etc. to show a profit then stop. Take a step back, I write a lot of stuff down and simply writing what I am thinking makes me realise that I am an idiot when I come up with daft stuff like race type filters / limiting the odds etc. To me this says either back fitting or that my signal is not correctly developed.



I have skimmed your on going thread on BA and the big thing that sticks out to me is your sample size relative to what you are doing coupled with I assume your execution on hedging. I tend not to make any changes or remove strategies until I have at least 1k orders through the market, and at that point I start to analyse [everything] and not just the pnl but matching rates, profit vs trigger / odds / time to start / volume etc. I don't think I have seen you go into this detail on your thread? (I might be wrong)



_I will talk about your latest inplay post next, to be continued.._

---

## 2021-05-05 22:59:58 - strategies channel

**Mo**

I'll give you my personal opinion. I think that the ability to come up with ideas that are likely to lead to profitable strategies is a rare skill. It's hard in the same way that being creative is hard. It's not really something you can force yourself to do. I don't think I personally possess this skill, hence why I believe networking is so important. Taking a ground up approach of building a model with the idea that it will give you a better price than the market is very very tough, whether that is the latest machine learning model or some technical indicator borrowed from finance. You should be thinking about why does the market think the price is X and what are the situations where it may have gotten it wrong. For example, favourite-longshot bias, early markets, obscure sports/leagues, punters wanting to bet on goals, not wanting to bet on draws, etc. etc.  Work out what parameters are implied by the market eg goal scoring rates. When you think the market is correct then plug these into models. Find situations where there are discrepancies (=statistical arbitrage). Think about things in terms of a system you're trying to exploit. How can you probe it? How does the Betfair matcher work? How can you be first in the queue? How does crossmatching work? What are the rules for the markets you're betting on? First understand then attack

---

## 2021-05-05 22:29:19 - strategies channel

**AndyL**

Ok how about this question, what makes a profitable strategy hard to find? Is it its complexity? Or are they just simple but just so obscure that they are really difficult to find?

---

## 2021-05-05 14:59:14 - general channel

**Jono**

So far its looking as if introducing a separate thread to handle the latency filled request solves this issue ive been struggling to get around. I was wondering if the trading object can be used in multiple threads in order to speed up run times further? For instance if i wanted to run a strategy over 10 events currently listed on the exchange would it be possible to initiate a thread per event, pass each thread the trading instance, and then place/adjust orders without causing problems?

---

## 2021-05-05 11:02:33 - general channel

**Jono**

Thats looks just like the field i'd need to do as you suggested [@UBS7QANF3](@UBS7QANF3) and set up an independant script keeping track of all relevant orders to the strat :ok_hand:

similarly [@U4H19D1D2](@U4H19D1D2) [@ULDAVFDRP](@ULDAVFDRP) i'll try out generating a thread to handle the slow requests in the event i run into problems attempting to separate the post to the db from my current strategy logic. Thank you very much everyone, ill shoot back with anything else i get held up with along the way, the helps been class as usual

---

## 2021-05-05 10:58:26 - general channel

**Mo**

Both references are very useful. Something outside the box you can do is use the stake size to tag orders, for example, encode stakes of £X.01 as one strategy, £Y.02 as another etc

---

## 2021-05-05 10:55:14 - general channel

**Oliver Varney**

customerorderref and customerstrategyref I think they are

---

## 2021-05-05 10:54:28 - general channel

**Jono**

yes [@UBS7QANF3](@UBS7QANF3) that seems like a solution but one of the reasons i was reluctant to go down that path was trying to work out what bet is associated with each strategy.

---

## 2021-05-05 10:53:13 - general channel

**Jono**

thanks guys. so certainly latency in the post made at the end of strategy is causing unnecessary time to be wasted. i suppose this kind of goes beyond bflw but basically i want to make this post request and forget about it.

---

## 2021-05-05 10:41:32 - general channel

**Oliver Varney**

[@UBS7QANF3](@UBS7QANF3) if you dont mind me asking, does that mean you sub accounts with the same strategy fight for the same volume and some accounts will get a greater slice of the pie?

---

## 2021-05-05 10:40:30 - general channel

**Jono**

network latency specifically is the problem here, the database is hosted on a cloud server which regardless of how im keeping track of the bets will always be where i have to send updates to. I dont need the strategy to use any info from this db endpoint i just need to send it updates. the resp time is holding things up. If threading is what sounds best for this issue i will definitely look into it.

---

## 2021-05-05 10:34:04 - general channel

**Mo**

I run the same strategy across multiple accounts

---

## 2021-05-05 10:26:12 - general channel

**Jono**

has anyone had any success using bflw with the aiohttp package? i have to perform a post request to a database after each event iteration performed and the wait time for the response is slowing the strategy down quite a bit. There isnt anything in the post response that is needed for the next iteration so i was thinking about implementing  some async logic along with aiohttp in order to perform other tasks without holding up the next run waiting for the response. I noticed though there is quite a bit suggesting that regular python requests will hold up an async event loop defeating the purpose of creating the event loop to save time in the fist place. Will this be the case with bflw and if so is ther a way to make my post request to db and not wait for the response before carrying on with the next event in the strategy?

Cheers!

---

## 2021-05-04 19:41:51 - general channel

**Jonjonjon**

If I am backtesting a strategy that utilizes limit orders with the market on close persistence type, what is the easiest way to check if it was filled at BSP or not?

---

## 2021-05-03 16:07:42 - strategies channel

**MacrcoPolo**

I'm in favor of modelling it as a distribution, but poisson (even joint) really isn't correct. Markov chains give much more flexibility

---

## 2021-05-03 12:13:03 - strategies channel

**Dave**

There is some value in not modelling it as poission tbh...there are basic classification methods that give you reasonable probabilities. Edge comes from having clean and consistent data, good data science practices when it comes to fitting/tuning, and thoughtful execution in the market.

---

## 2021-05-03 10:41:45 - strategies channel

**user34**

In the academic literature, a Weibull count distribution with copulas outperforms other parametric models for the goal distribution ([https://blogs.salford.ac.uk/business-school/wp-content/uploads/sites/7/2016/09/paper.pdf](https://blogs.salford.ac.uk/business-school/wp-content/uploads/sites/7/2016/09/paper.pdf), [https://core.ac.uk/download/pdf/220685085.pdf](https://core.ac.uk/download/pdf/220685085.pdf)). As others have said, the real value comes from the actual parameter estimates.

---

## 2021-05-03 10:35:00 - strategies channel

**Michael**

From the football outfits I've encountered (which admittedly is only a couple) I think [@UBS7QANF3](@UBS7QANF3) is right that a lot of their value comes from data and insight rather than particularly clever modelling. Some of them are quite remarkable in their data collection, huge numbers of people, scouts at all matches all over the world and so on. They go really into the detail of near misses, opportunities, success rate in passing, tackling and all sorts. If you're starting out with a small operation you can't compete with that so you might look to play another way and use your strengths. That might mean betting small and frequent, effectively market making but with a little bit of added edge from a basic model.

---

## 2021-05-03 09:53:06 - strategies channel

**Alessio**

There's no single practice or way of getting to a profitable strategy. What may work for a syndicate may not work for you and viceversa just because the details are usually many. You can definitely start from the lambdas but it's a one score per the entire team over multiple matches, you will need to refine from there.

---

## 2021-05-03 09:52:24 - strategies channel

**Mo**

Depends exactly what you are asking:



1. Do they use joint Poisson distributions? I highly doubt it. It's well understood that this does not model the actual distribution of goals

2. Do they parametrise team strengths in this way? Probably but I think most if not all of their value is in deep analysis of the strengths including qualitatively, rather than the exact model structure

---

## 2021-05-03 07:41:06 - general channel

**liam**

Not using the API, you can with the flumine framework as it has backtesting and paper trading built in 

---

## 2021-05-03 06:37:30 - general channel

**Peter**

Don't think you need it. Running a Flumine strategy keeps your connections open, and even restarts them if they fail.

---

## 2021-05-02 11:17:04 - random channel

**birchy**

{"asctime": "2021-05-01 01:05:59,816", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/flumine/worker.py\", line 232, in _get_cleared_market\n    group_by=\"MARKET\",\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/betting.py\", line 432, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'groupBy': 'MARKET', 'settledDateRange': {'to': None, 'from': None}, 'customerStrategyRefs': ['ip-172-26-33-16'], 'marketIds': ['1.182752035'], 'betStatus': 'SETTLED'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang07b-prd-04190756-002ab3f9ad', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang07b-prd-04190756-002ab3f9ad', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'groupBy': 'MARKET', 'settledDateRange': {'to': None, 'from': None}, 'customerStrategyRefs': ['ip-172-26-33-16'], 'marketIds': ['1.182752035'], 'betStatus': 'SETTLED'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang07b-prd-04190756-002ab3f9ad', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang07b-prd-04190756-002ab3f9ad', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}

{"asctime": "2021-05-01 09:13:50,608", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/flumine/worker.py\", line 232, in _get_cleared_market\n    group_by=\"MARKET\",\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/betting.py\", line 432, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'groupBy': 'MARKET', 'settledDateRange': {'to': None, 'from': None}, 'customerStrategyRefs': ['ip-172-26-33-16'], 'marketIds': ['1.182736400'], 'betStatus': 'SETTLED'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang26b-prd-04190756-002b4d66d5', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang26b-prd-04190756-002b4d66d5', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'groupBy': 'MARKET', 'settledDateRange': {'to': None, 'from': None}, 'customerStrategyRefs': ['ip-172-26-33-16'], 'marketIds': ['1.182736400'], 'betStatus': 'SETTLED'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang26b-prd-04190756-002b4d66d5', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie1-ang26b-prd-04190756-002b4d66d5', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}

{"asctime": "2021-05-01 10:42:17,013", "levelname": "ERROR", "message": "_get_cleared_market error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/flumine/worker.py\", line 232, in _get_cleared_market\n    group_by=\"MARKET\",\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/betting.py\", line 432, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'groupBy': 'MARKET', 'settledDateRange': {'to': None, 'from': None}, 'customerStrategyRefs': ['ip-172-26-33-16'], 'marketIds': ['1.182736390'], 'betStatus': 'SETTLED'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang28a-prd-04270851-0008c9b97e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang28a-prd-04270851-0008c9b97e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'groupBy': 'MARKET', 'settledDateRange': {'to': None, 'from': None}, 'customerStrategyRefs': ['ip-172-26-33-16'], 'marketIds': ['1.182736390'], 'betStatus': 'SETTLED'} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang28a-prd-04270851-0008c9b97e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0006', 'data': {'APINGException': {'requestUUID': 'ie2-ang28a-prd-04270851-0008c9b97e', 'errorCode': 'UNEXPECTED_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}

---

## 2021-05-01 05:41:58 - strategies channel

**Oliver Varney**

Just a couple of things on coming up with a model, be careful your not over fitting or data mining whereby you apply filters till you hit a profit, yet are left with such a small sample size that it isnt really significant.  if you have historical data, split it into two sections (80-20% split is generally okay with a smaller sample which you have by the sounds), train / come up with the model on the 80% and test it out applying the logic on the 20%. The performance should only be measured against the 20% and any performance on the 80% should be disregarded.

---

## 2021-04-30 23:38:57 - strategies channel

**AndyL**

i've had a lot of advice, but to be honest it doesn't always help for whatever reason... maybe advice just out of context or different to what I think I want to do.. At the moment i've collected 2months of data on UK horses, and back fitting strategies, unfortunately "fitting" is probably the theme! I've sorted of ended up with a trigger when some technical event happens, eg.selection far from vwap, then have added loads of extra conditions, like the style of race "Hcap"(theory should revert more), front favs are competitive, relative volume of selection is great than others,... you get the drift. Then "hedge" at the off. So basically going round this sort of circle, attempt after attempt, find something that fits, then live test forward, and repeat... Sadly, the current bot strategy I think is half decent, I tweaked one parameter by 1% and it then became an instant losing strategy.... hm not happy sign

---

## 2021-04-30 16:13:53 - strategies channel

**Jonjonjon**

I know how you feel [@U01PJ5YMFBJ](@U01PJ5YMFBJ). I wasted a few months grinding away at IP data last year, and started a new PE strategy a the beginning of this year, but neither of the ideas seems to be going anywhere.

---

## 2021-04-30 12:40:24 - strategies channel

**river_shah**

I managed to find success across a few sports. Some more successful than others, some sports not very consistent but value +.  Will second Michael. The path to success seems very varied for people so follow the maxim: `"You can't tell till you bet"`

Don’t bet money you can’t afford to lose, don’t quit a steady job till your models are steady and if too much stress for the psyche, then don’t do it. There are consistent biases in gambling markets, so much is sure. Building the right technological process for you to exploit those biases is the hard part (flumine reduces that lift massively). Gambling market edges are not going away any time soon, as long as we face off large waves of behaviour driven money. There is not enough pro money to keep, for example, Grand National efficient vs the recreational crowd at all moments. Good luck finding hot decks.

---

## 2021-04-30 10:32:14 - strategies channel

**James T**

Thanks for the shout out [@UQL0QDEKA](@UQL0QDEKA), but you’re definitely overstating any help I’ve given you. You’ve done well recently purely due to your own self-motivation.



Generally, to do well, I think you either need to have the right background (programming, finance, maths, or have worked for syndicates) or you will need some advice and/or mentoring from someone who has. One exception to that rule is [@UGV299K6H](@UGV299K6H) though. Michael did you start with programming right from the start or did you use other methods of automation?



Personally it came to me as a hobby while working in banking. My first strategy didn’t work, and I was lucky with my second, so I was up and running within 3-4 months. Markets were probably easier to crack 10 years ago though. At first it did seem like a fun hobby or puzzle to be solved, and to see how far I could push it. But now after 10 years it definitely does feel more job-like to me and just the easiest way for me to make good money with the least effort. 



Long term it’s always relatively difficult though I think. You can’t expect edges to last forever so it’s a constant process of adapting and developing. So once the interest does disappear it can be hard to maintain the same level of profitability. A lot of it is luck and trial and error in digging for profitable strategies though, so you need a thick skin to continue through patches of “missed shots”. 

---

## 2021-04-30 09:12:12 - strategies channel

**PeterLe**

For me [@U01PJ5YMFBJ](@U01PJ5YMFBJ) [@ULDAVFDRP](@ULDAVFDRP), although I’m not one of the big guys, in 2007, I took a new role in the company I worked for at the time and was the account manager to Betfair. At a meeting in Hammersmith I met an ex colleague who told me about trading (gambling!) and how people were using the exchange.I decided to have a go trading manually, sounded easy. Two years later my £2k bank was at £200 and at that point I decided to try automation (Betangel) with the intention that once the money had gone that was it, I would never deposit any more. That Saturday afternoon, using a very simple technique I made £426 and I never looked back. Over the next few years the stakes grew higher and higher, even cross machine didn’t affect me.

That three year period is where 90% of my lifetime profits came from.

This slack channel has been great for me, as its reset my expectations and Ive had some fantastic results this past year, thanks to [@U4H19D1D2](@U4H19D1D2) [@U01DPK9PGMC](@U01DPK9PGMC) and especially [@USYQKE5HN](@USYQKE5HN)

The thing is [@U01PJ5YMFBJ](@U01PJ5YMFBJ), you don’t find a strategy and then sit back and collect the money, it's an eco system and constantly changing. It's not easy as everyone would be doing it and there are some VERY intelligent people in this game. However it is possible. My advice would be keep working at it, but try and do something different from the crowd, always be testing, compare and contrast. You never stop learning.

---

## 2021-04-30 08:45:05 - general channel

**Taking Value**

Yea I have noticed these charges, I thought that I would get the same fees for shuttling files between S3 and EC2 though and wondered if streaming was cheaper to shuttling the file over.



 It also seems most people use S3 as backup storage but have a lot of data stored locally. I had assumed that as everybody uses S3 for storage they would be using EC2 for modelling but actually it seems most model locally so I will do the same.

---

## 2021-04-30 08:37:33 - general channel

**Taking Value**

Cheers, I have two years worth of horse racing pro data. I was going to build models with one and backtest on the other. I had assumed everyone was just doing backtesting via their EC2 environment. Perhaps I will just download the data locally and see if my laptop can cope with modelling it.

---

## 2021-04-29 23:36:01 - strategies channel

**AndyL**

Given how difficult it is to make long term profits from automation, do you guys do this for: "fun", or "for the aim of eventually finding that elusive profitable strategy", or "it's not difficult, I make a living from this, have done for years!" ?

---

## 2021-04-29 09:06:13 - general channel

**Unknown**

[@UFTBRB3F1](@UFTBRB3F1) we filter only flumine orders through the [https://github.com/liampauling/flumine/blob/dfbad123dcdce6ee7573d23b53a5772dee9d7f38/flumine/streams/orderstream.py#L22|hostname](https://github.com/liampauling/flumine/blob/dfbad123dcdce6ee7573d23b53a5772dee9d7f38/flumine/streams/orderstream.py#L22|hostname), you can remove this filter but you will get warnings as it's likely the strategy wont be available to try and import/create locally

---

## 2021-04-29 07:10:13 - random channel

**KG**

[@US72QTH33](@US72QTH33) we don't have a bookmaker arm to the business in Aus, pure Exchange model :ok_hand:

---

## 2021-04-28 18:13:01 - general channel

**azevedo**

Is there a way to then replay your Order Stream (i.e. Current Orders from order stream) in a similar way to Historical market data using the trading.streaming.create_historical_generator_stream?

---

## 2021-04-28 17:51:30 - general channel

**Newbie99**

If I want to access all orders coming through the order stream (i.e. that includes those not placed via Flumine so they won't necessarily form part of a strategy), where should I be looking?



I have setup a background worker and then was heading down this path:



```def get_live_orders(context: dict, flumine) -&gt; None:



    for stream in flumine.streams._streams:

        # Find the order stream and do whatever```

But is there a preferred way to go about this (i.e. something more obvious I've overlooked)?

---

## 2021-04-28 12:34:47 - issues channel

**moseley82**

Hey guys, hoping somebody might be able to help me here... trying to use a script that I've not used for probably 6ish weeks now and I'm getting this error:



`Params: {'marketIds': [['1.182032085']], 'priceProjection': {'priceData': ['EX_BEST_OFFERS'], 'exBestOffersOverrides': {}, 'virtualise': True, 'rolloverStakes': False}}` 

`Exception: None` 

`Error: {'code': -32602, 'message': 'DSC-0018'}` 

`Full Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}`



Which happens when trying to execute this part of my script:



`market_books_1x2 = trading.betting.list_market_book(market_ids=[market_matchodds],price_projection=price_filter)`



After looking up the error I can see DSC-0018 means "A parameter marked as mandatory was not provided". Does anybody know if something has changed recently that I now need to account for?



Thanks!

---

## 2021-04-27 08:15:46 - strategies channel

**liam**

i would be tempted to have a single 'execution strategy' which handles the execution/placement/batching/icebering etc which your model strategies feed into using context or redis

---

## 2021-04-27 07:57:40 - strategies channel

**Oliver Varney**

question on execution, say you have two models that become active at the same time but operate on different parameters, do you group these strategies to run on the same flumine instance? Just wondering if execution would be improved  as it could be likely they both algorithms separate come to the same bet. Im guessing the answer is it is probably a good idea but was wondering if people had any experience / thoughts on this

---

## 2021-04-26 10:40:01 - random channel

**D C**

no longer doing the XPS unbuntu preinstalled models.

---

## 2021-04-26 10:37:40 - random channel

**D C**

Yeah just spoke with a rep. They have 2 models of laptop geared at heavy high end data science use but they are in excess of 3.5K

---

## 2021-04-26 10:35:05 - random channel

**D C**

Can anyone recommend (from actual experience) a model and brand of new laptop that will allow an installation of ubuntu 20.04 (or linux mint equivalent) without any issues with hardware/drivers etc? Dell have crapped out on linux completely and I don't want to run the risk of excessive customs fees on a high end model from system76 in USA. And advice appreciated.

---

## 2021-04-26 10:00:58 - strategies channel

**PeterLe**

Yea as I mentioned earlier in the thread, I tend to treat ever bet in isolation on a market, so I do it the same way as MIchael. I think Im being too cautious with my staking and want to max the summer racing.  Im going to do some go forward modelling later today when I get the day job out of the way, cheers Liam :grinning:

---

## 2021-04-26 09:56:10 - strategies channel

**liam**

Np, I think [@UGV299K6H](@UGV299K6H) does something similar but 'per bet', this doesn't really suit my style of execution/analysis so base it per market per strategy

---

## 2021-04-26 09:52:38 - strategies channel

**Unknown**

Yeah, and that percentage will vary depending on the runner status, doing this right now on a strategy with these columns



```strategy_name	size	size_matched	profit	roi	market_count	profit_per_market	profit_per_day	size_matched_perc	size_matched_per_market```

And of course a graph with a line to signify when I changed something, in this case it was the bankroll which has resulted in my profit per market actually decreasing :face_palm:

---

## 2021-04-25 19:51:16 - strategies channel

**Unknown**

Yea he's my youngest (16) and just about to start his A level maths in the autumn. He loves maths (and good at it too) and I was trying to show him how Monte carlo works and kelly, this was one of the graphs we plotted on a theoretical bank on a random sample set). I just wanted to show him how you can apply maths to real world examples and it is a really exciting subject (Note: My qualifications are electronics and Business, not Maths!)

---

## 2021-04-25 19:43:23 - strategies channel

**PeterLe**

OK thanks Mo..Just on Kelly..I place many bets on a single in play market and each bet is determined in that brief moment in time on what I perceive as value. So I could lay a selection and then 100ms later I may back it irrespective of what I had previously laid it at. Is it therefore wrong to base Kelly on each bet rather than on the overall result of a single market?

---

## 2021-04-25 19:32:37 - strategies channel

**Mo**

I was going to tell you to just use Kelly

---

## 2021-04-25 18:43:01 - strategies channel

**PeterLe**

Thanks Mo. Well despite me saying initially forget about Kelly...my son and I spent some time this afternoon and created a graph forecasting the effect of Kelly at various percentages on a random subset of the data.

In the end, we just decided to spin up a sub account, and let it go on quarter Kelly. Even at quarter Kelly, the compounding effect is very powerful.

I was thinking that tomorrow I could create a go forward model too based on known strike rates and see where it ends up.

I think Ive answered mu own question, but appreciate the reply [@UBS7QANF3](@UBS7QANF3)

---

## 2021-04-25 11:41:57 - strategies channel

**PeterLe**

If you were fortunate enough to have a long term profitable system (hundreds of thousands of bets) and wanted to increase stakes as a proportion of the balance , let's forget Kelly for the time being. 

What level of governance and method would you adopt as time when by?

Ultimately, as the balance increased, (and Im borrowing a phrase by Michael which I like :grinning:), "your appetite for betting would be more than the market could sustain". Equally as stakes increased, you would be more likely for the whole stake to be taken when you are wrong. (Cant remember the phrase)

Initial thoughts are to monitor:



P&amp;L Curve

Matched V unmatched bets ratio

ROI



What other suggestions would you guys have to implement such a strategy?

Thanks in advance

---

## 2021-04-23 13:14:57 - issues channel

**Oliver Varney**

could be time to turn off the lay at bsp models

---

## 2021-04-23 13:12:16 - issues channel

**Oliver Varney**

didnt see the price close to off but looks somewhere between 15-25, if you model is looking for fatfinger mistakes or wild price swings surely it would of got caught up in it

---

## 2021-04-22 17:18:04 - general channel

**liam**

There will be but will depend on what the strategy does, assuming it’s simple it will be negligible I would just profile it

---

## 2021-04-22 17:17:07 - general channel

**Dave**

Flumine q: Will there be a big performance difference if I instantiate a strategy twice with different params and add them to a flumine instance Vs adding one strategy that takes both sets of params and applies them based on the market? The former seems cleaner but not sure if you lose some performance by having multiple strategy objects

---

## 2021-04-22 12:13:18 - general channel

**Jorge**

Aha, makes total sense to build the model outside of flumine, thanks guys!

---

## 2021-04-22 12:00:03 - general channel

**Oliver Varney**

realtime prediction depending on the size of the model and latency requirements can either block or personally I stick into into a redis stream queue, picked up by a prediction service, then pushed back

---

## 2021-04-22 11:58:04 - general channel

**Oliver Varney**

model building stage in my opinion especially on the AI side should be done outside, then validate prices + volumes and matches with flumine.

---

## 2021-04-22 11:55:09 - general channel

**liam**

Much quicker / easier to manipulate etc. whilst building a model. However imo the next step would be to move the model to flumine (or your own trading framework) so that you can better test implementation/ matching etc.



Quite a few follow the pattern of separating model building/generation and trading framework integration.

---

## 2021-04-22 09:08:52 - strategies channel

**Dave**

I think that it's a very difficult problem to fix given how extraordinary the pandemic effect has been. I have decided to just ditch the period Jan - Sept 2020 altogether for my more complex models. Then again our models must be very different...for _most_ of my models, anything further back than 6 months starts losing a lot of predictive power.

---

## 2021-04-22 07:09:06 - strategies channel

**IndikaE**

Football question: I have noticed that the hometeam win frequency has fallen a lot across all leagues since matches starting being played without crowds(no big surprise there). My model is performing alright, but much worse than in backtesting(using Jan-may data 2020). Towards the end of that period I see a performance decrease even in backtest(when some leagues started reopening with no crowd?). My training set stops in December 2019. I must do my split along the time axis, otherwise I will surely be leaking. How have other people been dealing with this significant change in base distribution of home/away wins? Do you have data on crowd attendance, and is that enough to fix it? I don’t like that this whole period should probably be held out when retraining in the future, so I’m building a new model that will predict probabilities relative to baseline win frequencies instead. I can only imagine that this has been debated before, so sorry if I’m reviving a dead topic.

---

## 2021-04-21 17:10:31 - general channel

**liam**

you have `strategy.context` and `market.context`

---

## 2021-04-21 17:09:51 - general channel

**Rich**

Hi, how are people storing / keeping track of 'state' in their strategy classes in Flumine?  Do you extend runner_context, use class variables? or something else?  It seems markets share the class instance, so if I put a boolean flag at class level to say "initial bet placed" it only works once (understandably)

---

## 2021-04-19 13:46:51 - random channel

**Jonjonjon**

Is there anything special about today's dog racing? My models are performing better than usual.

---

## 2021-04-18 22:11:19 - general channel

**Dave**

nevermind the fact that the data you can record with flumine is a lot cleaner and has the advantage of being exactly the same data you will be trading on :slightly_smiling_face:

---

## 2021-04-18 20:09:00 - general channel

**Jonjonjon**

My main strategy got started with just 1 month of self-recorded data.

---

## 2021-04-18 18:27:55 - general channel

**Michael**

I suppose it might depend on what kind of strategy you're thinking of - but I don't see why you couldn't just ask yourself how long you're willing to wait to be in profit then multiply that by three or four. If an edge isn't visible in that then you're not going to be willing to take the variability anyway.

---

## 2021-04-18 17:53:52 - general channel

**Taking Value**

Could I just take the forums opinion on three things from those of you who are active in the horse racing markets.

1. Do you think if I wanted to buy 2 years worth of pro horse racing data from Betfair it would warrant a discount if I asked for one? 

2. Could you find edge with 2 years worth of data. Are there enough data points to form statistically significant conclusions?

3. Has the disruption to the markets due to COVID caused a lot of models/strategies to fail in the past year? I can imagine there were probably additional opportunities too but I am more interested in how badly historical models were affected as I may or may not purchase data from the last year.

---

## 2021-04-18 07:30:23 - general channel

**Peter**

I would recommend getting one of the example strategy scripts such as "lowestlayer" working first and then adapting that to meet your specific needs.

---

## 2021-04-18 06:50:50 - general channel

**Peter**

My sports trading project is made up of two main parts: individual scripts with a single purpose, such as scrape data from specific site (initiated periodically by cron) or stream horse racing markets with Flumine and react when I see value (runs continuously) and analysis which is done in jupyter notebooks and which generates the graphic stuff. That wouldn't necessarily help if you're wanting to display stuff on web page, which coming from your background I used to do, but if you're the only person looking at it Jupyter notebooks are much quicker and easier to work with. One of the things I'm liking working with Python is escaping the clutches of a framework (Flumine excepted).

---

## 2021-04-16 16:45:33 - issues channel

**Jono**

are there any steps in the certs production steps laid out in:



[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Certificate+Generation+With+XCA](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Certificate+Generation+With+XCA)



which are outdated? I keep recieving an error that im fairly confident relates to the private key being incorrect specifically this error: "`HTTPSConnectionPool(host='[http://identitysso-cert.betfair.com|identitysso-cert.betfair.com](http://identitysso-cert.betfair.com|identitysso-cert.betfair.com)', port=443): Max retries exceeded with url: /api/certlogin (Caused by SSLError(SSLError(9, '[SSL] PEM lib (_ssl.c:3991)')))`"



the ploading of the relevant crt file to bf was successful and the trading client is able to find the corresponding .pem file but unfortunately the above problem is stopping me from getting further. Is there a preferred way of setting up certs that i should be following rather than this or what is listed in the bf docs? Alternatively is there a way to run flumine with an interactive login so i can forego the certs?

---

## 2021-04-16 14:12:42 - issues channel

**Unknown**

i believe i have set up the certs folder correctly but i keep receiving this error when trying to login()



"   Exception: [WinError 3] The system cannot find the path specified: '/certs/'   "



I have the certs folder at the same level as the python file executing. I receive the same error when performing the example strategy listed in the docs in both vscode and jupyter here are what the two directories look like. Is there something basic/obvious im setting up wrong?

---

## 2021-04-15 16:11:30 - strategies channel

**liam**

Yeah check out flumine, at least as a starting point as it’s designed to be flexible, tick to trade is certainly measures in ms. You also have backtesting (market and now event) + paper trading straight out of the box 

---

## 2021-04-15 16:06:14 - strategies channel

**Jono**

hmmm im not sure if i would be able to do so. the strategy goes kind of like per iteration: middleware retrieves instructions/existing bet info from database api, use instructions to send payload to client api, client api then places new orders on bf based on instructions, finally order responses are then used to update values in database. The process then starts again

---

## 2021-04-15 15:48:53 - strategies channel

**James T**

If your strategy is based on stats or analytics on data of a fixed period, like calculating a moving average or something, then that does require a little rethinking since streaming data arrives at irregular intervals. 

---

## 2021-04-15 15:42:44 - strategies channel

**Jono**

yes, ive yet to bear witness to the majesty of streamed data and i get a little bit too excited thinking about the possibilities. the 20 second time range is the result of other obstructions and api calls i have to make in order for the strategy to run. Ill be mending and streamlining the vast majority of the process just want o make sure im getting started on the right foot with the bf side of things

---

## 2021-04-15 15:24:37 - strategies channel

**James T**

bflw and flumine are two different things. Bflw is a python wrapper around the streaming API allowing you to easily call API functions. Flumine is a trading framework (which uses bflw) which abstracts around the functions allowing you to create an easy trading loop, along with providing offline backtesting (simulating) with historical tick data. 

---

## 2021-04-15 14:55:45 - strategies channel

**Jono**

Ive recently managed to implement a trading script able to turn a small profit when certain odds exist on the exchange but is extremely reliant on the speed at which it is able to check the exchange. I am wondering the best way to move forward with trying to upscale the program to run on several events at once and potentially tackle the speed issue in this second version i am writing. I need to be able to check as many 1X2 markets on the exchange as quickly as possible in order to be profitable. When testing, if the time between checking markets reaches ~20 seconds the profitability of this strat takes a large dip, so small scale running sequentially on a 3 or 4 events is do able but more than that results in barely breaking even/losses. I believe streaming the odds would be the first significant improvement to be made instead of calling the api in a long winded loop to look for changes in listed prices, and soon after looking into this as an option i ended up at the flumine docs - which look very promising. Before i dive in and commit to the flumine framework is this what is designed for or at least useful in this scenario; high speed retrieval of bf exchange info for efficient strategy execution?



Any help is really appreciated and if ive got the wrong idea about flumine or should try another avenue for what im looking to do please let me know your thoughts, cheers!

---

## 2021-04-15 12:26:52 - random channel

**Mo**

A couple of comments:



1. There are examples of data which are publicly available, such as on sites such as [http://WhoScored.com|WhoScored.com](http://WhoScored.com|WhoScored.com), which are both highly detailed and not really usable without extensive scraping and data transformation. You don't have to make such scraping code publicly available (although you would need to include it as part of your submission so the judging panel can - in principle - run it themselves to reproduce your predictions exactly) so you can still gain a significant edge over other entrants even with the public availability requirement

2. I've included a link to StatsBomb free data ([https://github.com/statsbomb/open-data](https://github.com/statsbomb/open-data)) in the README which is highly detailed, ball-by-ball data. For developing a betting strategy this free data is probably not very useful as you would need access to data going forward but the free data includes the last World Cup which is highly relevant to the competition. In other words, data which is of relatively low value generally can actually be of high value for the purposes of this competition

---

## 2021-04-13 18:20:41 - general channel

**river_shah**

cross market near-arbs or arbs can be seen as special case of choice markets. they give you option to agress on the side you like without incurring bid / ask spread. this can have beneficial impact on your strategy, both from trade entry and or exit. not a strategy in its own right but an execution optimization large scale strats should do

---

## 2021-04-13 08:40:47 - general channel

**John**

Hi finally got flumine working after asking betfair help to turn on my streaming. Was hoping to do paper trading or backtesting, but from the ExampleStrategy I don't see a way to record my bets and calculate P&amp;L. I wonder if I am missing something, or I need to write my own class/functions? Please could anyone give me a pointer? Many thanks.

---

## 2021-04-12 21:05:36 - issues channel

**Alessio**

The way you can do it is keeping intenral state by market and the order objects stored in the strategy. process_market_book -&gt; place the order. then in process_orders(market, orders) you can loop over them and see 'order.status'. If you index stuff by market id you can use the market.market_id to link to the state. Also, remember that the Trade constructor has a 'notes' argument where you can put an OrderedDict of what you want, and you can access the trade from the order.

---

## 2021-04-12 15:46:16 - issues channel

**Newbie99**

When trying to place an order using:



```trade = Trade(

           market_id=market.market_id,

           selection_id=selection_id,

           handicap=handicap,

           strategy=self,

       )

   order = trade.create_order(

       side=direction, order_type=LimitOrder(price=price, size=stake, persistence_type=persistence_type)

   )



order_placed = market.place_order(order)```

I am trying to catch errors as follows:



```if order_placed is False:

	# Do stuff```

I just noticed an order (correctly) failing due to BPE, so this is expected behaviour and from logs I can see the following:



```{"asctime": "2021-04-12 13:39:15,049", "levelname": "INFO", "message": "Order Place: FAILURE", "bet_id": null, "order_id": "138375275548404227", "status": "FAILURE", "error_code": "BET_LAPSED_PRICE_IMPROVEMENT_TOO_LARGE"}```

However, from place_order in execution.transaction thought the above would return True or False and I could catch the error that way and do whatever I need, but it doesn’t appear to be catching for failures in live (I could have sworn this worked in paper trading, but haven’t been able to replicate yet), it does return True for successfully placed orders, but doesn’t return False.



 So, what is the correct way to catch these errors, as I’m clearly mis-reading the code?

---

## 2021-04-12 11:57:00 - strategies channel

**Michael**

Yeah - there's a sliver of value just in the fact that you're offering and willing to wait to match. If you're not sure how that works imagine doing it constantly on both sides of the book. The problem is adverse selection, which is where your bad bets match and your good ones don't. If you've got a model that's good enough to reduce that just a little bit and then offer into the market that's enough to get you into the black. That's why so many people get off to what looks like a flying start but then stall when they scale. They imagine it's the amazing performance of their model that's generating their profits at small stakes but they're really just partial market makers. When they scale beyond the capacity of those forces they get a reality check. You can watch this play out live on these forums.

---

## 2021-04-12 10:49:46 - random channel

**Benito Pagnotto**

Hi, I’m am intermedie python dev, solid foundation in math. I have very little knowledge about betting and stock exchange neither about betting exchange (I know only how they works but I haven’t any operative experience). I would like to explore a bit of this worlds. Could you redirect me to some place where should I start? Is it better to download Liam’s libraries and start playing with them or get more knowledge about strategy in the betting exchange market? Any books or sites?



Thank you

---

## 2021-04-11 19:36:02 - general channel

**Taking Value**

Can I just check I understand the correct way to use flumine for building a strategy. If I want to build a strategy then I should build a child class of the BaseStrategy class with  unique logic in it that is relevant to my strategy? Sorry if this is a basic question.

---

## 2021-04-09 20:04:46 - general channel

**liam**

Yep, bflw is a wrapper and flumine is a fully functional trading framework that uses bflw 

---

## 2021-04-09 20:04:00 - general channel

**Taking Value**

Ohh I have misunderstood. I thought Flumine was for backtesting and bflw was for recording. Been reading the flumine docs. Just found the market recorder strategy on the Flumine GitHub. I will read it over, thanks very much.



Did you build the BF lightweight library first then Flumine later? Just wondering - Seems Flumine does everything BFL does and then some.

---

## 2021-04-09 19:57:25 - general channel

**liam**

No, tbh just use flumine and/or read the source code on how it does it with the market recorder strategy, reasonably straight forward 

---

## 2021-04-08 21:45:48 - general channel

**Sam Asin**

Hmm weird little half-baked modeling question that maybe I just need to think through a little more, but figured I'd see if someone wants to bounce ideas for a second or just already knows the answer.

---

## 2021-04-08 16:38:50 - general channel

**William Martin**

So I've abandoned trying to get data via the api to build the mvp of the new betting product I want to create.



Im trying to get the historical data for soccer for April but when I try and unzip its saying there are errors with the files. do I need something special to unzip a .tar?

---

## 2021-04-08 13:18:05 - random channel

**Unknown**

That's certainly something that I've found. This is a plot of cumulative profit v time to get filled for a live strategy I'm testing, that's bet on ~500 markets so far.

---

## 2021-04-08 11:24:51 - random channel

**Mo**

Some more thoughts. Similar to tennis, it is well suited to modelling because of the highly structured scoring system and continual flow of information. (This also means there are hundreds of betting opportunities per match). On the other hand, as [@U01HQ97J5HA](@U01HQ97J5HA) says, there are complex interactions between the batsman and the bowler plus the state of the pitch

---

## 2021-04-08 06:49:44 - random channel

**Mo**

Some matches have insane volume but not that many matches in total per year (around 2000). In play seems like a tough nut to crack because of the importance of latency and hard to model considerations like the impact of weather

---

## 2021-04-07 21:20:01 - random channel

**Dave**

Yeah never had much success modelling dogs from past results tbh.

---

## 2021-04-07 08:02:02 - general channel

**liam**

flumine [https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1180-2021-04-07|v1.18.0](https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1180-2021-04-07|v1.18.0) now released, a few depreciations as warned in v1.17, cleared order now available (thanks [@U01MPC0GUK1](@U01MPC0GUK1)), a pretty major backtesting bug and now the ability to process event data as per live, big thanks to [@U01B8031PM1](@U01B8031PM1) on sponsoring this development and allowing it to be open source :smile:



Small change required to allow event processing:

```strategy = ExampleStrategy(

    market_filter={"markets": [..], "event_processing": True},

)```

The `Market` object has a helper method for accessing other linked event markets (live and simulated):

```place_market = market.event["PLACE"]```

This allows you for example to backtest win/place in racing or all football markets as per live, this also only seems to add around 5% in processing time. I don't think there is anything else out there on the market which allows backtesting like this :sunglasses:

---

## 2021-04-06 22:15:32 - issues channel

**Jonjonjon**

Should [https://github.com/liampauling/flumine/blob/62b40ad11988ecab039b3b822bc70779aed64bca/flumine/strategy/strategy.py#L203-L206|this code](https://github.com/liampauling/flumine/blob/62b40ad11988ecab039b3b822bc70779aed64bca/flumine/strategy/strategy.py#L203-L206|this code):



        `if runner_context.trade_count &gt;= self.max_trade_count:`

            `order.violation_msg = "strategy.validate_order failed: trade_count ({0}) &gt;= max_trade_count ({1})".format(`

                `runner_context.trade_count, self.max_live_trade_count`

            `)`



Become



        `if runner_context.trade_count &gt;= self.max_trade_count:`

            `order.violation_msg = "strategy.validate_order failed: trade_count ({0}) &gt;= max_trade_count ({1})".format(`

                `runner_context.trade_count, self._*max_trade_count*_`

            `)`

---

## 2021-04-06 16:40:42 - random channel

**James T**

I think it’s a different skill though - betting track side. There must be a bit of race reading involved. GPS vs drone vs trackside must be pretty similar in terms of latency now. In-running has been doing particularly well since there were zero crowds (hence drones attempting to replace trackside), so it’ll be interesting to see how our strategies do once crowds do return. Has GPS completely wiped out trackside potential? I doubt it. 

---

## 2021-04-05 12:00:20 - random channel

**liam**

Where is the value in your strategy? If it’s back at x because of y and then lay at x-20 then the lay isn’t going to be value and there needs to be some sort of value logic for y or you are just going to lose money 

---

## 2021-04-05 09:20:06 - general channel

**Peter C**

Hi All, I have a question about analysing bets placed by my strategy I'd appreciate a sense check on. My strategy places only lay bets, so I say that value is

```value = bsp - price taken```

I sum 'value' for all the bets my strategy places over a period as a quick and easy yes/no for is value being taken - if the total value is positive I say that I have taken value, and if it's negative I say I haven't. I would appreciate anybody's thoughts on whether this is an acceptable way to roughly determine whether my strategy takes value before further assessment of the bets. Cheers

---

## 2021-04-04 16:38:21 - strategies channel

**Michael**

There's nothing to stop you from deriving prices simply by taking the current score and starting prices, but you'd have to bear in mind that that's quite a simplistic model and there's a lot of other information out there that others have that you're not incorporating, so you wouldn't expect such a model to  perform all that well. However, models that perform poorly can still be used to generate profits particularly if they are attached to some basic market making, where they can act to shield you from placing terrible bets. That reduction in adverse selection can be enough to get you into profit just by exploiting the spread.

---

## 2021-04-04 14:58:47 - random channel

**charlie_v**

I use tea if that helps. Very useful while trading

---

## 2021-04-04 10:22:56 - strategies channel

**thambie1**

Hey [@U01PQ9SR9MJ](@U01PQ9SR9MJ), not sure I fully understand what you're trying to do. The available odds on the correct score market is simply the odds that people are willing to bet that the event will/will not occur. This can be based on a myriad of factors. It's definitely based on the current score of the match, maybe some people's models care about the time each goal was scored, maybe not. There is surely a statistical relationship between the odds before and after a goal is scored as well.

---

## 2021-04-03 21:53:36 - random channel

**Jonjonjon**

Suppose I backtest 2 strategies with a single `framework.run`. e.g.



```client = clients.BacktestClient()

framework = FlumineBacktest(client=client)



...



framework.add_strategy(strategy1)

framework.add_strategy(strategy2)



...

    

framework.run()```

Would the results for `strategy1` and `strategy2` be different if I'd run them with separate `framework.run`'s

---

## 2021-04-01 18:47:49 - general channel

**Oliver Varney**

[@UQL0QDEKA](@UQL0QDEKA) its just that I use AI models, when features are empty / havent been seen im unsure whether the outcome will be great or not

---

## 2021-04-01 18:45:50 - general channel

**PeterLe**

By the way, I noticed a post by Oliver earlier about cutting back on some strategies as the exchange was a bit flaky...obviously depends on the strategy but some of my biggest wins have been on days such as these (safety in mind takes precedence of course)

---

## 2021-03-31 23:42:09 - general channel

**Sam Asin**

If it's a friend who isn't interested in betting anyways, does it put them in a bind? Genuine question, I just don't know.

---

## 2021-03-31 08:51:48 - random channel

**Dave**

My models just 0 out signals when features are detected to be rubbish or market volume is too low for when the data for features was collected

---

## 2021-03-31 08:44:23 - random channel

**Jonjonjon**

I just sit here and hope my models don't go crazy.

---

## 2021-03-31 08:41:13 - random channel

**Oliver Varney**

Just out of interest, anyone using models,  when the exchange is down for an extended period and some features are impacted as a result, do people continue as normal or sit on the bench

---

## 2021-03-30 12:45:51 - general channel

**liam**

I think 9.7.6 answers your question, you don’t lose out 



_For example, if the Premium Charge rate applicable to your betting increases from 20% to 40%, we will assume that you have always paid Premium Charges at 40%._ 

---

## 2021-03-29 18:02:04 - general channel

**river_shah**

do you have an example on how to poll the betgenius feed instead please? currently I am using this:

```import logging



from flumine.events.events import CustomEvent



logger = logging.getLogger(__name__)





def poll_in_play_service(context: dict, flumine, event_id: str) -&gt; None:

    trading = flumine.client.betting_client



    response = trading.in_play_service.get_scores(event_ids=[event_id])

    if response is None:

        logger.warning(

            "poll_in_play_service",

            extra={"response": response, "event_id": event_id},

        )

    for score in response:

        flumine.handler_queue.put(CustomEvent(score, callback))





def callback(flumine, event):

    # update market context

    score = event.event

    for market in flumine.markets:

        if market.event_id == str(score.event_id):

            logger.debug(

                "Updated market {0} with event {1} scores data".format(

                    market.market_id, market.event_id

                )

            )

            market.context["score"] = score```



---

## 2021-03-29 12:57:03 - general channel

**Rob (NZ)**

Previously I got the markets using the code on betfair aussie examples but that was awhile ago so just not sure if there is better approaches now... I've spent the last year working on my model and now need to feed it live info rather than just my back testing which I've been doing manually

---

## 2021-03-28 20:40:22 - random channel

**Mo**

Probably depends on the strategy. I had a lot of competition when I was doing pre-event football

---

## 2021-03-28 20:36:57 - random channel

**thambie1**

[@U011VL3CA2Y](@U011VL3CA2Y) When I started trading football pre, I didn't notice any latency competition, despite taking some really obvious trades. Which makes me wonder if if the competition you're talking about is me. If you want to send me one or two of the trades you missed out on, I'll let you know if I took them.

---

## 2021-03-28 18:33:02 - random channel

**Ruben**

Thanks a lot Mo; I'm asking mainly because I'm seeing that I'm receiving a price update that my strategy thinks is value, but I am always late to the party :man-facepalming: someone else takes the price before I can do it, so I'm trying to find possible leaks

---

## 2021-03-28 17:57:39 - general channel

**Sam Asin**

roger thanks sir! Will get going. Also for my "to be clear," per me asking about this the other day, this sort of ELO stuff is nothing I'm experienced with at all, giving it a try to help a friend who wants to bet on this crap with just his "instincts." Wanna give him a puncher's chance. So yeah, don't judge me too hard for my glicko attempts. My main schtick involves a lot of somehow squeezing a little money out of really crappy models, so maybe that's why I have low expectations :slightly_smiling_face:. Okay time to work.

---

## 2021-03-28 17:38:22 - general channel

**Mo**

To be clear, I'm rooting for you and am interested to see how the model evolves

---

## 2021-03-28 17:23:33 - general channel

**Sam Asin**

but yeah, thanks, that answers my question for now! I can stop looking for problems in my code and move onto checking vs. markets and maybe coming up with another model to stack etc. etc.

---

## 2021-03-28 07:30:05 - general channel

**Mo**

This is just calibration which looks good for most models but says nothing about their accuracy or competitiveness versus the market. I don’t think it looks remotely “too good”. In fact it seems quite poor, 50% - 60% only winning 42% of the time? Having said that, it’s probably a sample size issue

---

## 2021-03-28 00:44:14 - general channel

**Sam Asin**

So I'm curious what sort of results you'd expect out of a glicko model?

---

## 2021-03-28 00:39:31 - general channel

**Sam Asin**

[@UBS7QANF3](@UBS7QANF3) et all, if other people mess much with glicko/elo, I just tried to set up a very basic glicko model on some win/loss data. I haven't bothered to try to check it for betting specifically yet, but I started by just bucketing my data into 50-60% favorite, 60-70%, etc. according to the model, and seeing how often the favorite won in each bucket.

---

## 2021-03-27 14:16:56 - random channel

**river_shah**

Hey Mo, curious what your thoughts are for turning off best price execution when trading “fundamental” models. For football I am focused much more on proper modelling of the game and odds are inherently noisy. I would not want my bets to lapse if odds do improve during the inplay delay.

---

## 2021-03-26 20:31:16 - random channel

**liam**

Tbh neither do I really but in comparison to modelling based off form inplay has a lot more opportunities / unique events 

---

## 2021-03-26 20:29:27 - random channel

**Oliver Varney**

i dont know if this statement is true but there must be a point where at if you can predict a price movement/directionality  x% of time between updates you have a +ev strategy

---

## 2021-03-26 20:27:12 - random channel

**liam**

It is certainly quicker to see if a strategy is profitable compared to pre play, I am sure there is an eloquent way to describe this but I can’t 

---

## 2021-03-26 20:26:55 - random channel

**Oliver Varney**

but as an alternative learning objective probably would lead to +ev strategy

---

## 2021-03-26 17:20:49 - random channel

**liam**

[@ULDAVFDRP](@ULDAVFDRP) I do everything, 1.01 to 1000, low/high strike rate, depends on the strategy and market 

---

## 2021-03-26 17:19:45 - random channel

**liam**

No info? You have historic data, both for the current race (very important) and other races (important to be able to model the former)

---

## 2021-03-26 17:06:44 - random channel

**Oliver Varney**

do you fall into a low strike rate high odds bracket generally [@U4H19D1D2](@U4H19D1D2), or does it depend by strategy?

---

## 2021-03-26 16:57:07 - random channel

**Aaron Smith**

Well, the thing i cant get my head around is this: For pre event, i get a bunch of historical info, i can process that in some way and come up with a price. If i did a good job, i ll be making money. Now inplay, i may still have my modelled price, but now i need to adjust it (or even completly forget about it). So now all i have is: someone says the horse should be priced 3.4. Now i need some extra information that tells me its not actually 3.4, otherwise i m not matching anything.

---

## 2021-03-26 16:53:02 - random channel

**liam**

What is this model? To give you some context, I don’t use SP, for me it’s useless once things are inplay 

---

## 2021-03-26 16:51:25 - random channel

**Aaron Smith**

I can model again with the new info, but the new info is price movement, so i kinda have to guess how accurate that is. That is basically already processed info. If i had the situation on track i may be able to model a new pirce, but if i only get price movement i dont see how that works, as i dont know how accurate that is.

---

## 2021-03-26 16:46:28 - random channel

**Mo**

Your terminology is confusing, you keep referring to a model price as if one only has one before the race starts

---

## 2021-03-26 16:46:23 - random channel

**liam**

Your modelled price needs to be updated on every update (new information) that you get 

---

## 2021-03-26 16:44:09 - random channel

**Aaron Smith**

mh, then i feel like i m missing the point there. How would i know when to switch away from my modeled price? I suppose then its only based on price movement, but thats 1 seconds old. I suppose cancels are instant so i can try and derive enough info from that

---

## 2021-03-26 16:33:24 - random channel

**Aaron Smith**

well, that can be used aswell, but no matter how perfectly i model my price, if i just put that in there as a passive limit order i ll be broke in a day :smile:

---

## 2021-03-26 16:32:26 - random channel

**Mo**

What do you mean modelling a price obvious isn't the way to go?

---

## 2021-03-26 16:31:45 - random channel

**Aaron Smith**

Inplay is still somewhat a mystery to me. Modelling a price obviously isnt the way to go and price movement cant be trusted with the delay. I suppose i need some extra information about horse position/velocity (combined with historical info of the horse still i guess) to make it work?

---

## 2021-03-26 12:59:11 - random channel

**Oliver Varney**

my model also had it as value at 1.21

---

## 2021-03-26 12:58:33 - random channel

**river_shah**

my model systematically bets hard against heavy favourites….not sure what made it go fairly ballistic in backing 1.15s….

---

## 2021-03-25 20:20:18 - general channel

**Beeblebrox**

I've got a back testing logging control that records orders when `_process_cleared_orders_meta()` is called (using the example in the repository) and that all works fine.  I'm now trying to write a logging control to record orders from a live strategy, but I'm not sure how to replicate what I've done for the back testing control because  `event.event` in `_process_cleared_orders_meta()` is a list of `Order` objects, but for `_process_cleared_orders()` it's a `ClearedOrders` object.



I want to be able to write `order.trade.market_notes` and `order.trade.nodes_str` for each order, which is easy for the back test control, but for the live control how do I access them from the `ClearedOrder`?



I thought instead I could write the orders when `_process_closed_market()` is called and then loop over the orders in the market blotter, but I also want to write the profit for the order and that doesn't exist as a property for real orders (you can get it when back testing from `order.simulated.profit`).



There must be a way to do it, but I'm probably missing something obvious.  Any clues as to how I can do it? Thanks

---

## 2021-03-25 19:39:16 - general channel

**JC**

As an aside, was wondering if anyone has managed to create a model that can beat the market's pre-play accuracy of ~70%. I'm aware most of the opportunity is available in-play, but seems like an interesting challenge

---

## 2021-03-25 19:34:01 - general channel

**JC**

Hi everyone, question for those of you who are involved in tennis markets. I've recently got access to OnCourt's database, and was wondering if anyone had managed to integrate this into their automated system i.e. have data updating from OnCourt and feeding into models etc. Seems like a bit of a nightmare as it's .mdb, and i'm currently running a virtualbox so that i can use Microsoft Access to use it. Maybe people only use it for historic data and getting historic scores data and scrape/rely on other sources for new data and updating models?

---

## 2021-03-25 08:25:58 - strategies channel

**PeterLe**

Yes thanks Gents; I was just making a cuppa and thought this was more easily calculated that I first thought. So to keep things simple assume I was using a fixed stake and i know that for eg a MC simulation on past results were 10% (ie MC beats strategy) then i would create a go forward model and use a random number generator. Then run over a large number of iterations and count the longest sequence of losing runs ? This would be better actually that trying to calculate it in monetary terms as the loss would be proportionate to the profits at that time. Thanks again.

---

## 2021-03-25 08:01:01 - strategies channel

**PeterLe**

Morning, I have a set of real data for a strategy that has been running seven months. What would be the best way to calculate the most probable maximum drawdown in the future? Could I estimate this as some form of function of a MC simulation? (The liability (stakes) are increasing proportionally to the growing balance too). Thanks for any thoughts

---

## 2021-03-25 07:19:33 - strategies channel

**river_shah**

How do you guys think about maximal scaling for your strategies? Have typically gone with heuristics such as don't be more than x% of expected matched volume and or bet size/ frequency needs to be less than y and z (usually derived from observed size and update rate of offers). What can I do to make this more rigorous and what other factors would you recommend considering? Thanks 

Please assume that for all practical purposes we are clear of kelly constraints i.e market capacity is the limiting factor.

---

## 2021-03-24 23:37:19 - strategies channel

**MacrcoPolo**

Yes. You can model interactions if you wish, but usually not necessary - Do you want perfection or 'its good enough'?

---

## 2021-03-24 23:26:17 - strategies channel

**MacrcoPolo**

Mainly for building fundamental models

---

## 2021-03-24 08:20:34 - strategies channel

**Michael**

I think it's worth emphasising that whilst MC is a useful tool it can't safely be used to validate a poorly developed strategy, only to analyse a well developed one. It's no good doing a ridiculous over-fit then trying to Monte Carlo it into reality, 'garbage in, garbage out.'

---

## 2021-03-23 22:26:20 - strategies channel

**birchy**

As [@UGV299K6H](@UGV299K6H) correctly stated, it can be majorly complicated to MC bets by market, so the generally accepted "near enough" solution is to treat each bet as an individual. Ultimately, the MC simulation only tells us if each bet is, on average, +EV and is by no means a definitive answer to whether or not your strategy will profit long term.

---

## 2021-03-23 20:24:49 - strategies channel

**birchy**

[@UGV299K6H](@UGV299K6H) Ultimately, all triggers end up being binary, though? For instance `if wom &gt; 0.85` ends up being either True or False. I generally fire off a range of bets a few ticks apart to catch any "overshoot" and (theoretically) improve my perceived value. Does that seem sensible? That does of course increase my risk, so I'm also curious about how you reduce liabilities, i.e. do you try to balance risk per runner, place bets on both sides (unintentional hedging) or simply let bets ride? It can take a long time for edges to show their true colours, so I'm wondering how you determine what is an acceptable amount to lose when starting a strategy that may take a few thousand bets to settle?

---

## 2021-03-23 19:02:52 - strategies channel

**birchy**

[@ULDAVFDRP](@ULDAVFDRP) Yeah, I've always used train/test data but this was for a new sport. Was a bit premature going live TBH, but then again I keep reading that live betting is far more valuable than backtesting...

[@UGV299K6H](@UGV299K6H) sometimes shit turns to gold. I'm not overly bothered about losing a few hundred quid and see that as a necessary expense in the search for the golden eggs. I lost ~£200 on the above strategy, so not a major issue. I find the problem with asking for too much value often ends up with only the "wrong" bets getting matched more frequently, so seems counter intuitive. There is always the option to hedge bets, but again that's counter intuitive. Surely _some_ loss is to be expected when testing strategies?

---

## 2021-03-23 17:48:40 - strategies channel

**birchy**

With my strategy that I inadvertently over-fitted, I'd basically been using the same training data over and over (because I had no other data at the time), using various triggers and ideas until I ended up with a simulated P&amp;L that was satisfactory. I've never actually looked at the training data manually but unintentionally found the sets of triggers and values that hit the sweet spot _for that dataset._ Meanwhile, I was gathering more data for use as a testing sample and that was when I realised what I'd done. An expensive lesson was learnt. :grinning:

The other problem was that this was straight laying only and I'd calculated that a maximum drawdown of &gt; £1000 was to be expected, so even at -£700, I left it playing live. It went up, it went down, but the overall trend was slowly down. Luckily, I have some other strategies that earn small amounts at lower risks, but truth be told, I managed to undo 6 months of profit in a matter of weeks.

---

## 2021-03-23 16:59:48 - strategies channel

**Michael**

If the underlying thinking is sound then you'll be fine, but if your strategy is a tower of arbitrary filters that produced the best return on a particular data set then it won't work.

---

## 2021-03-23 16:57:56 - strategies channel

**Michael**

I think it might be worth considering your methodology. Every time you 'filter' or change your strategy then check again it becomes more likely that you'll over-fit and no MC will detect that - I'm sure that's what [@U016TGY3676](@U016TGY3676) experienced, it's what inevitably happens if you iterate strategy changes over a fixed data set. A different way to interrogate the soundness of your strategy might be to isolate the individual conjectures that it's based on and see if you can evidence them using simple reasoning, graphs and so on. In other words - step back from your bets and find ways to check if the underlying strategy is based on sound thinking.

---

## 2021-03-23 13:26:10 - strategies channel

**mandelbot**

Well that's encouraging! May I ask how many different parameters you had for this strategy?

---

## 2021-03-23 13:24:17 - strategies channel

**birchy**

It basically means that your strategy has a 14% that it is just a lucky streak. The lower the %, the more likely you have an edge. Less than 1% is where you want to be. FYI, my over-fitted strategy came out at 0% on 10K iterations and 39% for actual bets.

---

## 2021-03-23 13:19:39 - strategies channel

**mandelbot**

I've now run on a subset (odds &lt; 100) and found MC beats strategy 0.39% of the time.

---

## 2021-03-23 12:58:18 - strategies channel

**mandelbot**

So I ran [@U016TGY3676](@U016TGY3676)'s Montecarlo code and got "Montecarlo beats strategy 13.93%" of the time. Can someone explain please? Does this mean a random strategy beats mine ~14% of the time? Is that high or low? Also thanks for the code [@U016TGY3676](@U016TGY3676).

---

## 2021-03-23 11:12:17 - strategies channel

**Atho55**

It could be that the BSP`s you are selecting are trending in another direction. This is BSP floored Odd 4.1 for example [http://prntscr.com/10tduhx](http://prntscr.com/10tduhx) It`s been chosen because it does slightly favour Back rather than Lay which could be another reason why your strategy is taking a down turn. [http://prntscr.com/10te12r](http://prntscr.com/10te12r)

---

## 2021-03-23 10:57:31 - strategies channel

**Paul**

To those using Kelly: are you using a derivative that includes commission as part of the calc, or are you using fractional so it's "covered", anyway? I'm also looking around for a derivative of Kelly for multiple bets in the same market, but only solutions I can find are rather "exotic" (e.g. the Edmund Noon paper which resorts to a level of maths I'm not up to yet).

---

## 2021-03-23 10:40:56 - strategies channel

**Jonjonjon**

The source code is here: [https://github.com/liampauling/flumine/blob/7f6a4543b4239fa24b59c2a74b7df7f447fc9812/flumine/strategy/strategy.py](https://github.com/liampauling/flumine/blob/7f6a4543b4239fa24b59c2a74b7df7f447fc9812/flumine/strategy/strategy.py)

---

## 2021-03-23 10:06:51 - strategies channel

**mandelbot**

Yes It's been betting 4 pounds because the strategy is firing 2 pounds twice, not sure how to fix that...

---

## 2021-03-23 09:40:16 - strategies channel

**mandelbot**

Well it's not in great shape already, though it seems within the realms of what is to be expected for some periods (judging by the plot). How do I determine when it's time to hang in the towel for this particular strategy?

---

## 2021-03-23 09:16:10 - strategies channel

**mandelbot**

I've also been back testing the inverse of this strategy which also seems to be an edge. Would you say that is further evidence of an edge?

---

## 2021-03-22 20:46:13 - strategies channel

**birchy**

Just to forewarn you, I had a very similar result from Flumine backtesting which also went in the opposite direction when live. Mine was for ~1700 markets and ~9000 matched bets out of ~17k bets placed in backtest and double those quantities for live bets. Monte Carlo suggested that the backtest P&amp;Ls were &lt; 0.1% chance of being random...i.e. this was a strong edge rather than a lucky streak.

Have since run the backtest on some new data and had the same result as live betting.

Conclusion: strategy was inadvertently over-fitted.

---

## 2021-03-22 19:29:21 - strategies channel

**Michael**

Is this some sort of fundamentals model or a market based thing?

---

## 2021-03-22 19:21:00 - strategies channel

**Michael**

The reason I asked about your existing betting is that that might be a simpler way of calibrating your confidence. If you did the same type of thing that you did last time then you'll probably get the same type of result. All the statistical tests are wide open to error if your development process is weak because so many development pathways move inexorably towards excessive overfitting. I think it's also worth asking what more or less confidence would do for you in terms of informing your actions. In all likelihood the best approach will be to just give it a go with minimal stakes, having more confidence wouldn't make starting off more aggressively into a good idea and having less confidence probably won't stop you from having a go even if only for the sake of learning.  You probably already know in your gut whether having a go is a good idea. Think carefully about your reasoning and where your value comes from, if you can say that your reasoning is sound and you can identify why you expect your bets to have value then you're good to go.

---

## 2021-03-22 19:06:34 - strategies channel

**mandelbot**

I'll work on doing a Monte Carlo, never done one before. I do have a few profitable live strategies though I have to say my approach is pretty basic compared to many on here. I've only just moved to working with python and bflw in the last few months having come from automating strategies on betangel. Still learning the ropes as it were.



You're right 3k does seem a bit thin, unfortunately that's the extent of my historical database for now. I am also betting on bigger odds but &lt;100 so probably that makes 3k seem even thinner. I figured though since I was beating BSP then I might be doing something right.

---

## 2021-03-22 18:24:32 - strategies channel

**Michael**

Just lick of a finger but I'd say that's not that many for quite a thin edge, but it also depends on your development methodology. Doing a MC simulation won't do any harm but you should be aware that analysing multiple bets in the same market with MC is problematic. Where are you at with your betting more generally - do you have strategies betting live and making money?

---

## 2021-03-22 11:09:41 - general channel

**Rich**

{"asctime": "2021-03-22 10:57:58,544", "levelname": "INFO", "message": "Market closed", "market_id": "1.123344868", "client": {"id": "e553f03d", "exchange": "Simulated", "betting_client": null, "current_transaction_count_total": 0, "transaction_count_total": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxTransactionCount object at 0x0000020E6F6BEC10&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}, "markets": {"market_count": 818, "open_market_count": 0}, "streams": ["&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;HistoricalStream(HistoricalStream, initial daemon)&gt;", "&lt;

---

## 2021-03-22 10:30:17 - general channel

**liam**

Each new strategy, market, trade, order, cleared market etc all result in a call to the [https://liampauling.github.io/flumine/advanced/#logging-controls|control](https://liampauling.github.io/flumine/advanced/#logging-controls|control)

---

## 2021-03-22 10:19:33 - general channel

**Rich**

Is there a way to find which bz2 file a flumine backtesting strategy is acting on? for logging purposes? (i.e. i'm creating a DB of markets by name and storing which file the various markets are stored in?)

---

## 2021-03-21 10:23:05 - general channel

**Misha**

Priority always is, and has been, 1) get a decent working model; 2) get a decent working execution strategy; 3) enhance everything now that we are "self-funded"

---

## 2021-03-21 10:21:33 - general channel

**Misha**

For my system I am a long way from a "finished" product, so we will go through a lot of changes over the next 1-2 years. This strategy works for what I am doing at the moment, but at some stage we will be performing far more complex betting which will entail leaving offers there for certain amounts of time

---

## 2021-03-21 10:16:36 - general channel

**Misha**

It scaled to $200M/year turnover for pre-off UK horse racing, but that wasn't my money (used fill or kill for the main strategy for that as well)

---

## 2021-03-21 10:07:04 - general channel

**Misha**

Fill or kill is a better execution strategy over a manual fire and cancel

---

## 2021-03-20 17:29:21 - general channel

**Oliver Varney**

In horses in the last five I'd say it will make little difference apart from maybe super long odds stuff, even though I'm guessing your models pricing will not know the difference between the price you go for and the price one tick down. Having said this I still think it's a good idea to do your own in the long run.

---

## 2021-03-20 16:25:48 - general channel

**Peter C**

Is it possible to get flumine to submit bets at BSP? I'm trying to automate cashing out whilst I test my strategy

---

## 2021-03-19 21:22:30 - strategies channel

**Dave**

(FWIW I run a very similarly structured strategy on football and just execute over the REST API, no flumine there altogether)

---

## 2021-03-19 21:03:14 - strategies channel

**IndikaE**

I am papertrading my first strategy implemented in flumine, and I occasionally have latency issues. My strategy is really a straight (football) value betting strategy that will just take a backprice if it is +EV according to my model and lay when it is -EV. Dead simple with no need for precise timing, since the model operates on a timescale of minutes. With such a strategy is latency even something to worry about? To me it seems obvious that it is not, but being a noob and all, I’m a little scared I might be missing something in my reasoning. Apologies for the vagueness of the question!

---

## 2021-03-19 20:05:37 - random channel

**Paul**

As a general point: the AWS business model is built around shared resources and contention of those resources. If your application is particularly sensitive to contention, perhaps it’s not the optimal environment for that application.

---

## 2021-03-19 19:55:18 - random channel

**Paul**

It depends on what you’re trying to optimise for. If you’re trying to hold a lot of data in RAM, you’d go in a different direction to if you have an ML model. If you’re just doing a simple strategy that works on a small instance, use that, absolutely

---

## 2021-03-19 15:18:49 - issues channel

**Peter**

You can't specify a start time in your market subscription, but you can use the market.seconds_to_start attribute in your strategy's check_market_book method to simply ignore markets that are too far into the future.

---

## 2021-03-19 15:09:45 - issues channel

**Peter C**

Is it possible to filter markets by start time in streaming_market_filter when you add a strategy to the framework? I've tried but can't filter markets by start time at this point. If it's not possible to filter by start time at the point, how could I discard the markets that start too far in the future for me?

---

## 2021-03-19 14:04:28 - random channel

**river_shah**

My model is very simple now. `if horse == Irish: self.place_order("MATCH_ME", side="BACK")`

---

## 2021-03-18 20:58:02 - random channel

**Jonjonjon**

What's the preferred way to look at all logs, generated by Flumine, for a particular market and strategy? I've found that my backtest result (using data that I recorded) for a market hasn't matched what actually happened, and I'm trying to find out why.

---

## 2021-03-18 18:24:22 - general channel

**Sam Asin**

[@UBS7QANF3](@UBS7QANF3) For sure for sure. That's a good point. Stacking different models is probably a great way to have something a bit more intricate than the general field or whatever.

---

## 2021-03-18 18:13:32 - general channel

**Mo**

Something else to consider is stacking or ensembling these different methods and also different versions of the same method, for example, Elo models with different values of K

---

## 2021-03-18 18:07:13 - general channel

**Mo**

You shouldn’t be so dismissive of Elo. Yeah, it has some obvious shortcomings but all models are approximations of reality. Ease of implementation is an important consideration. I think the 80/20 rule applies here

---

## 2021-03-18 18:01:12 - general channel

**Sam Asin**

i looked at logit models with indicators for teams, which seems fine

---

## 2021-03-18 16:06:12 - general channel

**rd123**

are you implying that there will always be a tennis expertise layer that the market price takes into account, which can't be replicated by the models? Or that the best model is already out there, and it is impossible to beat? (second option seems very doubtful to me)

---

## 2021-03-17 21:40:46 - random channel

**Paul**

Random podcast recommendation: [https://twitter.com/halfkelly](https://twitter.com/halfkelly) - if you follow spanky and Captain Jack carefully there won't be much new here, but a nice 2-part audio documentary

---

## 2021-03-17 09:39:29 - random channel

**James T**

Yeah, a strategy that is volatile in its returns pays less PC than one which wins consistently even if they have the same absolute return. 



That’s because a win generates 1% implied comm, and a loss generates 1.5% comm. So in the case you win £100 and lose £100, you’ve generated £2.5 comm for PC, but only paid a physical £2 (from the winning bet). So breakeven strategies actually make you money from a PC perspective if you are on 2% comm. 

---

## 2021-03-17 09:33:29 - random channel

**Mo**

Not something I've thought about before [@U01B8031PM1](@U01B8031PM1). It is worth thinking about what the commission generated rate of your strategy is [@U01A8EKD545](@U01A8EKD545) because it determines what rate of PC you pay

---

## 2021-03-17 09:18:25 - random channel

**river_shah**

Imagine implied commission is 0, you have an uber model that never loses in any market. You paid £X in commission for the week. Betfair still divides X by 2 for the PC offset?

---

## 2021-03-16 15:06:58 - random channel

**river_shah**

Don’t think my models are calibrated for races that match £5M+. Still making money but nowhere around what the raw matched volumes would indicate.

---

## 2021-03-16 12:57:44 - general channel

**Mo**

Example: fitting your model to BSP gives you the distribution of speeds of the horses. You use these distributions in running combined with each horse's distance to the finish line to calculate an in running probability. Then you compare that to the current prices to find value. You're not comparing the current prices to the BSP to find value

---

## 2021-03-16 12:56:48 - general channel

**liam**

I have never made it work (using SP for modelling purposes inplay)

---

## 2021-03-16 12:18:33 - general channel

**Beeblebrox**

This is what I do. Mainly because I'm not smart enough to build my own models, so I just piggy back on the wisdom of the crowd.

---

## 2021-03-16 12:13:29 - general channel

**Mo**

Same thing can be said about assessing realised returns from a strategy versus calculating expected value using market implied probabilities

---

## 2021-03-16 11:57:06 - general channel

**Misha**

2. above is definitely part of my model

---

## 2021-03-16 11:53:16 - general channel

**Mo**

I think it's definitely something you should take a closer look at. Use the market to tell you the true price whenever you can. In a lot of cases it's going to be way better than any model you can build

---

## 2021-03-16 11:52:03 - general channel

**Mo**

Fit an efficient market to find value in an inefficient market. Two examples:



1. Statistical arbitrage e.g win versus place

2. Use starting prices to fit a model to identify value in running

---

## 2021-03-16 11:50:27 - general channel

**Unknown**

Stupid question perhaps but it sounds rather counter-intuitive to fit a model against implied probabilities derived from the market with the aim to beat the market?

---

## 2021-03-16 10:02:34 - general channel

**D C**

I recall from logistic regression with logit link that because of the simple formula for logit there is a similar formula to map upper and lower confidence intervals for your modelled probability. This is what I used to use to give myself a "cushion" around the estimates. I am certain my model worked mainly because the bookies prices were so shite back in the mid to late 2000's rather than any modelling skill on my part. After all, it only used public data scraped from yahoo sports. Typing this makes me realise how long ago this was.....

---

## 2021-03-16 10:00:49 - general channel

**D C**

SE - standard error. Like a standard deviation you can apply around a point estimate. From memory most maximum likelihood estimates thrown out by a linear model are shown to be normally distributed.

---

## 2021-03-16 09:55:44 - general channel

**D C**

Bayesian you would get a distribution rather than the frequentist point estimates. But other stuff that generates a point estimate and a SE is "usually" going to be normally distributed in the CI sense. I am not speaking for [@UBS7QANF3](@UBS7QANF3) here this is just based off my own (outdated) days of modelling and basics of the premise of Bayesian versus Frequentist statistics.

---

## 2021-03-16 09:53:44 - general channel

**Alessio**

If I understand correctly what [@UBS7QANF3](@UBS7QANF3) alludes to is more akin to Bayesian inference rather than standard inference, where either analytically or by simulation, you have an understanding of how certain is your estimate of that probability. The more certain you are, the more you can trust your Kelly, for example (scaling the 0.5 or understanding the odds are 'almost unreal'). Which makes a lot of sense to me. Did I understand correctly?

---

## 2021-03-16 09:51:12 - general channel

**Misha**

BTW, the more sophisticated modelling is being done by someone else (not my area of expertise)

---

## 2021-03-16 09:49:04 - general channel

**Misha**

I see this model as the "funding" for more sophisticated modelling to follow

---

## 2021-03-16 09:48:21 - general channel

**Misha**

The current model uses no ML or sophisticated maths. Models to follow will use linear regression and similar techniques

---

## 2021-03-16 09:41:13 - general channel

**Mo**

One way you can take advantage of this would be if you are trying to fit a model to the implied probabilities, don’t try to find the parameters that give the closest probabilities to the point estimates but the ones where all probabilities fit within the intervals

---

## 2021-03-16 09:40:26 - general channel

**D C**

This is what I used to do with logistic regression models - use the SE given to get a rough CI around the point estimates.

---

## 2021-03-16 09:23:20 - general channel

**user34**

I produce an estimated distribution of possible prices before betting. It seems to help catch both situations with vague data and where the model might be missing something.

---

## 2021-03-16 08:55:27 - general channel

**Oliver Varney**

your questions are not specific. who knows if dutching is a good strategy. What does your empirical backtesting show? Is it +EV?

---

## 2021-03-16 08:50:12 - general channel

**Unknown**

looking to get involved, dutching a good strategy?

---

## 2021-03-16 08:17:35 - general channel

**Outthebox sports trading**

whats the best strategy for Cheltenham today??

---

## 2021-03-16 08:13:15 - general channel

**Misha**

A related question: how many on this workspace generate a true price for a sporting event which they use to bet? I know [@UBS7QANF3](@UBS7QANF3) does, and I do as well, but interested to know how many others do as well? (this is more related to stats-based modelling rather than betting based on price movements)

---

## 2021-03-16 07:57:00 - general channel

**Mo**

```kelly_fraction = true_probability - (1 - true_probability) / (odds - 1)

if kelly_fraction &gt; 0:

    stake = 0.5 * kelly_fraction * bankroll_size

    place_bet(stake, odds)```

You’re literally guaranteed to make money this way!

---

## 2021-03-16 07:42:29 - general channel

**Oliver Varney**

to be constructive [@U01PUHXHEKC](@U01PUHXHEKC), best to phrase the question in a more specific way so we can give some constructive feedback and starting points. The initial question wont get answers as people wont give your their strategy on a plate

---

## 2021-03-16 07:38:28 - general channel

**Mo**

I find the best strategy is to place bets that have positive expected value

---

## 2021-03-16 07:07:32 - general channel

**Outthebox sports trading**

whats the best strategy to make some profits on the betfair exchange?

---

## 2021-03-16 05:42:25 - issues channel

**IndikaE**

Of course. Thanks! Now I feel quite embarrassed for even having asked such a question. I might not have been getting enough sleep lately, working so hard on getting my strategy to production :flushed: 

---

## 2021-03-15 21:55:13 - strategies channel

**Tom**

Hi All, apologies for the noobie question. I'm looking to build a horse racing strategy and wonder about the amount of data that you would recommend I first use for researching and then backtesting with. I've had a look at the free data available from BF and only downloading the BASIC plan for a year or two, there is a ton of data there. What would you recommend please?

---

## 2021-03-15 16:08:04 - general channel

**Unknown**

Guys (gals), following recent chats about Monte Carlo, bet analysis, etc, I threw together a Python project to quickly analyse a BetHistory.csv, which can be obtained from [https://myaccount.betfair.com/activity/bettinghistory](https://myaccount.betfair.com/activity/bettinghistory) when logged in to the betfair website. For those of us that are not statisticians or maths professors, I think it's a useful beginners tool. Would appreciate any feedback, improvements, etc.

Advance warning: I've used a tkinter gui. It's not the prettiest thing in the world, but it gets the job done and is already part of the Python standard library.

---

## 2021-03-15 14:19:16 - random channel

**D C**

I agree if we are talking about some shithouser like "The Badger" who "trades" allsorts but focuses on teaching IP horse racing traders how to "race read" using video streams delayed by who-knows-how-many-seconds. Now as an inplay botter I recognise that I benefit greatly from scum like him duping newbies with some pisspot e-book and making them think they can make money manually trading inplay against video lag/drones/GPS/tracksiders, but it does not sit comfortably with me at all from a moral perspective.



But now compare the other side of the "courses" coin. Imagine someone teaching a course on multinomial logistic regression to an audience who want to model probabilities of horses in a race using historical data/form etc. Or basic poisson regression so you could implement dixon-coles or some ML technique - specifics don't really matter provided it is an actual subject that the tutor has expertise in. The application area (making money from sports betting) is the selling point but paying to learn the methodology from a quality teacher is by no means "dodgy" even if afterwards the technique does not yield profit. After all you can have the right tools but they might not be good enough unless you have the right data (be that bespoke data or fast stream stuff etc). I think I know the types you are referring to though [@U016TGY3676](@U016TGY3676) and I agree with you for the most part. Nobody with an edge is going to sell it on unless they at stage 3 in your list - and after that point that edge will likely evaporate quickly the more people start to utilise it.

---

## 2021-03-15 12:19:38 - random channel

**Paul**

"I have an excellent trading strategy that makes me $100k a MONTH! And I'm prepared to absolutely destroy it by letting you in on my HOT SECRETS for just $3k! Discounted to $1k for 24 hours!"

---

## 2021-03-15 11:47:54 - random channel

**Paul**

There is plenty of free and cheap materials out there that will do wonders - I noticed [@UBS7QANF3](@UBS7QANF3) put up a list of books last week which I owned half of, the other half are now in my wishlist - and I think getting diverse thinking can only help you, but a little Bayesian thinking can help weight inputs. People posting perfect trading positions on twitter and asking for thousands for training and academics who know the theory but don't seem to be interested in the practice tend to go towards one end of the spectrum compared to books and papers written by people with proven tracks records, to my mind

---

## 2021-03-15 09:10:52 - general channel

**Mo**

BFLW is a lower level implementation of the Betfair API in Python. Flumine sits on top of this and aims to be a fully featured trading platform

---

## 2021-03-15 01:45:50 - general channel

**mandelbot**

betfair's new business model :joy:

---

## 2021-03-14 09:15:48 - strategies channel

**Michael**

If you said the same thing during the summer I'd point out that flat races are the main thing going on so they're bigger markets and suggest you check whether simple market size could be indicative, but if you're looking at recent markets then that's all weather racing and NHF, so I'd say it's not a great sign. In general; if your model is all about market behaviour it's probably safest to confine your analysis to market factors unless there's some plausible reason to expect a particular group of markets to behave in some particular way which you can then look for a way to verify.

---

## 2021-03-14 09:03:49 - strategies channel

**Michael**

The way I see it that would offer a different starting point - I'd look again at races with lots of quite evenly matched runners, which will include races that aren't handicaps and exclude some that are. That would pull your analysis back towards looking at market dynamics. Obviously if it were some kind of fundamentals model that would be different.

---

## 2021-03-14 08:39:16 - random channel

**IndikaE**

This is valuable information to me. I will consider starting scraping the IPS. I really only need a rough estimate of second half time stamp, so I think I will will rely on a combination of the proposed heuristics- including the bet delay. Already doing point 1. , btw! My strategy does not need very exact timing - for backtesting I just need to know that I am not using future events to predict the past (of course I don’t want preds to be wildly dated - but when backtesting I prefer to err on the side of caution ). And thanks for pointing me in the direction of IPS - I might try it for better syncing in production. You guys are great :pray:This was one of the last unsolved problems blocking me from deploying my first strategy - now I am pretty excited!

---

## 2021-03-13 22:05:55 - strategies channel

**Michael**

However you test your data there's no substitute for standing back from both your strategy and your process and just asking whether it makes sense, whether you understand (or at least have an idea) where your value is coming from and whether your process was likely to lead to a false or real result.

---

## 2021-03-13 21:58:46 - strategies channel

**Michael**

[@U01LD279D16](@U01LD279D16) - I've just been reading the responses above to your question. you've received a tonne of excellent advice but there's one little thing in your question that's needling me that hasn't been addressed. You say that your strategy looks profitable _'if I look at a subset of all runners, but a loss if I look at all runners (warning sign?)'._ Well yeah - that might be a warning sign. I suppose the questions are; how is that subset generated, does it make sense and when did you think of it?

---

## 2021-03-13 17:06:49 - strategies channel

**birchy**

That's exactly how I've been operating. It's always a bit of a twitchy-bumhole moment when you go live with a strategy and it turns out that you started on a down trend. I'll man it out and see how it goes. :joy:

---

## 2021-03-13 12:54:23 - strategies channel

**James T**

Taking prices with 3% margin against BSP is decent. Especially pre-off. It will be limited by how scalable it is. If it’s trading an hour before off time, then your backtests might be over optimistic because of market impact.  



You said the returns are bumpy. Is that because you are betting outright rather than closing? Why don’t you close at BSP (or at the off) for now and verify this trigger work in reality? Treat your open bets an hour before the race separately (give them their own strategy ref) to your closing bets, so that it’s easier to analyse them afterwards. 



If you’ve got 3% margin against BSP you’ll still make a healthy profit by closing (if the trigger pans out in live betting). 

---

## 2021-03-13 12:33:51 - strategies channel

**Mo**

Yeah that's what I'm saying. I think the more important thing is what I mentioned in the main channel. The first thing to do is to work out if you are actually making value bets according to BSP. If not, then the problem is the strategy itself rather than the variance

---

## 2021-03-13 12:12:32 - strategies channel

**Peter C**

I meant equalising the stake of the back bet you've laid as far as possible. So, for example, if the strategy laid the base stake x3 on a single runner, when the chance arises to lay a different runner the strategy would take a bigger stake to try and even this up

---

## 2021-03-13 12:07:51 - strategies channel

**birchy**

To add to the above, I've gone live with the strategy after extensive backtesting and am seeing much greater volatility than backtesting suggested.

---

## 2021-03-13 12:03:12 - strategies channel

**birchy**

I'm in a very similar boat to [@U01LD279D16](@U01LD279D16). I have a preplay, straight laying strategy that lays at &lt; BSP on &gt;80% of bets, so shouldn't that _theoretically_ produce a profit long term? The other 20% are slightly &gt;= BSP but only by small margins. There is an option to back at BSP to reduce volatility but that feels a bit dirty and I've not yet calculated if it would actually be +EV.

Also, what's the best way to calculate expected drawdown for a strategy?

---

## 2021-03-13 11:34:08 - strategies channel

**Peter C**

I've been exploring a single trigger for pre-off horse racing markets that I'm hoping to get some advice on. The strategy places a lay bet if the single trigger is met. Over 1800 markets the trigger returns a profit (beats fair value 56% of the time, and sum of lay bet prices is less than sum of fair value prices) if I look at a subset of all runners, but a loss if I look at all runners (warning sign?). Even though the trigger returns a profit, it is a significantly bumpy ride. I looked at the dose response in relation to the strength of the trigger, and there is a tiny positive correlation (size of trigger value/value found). Honestly, I think that the trigger may simply be skimming some noise before the market is particularly efficient because if it places bets only in the last hour before the off then it makes a loss, or may simply be overfit.

I tried to improve the consistency of the results by:

• encouraging the strategy to take similar total stakes across each runner bets are placed on

• increasing allowed selection exposure

• 'cashing out' bets that aren't value at the off (improved consistency but made the trigger produce a loss)

• only looking at bets in certain time periods

None of these things helped with consistency of results. I'm interested in what sort of things I should be thinking about to improve consistency of results (other than removing root causes of bad bets or a secondary trigger that confirms value), and whether the trigger itself appears worthless. I'd appreciate any advice anyone is willing to give, even if it's throw it all away and start again! Cheers

---

## 2021-03-12 19:50:06 - random channel

**Paul**

On the Football Index story: I encountered one of their senior people at a dinner for people in senior positions in London tech firms (for those who understand such things: back then I was a CTO of a scrappy healthcare startup, these days I'm just a lowly SDM in a FAANG), and he was talking about how tough he was finding it. Digging a bit I discovered he had moral questions about how some in the business behaved and wanted advice. The moment I mentioned I was knowledgable about exchanges and trading on sports markets and that I was mates with some of the data guys at City Football Group, he clammed up. Seems like there was more going on there than even I realised, perhaps.

---

## 2021-03-12 14:40:53 - issues channel

**liam**

its the strategy class, so if you were in the strategy its just `self`

---

## 2021-03-12 14:40:26 - issues channel

**Peter C**

Thanks Liam - sorry for the barrage of stupid questions but what does the 'strategy' argument want? I've tried everything I can think of

---

## 2021-03-12 11:40:32 - issues channel

**Peter**

Converting my first strategy from BFLW to Flumine and enjoying the paradigm shift (and the ability to throw away lots of code). I have a question about exposures. I'm overriding the default max_order_exposure and max_selection_exposure attributes for my strategy. When these exposures have been reached subsequent orders are flagged as violations. Is the violation recognition intended primarily as a fallback protection, or is it fine to use it as the front line approach to managing exposure, i.e. should I be be adding additional code to recognise and avoid "placing" orders that the framework will intercept and reject or would that be considered overkill / duplication?

---

## 2021-03-12 10:50:54 - issues channel

**mandelbot**

Not really sure why im getting this message:

```{"asctime": "2021-03-12 10:49:39,261", "levelname": "WARNING", "message": "Market not available to create order 138348389780580590", "bet_id": "226843537092", "market_id": "1.180439597", "customer_strategy_ref": "ID16985", "customer_order_ref": "c8312d8fc9d8c-138348389780580590", "strategy_name_hash": "c8312d8fc9d8c"}```

---

## 2021-03-12 08:33:39 - random channel

**Mo**

I suppose the newer dividends based on match performance that were time limited were an attempt to encourage more trading activity

---

## 2021-03-11 22:52:06 - random channel

**Misha**

There are no such thing as market results based on the fixed rules of a game. It's an area where if you do this, sports betting has no financial equivalent

---

## 2021-03-11 22:12:13 - random channel

**Misha**

There is also a difference if you model on the results of the sports rather than market movements. There is no equivalent in financial trading, and there is no equivalence to the stability of returns with a good model based on sporting results. I know of two very large organisations in sports betting and financial trading. The sports betting organisation checks returns every few weeks, The financial trading organisation checks positions every few hours

---

## 2021-03-11 21:32:19 - random channel

**MacrcoPolo**

I think that's mostly it... I think it helps to just remember that in both markets people have different goals. Investing in stocks may be generally +ve EV, but if that was the end of the story then market makers would lose money. I think the goal of most in gambling market is to get a bet on and have some fun. In the stock market these participants exist too, it's just that the proportion of folk looking for speculative fun from a bet is higher in betting markets. If the point is that gambling achieves very little economic benefit, then I whole-heartedly agree.

---

## 2021-03-11 20:25:53 - strategies channel

**James T**

There’s no getting away from sports betting being a zero sum game. Net winners offset net losers and bookmakers and exchanges take their cut. You can argue that “providing liquidity” adds value to the system, but ultimately if you didn’t take the other side of the bet and win then no one would lose. So financially, winners are clearly not contributing to the system. 



In my opinion, the only way to frame the “non-zero” game argument is to say that value is created through the entertainment of gambling. Losers are happy to pay a premium for the excitement of placing a bet even though they lose in the long run (otherwise why would they continue), and winners are compensated for offering that service (for the financial risk and work of pricing up the bets). So it is a net positive system in my opinion. As for whether people should be allowed to gamble or how, or whether it’s rational to gamble if you’re a net loser, is a separate question. 

---

## 2021-03-11 18:18:23 - strategies channel

**Lee**

I find it a potentially interesting problem. In my case it's not really affecting me yet as i'm not pushing stakes hard at all. But more from the point of view if you have two separate strategies that want different prices from the same tick update I could view that many ways. I could be asking for a better price on one strategy, maybe i'd rather a lower price to improve matching, maybe increasing stakes of the lower priced strategy might take away a decent chunk from the latter.

I guess it still goes back to what you was saying, a unified strategy that could then be AB tested.

---

## 2021-03-11 15:53:36 - random channel

**Dave**

But i've found much more room for modelling from fundamentals in footie...

---

## 2021-03-11 15:52:51 - random channel

**Dave**

For racing I have generally found price action far more useful than fundamentals. Maybe because my skills for modelling from fundamentals suck, but one thing that sticks out to me is that paragraph from that article about Bill Benter where incorporation of market data massively proved his pnl.

---

## 2021-03-11 13:20:11 - general channel

**Mo**

A man for all markets and trading bases are more autobiographical so I think those are fine on kindle. Precision, efficiency of race track betting markets and the Kelly criterion book are all text book-y so better to have hard copies if you like to make notes/highlight and easier to refer back to that way. The logic of sports betting is somewhere between the two. Statistical sports models in excel is a very practical book so nice to be able to read on a computer while also running excel 

---

## 2021-03-11 12:19:06 - random channel

**river_shah**

so obviously there is only so much I can share here but price action trumps fundamentals most of the time (again; my biases not true for everyone and strategy dependent)

---

## 2021-03-11 12:12:24 - random channel

**river_shah**

the single biggest factor in modelling bets well I find is options trading background

---

## 2021-03-11 11:58:29 - random channel

**river_shah**

I guess I am going with 80 /20. I am not at the limit to squeezing everything I can re horses but the models are decent enough (and run fairly autonomously) so gives me time to look at other things too. Next steps for horses are sizing up more but for that I need market feedback (acquired over months).

---

## 2021-03-11 08:55:29 - strategies channel

**Paul**

To go back to [@U016535QCJ2](@U016535QCJ2)'s argument - the "purely beneficial" way to bet then might be to take a buy and hold investment position: back an outcome pre-event and sit back and wait. Billionaires have been made in Hong Kong on that strategy, but it's a tough game...

---

## 2021-03-11 08:46:24 - strategies channel

**Jonjonjon**

A lot of what we do on Betfair can be thought of as liquidity provision. If my counterparties did not trade against me, their prices would be worse. I give them a better price, and make a little bit of cash each time as I have a superior pricing model.

---

## 2021-03-11 08:38:55 - strategies channel

**Paul**

I think most successful betfair (manual) traders would automate if they could, and they would increase transaction volume if they could - does that mean manual trading == good and hft algotrading on the same strategy on the same market == bad?

---

## 2021-03-11 00:08:07 - strategies channel

**Misha**

It's in the same vein as day trading, or god help us, high frequency trading. I don't think there is any net benefit in it at all. However, in reality you aren't ever in a one-to-one transaction with anyone, and a lot of the time, even if successful, you are taking the opposing side to others who have a lot of money in the game. In my chosen sport, in-play tennis, I am sure with Challenger matches that I am betting against some large individuals/organisations with a lot of money behind them, so I can only assume they have some amount of success as well

---

## 2021-03-10 22:41:56 - strategies channel

**Michael**

Analysis wise I think the only thing you can do is identify the specific overlaps and flag them for analysis. This is also the sort of thing where you can use market level AvB tests to good effect (if you're patient enough). That's all a bodge though, I think the best solution is to unify all of your betting. You can unify your betting either by taking strategy A into account when triggering strategy B - as in: If strategy_b.conditions_met and not strategy_a.conditions_met....  or by having a single model/strategy that generates whatever bets are appropriate in a oner. Personally I do a bit of both. There is an overlap between my TPD and non TPD betting so in TPD markets I take the former approach and if a market doesn't have TPD I have everything unified into one 'strategy'. After all, the effect of more strategies is just more bets at certain times so why not do that explicitly and in a way that structures the data well for analysis later?

---

## 2021-03-10 22:15:02 - strategies channel

**AndyL**

bloody difficult trying to find a profitable strategy, everything I look at just behaves as random outcomes

---

## 2021-03-10 18:48:07 - strategies channel

**birchy**

Personally, I treat them as individuals because my existing strategies are already part of the market data that strategy X is working with.

---

## 2021-03-10 18:40:19 - strategies channel

**Lee**

What are peoples thoughts on analysing/dealing with strategies that may overlap with each other? Does it even matter as it's a separate strategy which could be something someone else is running?

---

## 2021-03-10 17:47:37 - general channel

**Aaron Smith**

otherwise you can also "trust" that everything in BaseStrategy is being called when it intuitively makes sense. process_market_book is where you will want to put your decisionmaking and order placing.

---

## 2021-03-10 17:42:33 - general channel

**user34**

In this case it would be BaseStrategy.

---

## 2021-03-10 17:15:03 - general channel

**user34**

This seems like a natural architecture to have, but when I look at the flumine examples I can't see how to replicate this; the ExampleStrategy class has function definitions, but doesn't seem to do anything.

---

## 2021-03-10 17:13:57 - general channel

**user34**

I'm sorry if the answer to this question is already in the chat or examples, but I am looking to migrate my betfairlightweight strategy to flumine for hopefully better reliability and logging and I am having a hard time figuring out how to do this. My comfort zone for coding is very much defining functions that process specific inputs so this could be something in Python I am missing. My current set-up has separate processes that i) identify appropriate event ids in the next day, ii) identify the relevant market ids from those event ids and manage streaming subscriptions, and iii) receives data from the streams at fixed intervals and decides whether to place bets or cancel existing bets.

---

## 2021-03-10 10:31:37 - random channel

**Mo**

IMVHO, yes. The threshold would be if you can’t otherwise generate predictions for the strategy in time to act on them...

---

## 2021-03-09 19:29:23 - strategies channel

**IndikaE**

Yes - I will take your advice. I have probably been overthinking it a bit. I am really only seeking confirmation that my edge is there. I have no interest in calculating VAR or anything. But my back tests do not look random at all(either I have a pretty decent edge, or I am unwittingly leaking information from train to validation). So I guess I should just use one of the ‘naive’ approaches and get on with it. Looking forward to being able to use the “check £ in account”-approach as soon as I get this strategy deployed(first time for me).

---

## 2021-03-09 17:32:59 - strategies channel

**IndikaE**

Might be - good point. That’s also why I mentioned earlier that this approach would only be really good if the number of bets are exactly equal for each market. I think the characteristics of the strategy should be considered before choosing an approach.

---

## 2021-03-09 16:56:08 - strategies channel

**Michael**

It would be interesting to design a simple hypothetical strategy and work through an example. I'm thinking 'lay every time the prices shortens 10%' or whatever.

---

## 2021-03-09 16:47:12 - strategies channel

**Mo**

It's also probably less acceptable if there's some position dependent element to the strategy such that later bets depend on earlier bets

---

## 2021-03-09 15:21:39 - strategies channel

**IndikaE**

Thanks for your input - that actually got me thinking. Perhaps I could choose a number of random sub-strategies - each with only one bet per market - then do vanilla simulation for each sub strategy for each market, and finally do some sort of meta analysis on the set of p-values obtained for the sub strategies. The assumption would be if the probability of hitting a low p-value sub strategy is low, then I have an edge! Could this make sense? Not completely clear how I would do it - nor can I justify the method theoretically yet. I think this would work best, if the number of bets were equal for all markets -  but even when they are not, it might be a useful indicator if nothing else.

---

## 2021-03-09 15:00:51 - random channel

**Newbie99**

That makes sense, however the reason I wanted to go down this approach is to then try to work out after x games of the series, what is the probability then?



So I thought trying to understand this might help me get my way around the next step, as say we're 3 games in then, the probability will have changed (potentially dramatically) depending on the first 3 results.



In essence, my thought process was as follows:



1. Get starting price (modelled or market doesn't matter for now as its hypothetical)

2. Derive probability of winning each game from starting price (assumes scoreline is 0-0 at the start). I was going to attempt o reverse engineer this somehow once I understood the concept a bit better.

3. Once probability per game is known, then attempt to create live probability based on games won so far / remaining.

Is that approach logical (I appreciate its overly simplistic, its more conceptual than anything else at the mo)?

---

## 2021-03-09 14:49:28 - general channel

**Mo**

Welcome to algorithmic strategy development in sports betting!

---

## 2021-03-09 14:47:41 - general channel

**MacrcoPolo**

In addition, HK was perfect for his model. There is only 2 tracks, the weather is relatively consistent, the pool of horses is closed each season and the number of runners is similar each race, as is the length of race

---

## 2021-03-09 14:46:42 - general channel

**MacrcoPolo**

Getting the data isn't too tough. But for one thing, certain aspects of his model are non-trivial and you need to know a lot about statistical inference to fit it correctly and verify you don't have a pile of turd at the end

---

## 2021-03-09 14:46:22 - strategies channel

**IndikaE**

Hi. A short question about using Monte Carlo methods for estimating a p-value for your strategy outcome. I have done it several times before for simple (football match-odds) strategies that simply back one outcome before game start. In these cases I simply use the probability implied by the odds, and simulate a large number of histories, to estimate the probability

of a better outcome than my observed outcome (assumption: low p-value means edge). However, I am currently trying to validate a new strategy that will place several orders in play. Validation suddenly becomes a harder problem, since the events are not independent - and the implied

probabilities are ambiguous. Intuitively, it would not be meaningful to draw independent variables for each order, since the outcome of events for a single market are perfectly correlated. Right? How would you go about this?  What probabilities could function as 0-hypothesis? Maybe pregame odds?

---

## 2021-03-09 14:44:13 - general channel

**Mo**

Honestly, if you want ideas for models or strategies, I think academic papers are better than books

---

## 2021-03-09 14:43:49 - general channel

**Jonjonjon**

How big a project, would it be to get the data required to do some backtesting with Benter's model?

---

## 2021-03-09 14:41:40 - general channel

**MacrcoPolo**

None of it is state-of-the-art anymore, and he glosses over some key details (notably parameter estimation - which is non-trivial in his model) but it takes you through a rigorous approach to sports betting

---

## 2021-03-09 13:57:06 - general channel

**Mo**

Of course, but really you want to teach a man to fish. There are some really fundamental things that newbies overlook. For example, use the market to tell you the true price wherever possible (EV calculations, model parameter estimation, statistical arbitrage)

---

## 2021-03-09 13:44:44 - general channel

**Jonjonjon**

I've just done technical analysis so far. Using any of those models above just seems to make my head hurt, and I've never found anything worth trying.

---

## 2021-03-09 13:40:26 - general channel

**Mo**

But I think it's a much better starting point for newbies than building a ML model or technical indicator which seem to be the typical starting points

---

## 2021-03-09 13:37:37 - general channel

**MacrcoPolo**

Haha exactly. In fairness, the harville model in it's raw state is garbage

---

## 2021-03-09 13:35:50 - general channel

**MacrcoPolo**

Although in fairness I suspect it's based on Benter's arb model

---

## 2021-03-09 13:29:11 - general channel

**Jonjonjon**

By statistical arbitrage on Horse Racing, are you thinking of betting above/below an estimate of the fair value? Or some sort of back-the-win / lay-the-place strategy?

---

## 2021-03-09 10:25:16 - general channel

**river_shah**

Not to mention any cross market hedging if that’s what the strategy does

---

## 2021-03-09 09:23:49 - general channel

**Dave**

Not suitable for any relatively high frequency strategy though.

---

## 2021-03-08 21:29:21 - general channel

**Beeblebrox**

Are Betfair OK with us polling the inplay service to get the current score?  I've got it polling it every 30 seconds for each market I'm subscribed to for one particular strategy.  Is that acceptable or is that taking the mickey?

---

## 2021-03-08 16:16:06 - strategies channel

**Michael**

The scale of the place market barely compares to the win, so whilst I'm sure people must be calculating place prices from the win market I doubt they're doing it the other way round. I wouldn't expect a new place market strategy to affect the win market at all. The other way round might be possible but in reality I doubt you'd see it. You're always trying to minimise your market impact so it's hard to imagine your win market bets leading to effects in the place.

---

## 2021-03-08 14:52:28 - general channel

**Mo**

I think it's a very good book to recommend to newbies as it is quality technical content, even if we're at the level where we would prefer something along the lines of "Statistical Sports Models in Python", and would be very valuable to someone who has no idea where to begin calculating their own fair price

---

## 2021-03-08 14:21:21 - general channel

**Mo**

[https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723/](https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723/)

[https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175](https://www.amazon.co.uk/Trading-Bases-Fortune-Betting-Baseball/dp/0451415175)

[https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458](https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew/dp/1079013458)

[https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522](https://www.amazon.co.uk/Precision-Statistical-Mathematical-Methods-Racing/dp/1432768522)

[https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X](https://www.amazon.co.uk/Efficiency-Racetrack-Scientific-Financial-Economics/dp/981320351X)

[https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139](https://www.amazon.co.uk/Kelly-Capital-Growth-Investment-Criterion/dp/9814383139)

[https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975](https://www.amazon.co.uk/Man-All-Markets-Beating-Street/dp/1786071975)

---

## 2021-03-08 13:17:05 - general channel

**Aaron Smith**

There are certainly diffrent ways to be successful in sports trading and many of them dont requiere you to write a single line of code. However, if that is what you are trying to achieve, this slack group will probably of little help, as its about bflw and flumine.

---

## 2021-03-08 13:13:20 - general channel

**Michael**

For example, you could ask about Flumine, BFLW, Python and automated betting - which is what we do here.

---

## 2021-03-08 13:02:11 - general channel

**Pierino S**

ok [@UGV299K6H](@UGV299K6H), well the flumine and the Python stuff is not easy for me to follow, as I'm not a coder or along those lines, so I can't post usefully about that, much as I'd like to. So most of the discussions do go over my head. I am interested in football and i can kind of get in-play trading on that one. I do understand green pictures and this guy is out there, he does post green stuff, so hence my interest.

---

## 2021-03-08 13:01:26 - issues channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) Think this may be a bug, as the declarations say that `total_matched` should be `float` , however I can confirm that I'm seeing `None` :

[https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/resources/bettingresources.py#L560](https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/resources/bettingresources.py#L560)



[https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/resources/bettingresources.py#L478](https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/resources/bettingresources.py#L478)

---

## 2021-03-07 23:04:52 - strategies channel

**Misha**

In terms of my model, would make absolutely zero difference, even if there was a "free for all" for courtsiders

---

## 2021-03-07 23:03:46 - strategies channel

**Misha**

I don't think courtsiders, if they exist, make any real difference at all. It's very difficult to make money by being extra fast because almost all "risky" prices are removed between points before any smaller matches. Maybe you "could" take some on offer after a point has been completed if there is money there at a reasonable price, but from my observations there is still little to be had, and you still need a good model to be right. Tennis matches swing often late in the match

---

## 2021-03-07 17:41:48 - issues channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) think I've found the problem. Been through the logs and discovered a couple of intermittent critical errors due to a bug in my strategy code. Just to clarify, does Flumine reload the orders on restart?

---

## 2021-03-07 13:10:54 - strategies channel

**Atho55**

Do you think the return of courtsiders will have an adverse effect on your model?

---

## 2021-03-07 10:42:00 - strategies channel

**Dave**

i guess that perspective is dependent on how liquid your market is and how much you expect your strategy to trade. At least for most of my strategies currently 4% would be too thin to be worth the time I put into it :laughing:  but obviously I would be incredibly happy if I was yielding 4% from 700K in a week for sure

---

## 2021-03-07 10:26:49 - strategies channel

**Dave**

annoyingly impact is very hard to model in backtest...

---

## 2021-03-07 10:26:28 - strategies channel

**Dave**

QQ to racing specialists: Have you noticed any impact to your existing strategy performance when deploying another strategy in a seperate market on the same event? I'm deploying some stuff on the place markets and worried I will impact price action on win markets. Hopefully starting off with minimal stakes should show negligible impact...

---

## 2021-03-07 09:54:40 - strategies channel

**Dave**

that's pretty cool. What happened in first 150K bets? Just updating model calibration etc?

---

## 2021-03-07 05:07:35 - strategies channel

**Misha**

-) I don't use live prices in my model, only the "starting" price of the match. Obviously I compare with live prices at bet execution time to know whether to bet

---

## 2021-03-07 05:06:29 - strategies channel

**Misha**

-) My modelling input data stops at June 30, 2020 (like building a horse racing model for use now ignoring the last 8 months of racing)

---

## 2021-03-07 05:04:25 - strategies channel

**Misha**

Some random notes about my model:

---

## 2021-03-07 04:38:34 - strategies channel

**Misha**

You can say what you like about my knowledge about probability, but what I have done works. I started modelling on in-play tennis at the beginning of October, and have used no techniques I had used previously for any other sport. So in 5 months from scratch I have got to here (by October I did have the required data in a database). Here is a plot of my lifetime bets, normalised for size (483,000 in total) - lifetime net profit is 4.3% at this point in time:

---

## 2021-03-06 19:07:27 - issues channel

**liam**

When you run a recorder strategy you use the data stream which is a super lightweight mode as the raw updates are passed through the strategy to allow you to record it 

---

## 2021-03-06 19:05:38 - issues channel

**liam**

Ideally no, tricky bug as we want the blotter function to be called if there are orders I.e real strategy live on that market 

---

## 2021-03-06 19:00:53 - issues channel

**liam**

So the recorder has created a stream and your order placing strategy has created a stream, however they share the local market object in the framework, you can see the handling for this in _processclose_market_ where the instance type is checked (recorder requires the raw update and strategy uses objects)

---

## 2021-03-06 18:51:53 - issues channel

**Alessio**

```strategy = sure_strategy.TakeTheSureStrategy(

      name = 'Take The Sure',

      market_filter=uo25_filter,

      max_live_trade_count=4,

      max_trade_count=4,

      max_order_exposure=40.0,

      max_selection_exposure=40.0

)

framework.add_strategy(strategy)```

---

## 2021-03-06 18:51:36 - issues channel

**Alessio**

``` strategy = S3MarketRecorder(

      name="Soccer " + '_'.join(mtype),

      market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["1"],

        market_types=mtype,

        turn_in_play_enabled=True,

        country_codes = ccountries,

      ),

      stream_class=DataStream,

      context={

        "bucket": 'betfair-hist',

        "local_dir": "/home/user/dumper/bf/1_soccer_" + "_".join(mtype) + "_" +str(cidx)

      },

  )

  framework.add_strategy(strategy)```

---

## 2021-03-06 18:50:50 - issues channel

**liam**

What does the setup look like in terms of framework.add_strategy

---

## 2021-03-06 18:48:57 - issues channel

**liam**

Are you passing a dataclass into a strategy?

---

## 2021-03-06 15:14:10 - strategies channel

**D C**

Is it your model though Misha? Or is it your partners?

---

## 2021-03-06 15:13:51 - strategies channel

**Misha**

I doubt my model would be working if it was incompatible with probability theory :wink:

---

## 2021-03-06 14:54:09 - strategies channel

**Michael**

_'It exists for every model. And is different for every model'_ That's exactly what I dealt with above. Did you read it?

---

## 2021-03-06 14:53:07 - strategies channel

**D C**

The only thing that will differ is estimates of it from different models.

---

## 2021-03-06 14:52:02 - strategies channel

**Misha**

It exists for every model. And is different for every model. (which is what I have been saying all along)

---

## 2021-03-06 14:51:59 - strategies channel

**D C**

You can only determine "value" if you have an estimate of what the right price is (from modelling/whatever) and exploit market inefficiency when the available prices differ from it.

---

## 2021-03-06 14:48:51 - strategies channel

**D C**

Logistic regression - you model the probability of a selection winning. You get a CI around that for sure - its just an estimate. Regardless, the true probability DOES exist even if we cannot calculate it with precision.

---

## 2021-03-06 14:45:07 - strategies channel

**Misha**

Everything is done on a probability of winning. There can be a multitude of successful models all doing this on the same market, often betting on opposite sides. Because to be successful, you only need a small margin over which your bets win (I aim for &gt;5%). I can lose a lot and still come out ahead

---

## 2021-03-06 14:35:54 - strategies channel

**Michael**

Having said the above - I think I know where your confusion is coming from. Let me explain what I think you're thinking and why it's wrong: Say you had a 3 runner horse race that you knew nothing else about, you could reasonably price all runners at 3 and if you then evaluated that prediction in an information vacuum over many events it would turn out to be correct because one runner of the 3 will always win. If you 'paper traded' in your own private exchange then hypothetical bets at odds &gt; 3 would show a profit. Great, all your predictions look perfect, 3 is always 0EV.  Meanwhile someone else is looking at the same 3 runner races but they have access to some basic information about the relative quality of each horse that allows them to better price the runners. Will they agree that all horses are correctly priced at 3?  No. They will make some other model and generate from it a 0EV price that will be different to yours. Let's assume they validate that by testing over many markets so that it performs perfectly. So from your perspective (information blind) it looks like 3 is always 0EV and from his with some limited information he's generating 0EV prices that are not 3. That can make it look like there's more than one 0EV price - but that's an error. Consider what happens if you bet against him in an exchange, you've priced every horse at 3 but he knows better. Where's your 0EV now? You're backing any price he'll offer you that's &gt;3 and he's putting a deposit on a Ferrari. In this case both players have an ESTIMATE for 0V which looks perfect when evaluated internally but it turns out that one estimate is better than the other. That's because the notion of a 'true' 0EV price is predicated on a hypothetical state where all possible information is known. Anything else is an estimate that gets as close to that 'truth' as possible. I think your mistake comes from a failure to recognise that whilst your estimates of 0EV can reconcile perfectly when evaluated internally they wouldn't stand up to superior information and ultimately to perfect 'true' information.

---

## 2021-03-06 14:01:00 - general channel

**Beeblebrox**

I'm using Flumine to paper trade a strategy and in the logs I can see it placing an order and it getting matched, but I can't see if it ever reports the outcome of the order once the market closes.



Is this something I have to add to the Strategy myself? Should I be using `process_closed_market()` and the `market.blotter` list of orders to output this?

---

## 2021-03-06 11:07:10 - general channel

**V**

Yeah, this is how I’ve done it historically. But my stuff is relatively latency sensitive so want to reduce internal latency on the trading path as much as possible.



[@U4H19D1D2](@U4H19D1D2) this is probably a stupid question, but then again this is Betfair we’re talking about so can never be too sure: they only care if you’re consuming data and trading at the account level right? So if you’re only consuming with one client, but trading (and also consuming) with another, that’s fine?

---

## 2021-03-06 10:31:05 - strategies channel

**PeterLe**

The last 14 years of my in running racing strategy is based on there being a true price (at any moment from the start of the event to the close) for each selection. Sure, that changes on each market refresh, but it’s always there.

[@U016535QCJ2](@U016535QCJ2) Id just say keep you mind open that this may be a possibility. Take a walk down that path and check it out for yourself.

---

## 2021-03-05 22:09:58 - strategies channel

**Misha**

BTW, on the note that nothing is essential for a model, I have an in-play tennis model (running successfully) that doesn't take into account who is playing :wink:

---

## 2021-03-05 22:05:33 - strategies channel

**Misha**

That's not to say that the model couldn't be improved, but at the POT% they are getting at volume, it works

---

## 2021-03-05 22:03:28 - strategies channel

**Misha**

If there is one thing that the model is, it is mathematically rigorous

---

## 2021-03-05 22:02:37 - strategies channel

**Aaron Smith**

rescaling to 100% sounds to vague to me, but i m by no means an expert on what they do. Couldnt they run the models for these situations beforehand to be prepared?

---

## 2021-03-05 22:01:24 - strategies channel

**D C**

NR can get pulled at any time. I just find it amazing that someone putting as much money through the market as you claim they do and who has as sophisticated a model as you claim they have would not re-run the model estimates if the most likely winner was removed from the race.

---

## 2021-03-05 22:01:21 - strategies channel

**Misha**

The point here is that absolutely nothing is essential in any one model. Even if you think it is, someone will develop a successful model without it

---

## 2021-03-05 21:57:35 - strategies channel

**D C**

So how do they cater for that [@U016535QCJ2](@U016535QCJ2) ? If I have a set of probabilities and the even money favourite is removed the model probabilities on the other runners are meaningless. 10-1 shots will come into 5-1 shots ?? You have to recalculate value prices

---

## 2021-03-05 21:54:50 - strategies channel

**D C**

Seriously? So the favourite is removed and they don't rerun the model?

---

## 2021-03-05 21:51:40 - strategies channel

**Misha**

Also, the prices for these runners were generated hours before the start of the meeting. Only on extremely rare occasions were probabilities updated after racing had started. I found that fascinating that such a successful model didn't take into account anything happening close to the start time of the race

---

## 2021-03-05 21:47:38 - strategies channel

**Misha**

Even if the model is winning at over 10% and they are 10% of the volume, there are still the vast majority of the money to be made

---

## 2021-03-05 21:28:03 - strategies channel

**AndyL**

not unless your model coincides with theirs...

---

## 2021-03-05 21:16:03 - strategies channel

**AndyL**

although I would love to understand these models, I have a very good -ev model...!

---

## 2021-03-05 21:14:21 - strategies channel

**AndyL**

blimey, can you ping me the "model" please ? :grin:

---

## 2021-03-05 21:13:33 - strategies channel

**Misha**

When you have a model that good you just go for it

---

## 2021-03-05 09:43:01 - issues channel

**birchy**

Think I may have a race condition in my strategy code. Are the orders in `process_orders(self, market, orders)` ordered by place date?

---

## 2021-03-04 19:50:37 - strategies channel

**Mo**

[@UQL0QDEKA](@UQL0QDEKA) 1) is probably a bit better because you avoid situations where orders you would have matched get cancelled or matched by someone else in between orders sent by 2). If you are betting both sides then 2) will generate more commission so may help if you need to avoid 50% or 60% PC rates

---

## 2021-03-04 19:44:52 - strategies channel

**PeterLe**

Given the two following hypothetical scenarios, which would you consider to return the most profits long term, or indeed would the profits be approx the same :



Scenario 1: 1 Betfair Account running a proven strategy , £20 Liability Stakes

Scenario 2: 4 Betfair Accounts running the same strategy as above, £5 Liability Stakes



Assume all PC paying accounts and same comms etc

Just interested in opinions/thoughts and personal experience. Thanks

---

## 2021-03-04 17:22:24 - issues channel

**liam**

Yeah stored in the strategy object 

---

## 2021-03-04 17:13:19 - issues channel

**AP**

Just to confirm, is the runner context unique to each strategy?

---

## 2021-03-04 15:43:59 - issues channel

**birchy**

[https://github.com/liampauling/flumine/blob/b1717c7b13909d15fae865c88ecfd2108a4786d6/flumine/strategy/runnercontext.py#L20](https://github.com/liampauling/flumine/blob/b1717c7b13909d15fae865c88ecfd2108a4786d6/flumine/strategy/runnercontext.py#L20)

---

## 2021-03-04 15:41:52 - issues channel

**birchy**

[@U4H19D1D2](@U4H19D1D2), yeah, have just seen that in the source code. So I have no idea why I'm getting double-bets. Only happens in live strategy. Backtest doesn't do it and it's the same copy/pasted strategy. :thinking_face:

---

## 2021-03-04 15:07:45 - issues channel

**V**

The best way is probably as you said, a local in flight tracker. Add orders to the tracker on placement. The strategy can then check the tracker to see if it has any orders in flight and choose not to place any more. When the order comes in from the order stream you remove it from the in flight tracker.

---

## 2021-03-04 11:32:38 - strategies channel

**James T**

Yeah, I would imagine if you’re not very price sensitive (ie. have a large margin in a fundamental model) then generally taking volume would enable you to match more. I expect they do both though.

---

## 2021-03-04 11:23:20 - issues channel

**Atho55**

I would imagine that the Sportsbook and Exchange have differing business models such that in reality they compete with each other but having the Exchange odds visible in the Sportsbook and the option to direct your bet to either could direct funds towards the exchange if the odds are better and if to a value there is no commission.

---

## 2021-03-04 09:12:29 - issues channel

**Oliver Varney**

I find it hard to imagine that betfair would hand over a tried and tested business model to their competitor

---

## 2021-03-04 08:52:54 - strategies channel

**Beeblebrox**

Yes, but of course that's harder to do! What I'm thinking is, if the strategy I have actually works in practice, the next step would be to then refine it to identify the movements earlier to get more value. The problem I foresee with that is you're more likely to then get false positives.

---

## 2021-03-04 08:13:06 - strategies channel

**liam**

Probably going to regret trying to continue this but the [good] syndicates / big players spend 80% of their time trying to not move the price so you need to think outside the box a little if you want to try and follow. I would disagree [@U016535QCJ2](@U016535QCJ2) as it really doesn’t take much money to move the market (assuming you have a good model in the first place) 



That’s not to say their isn’t an edge here as any modelling that looks to try and model ‘trading flow’ as it can be very valuable.

---

## 2021-03-03 23:19:16 - strategies channel

**Paul**

Knowing that the syndicate just found value does not mean what in front of you remains value. You’d need to model how often they move a price by what % and then your EV calc is not on the price you now see, but on the likelihood it will continue to move as you catch those whirling tailwinds

---

## 2021-03-03 23:03:47 - strategies channel

**Misha**

On any one event we will all have different values. Over a lot of events the person with the most "accurate" values has the best "model"

---

## 2021-03-03 22:46:34 - strategies channel

**Misha**

EV is only a concept for the model you are using. Everyone has a different value for EV. We only find out who is right after the event over a lot of events

---

## 2021-03-03 22:39:54 - strategies channel

**Michael**

At any given time there is a 0EV price. There must be or there couldn't be a +EV or -EV price. Any given model may or may not get it right but it still exists. Two models may produce different prices for a particular instant for a particular bet and both models may be profitable overall but that doesn't mean that they both priced that bet correctly.

---

## 2021-03-03 22:37:18 - strategies channel

**Misha**

In terms of price movement: I have seen prices go from $10 to $5. Getting it at $9 (if that model was correct) is a good value bet

---

## 2021-03-03 22:36:56 - strategies channel

**Misha**

It's why two different models betting on the same races can both be very profitable. You only have to be right more often than not

---

## 2021-03-03 22:35:09 - strategies channel

**Misha**

Last point - if a single player pushes a price towards their model price, that doesn't mean it is pushed towards 0EV. That assumes their model is correct, which we know cannot possibly be so all the time

---

## 2021-03-03 22:01:11 - strategies channel

**Misha**

It might be possible, if you have enough background knowledge and skill, to identify movements generated by the largest and best of the syndicates. Their POT% is high, their turnover is huge, and I know that getting a fraction of that POT% and turnover would easily beat a full-time wage. I had thought about it in the past, but decided that it's a pretty risky strategy totally reliant on someone else

---

## 2021-03-03 09:34:37 - strategies channel

**birchy**

Always remember that the market efficiency increases as more money is traded (aka "wisdom of the crowd"), so in _theory,_ a £500K market will be more efficient than a £100K market. The probabilities for each runner will conclude at either 100% (winner) or 0% (loser). From market opening to market closure, the prices are constantly moving, which by it's very nature indicates that there is uncertainty and inefficiency in the market and _that_ is what you need to exploit. Breaking it down into micro markets triggered by price moves, money flow, etc helps. Think about _why_ the price moved and _how_ the market reports it. You don't have to know that the horse was playing up or the trainer made some comment on TV, all you need to know is if it has a positive or negative effect on the prices and volumes.



You _can_ try to predict the winners or losers using fundamental or statistical analysis but it's a highly competitive approach and would likely require some extremely complicated modelling to beat the market makers.



Simple (and obvious) mathematical approaches DO make a profit but can be difficult to execute optimally, e.g. lay the field at &gt; 100% book, lay 4 runners at &lt; 4.0, back the drifters, lay the steamers, etc. Don't be afraid to oppose what everyone else seems to doing. The horses don't know how much money is being traded and I can tell you with 100% certainty that "insider" knowledge doesn't make a horse win. I live in an agricultural area and know a handful of people that work in the racing industry. If I had £1 for every time I've been told "our horse will win today" (and it didn't), I'd be a lot richer than if I was backing them. Hell, I regularly see these horses get backed from 14/1 into 5/1 and they still don't win, so even the "insiders" get it wrong more often than they get it right.

---

## 2021-03-03 09:14:42 - issues channel

**liam**

hmm, without debugging going to be tricky unless you can replicate a simple example strategy

---

## 2021-03-02 23:53:50 - strategies channel

**Misha**

So player 1 might get a huge win on a race, while player 2 might make a huge loss. Sometimes profits will coincide, sometimes not. Some runners will be bet on by one model but not others

---

## 2021-03-02 23:52:30 - strategies channel

**Misha**

There is also no such thing as "too efficient". On UK racing there are a few syndicates making huge money on pre-off UK racing. And my view is that these models, while incredibly detailed and profitable, will all lead to different prices for different runners

---

## 2021-03-02 21:40:34 - strategies channel

**Aaron Smith**

I dont think a huge amount of data is needed for modeling, but the model has to be good. Taking a suffiecent amount of factors in (like for horse racing track type etc.) and knowing how to value them. Data from last year is pretty much pointless already for current races.

---

## 2021-03-02 21:37:20 - strategies channel

**James T**

Yeah, there will certainly be parties that price things using fundamentals, and some of these people take home some of the biggest sums. However don’t under estimate the amount of data required to go into modelling who wins a horse race for example. I’d say fundamental modelling is one of the more advanced methods and shouldn’t be tackled unless you’re already confident you have a chance of success.

---

## 2021-03-02 19:06:14 - strategies channel

**river_shah**

[@U01DJ4DBF9R](@U01DJ4DBF9R) is correct. But remember once you have checked on OOS, don’t then go back, tweak your models and then reuse that OOS. That OOS gets effectively “burned” even though your model never saw it in training or validation

---

## 2021-03-02 19:04:45 - strategies channel

**V**

Split your data in two: an in sample set and an out of sample. The latter is what you use a final test of “does this strategy generalise to unseen data”. Then you split the in sample further into train/test data sets. You do your tweaking on those. Once you’ve done finished all your tweaking, then you finally run that once on the OOS set.

---

## 2021-03-02 18:56:37 - strategies channel

**Beeblebrox**

One question I have is what do you do when you've created a strategy using the test data and then when you come to use the validation data the strategy doesn't perform as well as you hoped?



Because you could go back and tweak some parameters and then rerun the strategy on the validation data, but by doing that your validation data has now effectively become your test data.  So how do you refine/improve a strategy after you've used the validation data?

---

## 2021-03-02 17:23:28 - strategies channel

**birchy**

[@U01PQ9SR9MJ](@U01PQ9SR9MJ) It can be quite difficult to understand what "value" is and there is no binary answer to the question. The basic idea of making a profit is to place bets at prices greater than the true probability of an event happening. That could be horse winning a race or a football team losing, etc. The fact is that we never _truly_ know if the bet we are placing is good value or not and all we can do is make our best approximation. If our approximation is correct often enough, we make a profit. Sometimes we get it right, sometimes we get it wrong, but as long as we're right more often than the market, we make a profit. Unlike tossing coins, rolling dice or spinning roulette wheels, sports betting does NOT have probabilities that can be calculated exactly, so at best, we're using educated guesses. Whether intentional or not, strategies like "lay the favourite", "back the outsider", etc will only show a profit IF they are finding value.



Regarding backtesting, as others have mentioned, you are trying to predict _future_ patterns, so building a strategy using _all_ of your data only tells you what happened in the past. The problem is overfitting, where, through multiple filter adjustments and fine tuning, you end up picking all the sweet spots from events that have already happened. It's no different to shopping...if the item you want to buy is £10 today but was £8 yesterday, you will have to pay £10 for it because yesterday's price has now gone. Your strategy may tell you to buy at £8, but that's no longer available, so it's not a true value. You _can_ build a strategy using _all_ of your data but then you would have to place real bets and wait a long time to see if it's actually profitable. OR you can split the data into a "training" set and a "validation" set, the validation set representing the "future" data. It's critical to ensure that while developing the strategy that you _never_ use the validation data as it's for...you guessed it...validation only.



After many years at this game (I was botting [http://Flutter.com|Flutter.com](http://Flutter.com|Flutter.com) via browser emulation before Betfair bought them out in ~2002) I had also become very stuck in my thought process. I have a handful of bots that have earnt small amounts for many years but never enough to actually live off. Joining this Slack group was the best thing I've done in the last 20 years. The quality of knowledge collected here is second to none and the members are more than happy to answer stupid questions (and I've asked a lot of them!). I've recently had an epiphany after reading [https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723|The Logic Of Sports Betting](https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller/dp/1096805723|The Logic Of Sports Betting) and listening to the [https://player.fm/series/business-of-betting-podcast|Business Of Betting](https://player.fm/series/business-of-betting-podcast|Business Of Betting) podcasts, both of which were recommended on this group. Don't be put off by negative comments, they're actually a very truthful lot on here and, believe it or not ARE trying to help.

---

## 2021-03-02 13:07:20 - issues channel

**Newbie99**

oh yes good point, probably shouldn't have rushed that. Ok let me try on a proper strategy and report back

---

## 2021-03-02 12:26:01 - strategies channel

**Unknown**

[@U01PQ9SR9MJ](@U01PQ9SR9MJ) the point is that your conclusion of "what is the likely outcome going forward" is unlikely to be useful unless you evaluate this conclusion on data you have not incorporated when doing your data mining. To put it simply, you can't say that your observation of some pattern is a useful observation unless you find that this observation is profitable on data you have kept seperate from where you identified this pattern in the first place. indeed you are attempting to do something like this with your "forward testing", but you can very easily learn the results of your forward testing by just holding out some of your historical data. (This is of course not to disqualify the usefulness of actually taking your strategy to the market with small stakes).



also to add - if you are relying on real trading to do this "validation" for you, your whole process is going to be slow. By holding out some historical data you can instantly check if the patterns you've identified have some profitability (and  therefore meaning you have not just overfit your historical data set).

---

## 2021-03-02 12:24:04 - strategies channel

**James T**

I think like you suggested at the very start you need to change your overall thinking / mentality when coming up with strategy ideas. 



Very first thing is have an idea of where there might be value and possibly why. Imagine a specific point in time and you see odds at 2.1, is backing at that price cheap? Is 2.15 cheap? Is 2.2 cheap? How can you determine if any particular bet is cheap? For me, that’s what a strategy is - a method of determining a fair price so that I can either back or lay with a margin on top of the fair price. 



If you base things on ordering, why would the 3rd favourite necessarily be cheap or expensive based on history? For me the 3rd favourite has just as much probability of being either, so any trend you find in historical data will turn out to be you fitting to the data. 



So I recommend going back to the basics and write down 10 ideas of how you can measure whether a price is cheap or expensive to back or lay. Then test those ideas to see if they are actually a good measure. 

---

## 2021-03-02 12:05:22 - strategies channel

**Oliver Varney**

This is the typical learning approach from machine learning. Take your all the historical data you have and randomly shuffle it. Once shuffled take 20% of you data and put it aside, forget about it for now, almost like it doesn't exist.  With the remaining 80% you will use this data to come up with your model / script / decision maker. Apply the process of learning to this data solely making sure it never sees any of the 20% hidden away. A typical learning approach could be linear regression (gradient descent) but it can be as simple as using excel to filter records although this is sub optimal. Once you think you have constructed your model / script / decision maker, return to that 20% of data and apply the rules / model to it and evaluate performance.

---

## 2021-03-02 11:39:56 - strategies channel

**Unknown**

Splitting the data tells you how well your model generalises. This is a recipe for chucking away money

---

## 2021-03-02 11:38:05 - strategies channel

**Oliver Varney**

Personally Id never run any model off only training data. If so Id be able to predict 100% of winners

---

## 2021-03-02 11:15:17 - strategies channel

**Unknown**

I do something similar to goatiwish. It might be based on technical analysis, but it's definitely got legs. Though it definitely fits into the "Dregs" category of strategies. Below is the live equity curve. The recent bumpiness is because I started trading a second parameterisation of the strategy.

---

## 2021-03-02 11:12:38 - strategies channel

**Oliver Varney**

Id suggest downloading the daily BSP files, splitting your model data into 80% and 20% roughly. Build your script/ decision maker off of the 80% of the historical data, do not let it see the  other 20%. Once you have fully come up with the script / decision maker rules, return to the 20% and see if it makes profit.

---

## 2021-03-02 09:57:57 - issues channel

**Newbie99**

```import time

import logging

import betfairlightweight

from betfairlightweight.filters import streaming_market_filter

from pythonjsonlogger import jsonlogger

from flumine import Flumine, clients, BaseStrategy

from flumine.order.trade import Trade

from flumine.order.ordertype import LimitOrder

from flumine.order.order import OrderStatus

from flumine.utils import get_price



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))





class ExampleStrategy(BaseStrategy):

    def start(self):

        # subscribe to streams

        print("starting strategy 'ExampleStrategy'")



    def check_market_book(self, market, market_book):

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True



    def process_market_book(self, market, market_book):

        # process marketBook object

        self.log_validation_failures = True

        for runner in market_book.runners:

            if (

                runner.status == "ACTIVE"

                and runner.last_price_traded

                and get_price(runner.ex.available_to_back, 0) &gt;= 20



            ):

                trade = Trade(

                    market_id=market_book.market_id,

                    selection_id=runner.selection_id,

                    handicap=runner.handicap,

                    strategy=self,

                )

                order = trade.create_order(

                    side="LAY", order_type=LimitOrder(price=1.01, size=2.00)

                )

                market.place_order(order)



    def process_orders(self, market, orders):

        for order in orders:

            if order.status == OrderStatus.EXECUTABLE:

                if order.elapsed_seconds and order.elapsed_seconds &gt; 1:

                    if order.size_remaining == 2.00:

                        market.replace_order(order,2)



trading = betfairlightweight.APIClient("username")

client = clients.BetfairClient(trading, paper_trade=True)





framework = Flumine(client=client)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

            event_type_ids=['7'],

            country_codes=['GB','IE','AU','US'],

            market_types=['WIN']),

)

framework.add_strategy(strategy)



framework.run()```



---

## 2021-03-02 09:51:37 - issues channel

**Peter C**

X axis is number of markets. Strategy uses only limit orders, back and lay, with a try/except block for replace orders. The 'equivalent' file is my attempt to bring the strategy from 1.16.3 to 1.17.5 by adding a runner context check, and changing the orders from self.place_order(market, order) to market.place_order(order). The identical file test is the file I created to try and bring the strategy to 1.17.5 tested in both 1.16.3 and 1.17.5

---

## 2021-03-02 09:47:12 - issues channel

**liam**

What is the x axis here? Can you share more info on what the strategy uses, for example just limit orders? back / lay? cancel requests? replace requests?

---

## 2021-03-02 08:35:50 - issues channel

**liam**

If you can get a simple strategy that I can replicate I can look into it

---

## 2021-03-01 21:38:50 - strategies channel

**Oliver Varney**

so your lays assuming they were a good lay at BSP, these will most likely have drifted further and you wont match and the reverse is true for backs, they will have shortened. your smart money wont match and the no so smart money will get matched and you will have a -EV strategy

---

## 2021-03-01 21:15:59 - strategies channel

**Oliver Varney**

typically people take +EV bets, i.e. price up a horse using your model and if the price is better in the market, back it and worse then your price lay it

---

## 2021-03-01 20:46:05 - general channel

**Lee**

Hi,

`market.context` is fine to use, I use it too



I think you can put a streaming timeout on the strategy when instantiating to make it trigger? Not sure what the default is.



I’d do both, `listener_kwargs` just filters out to speed up backtesting but you’ll need to do it in `check_market_book` for live trading / testing logic

---

## 2021-03-01 20:45:53 - strategies channel

**Oliver Varney**

So the strategy is either to back or lay the favourite (lowest price horse) at BSP? A binary classification task if it is. You would have to bet like 5 seconds out to do this also as you wouldn't know what BSP would be.

---

## 2021-03-01 20:37:15 - strategies channel

**AndyL**

I think my main issue is my "mindset" is just wrong as to what a profitable strategy is, so basically I am creating strategy/method after strategy, but although they are different strategies I am using the same mental approach to find them. I suspect my mental approach is just wrong, so I create losing algo after losing algo..!! I need someone to "push" me onto the right page!

---

## 2021-03-01 20:34:59 - strategies channel

**Atho55**

It`s not betting on a specific horse, but betting on the BSP Rank favourite for every race (UK) for that day regardless of price and obv assumes bets matched at BSP. Have used historical data to give a pointer to what might be a reasonable combination on the day.

---

## 2021-03-01 20:21:22 - general channel

**Beeblebrox**

Hi, I've only just started using Flumine and have a couple of questions which I hope you can answer to clarify my understanding.  I've had a look through the docs and the code, but would like to make sure I'm correct in my thinking.



I'm adding a strategy that uses the last traded prices x, y and z seconds before the race start.



My first question is, is there a best practice for how/where to store the prices of each runner at the times I'm interested in?  At the moment I'm using the `market.context dict` when `process_market_book()` gets called.  Is that the right thing to be using?



Secondly is there a way to make sure `process_market_book()` get called at x, y and z seconds before the race start?



And lastly, because I'm only interested in the market x seconds before the race starts, is it best to filter out calls to `process_market_book()` by making `check_market_book()` only return True when it's close to the time that I'm interested in, or should I filter it out when initialising the strategy class by setting `"listener_kwargs": {"seconds_to_start": 1234}`? Or does it not really matter?

---

## 2021-03-01 20:03:56 - issues channel

**Peter C**

I think this is the root of my problem earlier because if I give the strategy a higher max exposure to account for the extra matched bets it starts to look a lot more like my backtests on 1.16.3 but on a different scale

---

## 2021-03-01 19:09:47 - issues channel

**Peter C**

I will try and create a simple strategy that replicates this and let you know, but unsure if I'll be able to replicate the issue. You're welcome to my output data from the tests as well if that helps

---

## 2021-03-01 19:04:02 - issues channel

**liam**

That is interesting, don’t suppose you can create a simple strategy and share a file so I can replicate?

---

## 2021-03-01 19:01:33 - strategies channel

**birchy**

Indeed, I have found some more dregs the last few days and am more than happy to take them. Regarding strategy tuning, let's say you have a fairly simple strategy that uses a handful of `if` statements to check volume traded, last traded, current price, etc and then places bets at N ticks offset. You started off with a rough idea of what these numbers should be, ran a backtest and then went live with it. The strategy shows a decent profit on a reasonable sample size but you don't know if the trigger or execution setpoints are optimal. Given that each of your triggers has a range of possible values that equates to &gt;1000 combinations, how would you approach finding the optimal ranges?

---

## 2021-03-01 18:03:41 - issues channel

**liam**

Can you turn strategy.log_validation on? What’s confusing is that the first order should be valid?

---

## 2021-03-01 17:56:34 - issues channel

**Newbie99**

Also using 1.17.5, once I get a violation for an order below min size then this warning appears and can't place a subsequent order, is this intended behaviour (I would have assumed once you try to place a correctly sized order, the message should go and the order should flow upstream)?



This is just paper trading (in case that makes a difference).



Correctly failed order:

```{"asctime": "2021-03-01 16:18:18,238", "levelname": "WARNING", "message": "Order has violated: ORDER_VALIDATION Error: Order size is less than min bet size (2) or payout (10) for currency", "control": "ORDER_VALIDATION", "error": "Order size is less than min bet size (2) or payout (10) for currency", "order": {"market_id": "1.179865560", "selection_id": 38527720, "handicap": 0, "id": "138339079234466185", "customer_order_ref": "869aeb021cad4-138339079234466185", "bet_id": "100000000162", "date_time_created": "2021-03-01 16:12:03.446618", "publish_time": "2021-03-01 16:12:03.626000", "trade": {"id": "933fb664-7aa8-11eb-a42d-2016d8944b85", "strategy": "simple_back_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138339078008452709", "138339079234466185"], "notes": "", "market_notes": "190,330,340", "status": "Live", "status_log": "Pending, Live, Pending, Live"}, "order_type": {"order_type": "Limit", "price": 180.0, "size": 0.05, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.05, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2021-03-01 16:12:03.447618", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Pending, Executable, Violation", "violation_msg": "Order has violated: ORDER_VALIDATION Error: Order size is less than min bet size (2) or payout (10) for currency", "simulated": {"profit": 0.0, "piq": 3.65, "matched": []}}}```

Correctly sized order that fails to place, due to previous violation:

```{"asctime": "2021-03-01 16:25:39,365", "levelname": "WARNING", "message": "Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failure", "control": "STRATEGY_EXPOSURE", "error": "strategy.validate_order failure", "order": {"market_id": "1.179865560", "selection_id": 38527720, "handicap": 0, "id": "138339087393647136", "customer_order_ref": "869aeb021cad4-138339087393647136", "bet_id": null, "date_time_created": "2021-03-01 16:25:39.364713", "publish_time": null, "trade": {"id": "c2a66a1f-7aaa-11eb-a8f0-2016d8944b85", "strategy": "simple_back_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138339087393647136"], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 290.0, "size": 0.06, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.06, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": "Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failure", "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}}}```

---

## 2021-03-01 17:11:49 - issues channel

**Peter C**

I mean in both the runner context check and when the strategy is pulled into the framework the limit is 4

---

## 2021-03-01 17:06:36 - issues channel

**Peter C**

I have 'if runner_context.live_trade_count &lt;= 4:' because I have max_live_trade_count = 4 when I add my strategy to the framework - is this wrong?

---

## 2021-03-01 15:07:53 - issues channel

**birchy**

Yeah...My hardware is not even 50% of that. :joy:

Just as an FYI, I've not tried my "million markets" strategy since this update. I implemented it in my own polling library as the strategy plods along steadily on a 10 second poll rate. Only took just over an hour from project to production, so a no brainer really. I think streaming is better suited to the faster aim-&gt;fire type strategies such as inplay geegees (which I had never got involved in previously).

---

## 2021-03-01 10:51:05 - issues channel

**IndikaE**

Hi. First post here - been lurking for a while. I absolutely love flumine, and I am preparing to deploy my first strategy. I just noticed, that after upgrading to flumine 1.17.4 that I started to hit the transaction limit(5000) when backtesting on around 1000 markets. My strategy usually places only 1-10 orders per market. I initially thought that I had a problem with the monkey patching of datetime, so that the control would use actual system time(this would explain the limit kicking in). However, after debugging a bit, now I don’t believe that to be the case(patched time seems to be ok). My markets are passed and processed in random chronological order, could this be causing trouble in the max transaction limit control? Also the first error occurs with a transaction_count of 6152, not 5001, as I would have expected. As I saw that some changes to this control were made with the latest version, I thought it might be an issue, but I absolutely cannot rule out that I am doing something wrong here. 

---

## 2021-03-01 10:03:45 - general channel

**liam**

per market / strategy [https://github.com/liampauling/flumine/blob/bbd145b7f18a63790fa844e9a0cdc9bab3991542/flumine/baseflumine.py#L215](https://github.com/liampauling/flumine/blob/bbd145b7f18a63790fa844e9a0cdc9bab3991542/flumine/baseflumine.py#L215)

---

## 2021-03-01 10:00:38 - general channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) in Flumine strategy, are the orders in `def process_orders(self, market, orders)` per strategy or per market? i.e. do we need to filter the orders to avoid picking up bets placed by other strategies?

---

## 2021-02-28 15:57:16 - strategies channel

**liam**

Much easier to find value but harder to get it, strategy / scale dependant obviously but pre play tends to be the opposite (in my opinion) 

---

## 2021-02-28 09:43:31 - general channel

**Dave**

[https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/resources/bettingresources.py#L358](https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/resources/bettingresources.py#L358)

---

## 2021-02-27 02:04:28 - issues channel

**birchy**

Did a `pip` Flumine upgrade earlier am now getting lots of errors in my backtest code:

```File "...snip.../tradingcontrols.py", line 22, in _validate

if order.EXCHANGE == ExchangeType.BETFAIR:

AttributeError: 'Market' object has no attribute 'EXCHANGE'```

Not sure if this is a bug or whether I need to make any further changes to my strategy code? Have added the `RunnerContext` check as discussed between [@U4H19D1D2](@U4H19D1D2) and [@UFTBRB3F1](@UFTBRB3F1) above. Note that I'm not using `market.replace_order()` ...these errors are from plain old `market.place_order(order)`

---

## 2021-02-26 19:28:48 - general channel

**James T**

I suppose it’s not really their business model. More of a sportsbook thing. 

---

## 2021-02-26 19:22:25 - issues channel

**birchy**

In a Flumine strategy, what are the (dis)advantages of `process_orders()` vs `market.blotter.live_orders` ? I presume the actual orders are updated at the same time and both of these contain the _same_ orders?

---

## 2021-02-26 18:22:49 - issues channel

**Newbie99**

I only use replace on one new strategy I'm testing...just so happened that was the one I used to test today, ha!

---

## 2021-02-26 17:15:05 - issues channel

**Newbie99**

```{"asctime": "2021-02-26 15:42:09,137", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.179756075", "selection_id": 28040651, "handicap": 0, "id": "138336469255121051", "customer_order_ref": "6012fe3b915f7-138336469255121051", "bet_id": "100000000018", "date_time_created": "2021-02-26 15:42:05.512104", "publish_time": "2021-02-26 15:42:05.763000", "trade": {"id": "2d6ee89a-7849-11eb-841c-2016d8944b85", "strategy": "simple_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138336469255121051"], "notes": "", "market_notes": "11,11.5,11.5", "status": "Pending", "status_log": "Pending, Live, Pending"}, "order_type": {"order_type": "Limit", "price": 10.5, "size": 1.57, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 1.57, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2021-02-26 15:42:05.716102", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Execution complete", "status_log": "Pending, Executable, Replacing, Execution complete", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 139.7, "matched": []}}

INFO:flumine.execution.baseexecution:Order Cancel: SUCCESS

{"asctime": "2021-02-26 15:42:09,138", "levelname": "INFO", "message": "Order Cancel: SUCCESS", "bet_id": "100000000018", "order_id": "138336469255121051", "status": "SUCCESS", "error_code": null}

INFO:flumine.execution.baseexecution:Order Replace: SUCCESS

{"asctime": "2021-02-26 15:42:09,139", "levelname": "INFO", "message": "Order Replace: SUCCESS", "bet_id": null, "order_id": "138336469291386029", "status": "SUCCESS", "error_code": null}

INFO:flumine.order.order:Order status update: Violation

{"asctime": "2021-02-26 15:42:09,140", "levelname": "INFO", "message": "Order status update: Violation", "market_id": "1.179756075", "selection_id": 28040651, "handicap": 0, "id": "138336469291386029", "customer_order_ref": "6012fe3b915f7-138336469291386029", "bet_id": "100000000057", "date_time_created": "2021-02-26 15:42:09.138602", "publish_time": null, "trade": {"id": "2d6ee89a-7849-11eb-841c-2016d8944b85", "strategy": "simple_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138336469255121051", "138336469291386029"], "notes": "", "market_notes": "11,11.5,11.5", "status": "Pending", "status_log": "Pending, Live, Pending"}, "order_type": {"order_type": "Limit", "price": 11.0, "size": 1.57, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 1.57, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2021-02-26 15:42:09.139609", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 254.41, "matched": []}}

WARNING:flumine.controls:Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failure

{"asctime": "2021-02-26 15:42:09,141", "levelname": "WARNING", "message": "Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failure", "control": "STRATEGY_EXPOSURE", "error": "strategy.validate_order failure", "order": {"market_id": "1.179756075", "selection_id": 28040651, "handicap": 0, "id": "138336469291386029", "customer_order_ref": "6012fe3b915f7-138336469291386029", "bet_id": "100000000057", "date_time_created": "2021-02-26 15:42:09.138602", "publish_time": null, "trade": {"id": "2d6ee89a-7849-11eb-841c-2016d8944b85", "strategy": "simple_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138336469255121051", "138336469291386029"], "notes": "", "market_notes": "11,11.5,11.5", "status": "Pending", "status_log": "Pending, Live, Pending"}, "order_type": {"order_type": "Limit", "price": 11.0, "size": 1.57, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 1.57, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2021-02-26 15:42:09.139609", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": "Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failure", "simulated": {"profit": 0.0, "piq": 254.41, "matched": []}}} ```

---

## 2021-02-26 10:32:03 - issues channel

**liam**

its because of the change in 1.17.0, you see the logs states `strategy.validate_order failure` this means this [https://github.com/liampauling/flumine/blob/806b5e1bd3f76886818da08dfa1d8db1a78e62fd/flumine/strategy/strategy.py#L179|function](https://github.com/liampauling/flumine/blob/806b5e1bd3f76886818da08dfa1d8db1a78e62fd/flumine/strategy/strategy.py#L179|function) is returning false which is likely because you already have a live trade. I am basically trying to force the user to check the `RunnerContext` first, see [https://github.com/liampauling/flumine/blob/806b5e1bd3f76886818da08dfa1d8db1a78e62fd/examples/strategies/lowestlayer.py#L37|here](https://github.com/liampauling/flumine/blob/806b5e1bd3f76886818da08dfa1d8db1a78e62fd/examples/strategies/lowestlayer.py#L37|here) for example

---

## 2021-02-26 10:29:39 - issues channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2) in flumine 1.17.2 I saw there's a mention of a bug fix around potential exposure, I'm seeing a lot of these:



```INFO:flumine.order.order:Order status update: Violation

{"asctime": "2021-02-26 10:17:21,505", "levelname": "INFO", "message": "Order status update: Violation", "market_id": "1.179742967", "selection_id": 28253114, "handicap": 0, "id": "138336274415049218", "customer_order_ref": "6012fe3b915f7-138336274415049218", "bet_id": null, "date_time_created": "2021-02-26 10:17:21.504921", "publish_time": null, "trade": {"id": "d00f5a01-781b-11eb-8ae9-2016d8944b85", "strategy": "simple_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138336274415049218"], "notes": "", "market_notes": null, "status": "Live", "status_log": ""}, "order_type": {"order_type": "Limit", "price": 16.0, "size": 1.0, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 1.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": null, "elapsed_seconds_executable": null}, "runner_status": null, "status": "Violation", "status_log": "Violation", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}}

WARNING:flumine.controls:Order has violated: STRATEGY_EXPOSURE Error: strategy.validate_order failure```

When by my calcs I shouldn't be anywhere near a violation. I'm placing orders using market.place(order) as opposed to strategy.place and this is paper trading if it makes a difference.



Is it possible a bug remains, or perhaps more likely is there another change I need to make (I read through the change logs but I appear to have missed something)?

---

## 2021-02-25 17:03:06 - general channel

**William Martin**

I am looking to get the live data of outright markets for different football competitions, premier league, champions league, Euros etc.



Its not for a trading bot but for a prototype of a new interface I designed for a gambling product

---

## 2021-02-25 10:43:35 - strategies channel

**liam**

[@UUCD6P13J](@UUCD6P13J) bringing your question back up have you looked at testing market capacity / roi / profit by pure back testing? I have done a few tests where I bump stakes up to silly sizes to see how the profit varies and it can make some interesting graphs that do match up with live betting more than you would think 

---

## 2021-02-24 15:06:44 - strategies channel

**river_shah**

It is not a one to one mapping to the trading domain but ml techniques such as support vector regression have a built in concept of “margin” to separate points better and give better out of sample performance. maintaining margin for trading strats to me is similar to how SVR creates bands around training examples to help classify points better. too low of a margin and SVR has high variance. Something similar happens to trading strats

---

## 2021-02-24 14:56:13 - strategies channel

**river_shah**

Driving up margin (to a limit) usually reduces adverse selection. All trading strategies, even well selected ones tend to exhibit out of sample overfit. If margin is high enough that usually means strategy ends up avoiding lots of trades which do nothing but cause noise PL and lastly alert the market to your impending trading direction.

---

## 2021-02-24 14:09:57 - strategies channel

**Lee**

I think that's also why i've been looking at ROI. Pushing more volume from the market is easier said than done, so went for improving my matching / removing bad bets and then try again when i have more margin to play with. It felt like a logical approach sacrificing a small amount of profit hopefully in the short term for the long term gains but at the same time choosing a less profitable strategy didn't seem logical.

---

## 2021-02-24 13:28:19 - general channel

**river_shah**

instance_id is just my internal model reference id so I can do live A/ B tests. this remains persistent through time

---

## 2021-02-24 13:25:46 - strategies channel

**Michael**

I think this is one of the knottiest problems of betting.

---

## 2021-02-24 11:28:32 - general channel

**liam**

FYI flumine [https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1171-2021-02-24|1.17.1](https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1171-2021-02-24|1.17.1) released with transaction control fix and `blotter.strategy_selection_orders` function added

```{

    "asctime": "2021-02-24 11:00:54,794",

    "levelname": "INFO",

    "message": "Execution new hour",

    "filename": "clientcontrols.py",

    "funcName": "_check_hour",

    "module": "clientcontrols",

    "process": 6,

    "threadName": "MainThread",

    "current_transaction_count_total": 387,

    "current_transaction_count": 357,

    "current_failed_transaction_count": 30,

    "total_transaction_count": 831,

    "total_failed_transaction_count": 61,

    "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7fd48db7adc0&gt;"

}```

---

## 2021-02-23 20:40:55 - strategies channel

**Mo**

I prefer strategy 3, you find a way to squeeze some extra volume through



3. size settled £1.5k and makes roi 4% (£60 profit)

---

## 2021-02-23 20:33:25 - strategies channel

**Lee**

What about when comparing two strategies (dummy numbers), if i had the first strategy and tried optimising the signal to remove some poor bets and ended up with strategy 2, would you see that as a good/bad change?

1: size settled £1k and makes roi 5% (£50 profit)

2: size settled £500 and makes roi 8% (£40 profit)

---

## 2021-02-23 11:36:09 - general channel

**liam**

the former is per order and latter per strategy, but you can create your own control to do the latter if you require

---

## 2021-02-23 11:25:36 - general channel

**mandelbot**

are `max_order_exposure` and `max_selection_exposure` judged per strategy or across all strategies?

---

## 2021-02-22 17:55:03 - general channel

**river_shah**

[@U4H19D1D2](@U4H19D1D2) having just freshly paid £200 in txn charges, would it be possible to expose `transaction_count`  to the framework / strategy. need to back off doing stupid actions on edge cases that were not seen and/or are hard to replicate in backtests

---

## 2021-02-22 16:43:48 - general channel

**Mo**

[https://www.betfair.com/aboutUs/Betfair.Charges/#TranCharges2](https://www.betfair.com/aboutUs/Betfair.Charges/#TranCharges2)



&gt; *What is a failed transaction?*

&gt; An action that leads to an API error, resulting in a failed bet placement, failed cancellation or other failed transaction. Full descriptions of each failed transaction type can be found in the link below:

&gt; [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-ExecutionReportErrorCode](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-ExecutionReportErrorCode)

---

## 2021-02-22 14:49:07 - general channel

**liam**

Just released flumine [https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1170-2021-02-22|v1.17.0](https://github.com/liampauling/flumine/blob/master/HISTORY.rst#1170-2021-02-22|v1.17.0), contains some potential breaking changes (controls now per order and `strategy.*_order` to be depreciated in 1.18.0) so recommend reading the changelog and testing before upgrading however this upgrade has a lot of improvements including user configurable order placement:



```market.place_order(order)  # as per strategy.place_order



with market.transaction() as t:

    market.place_order(order)  # executed immediately in separate transaction

    t.place_order(order)  # executed on transaction __exit__



with market.transaction() as t:

    t.place_order(order)

    ..

    t.execute()  # above order executed

    ..

    t.cancel_order(order)

    t.place_order(order)  # both executed on transaction __exit__```

---

## 2021-02-21 14:21:31 - general channel

**river_shah**

what is the graceful way to tell the framework to shutdown please? I have a handle to the framework in the strategy. Calling this causes errors

```self.framework._process_end_flumine()

self.framework.__exit__()

CRITICAL Unknown error API logout FAIL: INPUT_VALIDATION_ERROR```



---

## 2021-02-20 19:27:28 - issues channel

**Aaron Smith**

i m confused here, `High latency between current time and MarketBook publish time`  is thrown before the strategy actually processes the market_book, so it does not take processing time into account?

---

## 2021-02-20 19:18:59 - issues channel

**Angelos**

how frequent is that event fired?

~guessing i’ll have to implement `_process_custom_event` in my strategy to grab the scores for this right?~

---

## 2021-02-20 19:15:24 - issues channel

**liam**

High latency means you are spending too much time in the strategy, are you doing something slow?

---

## 2021-02-20 12:05:53 - random channel

**Misha**

Not sure how a general strategy would work

---

## 2021-02-20 09:48:52 - general channel

**Dave**

Ensembles are a very popular modelling technique yes.

---

## 2021-02-19 19:55:01 - general channel

**Oliver Varney**

[https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/endpoints/betting.py#L10](https://github.com/liampauling/betfair/blob/f370d111d2e7adf1ca4221fc8cc4b028e4b2b2f8/betfairlightweight/endpoints/betting.py#L10)

---

## 2021-02-19 19:54:26 - general channel

**Oliver Varney**

then have a look at the betting endpoint in the betfairlightweight repo

---

## 2021-02-19 19:25:26 - general channel

**Oliver Varney**

[@U01N8P7UFPB](@U01N8P7UFPB) flumine is a great place to start I think (thanks to [@U4H19D1D2](@U4H19D1D2) ). it provides both live trading and backtesting functionality and creating strategies is easy. Id play around with it look at the code and ask questions in here. As far as I know theres a mix of sports in here but mostly horses, tennis and football (soccer)

---

## 2021-02-19 19:20:55 - strategies channel

**birchy**

Spawned by [@U4H19D1D2](@U4H19D1D2)'s link to the BA greyhound thread earlier, I was wondering how many of us play the dogs? I had a very successful dogs model many years ago and have revisited it in recent weeks, particularly as the traded volumes are now much higher than they were back then (i.e. £5k per race was average). Fired up a new bot a few days ago and have a few hundred quid more than I did on Tuesday, so looking forward to expanding on this in the future.

---

## 2021-02-19 19:19:40 - general channel

**Unknown**

I don't think using a worse model as a tie breaker is a good idea :scream:

---

## 2021-02-19 19:10:09 - general channel

**William Martin**

thanks! very new to automated stuff, used trade football markets in college a good few years ago, with a lot of success but got to time consuming with no automation and when I finished college I didnt have the free time I did before!



I'm looking to build a prototype of an app idea I have so not 100% sure if I am in the right place but eager to learn what people are doing with the betfair API and the bot trading aspect is really interesting

---

## 2021-02-19 16:32:03 - general channel

**liam**

not sure I agree on this, you have a 'super-good' model which ideally tells you where the value is, why when it doesn't detect value would you find a random forecast and use it? Seems very random to me

---

## 2021-02-19 15:32:21 - general channel

**Oliver Varney**

pre off stuff I had in mind. It will be the highest weighted coefficient in the model most likely, and at the start of betting I think its a fairly safe assumption to say that there will be volume available at initial stake sizes, especially closer to the off

---

## 2021-02-19 14:39:00 - random channel

**MacrcoPolo**

in fairness long shots don't win often regardless of your model

---

## 2021-02-19 14:36:52 - random channel

**river_shah**

I feel gambling on horses is making me a superstitious person. anytime model backs big on long shots and I watch the race, they never win. A watched pot never boils. Now I just let the model bet and sit with eyes shut tight.

---

## 2021-02-19 08:45:34 - general channel

**Aaron Smith**

[@U01NJ85MP7F](@U01NJ85MP7F) basic / advanced historical data is pretty much useless and pro data is costly. I d rather subscribe to a market and put the money in bets instead of buying the pro-data with it. Having a strategy running will probs give you a better feel for the market and even if your "strategy" sucks, as long as your placing bets on a runner with low price spread, you wont lose a lot. Even if you place low stake bets at random, you ll win some and lose some and it would take some time until you actually reach what you would ve paid for the pro data set

---

## 2021-02-19 08:23:05 - general channel

**Oliver Varney**

I think unsubbing will not be worth it if you run multiple strategies on one instance, for example one strategy might only need the first 65 mins the second strategy the last 25-30 mins. You start to cap yourself unnecessarily, making things messy down the line when you add more and more strategies.

---

## 2021-02-19 08:20:42 - general channel

**Oliver Varney**

[@U019Z6V6DHS](@U019Z6V6DHS) can you not just have logic within check_market_book function to return False if your strategy doesnt want to process the market_book

---

## 2021-02-19 08:18:16 - general channel

**Angelos**

hey, i’ve started using flumine a few days ago. is it possible to unsubscribe from an event_id within my strategy? for example, if the match gets passed the 65' mark i would like to stop the stream for that particular event

---

## 2021-02-18 08:54:39 - general channel

**liam**

yeah use conflate and you can set the `streaming_timeout` to 60 so that you can an update every 60s [https://liampauling.github.io/flumine/advanced/#parameters|regardless](https://liampauling.github.io/flumine/advanced/#parameters|regardless)



```strategy = ExampleStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB"],

        market_types=["WIN"],

    ),

    conflate=5000,  # 5s

    streaming_timeout=60,  # 60s (should probably change this to match conflate)

) ```

---

## 2021-02-18 08:22:07 - general channel

**Angelos**

hi there, i really like the strategy builder in [https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py|flumine](https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py|flumine) and i’m giving a go now!



i’m wondering if there’s a way to configure it to *not use* the streaming API and run the framework on a fixed interval instead?



alternatively, is there a way to configure the stream to trigger the fetch every minute?

---

## 2021-02-18 07:09:20 - general channel

**KG**

thanks [@UBS7QANF3](@UBS7QANF3) - I amended with the patch, still getting the same error though - any chance you can cast your eyes over my code and see if you can catch my mistake? I'm not a python native, but trying to get the library to work:



```import logging



from unittest.mock import patch

import smart_open



import betfairlightweight

from betfairlightweight import StreamListener



# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



# create trading instance (don't need username/password)

trading = betfairlightweight.APIClient("username", "password")



# create listener

listener = StreamListener(max_latency=None)



# create historical stream (update file_path to your file location)

stream = trading.streaming.create_historical_generator_stream(

    file_path="../_data/2021_01_JanRacingPro.tar",

    listener=listener,

)



with patch("builtins.open", smart_open.open):   

    gen = stream.get_generator()



    for market_books in gen():

        for market_book in market_books:

            print(market_book)```

---

## 2021-02-16 18:44:57 - random channel

**liam**

Kelly is for optimising your bankroll whereas you will hit market capacity issues (is this inplay?) As you know it won’t take much for your pnl to fall very fast in which case you won’t optimise your profit but just oscillate between profit and loss as it tries to stabilise but this should be simple to model 

---

## 2021-02-16 18:42:18 - random channel

**birchy**

[@UQL0QDEKA](@UQL0QDEKA) have you not heard of Martingale? :rolling_on_the_floor_laughing:

Seriously though, fractional Kelly is the way forward. Rather than using the _actual_ bank for calculating, I would use a fixed bank size and update daily/weekly/every 1000 bets/whatever.

---

## 2021-02-16 17:07:24 - random channel

**Aaron Smith**

so the percentage (here 1%) is of what ever you made with the strategy so far?

---

## 2021-02-16 16:46:02 - random channel

**PeterLe**

Sorry I was about to add...(I know we have kelly or partial kelly, but wouldnt the above work in the same manner?)

---

## 2021-02-15 21:20:08 - issues channel

**Jonjonjon**

I recorded some data, and there is a bsp of "Infinity"



`{"op": "mcm", "clk": null, "pt": 1612419337919, "mc": [{"id": "1.178772818", "marketDefinition": {"bspMarket": true, "turnInPlayEnabled": true, "persistenceEnabled": true, "marketBaseRate": 6, "eventId": "30265109", "eventTypeId": "7", "numberOfWinners": 1, "bettingType": "ODDS", "marketType": "WIN", "marketTime": "2021-02-04T06:04:00.000Z", "suspendTime": "2021-02-04T06:04:00.000Z", "bspReconciled": true, "complete": true, "inPlay": true, "crossMatching": false, "runnersVoidable": false, "numberOfActiveRunners": 0, "betDelay": 1, "status": "CLOSED", "settledTime": "2021-02-04T06:15:13.000Z", "runners": [{"adjustmentFactor": 0.922, "status": "REMOVED", "sortPriority": 1, "removalDate": "2021-02-03T21:42:31.000Z", "id": 38389550}, {"adjustmentFactor": 2.491, "status": "REMOVED", "sortPriority": 2, "removalDate": "2021-02-03T21:42:41.000Z", "id": 38389553}, {"adjustmentFactor": 18.868, "status": "LOSER", "sortPriority": 3, "bsp": 8.351698159, "id": 28143714}, {"adjustmentFactor": 0.709, "status": "LOSER", "sortPriority": 4, "bsp": 969.8251431363869, "id": 15424296}, {"adjustmentFactor": 16.667, "status": "LOSER", "sortPriority": 5, "bsp": 8.63260113914148, "id": 28485888}, {"adjustmentFactor": 39.11, "status": "WINNER", "sortPriority": 6, "bsp": 1.910361925779252, "id": 38389544}, {"adjustmentFactor": 4.255, "status": "LOSER", "sortPriority": 7, "bsp": 29.698602524282755, "id": 369626}, {"adjustmentFactor": 6.41, "status": "LOSER", "sortPriority": 8, "bsp": 13, "id": 2648545}, {"adjustmentFactor": 7.143, "status": "LOSER", "sortPriority": 9, "bsp": 19.893867845765776, "id": 38389545}, {"adjustmentFactor": 1.408, "status": "LOSER", "sortPriority": 10, "bsp": 107.95724409554154, "id": 38389546}, {"adjustmentFactor": 2.439, "status": "LOSER", "sortPriority": 11, "bsp": 49.13699878256768, "id": 1254801}, {"adjustmentFactor": 1.667, "status": "LOSER", "sortPriority": 12, "bsp": 158.11592936579493, "id": 38389551}, {"adjustmentFactor": 0.909, "status": "LOSER", "sortPriority": 13, "bsp": 209.13771912477907, "id": 38389552}, {"adjustmentFactor": 0.414, "status": "LOSER", "sortPriority": 14, "bsp": "_*Infinity*_", "id": 38389555}], "regulators": ["MR_INT"], "venue": "Doomben", "countryCode": "AU", "discountAllowed": true, "timezone": "Australia/Queensland", "openDate": "2021-02-04T03:34:00.000Z", "version": 3608935591, "raceType": "Flat", "priceLadderDefinition": {"type": "CLASSIC"}}, "_stream_id": 2009}]}`



It causes an issue here:



[https://github.com/liampauling/flumine/blob/0b0bb9d8b7a2ca94c05996284692bccaede679c1/flumine/backtest/simulated.py#L230](https://github.com/liampauling/flumine/blob/0b0bb9d8b7a2ca94c05996284692bccaede679c1/flumine/backtest/simulated.py#L230)



I think it might happen when there isn't enough size to match an SP.

---

## 2021-02-15 21:08:52 - issues channel

**jhaa**

I have this unseen error in my logs from calling:





```current_orders = self.trading.betting.list_current_orders(market_ids=[stream_market.get_market_id()],

                                                          from_record=from_record)```



---

## 2021-02-15 21:08:12 - issues channel

**jhaa**

Traceback (most recent call last):

  File "/home/code/venv/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 113, in process_response

    return resource(elapsed_time=elapsed_time, **result)

  File "/home/code/venv/lib/python3.6/site-packages/betfairlightweight/resources/bettingresources.py", line 695, in __init__

    self.orders = [CurrentOrder(**i) for i in kwargs.get("currentOrders")]

  File "/home/code/venv/lib/python3.6/site-packages/betfairlightweight/resources/bettingresources.py", line 695, in &lt;listcomp&gt;

    self.orders = [CurrentOrder(**i) for i in kwargs.get("currentOrders")]

TypeError: __init__() missing 1 required positional argument: 'regulatorCode'

---

## 2021-02-15 19:29:37 - issues channel

**tobsve**

well, I can try. The auth etc are no problem. But when using

```trading.betting.list_events(

    filter=filters.market_filter(text_query="Chelsea v Newcastle")

)```

i get  30267429 Chelsea v Newcastle

So now I have a event_list_id



And here... I just get blown away. I totally don't understand

---

## 2021-02-15 11:50:44 - strategies channel

**RicHep**

Well overall it beats the SP, it also seems unlikely (although not impossible) that a strategy would  churn out 1100 points to single point stakes in 2.5 months and not have some long term profitability, so I shall run it for now and see what happens

---

## 2021-02-15 03:30:39 - general channel

**Misha**

Everyone does their own "strategy"

---

## 2021-02-14 12:32:01 - strategies channel

**MacrcoPolo**

To be honest, I'd still run this strategy on small stakes - it won't cost much and you'll collect more data. Worst case you lose a few quid, best case you're able to validate it.

---

## 2021-02-13 23:20:55 - strategies channel

**Misha**

My view is if you can average around 5% for around 2 months then you "might" be there (depending on what your model is relying on)

---

## 2021-02-13 20:32:30 - strategies channel

**user34**

Is there something inherently wrong with relying on long shots? I can see that it makes it very hard to evaluate your profits as the variability will be very large, but is there something else to be aware of? My models tend to predict a lot of value at long odds.

---

## 2021-02-13 20:18:37 - strategies channel

**Jonjonjon**

This might be a bit of a vague question, but does your model have many parameters, and have you optimised on them?

---

## 2021-02-11 14:00:08 - general channel

**Jonjonjon**

I guess that's my next pre-event strategy sorted.

---

## 2021-02-11 12:03:02 - strategies channel

**Michael**

[@U0128E7BEHW](@U0128E7BEHW) yeah assumes some small fixed stake. In my case that's about £5 for that type of betting.

---

## 2021-02-11 11:29:31 - strategies channel

**Misha**

So modelling by day from August 24 to February 7:

---

## 2021-02-11 11:28:19 - strategies channel

**Misha**

My model and actuals align pretty closely. I have detailed data going back to August 24, so now closing in on 6 months. So two basic tests (it's a probability model based on stats): Brier score v market, and profitability per market for my betting "patterns"

---

## 2021-02-11 10:54:46 - strategies channel

**Michael**

Or maybe your previous client isn't the only or best model for everyone else and the answer to every question.

---

## 2021-02-11 10:49:07 - strategies channel

**Misha**

I have never seen a model that doesn't go up and down

---

## 2021-02-11 10:44:24 - strategies channel

**Michael**

It's certainly true that your money impacts the market but it's worth adding that it's wrong to assume that the best players get the most money on. There are some good players who match a lot but in general getting tonnes of money on is more a characteristic of lower margin players who do it because they have to. There is an inevitable and unavoidable trade off between margin and turnover. Give me more margin and less turnover any day. Also - let's assume that your £60 guy is a winner; he doesn't have to be the worlds biggest winner to make a lot of money. Maybe he's figured out that he can get really good margin on small amounts of money early in the day (which makes perfect logical sense) - good for him, he'll make a killing and no one will even notice. That's smart. This idea that very successful individual players provide the only or best model is total nonsense. Most people, (including most people on this forum) make losses, a few make a little and a tiny number make a lot. None of them need to concern themselves with what the world's top players do, just how they can make a little bit more than last month. This guy could be making a choice that more value for less stake early in the day is worth it to him despite his market impact. That would put him well ahead of the pack. If he's matching a few hundred quid with good margin on every race that's easily £20 per market which is over £250k a year. That would be adequate for most people's needs and would far exceed most players here. How many of the 800+ players here made &gt; £250k last year? How many posting on this topic?

---

## 2021-02-11 10:42:36 - strategies channel

**D C**

[@U01B8031PM1](@U01B8031PM1) That is kind of what I am getting at. If I can lump on a few hundred quid on a donkey to get a price contraction, that could raise the price of the runner I REALLY want to back later for tens of thousands. That contraction has to result in drift on a subset of the other runners (possibly all of them) so if it were that easy, would not everyone be doing it? I talk here of people who obviously have good models and decent probability estimates for horses and that is going to be a very small proportion of the population of people betting on that market (in terms of numbers of participants, not betting volume necessarily).

---

## 2021-02-11 09:51:22 - strategies channel

**D C**

£60 every 15 minutes for 12 hours adds up to quite a lump if their method is junk. Assuming its all the same person and they they don't consolidate their position of course. I've always thought that if you had a good model price, then getting in early if the price is value was a good thing - but a lot of you here tell me that is not what the "big" boys do as it will drag the price down because of their action. I guess it depends on the amounts you want to get matched for at the end of the day.

---

## 2021-02-10 20:34:17 - strategies channel

**Misha**

The simple thing is that large bettors have been after this info for years. But it's either not available or not accurate. So you can't really have a strategy that relies on this information

---

## 2021-02-08 12:37:14 - strategies channel

**Jorge**

Yes, my Strategy's EV is positive. But my concern is that it is too small compared to the Variance. So I want to estimate the Variance and try to reduce it without damaging the EV

---

## 2021-02-08 11:51:47 - strategies channel

**Jorge**

Yes, I want to know how many observed values (markets) do I need to feel confident about the Strategy's Variance

---

## 2021-02-08 11:36:23 - strategies channel

**Jorge**

For the math guys in here... I need to calculate the Variance of my strategy's P&amp;L. I assume the P&amp;L per market are independent random variables so I can sum their Variances up. What statistical test can I use to determine what is a good sample size to estimate the strategy's Variance?

---

## 2021-02-08 01:39:35 - strategies channel

**mandelbot**

If your strategy has money waiting it wont get taken by such moves when in fact it should

---

## 2021-02-07 16:33:05 - strategies channel

**liam**

Can be tricky to model without the fave, which odds are you using when calculating your results?

---

## 2021-02-06 16:46:20 - strategies channel

**RicHep**

Oh ok, years ago I found the early moves to be the best, but more recently it seems to have changed, for my strategy anyway

---

## 2021-02-06 10:11:23 - general channel

**PeterLe**

Just out of interest [@UBS7QANF3](@UBS7QANF3) have you/do you play tennis, and do you have detailed knowledge of the game in the manner [@U016535QCJ2](@U016535QCJ2) describes above? Or do you solely employ a modelling and stats based approach? For my own part; whilst I have traded (gambled :grinning:) hundreds of thousands of horse racing markets, whilst I have an appreciation for the sport in general, I still know very little about it overall.

---

## 2021-02-06 09:56:15 - general channel

**Mo**

I agree with [@U016535QCJ2](@U016535QCJ2) both that the IID assumption is flat out wrong and that most academic papers and the particular one he’s referring to use laughably small sample sizes. However, all models are approximations of reality and I’ve never used a tennis one without the IID assumption. Hasn’t stopped my strategies from being wildly successful by anyone’s measure. Of course you don’t NEED to use academic papers to develop strategies but it’s hard to see how it can be in any way negative to read them provided you do so critically 

---

## 2021-02-06 09:19:42 - general channel

**Misha**

Notwithstanding [@UBS7QANF3](@UBS7QANF3)'s excellent reading list, I have found that doing tennis we have used nothing from the literature out there (and we have read widely). One of our models uses linear regression, so using a general modelling technique, but other than that we have completely ignored any of the tennis ideas out there and decided to just tackle the problem solely by using our knowledge of tennis (my partner has played tennis at a high level for many decades). I realise that this certainly isn't an approach for everyone, but I wouldn't get too worried about needing to read too widely. Nothing beats getting some data and betting with low amounts to get a feel for things

---

## 2021-02-06 08:09:39 - general channel

**Unknown**

• US centric but an excellent introduction to understanding betting markets and how to think about value: [https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller-ebook/dp/B07RG6H8C2](https://www.amazon.co.uk/Logic-Sports-Betting-Ed-Miller-ebook/dp/B07RG6H8C2)

• Seminal paper for modelling football (soccer): [https://betfairlightweight.slack.com/files/UBS7QANF3/F010NTJJK88/dixoncoles.pdf?origin_team=T4G9NBD2M&amp;origin_channel=C4HL6EZTQ](https://betfairlightweight.slack.com/files/UBS7QANF3/F010NTJJK88/dixoncoles.pdf?origin_team=T4G9NBD2M&amp;origin_channel=C4HL6EZTQ)

• A follow up on in-running football: [https://betfairlightweight.slack.com/files/UBS7QANF3/F010A4MK9MY/dixon1998.pdf?origin_team=T4G9NBD2M&amp;origin_channel=C4HL6EZTQ](https://betfairlightweight.slack.com/files/UBS7QANF3/F010A4MK9MY/dixon1998.pdf?origin_team=T4G9NBD2M&amp;origin_channel=C4HL6EZTQ)

• A classic horse racing paper: [https://www.gwern.net/docs/statistics/decision/1994-benter.pdf](https://www.gwern.net/docs/statistics/decision/1994-benter.pdf)

• An excellent starting point for tennis modelling: [http://www.strategicgames.com.au/PhD.pdf](http://www.strategicgames.com.au/PhD.pdf)

• Outstanding book on cognitive biases: [https://www.amazon.co.uk/Thinking-Fast-Slow-Daniel-Kahneman-ebook/dp/B005MJFA2W](https://www.amazon.co.uk/Thinking-Fast-Slow-Daniel-Kahneman-ebook/dp/B005MJFA2W)

• Excellent introduction to probabilistic forecasting in general: [https://www.amazon.co.uk/Signal-Noise-Art-Science-Prediction-ebook/dp/B0097JYVAU](https://www.amazon.co.uk/Signal-Noise-Art-Science-Prediction-ebook/dp/B0097JYVAU)

• Inspiration for how far you can go: [https://www.amazon.co.uk/Man-All-Markets-Beating-Street-ebook/dp/B07ZWJFYW5](https://www.amazon.co.uk/Man-All-Markets-Beating-Street-ebook/dp/B07ZWJFYW5)

If you can be more specific about what sport(s) I can recommend more papers

---

## 2021-02-06 05:15:05 - general channel

**Misha**

I can't speak for horse racing betting, and I'm only really talking about models based on stats (not market models), but absolutely nothing is better than understanding the sport

---

## 2021-02-05 17:13:28 - random channel

**Oliver Varney**

ive just wonder whether its distracting or whether there is value in it. It can highlight issues / questions like why hasnt the strategy bet, or even give new ideas, but also its easy to lose the whole day watching races.

---

## 2021-02-05 17:02:18 - issues channel

**river_shah**

[@U4H19D1D2](@U4H19D1D2) can bflw and flumine allow interactive login please for streaming? if I don’t pass a cert path and use `trading.login_interactive()` the framework throws exception.

---

## 2021-02-05 16:42:22 - random channel

**Oliver Varney**

kind of on topic, just out of curiosity, do people generally watch races or not? If so, is it just the odd one or two per day, or is there any rationale for doing so, i.e. strategy ideas / order checking

---

## 2021-02-05 16:29:07 - strategies channel

**AP**

I should really start using the logging control but for now I map the strategy name hash to a strategy ref when my lambda function that pulls in account statement and cleared orders 

---

## 2021-02-05 15:02:26 - random channel

**liam**

Pretty cool:



```The Eurex exchange experienced an increasing amount of "speculative triggered" packets during 2019 and 2020. These

packets are sent by Trading Participants based on receiving the first bytes of market data in anticipation of potential trading

opportunities.

During processing of further bytes of these market data packets the data of the requests can still be modified to non-trading

requests in case the incoming market data turns out not to show a trading opportunity. This is possible if the respective fields

of the requests have not yet been written to the underlying physical ethernet layer.

Various adjustments of the Excessive System Usage (ESU) Fees mitigated the problem only for a limited timeframe and the

amount of speculative requests became a load issue and an increasing amount of orders went into the orderbook.

The graph shows this development by means of the ratio of sent versus executed IOC orders for Eurex benchmark products```

---

## 2021-02-05 14:03:59 - strategies channel

**liam**

are you confusing customer_strategy_ref with customer_order_ref?

---

## 2021-02-05 14:00:53 - strategies channel

**Oliver Varney**

are you confusing customer_strategy_ref with customer_order_ref or am I being silly?

---

## 2021-02-05 13:53:24 - strategies channel

**Oliver Varney**

nope, should I? I only touch the order ref not the strategy ref

---

## 2021-02-04 23:50:14 - random channel

**V**

Interesting read for those into this kind of stuff: [https://www.eurex.com/resource/blob/48918/74e70365580415639ea4628ec25a6b72/data/presentation_insights-into-trading-system-dynamics_en.pdf|https://www.eurex.com/resource/blob/48918/74e70365580415639ea4628ec25a6b72/data/presentation_insights-into-trading-system-dynamics_en.pdf](https://www.eurex.com/resource/blob/48918/74e70365580415639ea4628ec25a6b72/data/presentation_insights-into-trading-system-dynamics_en.pdf|https://www.eurex.com/resource/blob/48918/74e70365580415639ea4628ec25a6b72/data/presentation_insights-into-trading-system-dynamics_en.pdf)

---

## 2021-02-04 13:46:17 - general channel

**Mo**

```def market_book_to_data_frame(market_book: Union[MarketBook, dict]) -&gt; pd.DataFrame:

    if type(market_book) is MarketBook:

        market_book = market_book._data



    return pd.DataFrame(

        {

            'market_id': market_book['marketId'],

            'inplay': market_book['inplay'],

            'selection_id': runner['selectionId'],

            'side': side,

            'depth': depth,

            'price': price_size['price'],

            'size': price_size['size'],

            **({'publish_time': market_book['publishTime']} if 'publishTime' in market_book else {})

        }

        for runner in market_book['runners']

        for side in ['Back', 'Lay']

        for depth, price_size in enumerate(runner.get('ex', {}).get(f'availableTo{side}', []))

    )





def file_to_data_frame(path_to_betfair_price_file: str) -&gt; pd.DataFrame:

    trading = betfairlightweight.APIClient(username='', password='', app_key='')

    stream = trading.streaming.create_historical_generator_stream(

        directory=path_to_betfair_price_file,

        listener=StreamListener(max_latency=None, lightweight=True)

    )



    with patch("builtins.open", smart_open.open):

        g = stream.get_generator()

        return pd.concat(market_book_to_data_frame(mbs[0]) for mbs in g())```

---

## 2021-02-04 13:29:41 - issues channel

**mandelbot**

`{"asctime": "2021-02-04 13:26:56,741", "levelname": "ERROR", "message": "poll_market_catalogue error", "exc_info": "Traceback (most recent call last):\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/flumine/worker.py\", line 132, in poll_market_catalogue\n    \"MARKET_DESCRIPTION\",\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/betting.py\", line 233, in list_market_catalogue\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listMarketCatalogue \nParams: {'maxResults': 25, 'marketProjection': ['COMPETITION', 'EVENT', 'EVENT_TYPE', 'RUNNER_DESCRIPTION', 'RUNNER_METADATA', 'MARKET_START_TIME', 'MARKET_DESCRIPTION'], 'filter': {'marketIds': ['1.178881473', '1.178881478', '1.178881488', '1.178881493', '1.178777677', '1.178777679', '1.178777426', '1.178833494', '1.178847880', '1.178847882', '1.178777194', '1.178883033', '1.178883028', '1.178883003', '1.178883008', '1.178883023', '1.178883018', '1.178883013', '1.178848742', '1.178848744', '1.178848702', '1.178848700', '1.178777963', '1.178777027']}} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang18a-prd-01140948-002d67ab25', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang18a-prd-01140948-002d67ab25', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}", "trading_function": "list_market_catalogue", "response": "SportsAPING/v1.0/listMarketCatalogue \nParams: {'maxResults': 25, 'marketProjection': ['COMPETITION', 'EVENT', 'EVENT_TYPE', 'RUNNER_DESCRIPTION', 'RUNNER_METADATA', 'MARKET_START_TIME', 'MARKET_DESCRIPTION'], 'filter': {'marketIds': ['1.178881473', '1.178881478', '1.178881488', '1.178881493', '1.178777677', '1.178777679', '1.178777426', '1.178833494', '1.178847880', '1.178847882', '1.178777194', '1.178883033', '1.178883028', '1.178883003', '1.178883008', '1.178883023', '1.178883018', '1.178883013', '1.178848742', '1.178848744', '1.178848702', '1.178848700', '1.178777963', '1.178777027']}} \nException: None \nError: {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang18a-prd-01140948-002d67ab25', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie2-ang18a-prd-01140948-002d67ab25', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}"}`

---

## 2021-02-04 12:52:40 - issues channel

**mandelbot**

```trading.login()



client = clients.BetfairClient(trading)



framework = Flumine(client=client)



strategy = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["4339"],

        country_codes=["AU"],

        market_types=["WIN"]

        # market_ids=["1.169056942"],

        # event_ids=[29671376]

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/home/ubuntu/Documents/Historical/GH/AU/",

        "bucket": "fluminetest",

        "force_update": False,

        "remove_file": False,

    },

)



strategy2 = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["4339"],

        country_codes=["GB"],

        market_types=["WIN"]

        # market_ids=["1.169056942"],

        # event_ids=[29671376]

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/home/ubuntu/Documents/Historical/GH/GB/",

        "bucket": "fluminetest",

        "force_update": False,

        "remove_file": False,

    },

)



strategy3 = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["AU", "US", "SE", "FR"],

        market_types=["WIN"]

        # market_ids=["1.169056942"],

        # event_ids=[29671376]

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/home/ubuntu/Documents/Historical/HR/AUUS/",

        "bucket": "fluminetest",

        "force_update": False,

        "remove_file": False,

    },

)



strategy4 = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB","IE"],

        market_types=["WIN"]

        # market_ids=["1.169056942"],

        # event_ids=[29671376]

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/home/ubuntu/Documents/Historical/HR/GBIE/",

        "bucket": "fluminetest",

        "force_update": False,

        "remove_file": False,

    },

)

framework.add_strategy(strategy)

framework.add_strategy(strategy2)

framework.add_strategy(strategy3)

framework.add_strategy(strategy4)



framework.run()```



---

## 2021-02-04 00:46:58 - random channel

**Misha**

Last thing from my point of view: it seems my model is most profitable when the market prices are WAY out from what would be expected. For big price swings the market gets it wrong more often than right (and that surprised me). But to be profitable you need to hold your nerve, because it makes for some truly awful losses

---

## 2021-02-04 00:39:35 - random channel

**Misha**

My modelling suggests (and actual betting suggests) that they just aren't a big proportion of losses (and sometimes we win from then as well)

---

## 2021-02-03 20:40:15 - issues channel

**Peter C**

I'm trying to access live data for the first time - using the quickstart example from the docs. I import the example strategy, and start(self) runs, but then check_market_book doesn't appear to be called, but the program continues to run with no error. Has anyone experienced this before?

---

## 2021-02-03 17:47:02 - issues channel

**Newbie99**

for reference, this is the message from a cancel I requested (as opposed to BPE):



```INFO:flumine.order.order:Order status update: Execution complete

{"asctime": "2021-02-03 17:44:49,317", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.178739219", "selection_id": 20867982, "handicap": 0, "id": "138316670786111761", "customer_order_ref": "81ec14d3e0056-138316670786111761", "bet_id": "223440411072", "trade": {"id": "7cb88910-6647-11eb-a5d2-2016d8944b85", "strategy": "betting_market_back", "status": "TradeStatus.LIVE", "orders": ["138316670786111761"], "notes": "", "market_notes": "13.5,15,15.5"}, "order_type": {"order_type": "Limit", "price": 15.0, "size": 1.08, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 1.08, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Execution complete", "status_log": "Pending, Executable, Cancelling, Executable, Execution complete"}

INFO:flumine.order.trade:Trade status update: Complete```

---

## 2021-02-03 16:44:57 - issues channel

**Newbie99**

```INFO:flumine.order.order:Order status update: Execution complete

{"asctime": "2021-02-03 15:52:25,074", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.178737548", "selection_id": 12059876, "handicap": 0, "id": "138316603346915167", "customer_order_ref": "81ec14d3e0056-138316603346915167", "bet_id": "223429282318", "trade": {"id": "c9080f5e-6637-11eb-b51f-2016d8944b85", "strategy": "betting_market_back", "status": "TradeStatus.PENDING", "orders": ["138316603346915167"], "notes": "", "market_notes": "16.5,55,16.5"}, "order_type": {"order_type": "Limit", "price": 55.0, "size": 0.28, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.28, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Execution complete", "status_log": "Pending, Executable, Cancelling, Execution complete"}```

I might be mis-reading this, but given this was the last message from a cancellation, should the size_remaining &amp; size_cancelled not be the other way around (i.e. size_cancelled 0.28, size_remaining 0.0)?

---

## 2021-02-03 15:54:12 - strategies channel

**thambie1**

Since were on the subject, I'm likely going to hire someone someone soon to help me in my trading activities. Anyone have suggestions on the best country for doing this, and best way to minimize taxes? (Currently living in the UK, but would consider moving)

---

## 2021-02-03 14:17:12 - random channel

**MacrcoPolo**

Welcome to horse race modelling (missing data...). Do I recall you work at seemlessML?

---

## 2021-02-03 12:29:45 - strategies channel

**jp**

Good point, that is maybe something I can use here, a strategy that worked a few years ago has no guarantee to work in the future...

---

## 2021-02-03 12:27:49 - strategies channel

**Mo**

I think that's an important distinction and it should be much easier to say whether this shows you have a systematic edge than try to use 7 year old back test data to justify rolling your strategy out into production

---

## 2021-02-03 12:27:36 - strategies channel

**jp**

So, I am not longer wondering if my strategy is profitable :slightly_smiling_face:

---

## 2021-02-03 12:04:07 - strategies channel

**jp**

From time to time I see the question raised from bettors about how many bets they need to make from a certain strategy before they can conclude that the strategy is +EV. Isn't this a question well suited for statistical hypothesis testing? So, given a history of bets, you define a confidence interval, and this analysis could either conclude that the strategy is +EV within the given confidence interval or not. Has anybody tried such an approach?

---

## 2021-02-02 09:44:59 - issues channel

**liam**

yeah I use it a lot, you need to be careful when calling `market.place_order` as it doesn't call `strategy.validate_order` the PR I am working on fixes this by removing the `strategy.place_order` call completely

---

## 2021-02-01 23:47:09 - general channel

**Sam Asin**

i tried to make a little betfair strategy and managed to trade like $2k-$3k with myself

---

## 2021-02-01 10:37:08 - general channel

**Michael**

It depends how you're answering the question - would it increase my betting? Well yeah, because I'd have to increase my betting - do I want it? Probably not.

---

## 2021-02-01 09:35:39 - random channel

**Lee**

nice, i'll give it a go. It's the schedule that's really sold me. Being able to create tasks quickly and interact using the same django models

---

## 2021-02-01 09:33:19 - random channel

**Lee**

Has anyone used zappa and if so what's your thoughts on it in relation to maintenance/monitoring? (compared to a docker image)

I'm also curious about any potential drawbacks of using zappa schedule over an independent lambda. I quite like the idea of being able to reuse django models.

---

## 2021-01-31 19:56:11 - strategies channel

**Sam Asin**

Hey guys, for my background I've always just used linear regressions and made 'em work. I think it's pretty fun and you can do a lot to get around stuff, but, like I *think* [@UBS7QANF3](@UBS7QANF3) said a month or two ago, it's not 1904. I wanna mess with something a bit more fancy/modern, especially to handle things like non-linearity. I saw Xgboost mentioned here and am wrapping my head around decision trees a bit, they seem cool. Do you guys have other recommendations for things to look at if I'm especially interested in non-linear effects? I hear a lot about neural nets as well, not sure what the pros and cons are. Within decision trees, I'm thinking random forest models seem interesting? Just curious if there's anything else I should be thinking about if I'm looking into non-linear models.

---

## 2021-01-31 10:58:07 - strategies channel

**Misha**

Although in some sports it is possible. We are thinking of developing a tiebreaker model for tennis that wouldn't be related to out main model, and could in fact bet against it

---

## 2021-01-31 10:55:42 - strategies channel

**D C**

[@ULDAVFDRP](@ULDAVFDRP) surely this is just unavoidable if you are working off of your own calculations of each runner's probability of winning? If the market is underpricing one runner, then it has to be overpricing at least one other. If you are +EV with your model overall surely all you need to do is make sure you stake sensibly and have sufficient bankroll? I can't see how you can prevent correlation between the two if you consider laying as a different "strategy" to backing - if the market goes the wrong way and the wrong runner comes home you will clearly take a bigger hit but overall you are compensated by the races where the market goes the right way and the right runner comes home?

---

## 2021-01-31 10:41:21 - strategies channel

**Oliver Varney**

they do kind a merge into one strategy, although they operate on different inputs, models, timeframes and order side as the opportunity and value all exists at the time of taking the bet. Bank structure / sizes is separate and im not really concerned about return or overly too much about risk. Several strategies may price up a market very good, i.e. backs get backed in lays get pushed out, but again this leads to a very correlated outcome across all bets. For example I may have backed something, it gets pushed it then runs awful and a horse that hasnt won in years pops up and wins. Its likely that I have layed that horse also, so you get a double hit. is this typically what others see across their bets?

---

## 2021-01-31 10:34:16 - strategies channel

**Misha**

We are essentially doing that (one strategy at the moment) and trusting the model. Makes for a roller coaster ride

---

## 2021-01-31 10:33:35 - strategies channel

**Kai**

I have some moderate correlation between different strategies and estimate it from pnl. But for me the first question about the strategy is always about value. If strategies are correlated and you want to reduce variance then you can adjust stakes, but in general I am happy about every strategy with value and correlation is a secondary question for me.

---

## 2021-01-31 08:21:07 - general channel

**Mo**

Let's also not overlook the importance of the extra information like knowing when points start (good for pulling bets) and when a player calls for a medical timeout (extremely important to be aware of for a fully automated strategy)

---

## 2021-01-30 17:31:52 - issues channel

**Unknown**

Just as an FYI, restarted the bot with the above mentioned filter and no code changes. Strategy is minimal, i.e. nothing more than a single loop through the runners in `process_market_book`.

bflw 2.12.0

flumine 1.16.1

---

## 2021-01-30 16:33:52 - issues channel

**birchy**

I can probably use specific filters for each event type and run a strategy per sport. Tempted to go 100% polling with this bot and save streaming for inplay, where speed IS important.

Also, just checked in and bot had crashed and burned. Last log was:

`{"asctime": "2021-01-30 08:31:23,529", "levelname": "WARNING", "message": "High latency between current time and MarketBook publish time", "market_id": "1.178427846", "latency": 752.4693222045898, "pt": "2021-01-30T08:18:50.921000"}`

I'm guessing it's been terminated by the Linux OOM killer as ram was on 65% of 2GB when I last looked yesterday. That is/was using only

`streaming_market_filter(event_type_ids=['1'])`

---

## 2021-01-30 13:25:06 - issues channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) Is there a recommended way to close a market subscription gracefully from within a strategy, i.e. from `check_market_book` after identifying a market I don't want?

---

## 2021-01-30 13:02:49 - issues channel

**birchy**

Just to clarify, if my bot identifies a market that it definitely doesn't need anymore, is it ok to close the market from within the Flumine strategy via `close_market`?

---

## 2021-01-30 12:31:01 - issues channel

**birchy**

My usage for this particular strategy is to have a small number of bets in lots of markets preplay, where speed is not required. Slow and steady wins this particular race, so polling is probably better suited. It's a shame that `listMarketCatalogue` doesn't have a param like `notMarketIds` where we could specify a list of market IDs that we're no longer interested in.

---

## 2021-01-29 10:46:25 - general channel

**Misha**

I thought this might be how my model works, but mostly I just hammer one side point after point. Can look ugly when there is a final set tiebreaker :wink:

---

## 2021-01-29 09:17:21 - general channel

**Misha**

I think I have a way to do it, but need to confirm (over a few months) the current model

---

## 2021-01-29 09:13:32 - general channel

**Mo**

There are definitely cases where the starting price spread is wide but it's worth betting in play; I understand why it creates problems for [@U016535QCJ2](@U016535QCJ2)'s approach but definitely worth finding another starting price you can use in my opinion

---

## 2021-01-28 17:55:59 - strategies channel

**liam**

`The trigger was a guy running a ridiculous bot on the API on one of his unfunded sub accounts.



It was doing a martingale over and over again, going from tiny to huge stakes in a cycle. The max stake on the exchange was some very large number, I don’t remember what, but bigger than 2e31.



Two things happened at the exact same moment: this martingale bot tried to place some huge bet way over the numeric max (and crucially, over that subaccount’s exposure limit) this caused a numeric error inside the trading engine exposure checking code.



This bet was rejected and you never saw it: all good. Unfortunately, the long dormant bug activated and allowed another bet which was not over the numeric max stake but was over the exposure limit for the account (it had nothing like the 20m to bet in it) to skip the exposure check.



Because it was a valid stake and the exposure check was missed, it went into the market and became good value pretty quickly. The nature of the bug meant that both bets had to be placed effectively at the same time, otherwise the tiny window of time that the numeric error opened up for the second bet to skip the exposure check would be closed again.



All involved in all aspects of handling this bug at the time were given the usual spiel of secrecy, which was fair because the bug was exploitable for a little while until fixed.



However, it was fixed long ago (although similar bugs probably existed because the codebase was very difficult to reason over) and now that whole trading system has been rewritten in a more modern language with a safer architecture (and it’s much much faster). I imagine there are all sorts of bugs in it, but they won’t be this type.`

---

## 2021-01-28 17:47:44 - general channel

**river_shah**

```from flumine.strategy.strategy import DEFAULT_MARKET_DATA_FILTER```



---

## 2021-01-28 17:39:03 - strategies channel

**Lee**

okay so it's not really understanding how your bet moved the market in a certain way but more seeing how different approaches effect your return / matching / roi / etc? so you can optimise/maximise a strategy

---

## 2021-01-28 17:35:54 - strategies channel

**Michael**

It's sort of un-knowable because everything's shifting around you all the time and you can have no control on any experiment. That's why I think AvB is the best approach to the problem. Actually it's the only thing I use AvB for. Broadly you're tracking how your returns diminish as your betting increases to try to find an optimum, that's easily observable relative to stake but a lot of small bets in a short period can have a similar effect to a larger stake so that's the tricky thing to understand - it can only be tested at market level (hence AvB). You might end up thinking more in terms of 'stake per second' or something like that.

---

## 2021-01-28 15:59:04 - general channel

**liam**

```trading = betfairlightweight.APIClient("username", "password")



# create listener

listener = StreamListener(max_latency=None)



# create historical stream (update file_path to your file location)

stream = trading.streaming.create_historical_generator_stream(

    file_path="/tmp/BASIC-1.132153978",

    listener=listener,

)



# create generator

gen = stream.get_generator()



data = []

for market_books in gen():

    for market_book in market_books:

        data.append(market_book)```

---

## 2021-01-28 10:43:15 - general channel

**Michael**

They won't let you scrape for long even streaming. Honestly it's not such a bad thing - you learn so much more from betting than you can from simulating. Just pick a sport, make up any crappy strategy and bet a few quid. That's almost always how it's done.

---

## 2021-01-28 10:00:13 - general channel

**Peter C**

I've been reading and understand the concept of closing line value when betting pre off - but I'm not sure (and can't find anything) about the validity of this method for comparing value to in play betting. If a punter, for example, waited for a runner to come in x% and then backed them (assume this is a -eV bet), and then compared to the clv - are you going back and self selecting winners (now more likely to win because they've come in) and therefore skewing the value calc, or would you say that the punter who waited for them to come in first wasn't taking anywhere near full value, even though he makes a decision based on information that wasn't available at the time the clv price was taken?



I guess my question is is the clv valid if you're now running with information that wasn't available at the time the clv was taken.

---

## 2021-01-28 09:15:35 - issues channel

**liam**

i think the real problem is basing fail safes on your balance, surely you trust the strategy / exposure calculations to not have to do that

---

## 2021-01-28 09:12:35 - issues channel

**thambie1**

Yeah, that parts easy. The part I need to put some effort into is handling the business logic afterwards. In this particular case, how should be bot handle the case where my account funds knowledge is stale? Keep betting normal sizes, and risk getting an insufficient funds error? Keep betting, and not have my fail safes regarding losing too much money too quickly?

---

## 2021-01-27 19:48:46 - random channel

**river_shah**

Re asset class for retail quant, I would recommend to steer clear of CME and EUREX futures trading. They are extremely deterministic and dominated by &lt; 5 players for delta one strats. If you know about options, then your space opens up significantly as options trading (especially delta neutral strats) are more about modelling than execution speed. Look at more niche sectors, for example agricultural products, Chinese products, LME metals. I am not sure about market access for those at the retail level though.

---

## 2021-01-27 19:38:14 - random channel

**MacrcoPolo**

First tip if you go down this route is to get hold of some intraday data, even a daily model should try and avoid using the closing prices - they're not executable, they're marked from a closing auction which isn't a price you can be certain to get

---

## 2021-01-27 14:01:16 - general channel

**liam**

```MARKET INFORMATION



For further information please see Rules &amp; Regs.



Who will finish 1st or 2nd in this race? NON RUNNERS DO NOT CHANGE THE PLACE TERMS. Should the number of runners be equal to or less than the number of places available as set out above in these rules all bets will be void. Betfair Non-Runner Rule applies. This market will turn IN PLAY at the off with unmatched bets (with the exception of bets for which the "keep" option has been selected) cancelled once the Betfair SP reconciliation process has been completed. Betting will be suspended at the end of the race. This market will initially be settled on a First Past the Post basis. However we will re-settle all bets should the official result at the time of the "weigh-in" announcement differ from any initial settlement. BETS ARE PLACED ON A NAMED HORSE. Dead Heat rules apply.```

---

## 2021-01-27 13:44:39 - general channel

**birchy**

Anybody here read [https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew-ebook/dp/B07SPWLYQJ|THIS](https://www.amazon.co.uk/Statistical-Sports-Models-Excel-Andrew-ebook/dp/B07SPWLYQJ|THIS) book and/or the second edition? Just wondering if it's any good for noobs?

---

## 2021-01-27 08:54:24 - general channel

**Misha**

Lots of "trading". Have been watching it for the last couple of years. Franchise T20 is the target. If you have a really good model, you could make a lot of money. Data available is good. Matches are constrained. And if you look hard you might be able to get ball-by-ball for pretty much every franchise T20 match ever played. Would take some effort, but think what you could do with that!

---

## 2021-01-27 08:48:40 - general channel

**Peter C**

Cheers for your thoughts. Please could you expand on suitable sample sizes based on strategy? I hadn't really thought about the difference but my initial thought was that with only two runners the variance in betting on favourites/longshots would take the same amount of time to come out given the pairing of the odds, but that's just a guess really.

---

## 2021-01-27 08:31:24 - general channel

**Mo**

Depends exactly what markets you are betting on but most likely those 1500 are not independent so your effective sample size is the number of matches: 400. A suitable sample size will depend on the nature of the strategy (e.g. is it betting on favourites or longshots) but I agree, you probably want 10 or 100 times what you have in order to conclusively say whether you have something profitable. And that may be impossible given frequency (or lack thereof) of matches

---

## 2021-01-27 08:21:11 - general channel

**Peter C**

Hi All - new here from more general value betting. Currently backtesting my first strategy and reading about the law of large numbers. Wondering if anyone could offer me their thoughts on what they would consider adequate backtesting? Currently testing with 400 cricket matches - c. 1500 matched bets, but this feels like not enough to overcome any variance.

---

## 2021-01-24 19:23:27 - general channel

**birchy**

I'm not really qualified enough to be specific, but as I understand it, bflw was the original implementation of the streaming API and users then had to consume the data &amp; JSON dicts themselves for handling strategies, bet placement, etc. That also means you have to do your own error handling, connection handling, etc. I believe Flumine has been developed on top of bflw in order to address those issues and create a much simpler interface for end users, particularly where strategy development and backtesting is concerned.

---

## 2021-01-24 16:50:23 - general channel

**river_shah**

bflw handles all the critical features for market and order streams and all other helper functions to communicate with betfair servers for market catalogues, runner meta data. flumine, builds on top of this core to provide a feature rich strategy design, backtesting and productionizing framework.

---

## 2021-01-21 11:07:05 - strategies channel

**river_shah**

What I have seen though is that not matter how well documented and tracked your research process was, most staff invariably “found” things that never pushed the boundaries of knowledge. The guys who pushed the boundaries of knowledge were typically with very deep expertise (Phds etc or deep market knowledge in their respective domains) . I am all for hiring research scientists straight from uni but then paying them £35K and expecting to crack big alpha is a dumb business model.

---

## 2021-01-21 11:05:54 - strategies channel

**Misha**

It counts less for more trading based models, but I go for the stats based models

---

## 2021-01-21 11:03:51 - strategies channel

**Misha**

The best models (in the main) are developed by the people who best understand the sport and how the markets for that sport work

---

## 2021-01-21 09:22:01 - strategies channel

**Jonjonjon**

You're right. It won't be there in the backtest. But  I think it will be there if I run the strategy for real.

---

## 2021-01-21 09:07:40 - strategies channel

**Jonjonjon**

No.



I am backtesting a strategy that places orders below/above the best "available to back"/"available to lay" prices. The strategy cancels the orders if a condition is met. However, if the latency is high, the strategy might not cancel them fast enough. So if the latency is too high, I'd prefer not to cancel the orders.

---

## 2021-01-20 18:05:41 - random channel

**V**

Modelling the actual sports

---

## 2021-01-20 18:04:56 - random channel

**V**

I mean actually pricing the underlying probs and trading deviations to their models 

---

## 2021-01-20 16:28:06 - strategies channel

**D C**

I've chatted with these guys on twitter. They are nice chaps and very helpful - sent me a few football modelling papers (not sure if directly used by them). That in itself means nothing but they were not pestering me to try the product. For what it is worth, I can't see how it can work as if they have loads of customers how do they prioritise whose money gets matched ahead of others as they appear to run exclusively on Betfair markets.

---

## 2021-01-19 19:03:46 - issues channel

**jhaa**

I have a bunch of football fixtures in a database and query the inplay scores using the event_ids. Some of those fixtures are accumulators or specials which cause the query to return an error:



`Traceback (most recent call last):`

  File "/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 108, in process_response

    return [resource(elapsed_time=elapsed_time, **x) for x in result]

  File "/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 108, in &lt;listcomp&gt;

    return [resource(elapsed_time=elapsed_time, **x) for x in result]

  File "/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/resources/inplayserviceresources.py", line 193, in __init__

    self.score = Score(**kwargs.get("score"))

  File "/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/resources/inplayserviceresources.py", line 87, in __init__

    self.home = HomeAwayBase(**home)

TypeError: __init__() missing 1 required positional argument: 'name'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):

  File "/home/code/PycharmProjects/betfair_jhaa/v2/core/StreamEngine.py", line 247, in query_inplay_scores

    scores = [http://self.trading.in|self.trading.in](http://self.trading.in|self.trading.in)_play_service.get_scores(event_ids=event_ids)

  File "/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/endpoints/inplayservice.py", line 99, in get_scores

    return self.process_response(

  File "/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 110, in process_response

    raise InvalidResponse(response=result)

betfairlightweight.exceptions.InvalidResponse: Invalid response received:

---

## 2021-01-19 10:18:08 - general channel

**river_shah**

moving this to DM but want this to return immediately.

```elif event.EVENT_TYPE == EventType.ORDER_PACKAGE:

    self._process_order_package(event)```

strategy does not care if bet was placed (as long as eventually the blotter reflects true matched and executable bets)

---

## 2021-01-19 09:19:11 - random channel

**Jonjonjon**

My models are very crude, and I need the skew to work in my favour. So if I have an IT issue I still have the chance of winning big, rather than losing lots

---

## 2021-01-18 18:30:51 - issues channel

**Diniz**

Python 3.8, Windows 10.

yes, just running



&gt; trading = betfairlightweight.APIClient(

&gt;         "username", "password", app_key="app_key", certs="/certs"

&gt;     )

&gt;  trading.login()

---

## 2021-01-18 13:58:27 - random channel

**Oliver Varney**

yes, highly likely its just the subset of runners my models been picking and a very very small sample size.

---

## 2021-01-16 13:38:17 - random channel

**Michael**

You're probably doing exactly the right thing. If you're investing relatively modest sums then a couple of Index funds is ideal because it limits your transaction costs. That's what I did to start with. When the amounts get bigger I think it makes more sense to buy a broad portfolio of individual shares with a leaning towards value as index funds always slightly under-perform the index because of costs and fees whereas shares held directly give you all the performance of those shares. Although I have done well from investing I've always made much more money from betting so I never found it all that exciting. This is likely to be true of any investment. However you probably already know that in real life betting profits don't compound like they do in the movies so you have to put the money somewhere....

---

## 2021-01-16 08:03:42 - random channel

**Ruben**

Good morning gents, do you know of an API that can be used to retreive prices from the global befair exchange (i.e. [http://betfair.com|betfair.com](http://betfair.com|betfair.com)). I can't bet on the global exchange so I don't have access to the official global API, but I think my model would perform a lot better if the odds used as input came from the global exchange vs my local exchange, which has less volume

---

## 2021-01-15 14:22:29 - general channel

**Alessio**

Yeah i run a strategy that writes into a file every X "virtual" milliseconds.

---

## 2021-01-15 14:02:47 - strategies channel

**Unknown**

Seminal paper on modelling football: [https://betfairlightweight.slack.com/files/UBS7QANF3/F010NTJJK88/dixoncoles.pdf](https://betfairlightweight.slack.com/files/UBS7QANF3/F010NTJJK88/dixoncoles.pdf)

---

## 2021-01-15 13:12:16 - strategies channel

**MacrcoPolo**

Assuming you know what a linear regression is and how they work then I'd probably use statsmodels. Otherwise I'd probably use excel - easier to build intuition and play about with toy problems

---

## 2021-01-15 11:58:04 - random channel

**bb**

One potential thing to be aware of for modelling with RPRs is they are not set in stone and are sometimes adjusted retrospectively. This is not a frequent thing but is enough to be a potential source of data leakage and throw off a model in production

---

## 2021-01-15 10:35:24 - random channel

**D C**

Totally agree. I think the exchange model would be trashed completely if loss limits were forced on users and that would be game over for me. It does make me angry that such things are even discussed as an option - can you imagine the uproar if people were only allowed to consume 5 units of alcohol per week or 10 cigarettes per week. I can piss my life savings up a wall and nobody is concerned but if I want to gamble with the same money its a problem. Really hope common sense prevails, but given recent events I have very little faith in decision makers right now.

---

## 2021-01-15 10:21:48 - strategies channel

**Alessio**

One thing i recently discovered is the 'interpret' package by MS folks. It contains both things like logistic and linear regression + xgboost stile stuff, but the cool stuff is that they are all explainable models, i.e. you can graph stuff very easily. [https://github.com/interpretml/interpret](https://github.com/interpretml/interpret)

---

## 2021-01-15 09:37:31 - random channel

**D C**

Is anyone else quite worried about the potential impact that this review might have on the exchange model? Social media is a cesspit for sure, but I have seen talk from people who "work in the industry" of monthly loss limits and means tested deposit limits. I don't want to see people having problems from gambling, but there must be better ways to deal with that than blanket limits and restrictions.

---

## 2021-01-15 09:10:50 - strategies channel

**river_shah**

[https://scikit-learn.org/stable/modules/linear_model.html](https://scikit-learn.org/stable/modules/linear_model.html) good primers on all the major techniques including the various penalised regressions

---

## 2021-01-15 07:22:35 - strategies channel

**Mo**

For linear regression I like statsmodels 

---

## 2021-01-14 13:23:02 - strategies channel

**Alessio**

The key point of these things is that they are linear models, i.e. you give one weight for each of the values you put inside, and you don't spend time thinking about things that are intercorrelated. It's very simple, but that's a very good place to start when thinking about probabilities that are function of multiple variables.

---

## 2021-01-14 13:18:52 - strategies channel

**Alessio**

These are in general linear models where you use a linear combination of variables to generate a probability. So, yes, it normalizes things. It does it in a specific way though, Assume you only have 2 horses just for plotting reasons, it will look like this: [https://en.wikipedia.org/wiki/Sigmoid_function#/media/File:Logistic-curve.svg](https://en.wikipedia.org/wiki/Sigmoid_function#/media/File:Logistic-curve.svg)

---

## 2021-01-14 09:46:28 - strategies channel

**Mo**

No doubt that was part of the expert's mental model :wink:

---

## 2021-01-14 09:37:39 - issues channel

**Newbie99**

my logic is quite simple under process current orders tbh:



```    def process_orders(self, market, orders):

        if market.market_book is not None and \

                market.market_book.status not in ['CLOSED','SUSPENDED'] and \

            len([order for order in market.blotter.strategy_orders(self) if order.status == OrderStatus.EXECUTABLE]) != 0:



            rf.cancel_and_replace_orders(self, orders, market)```

---

## 2021-01-14 09:34:30 - issues channel

**Newbie99**

```{"asctime": "2021-01-14 09:12:30,117", "levelname": "INFO", "message": "Order status update: Cancelling", "market_id": "1.177891689", "selection_id": 16786966, "handicap": 0, "id": "138299083469138870", "customer_order_ref": "6012fe3b915f7-138299083469138870", "bet_id": "221690469430", "date_time_created": "2021-01-14 09:12:26.913912", "publish_time": "2021-01-14 09:12:26.886000", "trade": {"id": "9ef0aa3a-5648-11eb-a0bb-02f9e1e2dd3a", "strategy": "simple_lay_mm", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138299083469138870"], "notes": "", "market_notes": "8.4,8.8,8.6", "status": "Live", "status_log": "Pending, Live"}, "order_type": {"order_type": "Limit", "price": 8.2, "size": 2.08, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 2.08, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2021-01-14 09:12:27.117261", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Cancelling", "status_log": "Pending, Executable, Cancelling", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 0.0, "matched": []}}

INFO:flumine.streams.orderstream:Stopped OrderStream 1001

{"asctime": "2021-01-14 09:12:30,117", "levelname": "INFO", "message": "Stopped OrderStream 1001"}

INFO:flumine.streams.marketstream:Stopped MarketStream 2001

{"asctime": "2021-01-14 09:12:30,118", "levelname": "INFO", "message": "Stopped MarketStream 2001"}

INFO:flumine.execution.baseexecution:Shutting down Execution (SimulatedExecution)

{"asctime": "2021-01-14 09:12:30,118", "levelname": "INFO", "message": "Shutting down Execution (SimulatedExecution)"}

INFO:flumine.execution.baseexecution:Shutting down Execution (BetfairExecution)

{"asctime": "2021-01-14 09:12:30,119", "levelname": "INFO", "message": "Shutting down Execution (BetfairExecution)"}

INFO:flumine.worker:BackgroundWorker keep_alive shutting down

{"asctime": "2021-01-14 09:12:30,119", "levelname": "INFO", "message": "BackgroundWorker keep_alive shutting down", "worker_name": "keep_alive", "function": "&lt;function keep_alive at 0x7f7644889680&gt;"}

INFO:flumine.streams.orderstream:Stopped output_thread (OrderStream 1001)

{"asctime": "2021-01-14 09:12:30,365", "levelname": "INFO", "message": "Stopped output_thread (OrderStream 1001)"}

INFO:flumine.streams.marketstream:Stopped output_thread (MarketStream 2001)

{"asctime": "2021-01-14 09:12:32,043", "levelname": "INFO", "message": "Stopped output_thread (MarketStream 2001)"}

INFO:flumine.worker:BackgroundWorker poll_account_balance shutting down

{"asctime": "2021-01-14 09:12:34,120", "levelname": "INFO", "message": "BackgroundWorker poll_account_balance shutting down", "worker_name": "poll_account_balance", "function": "&lt;function poll_account_balance at 0x7f76448967a0&gt;"}

INFO:flumine.worker:BackgroundWorker poll_market_catalogue shutting down

{"asctime": "2021-01-14 09:12:38,120", "levelname": "INFO", "message": "BackgroundWorker poll_market_catalogue shutting down", "worker_name": "poll_market_catalogue", "function": "&lt;function poll_market_catalogue at 0x7f7644896710&gt;"}

INFO:flumine.worker:BackgroundWorker poll_cleared_orders shutting down

{"asctime": "2021-01-14 09:12:42,121", "levelname": "INFO", "message": "BackgroundWorker poll_cleared_orders shutting down", "worker_name": "poll_cleared_orders", "function": "&lt;function poll_cleared_orders at 0x7f7644896830&gt;"}

INFO:flumine.baseflumine:Exiting flumine

{"asctime": "2021-01-14 09:12:46,214", "levelname": "INFO", "message": "Exiting flumine", "client": {"id": "74093be2", "exchange": "Betfair", "betting_client": "APIClient", "chargeable_transaction_count": 0, "trading_controls": ["&lt;flumine.controls.clientcontrols.MaxOrderCount object at 0x7f7643506d50&gt;"], "order_stream": true, "best_price_execution": true, "paper_trade": false}, "markets": {"market_count": 262, "open_market_count": 259}, "streams": ["&lt;OrderStream(OrderStream, stopped daemon 140145877423872)&gt;", "&lt;MarketStream(MarketStream, stopped daemon 140145869031168)&gt;"], "logging_controls": [], "threads": ["&lt;_MainThread(MainThread, started 140146403047232)&gt;", "&lt;BackgroundWorker(keep_alive, started daemon 140145910994688)&gt;", "&lt;BackgroundWorker(poll_account_balance, started daemon 140145902601984)&gt;", "&lt;BackgroundWorker(poll_market_catalogue, started daemon 140145894209280)&gt;", "&lt;BackgroundWorker(poll_cleared_orders, started daemon 140145885816576)&gt;"]}

Traceback (most recent call last):

  File "jumps.py", line 187, in &lt;module&gt;

    framework.run()

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/flumine.py", line 32, in run

    self._process_current_orders(event)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/baseflumine.py", line 238, in _process_current_orders

    strategy.process_orders(market, strategy_orders)

  File "/home/ec2-user/trading/env/projects/simple_book.py", line 418, in process_orders

    rf.cancel_and_replace_orders(self, orders, market)

  File "/home/ec2-user/trading/env/projects/racing_functions.py", line 3563, in cancel_and_replace_orders

    back_all_runners_without_back_price

  File "/home/ec2-user/trading/env/projects/racing_functions.py", line 3699, in replace_all_orders

    self.replace_order(market, order, back_price)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/strategy/strategy.py", line 146, in replace_order

    market.replace_order(order, new_price)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/markets/market.py", line 70, in replace_order

    order.replace(new_price)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/order/order.py", line 332, in replace

    raise OrderUpdateError("Current status: %s" % self.status)

flumine.exceptions.OrderUpdateError: Current status: OrderStatus.CANCELLING

(env) [ec2-user@ip-172-31-8-45 projects]$       ```

---

## 2021-01-14 09:31:57 - issues channel

**Newbie99**

This is confusing me a bit, I've been getting this a lot over the last couple of days (seemingly out of the blue). Whilst the error is self explanatory, what I'm not understanding is how it occurs, as I check the order status before any cancel or replace:



```Traceback (most recent call last):

  File "jumps.py", line 187, in &lt;module&gt;

    framework.run()

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/flumine.py", line 32, in run

    self._process_current_orders(event)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/baseflumine.py", line 238, in _process_current_orders

    strategy.process_orders(market, strategy_orders)

  File "/home/ec2-user/trading/env/projects/simple_book.py", line 418, in process_orders

    rf.cancel_and_replace_orders(self, orders, market)

  File "/home/ec2-user/trading/env/projects/racing_functions.py", line 3563, in cancel_and_replace_orders

    back_all_runners_without_back_price

  File "/home/ec2-user/trading/env/projects/racing_functions.py", line 3699, in replace_all_orders

    self.replace_order(market, order, back_price)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/strategy/strategy.py", line 146, in replace_order

    market.replace_order(order, new_price)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/markets/market.py", line 70, in replace_order

    order.replace(new_price)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/order/order.py", line 332, in replace

    raise OrderUpdateError("Current status: %s" % self.status)

flumine.exceptions.OrderUpdateError: Current status: OrderStatus.CANCELLING```

---

## 2021-01-14 09:18:18 - strategies channel

**Mo**

Stephanie has done a lot of interesting work in tennis, I rate her research very highly. I had a profitable pre-event tennis strategy based off Elo but it required a human expert's input. The Elo model was like a filter to highlight matches for the expert to focus on

---

## 2021-01-14 09:11:15 - strategies channel

**Mo**

Big fan of Nate Silver generally speaking. I don't know too much about what he does in tennis specifically. Elo rankings are a great place to start with any pre-event model.

---

## 2021-01-14 09:09:35 - strategies channel

**Alessio**

That's the model that you were referring to sometimes ago that it doesn't work anymore?

---

## 2021-01-13 21:43:12 - strategies channel

**birchy**

I was referring to everything that's not betfair API, i.e. modelling, decision making, execution, analysis, etc. Basically everything that is/was required to get to a point where satisfactory bets are placed. The question was asked as a sanity check to discover if I've totally underestimated how 'simple' a strategy could be.

---

## 2021-01-13 20:44:03 - strategies channel

**birchy**

Well just those 2 responses alone tells me that your setups are far more complicated than mine are. I'm literally taking data as it arrives from betfair, doing a few simple calculations and submitting some bets. I don't have any external frameworks or components beyond a single utilities file that contains a handful of boilerplate functions. As for "modelling", when I have an idea, I create some triggers/parameters in a Flumine strategy, press the go button and wait...modify triggers...rinse and repeat. I don't have 100's of hours available to be able to learn data science and then write a million lines of code to create an AI that tells me I need to back winners and lay losers. Yes, I'm a Luddite.

Anyone got a link to some sort of "modelling for twats" articles/books?

---

## 2021-01-13 19:30:51 - strategies channel

**thambie1**

Agree with Dave, really hard to draw a clear line on what is strategy code. On top of what he mentioned, there can be model code, model training code, etc.

---

## 2021-01-13 19:28:50 - strategies channel

**Dave**

Given different coding styles I can't imagine SLOC has much correlation between how much a strategy earns beyond a certain point! Also what counts as a strategy, the actual decision making and execution logic or also the core frameworks code that sorts out plumbing between your components etc?

---

## 2021-01-13 19:21:40 - strategies channel

**birchy**

I'm curious...for those of you that have strategies using only betfair API market data and no external data feeds, excluding boilerplate API code, approximately how many SLOC are your strategies? Mine are typically ~20-50 per strategy because I like to keep things as simple as possible, however I don't really have any 'big' earners and am wondering if my obsession with minimal code is holding me back?

---

## 2021-01-13 14:01:10 - issues channel

**Oliver Varney**

yes my model is trained off these files so I will need to match the settings

---

## 2021-01-13 06:11:52 - general channel

**liam**

Just update the MarkettRecorder strategy so it does what you want, it’s just an example (delete code is in clean_up)

---

## 2021-01-12 15:37:04 - general channel

**river_shah**

My suggestion would be that your prediction / recommendation engine project should have a few more modules that interact with flumine. So you still launch a flumine strategy when it comes time to trade, first that process instantiates your prediction engine and then it instantiates relevant flumine pieces. please take a look the example strats. Unless the recommendation engine is super heavy, splitting up recommendations from the trading is not a good idea because you’ll add a ton of code complexity (csv, redis, zmq etc) and backtesting will be that much harder

---

## 2021-01-12 15:32:05 - general channel

**Matthieu Labour**

Would that take place within Flumine? The idea is to prepare an order (in CSV or via API like Oliver &amp; liam suggested) but, then, where does the reading of the CSV is taking place? In a Strategy? A background worker?

---

## 2021-01-12 11:54:38 - strategies channel

**Oliver Varney**

when backtesting is it best to backtest one strategy at a time or do people add a few that are variations of each other, then evaluate which one is best. Do you run into issues if you add multiple strategies?

---

## 2021-01-12 10:40:54 - general channel

**Matthieu Labour**

Hello,

I am looking for guidance when using Flumine. I want to manually force/enter an order using the API. What would you recommend?

I see a few options:

Option1: I create a separate program that uses BetfairLightWeight only. No Flumine involved.

Option2: I create a strategy in Flumine that triggers an order when receiving a CustomEvent.

Option3:  I run flumine and share the BetfairClient as shown below:

```trading = betfairlaightweight.APIClient("username")

client = clients.BetfairClient(trading)

framework1 = Flumine(client=client)

framework2 = GatewayToSendOrder(client=client)```

Others?

Thank you for your help!

---

## 2021-01-12 08:51:26 - general channel

**Carsten**

when running the code as is in example i get this :

 trading.set_session_token(session_token[0])

IndexError: list index out of range

---

## 2021-01-11 22:23:16 - issues channel

**Newbie99**

```{"asctime": "2021-01-11 22:06:46,792", "levelname": "INFO", "message": "Order status update: Violation", "market_id": "1.177838493", "selection_id": 25383704, "handicap": 0, "id": "138296955628176706", "customer_order_ref": "869aeb021cad4-138296955628176706", "bet_id": "221534743900", "trade": {"id": "f3590071-5458-11eb-b622-2016d8944b85", "strategy": "simple_back_mm", "status": "TradeStatus.LIVE", "orders": ["138296954581483634", "138296954616777215", "138296955628176706"], "notes": "", "market_notes": "13.5,14,13.5"}, "order_type": {"order_type": "Limit", "price": 13.5, "size": 0.2, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.01, "size_remaining": 0.19, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 13.5}, "status": "Violation", "status_log": "Pending, Executable, Replacing, Violation"}

INFO:flumine.order.trade:Trade status update: Complete

{"asctime": "2021-01-11 22:06:46,793", "levelname": "INFO", "message": "Trade status update: Complete", "id": "f3590071-5458-11eb-b622-2016d8944b85", "strategy": "simple_back_mm", "status": "TradeStatus.COMPLETE", "orders": ["138296954581483634", "138296954616777215", "138296955628176706"], "notes": "", "market_notes": "13.5,14,13.5"}

WARNING:flumine.controls:Order has violated: ORDER_VALIDATION Error: Order size is less than min bet size (2) or payout (10) for currency

{"asctime": "2021-01-11 22:06:46,794", "levelname": "WARNING", "message": "Order has violated: ORDER_VALIDATION Error: Order size is less than min bet size (2) or payout (10) for currency", "control": "ORDER_VALIDATION", "error": "Order size is less than min bet size (2) or payout (10) for currency", "order": {"market_id": "1.177838493", "selection_id": 25383704, "handicap": 0, "id": "138296955628176706", "customer_order_ref": "869aeb021cad4-138296955628176706", "bet_id": "221534743900", "trade": {"id": "f3590071-5458-11eb-b622-2016d8944b85", "strategy": "simple_back_mm", "status": "TradeStatus.COMPLETE", "orders": ["138296954581483634", "138296954616777215", "138296955628176706"], "notes": "", "market_notes": "13.5,14,13.5"}, "order_type": {"order_type": "Limit", "price": 13.5, "size": 0.2, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.01, "size_remaining": 0.19, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 13.5}, "status": "Violation", "status_log": "Pending, Executable, Replacing, Violation"}}```

With Flumine, the above violates (obviously because its less than GBP 10), however using the REST API it is possible to replace small orders, so should it work from Flumine, or is the above expected behaviour (specifically on a replace)?



If so, other than quickly placing and cancelling, is there a smarter way to submit small orders (I know this comes up every now and again, but I thought the replace approach was the correct one and I'd never really had much of a need when streaming before)?

---

## 2021-01-11 14:16:39 - strategies channel

**Jonjonjon**

Interesting. Thanks Byron. Why do you think that is? My model might be suffering from the same problem

---

## 2021-01-11 14:15:22 - strategies channel

**Byron**

[@UPMUFSGCR](@UPMUFSGCR) I would advise strongly that if you are building a model for betting in Australia that you create a variable "days" which is the day of the year (so January 1st, is 1, the 2nd is 2 and so on). You will find that there are two sets of 60-90 day periods that run from about mid Feb-April and then Aug-mid Nov where the model will perform better than at other times (at least mine does).

---

## 2021-01-11 08:39:46 - strategies channel

**Mo**

It's hard to engage with such broad questions but I will say I think you should be cautious about taking ideas that work in financial markets and blindly applying them to betting markets. It's important to appreciate that placing a bet is different to buying (or selling) a financial instrument. Your risk and potential payoff is known in advance and therefore capped. There is some limited drifting of odds but generally temporal trends are dominated by the simple fact that as you get closer to the end of the event, the implied probabilities approach 0 or 1.



Speaking about Betfair specifically, you don't get to see individual orders in the order book, only the aggregate volumes available at each price. Similar for matched bets, you do not see individual trades on each update but aggregate data on all trades that happened in that matching cycle.

---

## 2021-01-11 02:44:33 - strategies channel

**Joseph kravets**

So I run trend following strategies on futures, crypto , equities. I don’t know anything about sports. What’s a good resource  to learn about the betting markets? Is there a sample strategy anywhere ? What are some good indicators to look at here?

---

## 2021-01-10 20:42:51 - strategies channel

**Michael**

That way you get to see and understand the variables that determine the value of each bet and you can feed that knowledge back into your strategy.

---

## 2021-01-10 20:41:00 - strategies channel

**Michael**

I think a lot of this comes down to how you do your analysis. Some people are into analysing the performance of a strategy as a whole and will test strategy A against strategy B and so on. To me this doesn't make much sense as your strategy is only visible or meaningful to you, the exchange only sees your bets and treats them individually. Personally I like to take my bets independently of whatever triggered them and analyse them that way round.

---

## 2021-01-10 20:37:21 - strategies channel

**PeterLe**

What Ive found is that if you run a single profitable strategy and the stakes scale, you eventually hit a point where you cant increase stakes - diminishing returns, (im talking in play horses now, not football where the volume is much greater). Id rather have 10 systems using smaller stakes than a single one using large stakes. Its just my preference [@UGV299K6H](@UGV299K6H).

---

## 2021-01-10 20:31:19 - strategies channel

**Michael**

[@UQL0QDEKA](@UQL0QDEKA) Like I said to an extent it's a question of style, but if you're running a lot of variations on a theme it would presumably be quite easy to identify the commonalities in them and bring them all into a single strategy with triggers that cover all reasonable variations. Wouldn't that be better? If there is sufficient capacity for overlap why not just explicitly place more or bigger bets at those times?

---

## 2021-01-10 20:26:44 - strategies channel

**Dave**

Additional models also come with maintenance costs, rather have fewer models that have been chosen empirically

---

## 2021-01-10 20:19:47 - strategies channel

**Michael**

[@U4H19D1D2](@U4H19D1D2) In this case maybe but you're still just kicking the can down the road. What are you going to do when you find another feature? Start a model C and run that too? Just in the general case I don't like to approach. You can make it better by having some structure like a perpetual AvB with a 'winner stays on' structure or something like that but you can see the potential for muddying the waters if you don't. I suppose it is a question of style and how you manage your development though.

---

## 2021-01-10 19:58:35 - strategies channel

**Dave**

In my case I'd probably decommission the model that performs worse over some period of time and double the stakes of the better one, rather than run both perpetually with half the potential stake.

---

## 2021-01-10 19:34:46 - strategies channel

**Michael**

Personally I'm not keen on [@U4H19D1D2](@U4H19D1D2)'s approach to this problem for a few reasons, one of which is that you can easily end up with a proliferation of poorly optimised models that might be interacting in all kinds of ways that you'll never know about. I prefer to try to understand the features I'm using as deeply as possible and integrate them into a single unified model wherever possible.

---

## 2021-01-10 19:06:37 - strategies channel

**Michael**

also nice to have the option of using model A where sufficient data is available and model B where it's not.

---

## 2021-01-10 19:01:49 - strategies channel

**Michael**

...or just test model B against the markets that qualify for model A?

---

## 2021-01-10 19:00:56 - strategies channel

**Dave**

That's a good question, I was just about to comment about it! The more complex model requires a larger history to exist for each team, and naturally it cuts the tradeable number of events down by about 20%. It's possible that the uncertainty in this 20% is larger, therefore more market innefficiency and higher margins opportunities that the simpler model is able to take advantage of. I'll check the margin on these 20% and see if it massively outweighs the rest

---

## 2021-01-10 18:57:18 - strategies channel

**Michael**

Do both models generate similar numbers of bets?

---

## 2021-01-10 18:56:36 - strategies channel

**Dave**

Yeah the fact that the model is simpler is what makes it quite attractive over the other. I should stop being lazy and do some tests on the features themselves like you say!

---

## 2021-01-10 18:48:39 - strategies channel

**Michael**

Would opting for the model with fewer features allow you to analyse the remaining features against the bets? If I were struggling to make up my mind I'd generally plump for the simpler model. 3000 markets with bets in them backing at &lt; 2 seems like quite a lot to me.

---

## 2021-01-10 18:35:13 - strategies channel

**Mo**

I don’t know if you’re targeting specific leagues or trying to model every football match but your _effective sample size_ could be (a lot) smaller if the profits are driven by a small number of large bets you can get down on the higher liquidity events 

---

## 2021-01-10 18:32:05 - strategies channel

**Dave**

About 3K football matches. On this size I would not expect one model to provide 2x the pnl than the other, but I think I am just underestimating the variance I can expect

---

## 2021-01-10 18:07:33 - strategies channel

**Dave**

[@US2K70JR0](@US2K70JR0) I guess that raises the q of what is "big sample". In my case I thought my holdout set on which these metrics are computed is big enough, and so I was just surprised a model that shows up as having better predictive ability was yielding worse results backtest-wise (I.e. when you bring the forecasts to the market). Probably just the case that the dataset is not large enough and just seeing some continued variance. Might as well run both models on 50% of events each and see how it goes.

---

## 2021-01-10 17:37:56 - strategies channel

**Michael**

I'm far from being a stats expert so maybe this is bollocks - but doesn't it depend on your sample size? Surely the various statistical tests essentially just substitute for a larger sample, so if you have a big sample you just go for the biggest profit and if your sample is limited you lean towards the models that perform best on the statistical tests... or is that wrong?

---

## 2021-01-10 17:28:28 - general channel

**Michael**

Although all the covid era months seem very non-typical to me I wouldn't discard any of the data, especially if that's all the data you have. The betting has been unusual in that there have been more opportunities to bet and it's been really easy to get bets matched but the signals that are ultimately used for triggers are just the same as ever and that's usually what you're looking for when you back test. Just keep in mind that your back-tested returns are likely to be on the high side, so if your strategy looks a bit marginal tread carefully. From where I sit the betting now is just as good as at any time and I'm continuing to see superb returns relative to time of year, race type and so on. Who knows how long it will last but for the time being I guess we all just enjoy it.

---

## 2021-01-10 16:28:39 - strategies channel

**Alessio**

not really, tbh. depends on the structure of the model, but if it is highly nonlinear it may correlate, and that's enough to screw up things.

---

## 2021-01-10 16:19:07 - strategies channel

**D C**

You guys who do proper modelling based on variables / fundamentals as opposed to pure market / price based backfitting , how do you go about your sport(s) when subject to a new rule change or similar? Or something like covid era where home advantage effect is very likely altered by absence of crowds. Mainly I am thinking about introduction of VAR in football which was a big one, but in other sports there are subtle rule changes introduced at times. Do you just run prior models on the "new" version of the sport and carefully monitor for differences in your expected profits or do you shut up shop until you can rebuild a model from "new" data as it becomes available?

---

## 2021-01-10 16:04:25 - strategies channel

**Dave**

Modelling question: I have a model, A, that by standard statistical tests performs better than model B (higher ROC, better precision/recall etc). However, on backtest, model B results in higher Sharpe and more total pnl. How would one choose which model to use? My theory is that model A is just better at forecasting situations that are already easy for the market to forecast too, and therefore unlikely to find opportunities where the market gets this wrong (hence an opportunity to take a position in the market). Note: Model B is just fit on a subset of features.

---

## 2021-01-09 15:12:24 - strategies channel

**birchy**

Currently calculate in my own utils add-on in strategy, so maybe not efficient?

---

## 2021-01-08 17:39:12 - general channel

**river_shah**

ok, I can put the appropriate handling in my strategy. thank you

---

## 2021-01-08 17:27:17 - general channel

**river_shah**

In backtest mode, how do I receive the `market_book.streaming_update` before the runner books are updated please? I tried changing the stream class to `DataStream` but does not seem to work. ideally my strategy would get called first at `process_raw_data` / flumine then processes and then the standard `process_market_book` callback.

---

## 2021-01-08 08:32:59 - random channel

**Michael**

Could you construct some kind of 'poor data' races model? We do get this problem every year for one reason or another. Thinking back we've had floods, snow, drought, equine flu, foot and mouth.... there's always something.

---

## 2021-01-08 08:32:19 - random channel

**bb**

One of my colleagues who knows more about racing than I could ever hope to, but nothing about modelling, loves betting in these markets and experience has shown that the markets he loves are where my models tend to fall over

---

## 2021-01-08 08:28:02 - random channel

**Oliver Varney**

in my opinion is all very reliant on your models + techniques + how the data is used in training used which is very individual. Im guessing most AI models will struggle as the sample size is small and a large number of expected inputs are missing. My models are built to generalise, but I think if I built more an anomaly detection algorithm that would hold up better.

---

## 2021-01-08 08:23:18 - random channel

**Michael**

It's certainly true that there aren't usually that many of these races so I can see why you might sit them out. That said; you can end up classifying quite a lot of races as 'unusual' for one reason or another, for example the longest races in either NH or Flat racing can have very little associated form and there are always mountains of confounding variables. If you were to over-stretch that approach you'd miss out on quite a lot of markets. A lot of our money comes from being calm and consistent when others are over rating the significance of one variable or another, it's often less about our amazing predictions and more about our not getting carried away. There's a balance to strike between checking the validity of your model and just letting your variability shake out over as many markets as possible.

---

## 2021-01-08 08:09:49 - random channel

**bb**

I have a seperate set of models for juvenile races with a much heavier weighting on pedigree and aptitude for the distance

---

## 2021-01-08 08:07:05 - random channel

**bb**

I personally give these races a miss for all but the true bumpers at the beginning of the cards. Trying to accurately assess the chances of a horse stepping back from a 3 mile chase to a 2 mile bumper is not something I think my models are well suited for.

---

## 2021-01-08 06:35:59 - random channel

**Oliver Varney**

Those using models it may be worth checking your data providers for Lingfield and Newcastle today. Some strange race types / variables

---

## 2021-01-07 16:04:15 - random channel

**Jonjonjon**

Does anyone use Sympy to help them hack through betting equations?

---

## 2021-01-07 14:49:42 - issues channel

**Newbie99**

(where strategy_list is a list of your strategy names)

---

## 2021-01-07 14:49:24 - issues channel

**Newbie99**

you need to create a hash of the strategy name and see if it matches, something along these lines:



```strategy_name_list = [{'strategy_name': strategy,

                      'strategy_hash': flumine.utils.create_cheap_hash(strategy, 13)}

                      for strategy in strategy_list]```

---

## 2021-01-07 14:48:49 - issues channel

**birchy**

pre-flumine/bflw, I used the `customer_strategy_ref` it is returned by the API

---

## 2021-01-07 14:47:52 - issues channel

**birchy**

OK...so how do I identify which strategy placed the bets when calling `listClearedOrders` ? i.e. some identifier that tells me where the bet originated from without having a local cache?

---

## 2021-01-07 14:16:27 - issues channel

**birchy**

stupid question...where do I set a custom `customer_strategy_ref` in Flumine? Been all through order, trade, place_order(), etc but not found it yet...

---

## 2021-01-07 11:38:44 - general channel

**Misha**

CREATE TABLE [dbo].[Bf_Bet](

	[TransactionId] [bigint] NOT NULL,

	[EventTypeId] [bigint] NOT NULL,

	[EventTypeName] [varchar](100) NOT NULL,

	[EventId] [bigint] NOT NULL,

	[EventName] [varchar](100) NOT NULL,

	[MarketId] [varchar](100) NOT NULL,

	[MarketName] [varchar](100) NOT NULL,

	[SelectionId] [bigint] NOT NULL,

	[AsianSelectionId] [bigint] NOT NULL,

	[SelectionName] [varchar](100) NOT NULL,

	[AsianSelectionHandicap] [decimal](18, 2) NOT NULL,

	[BetId] [bigint] NOT NULL,

	[MarketSubType] [varchar](100) NULL,

	[UtcStartTime] [datetime] NOT NULL,

	[NumberOfWinners] [int] NULL,

	[BetCategoryType] [varchar](100) NOT NULL,

	[BetOutcome] [varchar](100) NULL,

	[BetPersistenceType] [varchar](100) NOT NULL,

	[BetStatus] [varchar](100) NOT NULL,

	[BetType] [varchar](100) NOT NULL,

	[CancelledSize] [decimal](18, 2) NULL,

	[GrossProfit] [decimal](18, 2) NULL,

	[IsPriceReduced] [bit] NOT NULL,

	[MatchedPrice] [decimal](18, 2) NULL,

	[OrderRef] [varchar](100) NULL,

	[RequestedPrice] [decimal](18, 2) NOT NULL,

	[SettledSize] [decimal](18, 2) NULL,

	[StrategyRef] [varchar](100) NULL,

	[UtcMatchedTime] [datetime] NULL,

	[UtcPlacedTime] [datetime] NOT NULL,

	[UtcSettledTime] [datetime] NULL,

	[LastUpdated] [datetime2](0) NOT NULL,

 CONSTRAINT [PK_Bf_Bet] PRIMARY KEY CLUSTERED

(

	[TransactionId] ASC

)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, FILLFACTOR = 80) ON [PRIMARY]

) ON [PRIMARY]

GO

---

## 2021-01-07 11:28:45 - general channel

**birchy**

Question regarding analysis of settled bets...

What setups do you have to handle this? Or more specifically, what bet data do you save? I've always been a bit slack-arsed with post-race analysis: if the P&amp;L is &gt;£0, I leave the bot alone (or maybe make some minor tweaks if I can see some _obvious_ improvements) and if P&amp;L &lt;£0, I simply change some trigger values and try again. There's no real analysis behind it other than what I _think_ the triggers should be. I'm designing something to improve this and want to keep things simple, so was thinking of creating a CSV per strategy with the following data in it:



1. triggers that activated the bet being placed

2. market conditions when triggers were satisfied

3. the actual bet info (price, stake, etc)

4. result/P&amp;L for the bet

Obviously the above is potentially a LOT of data per bet, so I'm wondering what you would consider to be essential? Or maybe there is a better approach?

---

## 2021-01-06 16:26:40 - general channel

**liam**

This is going to be so painful for me, api / strategy setup / database 

---

## 2021-01-05 15:38:01 - random channel

**Michael**

[@UBS7QANF3](@UBS7QANF3) are you still using Kelly?

---

## 2021-01-05 10:03:28 - issues channel

**Alessio**

Hey [@U4H19D1D2](@U4H19D1D2) how did you choose the 1200 seconds for the API keep_alive? I am seeing repeatedly this stuff:

`{"asctime": "2021-01-05 09:56:39,831", "levelname": "ERROR", "message": "keep_alive error", "exc_info": "Traceback (most recent call last):\n File \"/usr/local/lib/python3.7/site-packages/flumine/worker.py\", line 97, in keep_alive\n  resp = client.keep_alive()\n File \"/usr/local/lib/python3.7/site-packages/flumine/clients/betfairclient.py\", line 32, in keep_alive\n  return self.betting_client.keep_alive()\n File \"/usr/local/lib/python3.7/site-packages/betfairlightweight/endpoints/keepalive.py\", line 30, in __call__\n  (response, response_json, elapsed_time) = self.request(session=session)\n File \"/usr/local/lib/python3.7/site-packages/betfairlightweight/endpoints/keepalive.py\", line 56, in request\n  self._error_handler(response_json)\n File \"/usr/local/lib/python3.7/site-packages/betfairlightweight/endpoints/keepalive.py\", line 63, in _error_handler\n  raise self._error(response)\nbetfairlightweight.exceptions.KeepAliveError: API keepAlive FAIL: NO_SESSION", "trading_function": "keep_alive", "response": "API keepAlive FAIL: NO_SESSION"}`

---

## 2021-01-05 09:46:52 - random channel

**Mo**

Kelly is just maximising the geometric growth rate or equivalently expected log return. You can fairly easily calculate the expected log return by integrating over all possibilities for simultaneous bets or some existing unsettled bets plus new bets. Then maximise using your favourite optimiser (although you can work it out analytically as well)

---

## 2021-01-05 09:40:37 - random channel

**Mo**

Nowadays I would prefer the concept of an overall bankroll or a per strategy bankroll

---

## 2021-01-05 09:40:16 - general channel

**Lee**

You'll be able to check at startup from the logs as it has the same stream id (2000 in this example)

```2021-01-04T12:01:44.916563534Z app[prod.1]: {"asctime": "2021-01-04 12:01:44,916", "levelname": "INFO", "message": "Creating new &lt;class 'flumine.streams.marketstream.MarketStream'&gt; (2000) for strategy StrategyOne"}

2021-01-04T12:01:44.917101796Z app[prod.1]: {"asctime": "2021-01-04 12:01:44,916", "levelname": "INFO", "message": "Adding strategy StrategyOne"}

2021-01-04T12:01:44.917474590Z app[prod.1]: {"asctime": "2021-01-04 12:01:44,917", "levelname": "INFO", "message": "Using &lt;class 'flumine.streams.marketstream.MarketStream'&gt; (2000) for strategy StrategyOne"}

2021-01-04T12:01:44.917878853Z app[prod.1]: {"asctime": "2021-01-04 12:01:44,917", "levelname": "INFO", "message": "Adding strategy StrategyOne"}

2021-01-04T12:01:44.918276110Z app[prod.1]: {"asctime": "2021-01-04 12:01:44,918", "levelname": "INFO", "message": "Using &lt;class 'flumine.streams.marketstream.MarketStream'&gt; (2000) for strategy StrategyTwo"}```

---

## 2021-01-05 09:39:45 - random channel

**Mo**

When I used to use Kelly I would have a bankroll per match

---

## 2021-01-05 09:36:56 - random channel

**Oliver Varney**

each strategy has its own bankroll, but within the strategy itself there are many bets that may have not settled before a new bet opportunity becomes available

---

## 2021-01-05 09:27:07 - random channel

**river_shah**

If you truly want to avoid heuristics then my suggestion is to look at markowitz multi period mean variance optimization (this is the generalisation of kelly to multiple bet scenarios with no assumptions of independence either)

---

## 2021-01-05 09:23:39 - random channel

**river_shah**

hmmm, maybe look up multi period mean variance optimization papers. [https://opus4.kobv.de/opus4-zib/files/418/SC-99-30.pdf](https://opus4.kobv.de/opus4-zib/files/418/SC-99-30.pdf)

---

## 2021-01-05 09:19:36 - random channel

**river_shah**

I will just make a heuristic argument (although there is an exact answer and I need to look up the paper)

Typically in real world situations the kelly size bet is usually a small fraction (i.e one third or half kelly) as is the edge for any given bet. Considering the bets are independent, I would just bet with same bank roll assumption

---

## 2021-01-05 09:10:36 - random channel

**Oliver Varney**

morning chaps, just a general question on staking for those that use kelly style staking, but in the scenario where you have one bet that settle in like 1 hour lets say, then a second new bet comes along which settles in a few minutes, what % of bankroll are you basing the second bet on? Are you basing the bet on the bankroll what you have available at the time of bet or do you attribute some value to the initial bet?

---

## 2021-01-05 08:22:37 - issues channel

**mandelbot**

On a seperate note why would an order not get matched even though it's taking the price available?

`"orders": ["138291273086345874"], "notes": "", "market_notes": "6.6,6.8,6.8", "status": "Pending", "status_log": "Pending"}, "order_type": {"order_type": "Limit", "price": 6.8, "size": 59.64, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 59.64, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "responses": {"date_time_placed": "2020-11-08 04:39:45.242000", "elapsed_seconds_executable": null}, "runner_status": null, "status": "Executable", "status_log": "Pending, Executable", "violation_msg": null, "simulated": {"profit": 0.0, "piq": 33.57, "matched": []}}`

`{"asctime": "2021-01-05 08:15:08,634", "levelname": "INFO", "message": "Trade status update: Live", "id": "1fd92291-4f2e-11eb-bc86-5c969d7d9766", "strategy": "projectedBotAUSHR", "place_reset_seconds": 0.0, "reset_seconds": 0.0, "orders": ["138291273086345874"], "notes": "", "market_notes": "6.6,6.8,6.8", "status": "Live", "status_log": "Pending, Live"}`

---

## 2021-01-04 22:12:27 - issues channel

**Lee**

[https://github.com/liampauling/flumine/blob/707a81990d1c51d64e964c781c5e700fe58646de/flumine/strategy/strategy.py#L158|https://github.com/liampauling/flumine/blob/707a81990d1c51d64e964c781c5e700fe58646de/flumine/strategy/strategy.py#L158](https://github.com/liampauling/flumine/blob/707a81990d1c51d64e964c781c5e700fe58646de/flumine/strategy/strategy.py#L158|https://github.com/liampauling/flumine/blob/707a81990d1c51d64e964c781c5e700fe58646de/flumine/strategy/strategy.py#L158)

---

## 2021-01-04 20:15:01 - issues channel

**Lee**

What happens in the case of duplicating a strategy? An order from each strategy will be combined into one packaged and one of them will be ignored?

---

## 2021-01-04 08:54:57 - general channel

**river_shah**

After a restart, how do I ensure that strategy exposures for each selection take into account all filled orders please? Currently the exposures get reset to 0.

---

## 2021-01-04 04:16:22 - random channel

**Misha**

If your model is really good you just ratchet it up until you can't put any more money on without eating into your profits

---

## 2021-01-03 20:36:57 - random channel

**Chris**

Not particularly betfair related more general betting, wonder if anyone can help. When calculating EV for a bet if I have a “true price” obviously the calc is fairly simple but I’ve some markets where dead heats are common. If I know how often that a dead heat would occur (from my calculations) how could I calculate the EV to account for that. Or should that be included in my original estimates price and factored in there?

---

## 2021-01-03 16:25:59 - strategies channel

**JC**

Yes BPE is on and in backtesting these matches are actually favourable and seem to have positive EV. So I want BPE to be on. I'm just hoping that the real matching is the same as in simulation. If so, the strategy must be placing bets at times of extreme volatility in order to get these kind of results.

---

## 2021-01-03 16:18:00 - strategies channel

**JC**

Thanks, just found it on mobile and it is switched on. Couldn't find a page that looks like that on desktop. R.e. example - I will run the strategy against some of todays markets and compare with real matching and let you know. In backtesting there are some crazy differences like backs getting average price matched at 7.6 when posting at 1.01. The strategy offers backs at best available lay price and shouldn't cross the spread, so it seems weird

---

## 2021-01-03 16:03:29 - general channel

**liam**

When live trading market filter is a `streaming_market_filter` but when backtesting you instead pass the `markets` var so in your example above "market_types" is ignored when backtesting

---

## 2021-01-03 15:57:48 - general channel

**Matthieu Labour**

Thank you. I am a bit confused on how to build `market_filter` when creating a strategy. For example, I can create the dictionary with `market_types` and `markets` keys. However, I wanted to use a factory method such as `def streaming_market_filter`  but it does not have `markets` . Will the following work?

```   market_filter = {

        "market_types": [

            "MATCH_ODDS",

        ],

        "markets": [market],

    }```

---

## 2021-01-03 15:46:01 - strategies channel

**JC**

I'm testing an in-play strategy and in backtesting I am often getting matched at much better prices than I post due to BPE and the 1 second delay (I imagine). Has anyone found flumine's matching to be more generous than the odds matched when using real money? These favourable prices are contributing massively to the profitability of the strategy in backtesting

---

## 2021-01-03 15:03:10 - general channel

**Matthieu Labour**

Hi, looking for guidance. When backtesting and filtering on market_type, would you recommend the following

```    market_filter = {

        "market_types": [

            "MATCH_ODDS",

        ],

        "markets": [market],

    }



    strategy = MyStrategy(

        market_filter=market_filter,

        max_order_exposure=1000,

        ...

    )```

or

```    strategy = MyStrategy(

        market_filter={"markets": [market]},

        max_order_exposure=1000,

        max_selection_exposure=1000,

    )



class NyStrategy(BaseStrategy):

        def check_market_book(self, market, market_book):

            if market.market_type not in ['MATCH_ODDS']:

                return False```

Thank you!

---

## 2021-01-03 14:04:06 - general channel

**Dave**

Liking the optimizations [@U4H19D1D2](@U4H19D1D2) , glad to see less attribute lookups!

---

## 2021-01-03 12:57:44 - issues channel

**JC**

this is the start of the log

`{"asctime": "2021-01-03 12:45:09,144", "levelname": "ERROR", "message": "Execution error", "trading_function": "place", "response": "SportsAPING/v1.0/placeOrders \nParams: {'marketId': '1.177514173', 'instructions': [{'orderType': 'LIMIT', 'selectionId': 24003006, 'side': 'BACK', 'handicap': 0, 'limitOrder': {'price': 2.02, 'persistenceType': 'LIMIT', 'size': 4}, 'customerOrderRef': 'ec2e3b2b42f12-138289707090911470'}], 'customerRef': '833f4dc64dc111eb97cd0a1ab5524ac8', 'customerStrategyRef': 'ip-172-31-40-12', 'async': False} \nException: None \nError: {'code': -32602, 'message': 'DSC-0018'} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}", "order_package": {"id": "833f4dc6-4dc1-11eb-97cd-0a1ab5524ac8", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f59562b9a50&gt;", "market_id": "1.177514173", "orders": ["138289707090911470"], "package_type": "Place", "customer_strategy_ref": "ip-172-31-40-12"}}`

---

## 2021-01-03 12:51:09 - issues channel

**JC**

I'm running a strategy via flumine and getting the following response error from Betfair, anyone got any idea what might be going wrong? The strategy worked fine in backtesting



`{"asctime": "2021-01-03 12:50:30,712", "levelname": "ERROR", "message": "Execution error"`



`\nException: None \nError: {'code': -32602, 'message': 'DSC-0018'} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}`

---

## 2021-01-03 12:30:22 - general channel

**steve**

just using this



market_books = trading.betting.list_market_book(

    market_ids=['1.177514198'],

    price_projection= bflw.filters.price_projection(price_data=['SP_AVAILABLE','SP_TRADED','EX_BEST_OFFERS','EX_ALL_OFFERS','EX_TRADED','SP_PROJECTED'])

    )

for runner in market_books[0].runners:

    print(runner.sp.near_price, runner.sp.far_price)

---

## 2021-01-03 11:57:02 - general channel

**steve**

hi guys new to using live odds. im trying to find the near_price and far_price bsp, but keep getting 'None'. Can get the back and lay prices ok. i'm using the following code. anyone know what im doing wrong?



price_filter = bflw.filters.price_projection(

    price_data=['SP_AVAILABLE','SP_TRADED','EX_BEST_OFFERS','EX_ALL_OFFERS','EX_TRADED']

    )

market_books = trading.betting.list_market_book(

    market_ids=[1.177514203],

    price_projection=price_filter

    )

for runner in market_books[0].runners:

    print(runner.sp.near_price)

    print(runner.sp.far_price)

---

## 2021-01-03 01:53:46 - strategies channel

**birchy**

[@UGV299K6H](@UGV299K6H) agree on the 15% match rate being low, I generally prefer 50%+ and that's something I'm working towards. Bets are cancelled after 100ms as this is a geegees inplay strategy... perhaps not long enough?

---

## 2021-01-03 00:42:27 - strategies channel

**Michael**

I agree with [@U0128E7BEHW](@U0128E7BEHW)’s advice but I'd add that 15% matched seems very low to me. People's operations differ but personally I look to get a much higher proportion on, like maybe 70% for a purely market based strategy.  Might you be asking for too much value? Have you tried asking for less? Also at just 15% matched I'd bet that the orders that do match do so quite a long time after being posted (unless you're cancelling most of your transactions quite quickly). If your bets match too slowly then the signals you're using are rendered ineffective because they've likely expired by the time your money is taken. Any profit that's left probably either comes from the spread or from skimming a bit of noise - either way it won't be much and won't scale well.

---

## 2021-01-02 22:00:58 - general channel

**Charlie 303**

Would it be safe to say that BSP on horse win markets will pretty much always beat racebook win odds?  Have a win ticket strategy at the racebook that just breaks even, so I would intuit that if I simply mirrored the strategy on exchange, backing my selections at BSP would make it profitable....but im wondering if that logic is flawed / if i'm overlooking the dynamics of bsp in practice

---

## 2021-01-02 20:38:35 - strategies channel

**Mo**

But as a profitable strategy by itself? No

---

## 2021-01-02 20:34:32 - strategies channel

**birchy**

I'm sure this has been asked before but I can't find it in the slack history...

Say you have a strategy that you backtest using Flumine. After ~6k matched bets (match rate ~ 15%, so ~40k bets submitted), it shows -0.1% ROI calculated from `total_pnl / total_risk`, where total risk is the sum of each bet risk rather than the net risk per market. No commission is deducted and each matched bet is deducted from the available volume.

Would you push this strategy to real money? I'm thinking no, but have not (yet) compared a Flumine backtest vs live, so have no idea how matching, P&amp;L, etc compares.

---

## 2021-01-02 17:04:04 - general channel

**Alessio**

AWS folks who run their production strategy there, which instance kind do you use? Is something in the free tier powerful enough (esp. in terms of RAM) ?

---

## 2021-01-02 12:26:21 - general channel

**Mo**

Where benchmark.py is:



```import time



import betfairlightweight

from tqdm import tqdm

from tqdm import trange

from betfairlightweight import StreamListener



trading = betfairlightweight.APIClient("username", "password", "app_key")

listener = StreamListener(max_latency=None)

stream = trading.streaming.create_historical_generator_stream(

            file_path="/tmp/1.172557162",

                listener=listener,

                )

gen = stream.get_generator()

# Warmup

number_of_market_books = sum(1 for market_books in gen())

start_time = time.time()

for _ in trange(10):

    for market_books in tqdm(gen(), total=number_of_market_books):

        pass

print(time.time() - start_time)```

---

## 2021-01-02 08:05:45 - general channel

**Matthieu Labour**

Thank you. I will try. This will work for live but not for backtesting, correct? The strategy code will be different depending on backtesting or live, correct?

---

## 2021-01-02 07:53:23 - general channel

**liam**

You can ensure by setting `strategy.streaming_timeout` to a value such as 5, this will result in the cache being snapped every 5s and a market book event being sent through regardless of an update 

---

## 2021-01-02 06:17:39 - general channel

**Charlie 303**

Trying to collate BSP csv data (from [https://promo.betfair.com/betfairsp/prices](https://promo.betfair.com/betfairsp/prices)) and bf historical for the same market -- BSP data gives only the 'event_id', so I figured I could get the corresponding historical data by using the eventId filter, but neither trading.historic.get_file_list(... event_id) in betfairlightweight, nor the crappy download form at [http://historicdata.betfair.com/$/mydata|historicdata.betfair.com/$/mydata](http://historicdata.betfair.com/$/mydata|historicdata.betfair.com/$/mydata) works. Has anyone used eventId filter successfully or otherwise have any hints to get the corresponding historical market id(s) associated with a target event from a BSP file? I suppose I could just download all markets on a given day and grep through the entire collection for the eventId

---

## 2021-01-01 22:24:50 - general channel

**Matthieu Labour**

Hello! I am looking for some guidance in Flumine. How to receive a timeout in a strategy. Let’s say I want a strategy to get a notification some time before a market starts. Would you recommend having a background worker send the notification? Ideally the solution should work for both live and backtesting.

---

## 2021-01-01 14:42:28 - general channel

**Misha**

Started with bet sizes today, that if the modelling is good, will now pay my way. If it works I can increase that 10-fold relatively easily. I'm chasing a bigger pay-day because I think we can get there

---

## 2021-01-01 14:29:59 - general channel

**D C**

[@U016535QCJ2](@U016535QCJ2) I am surprised you don't look at horses more given this inside knowledge of how these big clients work. I mean you know that these orders are coming in and you know roughly when they will come and how they are filtered into the market. How are you not able to use this to your advantage? After all, as you say, YOU wrote the software so this must be a HUGE edge knowing that these price moves are coming? I realise without model parameters you won't know WHAT is going to be backed, but knowing how the orders are pushed through must mean you have sufficient knowledge to take advantage of this?

---

## 2021-01-01 14:21:22 - general channel

**Misha**

The reasoning is that you use a model that prices the entire field. You back/lay anywhere you think you have a significant advantage, and it stands to reason that if you think a 1.50 runner should be at 1.30, a back. most of the rest of the field will be lays

---

## 2021-01-01 12:08:08 - issues channel

**Dave**

Well, at least newer versions of python use a faster decimal implementation. Generally I like to keep things as fast as possible, maybe in real-time trading it doesn't matter too much given network bottlenecks and whatnot, but if it cuts my backtesting time 10x due to a large number of markets pumping through at once then I find that to be a win. For me, decimal slowdown is indeed negligible.

---

## 2021-01-01 11:51:50 - general channel

**Graham**

the whole process really. I've trained plenty of models with varying degrees of success. But, it's a rather isolating experience and I don't have the network with sufficient domain knowledge &amp; coding to just throw ideas around.

---

## 2021-01-01 11:38:07 - issues channel

**liam**

however if you have logging setup the warnings will show if you set [https://github.com/liampauling/flumine/blob/707a81990d1c51d64e964c781c5e700fe58646de/flumine/strategy/strategy.py#L45|log_validation_failures](https://github.com/liampauling/flumine/blob/707a81990d1c51d64e964c781c5e700fe58646de/flumine/strategy/strategy.py#L45|log_validation_failures) to True

---

## 2021-01-01 11:37:17 - issues channel

**liam**

yeah you have the trade count limit and the strategy investment limit (default is 1 live order per runner per strategy)

---

## 2021-01-01 11:37:10 - issues channel

**birchy**

That's a Flumine default. I found it when trying to backtest a strategy with &gt;1 trade per runner. Just set it to 2+ and job done.

---

## 2021-01-01 11:29:09 - general channel

**Graham**

It's not quite the intention of this slack group, but if anyone's interested in collaborating on a Horse Racing pricing model I'd welcome the help.

---

## 2021-01-01 10:52:20 - issues channel

**liam**

might be easier if you share the code if possible? Single trade? what does the strategy initialisation look like?

---

## 2021-01-01 10:39:11 - issues channel

**PeterLe**

Well Im ashamed to say that Ive never run model as such, although I do run 8/9 accounts every day and compare/contrast using real money; works just fine for me (all in profit)

It’s a reoccurring theme on here. I whole heartily agree that GCSE maths is quite sufficient to take you to seven figures (and beyond). So for those of you who haven’t got a Phd in maths all is not lost, don’t give up.

Test sensibly (using a well thought out idea, £2 Stakes), observes results, hone and refine.Why think up complicated strategies when there are simple ones aplenty :+1:

---

## 2021-01-01 09:52:27 - issues channel

**Michael**

I find I have a lot in common with [@U4H19D1D2](@U4H19D1D2) when it comes to strategy development, although I think I'm more into drilling into the detail of my bets than he is. I note that [@ULDAVFDRP](@ULDAVFDRP)'s comments are made at 2am and that the tone and grammar might suggest a little influence of alcohol...? Even so I can put my hand up for quite a bit of it. I also have very little maths training - nothing above GCSE. I don't even know where to start with advanced maths but I've done just fine like that and I'm still growing. As I understand it [@ULDAVFDRP](@ULDAVFDRP) is a premium account holder? If so that means he's done pretty well too - presumably well into six figures at least which is much more than most of the statistics experts. Higher level maths may be useful but it certainly neither necessary nor sufficient. One thing I'm sure every winning player will agree on is that projections mean very little until you have real money in the market. We've all seen how easy it is to write what seems like a brilliant model only to see it totally fail when you try getting money down. That happens because of mechanisms that never entered your model, you don't see them coming and sometimes you don't understand them even afterwards. Over time we learn to temper our confidence in our projections and base it on our history instead.

---

## 2021-01-01 09:14:28 - general channel

**Oliver Varney**

so in that sense [@U01A64T6DJQ](@U01A64T6DJQ) knowing who money is whos can be profitable, but if my model says its value, I dont care who im matching against. For me if you start questioning the model you get into sticky situations (blind gambling)

---

## 2021-01-01 09:08:42 - general channel

**Oliver Varney**

I did chat to someone whos entire strategy was to copy my bets, but I was a little easier to identify then the typical person when betting with that strategy

---

## 2021-01-01 08:47:30 - general channel

**Mo**

I think it's not very insightful to have an overall figure per race but if you can identify the breakdown per horse I think it can be the basis of a profitable strategy

---

## 2021-01-01 07:00:36 - issues channel

**liam**

Ignoring TPD my strategies are based purely off the market with the modelling more on execution to improve matching rates 

---

## 2021-01-01 06:57:40 - issues channel

**Misha**

[@U4H19D1D2](@U4H19D1D2) - Are you modelling off market movements? Or a statistical model?

---

## 2021-01-01 06:45:19 - issues channel

**liam**

Funny how we all approach the game differently, for me it’s all about taking a simple idea and getting in the market with real money. See what works and what doesn’t, iterate to maximise profit/matching and move on.



I think the longest I have spent on making a model was a day (I get bored very quickly developing strategies) but that was only because I was crunching a few years of inplay data.

---

## 2021-01-01 06:41:18 - issues channel

**Sam Asin**

sometimes i also think you can just catch things that are really hard to get in a model. Like pick up on a subtle pattern. Especially if you're dealing with limited data.

---

## 2021-01-01 02:08:04 - issues channel

**Misha**

I just stick to tennis. My knowledge of horses wouldn't amount to enough to build a decent model

---

## 2021-01-01 02:05:09 - issues channel

**Oliver Varney**

I work with an AI model, you maths guys are far too smart for me, im literally retarded in comparison, yet id guess my  model would outperform yours quite easily in pre off horses

---

## 2021-01-01 02:01:58 - issues channel

**Misha**

I suspect that you work from market movements rather than stats, so a different "type" of model (my approach might not be applicable)

---

## 2021-01-01 01:54:09 - issues channel

**Misha**

In my case it has been the most important thing. It allows me to focus on things that matter and increase the accuracy of the model. But I am looking at a sport, not prices

---

## 2021-01-01 01:51:12 - issues channel

**Oliver Varney**

fuck understanding your data the model does this for you

---

## 2021-01-01 00:24:29 - issues channel

**Misha**

One thing that might be different to many others is that I am building a model based on historical tennis results, so apart from using a starting price (calculated) for each match, I don't use pricing data at all in my model

---

## 2021-01-01 00:22:57 - issues channel

**Misha**

I spend a huge part of my time "cleaning" data, and another huge part of my time just looking at it by running query after query. I have several data sets for different purposes (historically sourced data, live collected data, etc) and it's all in databases on SQL server. I have probably run an average of 100 hand-crafted queries per day for the last 3 months on my data. My view is that you really really need to understand your data. The longer I go the more insights I get from the data. Also remember I use absolutely no ML (my partner working on his model does)

---

## 2020-12-31 23:59:37 - general channel

**Oliver Varney**

Its a question that is irrelevant especially if your starting out. profit is profit. Will the answer to that question change a non profitable strategy into a profitable one?

---

## 2020-12-31 17:05:00 - random channel

**Michael**

Might be worth noting that I haven't had this warning email, I don't think [@UBS7QANF3](@UBS7QANF3) or [@U4H19D1D2](@U4H19D1D2)  mentioned receiving it either, which might suggest that there is at least some targeting going on and it could be worth those who got it taking a look at their transactions. Quite apart from transaction charges posting a lot of transactions without getting them matched is rather pointless and not really indicative of a well optimised strategy.

---

## 2020-12-31 16:53:22 - general channel

**liam**

High level is you build cache of the alt data (pt: data) and then do a lookup based on the marketBook pt and inject it into the context for your strategy to use (just like live) 

---

## 2020-12-31 15:59:59 - general channel

**liam**

Like many on here I keep all data in raw streaming form and then process when backtesting / modelling into ram using redis or just massive text files 

---

## 2020-12-31 14:25:20 - issues channel

**MacrcoPolo**

What I love about folk who want to do datascience is that they're generally obsessed with complex models and hitting the .fit() method on tensor flow, when actually spending time making sure your data is clean and working on sensible features is 95%+ of the job...

---

## 2020-12-31 12:46:05 - general channel

**river_shah**

Currently I am using cloud service providers for back testing however when it comes to live trading, just launching scripts off my London based laptop (have high bandwidth reliable residential broadband). Could I please be guided on what the best way to run a prod model may be from a colo perspective? Speed is not so important to me but if I can get a few milliseconds for free running from AWS Dublin or some other location, won’t say no to it. Think this topic was discussed earlier but search history has run out. Thanks

---

## 2020-12-31 12:36:31 - issues channel

**Misha**

Early stages yet - model will take another 12 months to get to a decent maturity (as you well know)

---

## 2020-12-31 12:29:05 - issues channel

**Mo**

How are you calculating the market probability that you compare your model against with the Brier score?

---

## 2020-12-31 12:25:44 - issues channel

**Mick**

I am reading the back bet odds/size with the following..

price_filter = betfairlightweight.filters.price_projection(price_data=['EX_BEST_OFFERS'])

market_books = trading.betting.list_market_book(market_ids=[mk_id],price_projection=price_filter)

...and I see the set of three back prices just like on the exchange website. Early in the

morning the best back price available may be stable for many minutes on end (maybe even longer).

However when I actually programatically place an order with trading.betting.place_orders, I

very often find that I succeed in getting an even better price. Why might that be?

---

## 2020-12-31 10:21:25 - issues channel

**Misha**

The second one. For this model I never look at the Betfair price at all until I decide whether to bet. I come up with my own probabilities just from the historical stats and the current score

---

## 2020-12-31 10:01:05 - issues channel

**Alessio**

[@U016535QCJ2](@U016535QCJ2) out of curiosity and if you don't mind. Do you start from BF odds and refine them or do you have a complete model on the side and only compare it with BF at the very end?

---

## 2020-12-31 09:52:05 - issues channel

**mandelbot**

How can I write errors/orders from a strategy to a text file?

---

## 2020-12-31 08:38:08 - issues channel

**Misha**

Neither can be measured directly, because the outputs are the model, and you shouldn't set a threshold just to get better results from the model (neither give anything like linear results as I change thresholds, and the "noise" is significant)

---

## 2020-12-31 08:32:55 - issues channel

**Dave**

[@U016535QCJ2](@U016535QCJ2) what do you mean by your model "only uses a few arbitrary thresholds"? Surprised your thresholds are arbitrary and not set empirically?

---

## 2020-12-30 23:33:11 - issues channel

**Misha**

And then once you "solve" them, keep looking for more "elegant" solutions. By elegant I mean simpler and less moving parts. My model that I have refined over the past few months uses a "minimal" set of data and only a few arbitrary threshold values. It's now much simpler than it was a month ago

---

## 2020-12-30 23:25:21 - issues channel

**Misha**

BTW, I have a model for tennis in-play that works and relies on no higher-level maths or machine learning other than basic statisitcs

---

## 2020-12-30 23:10:57 - issues channel

**D C**

Don't see it myself. An expert in number theory would not be much use at modelling.

---

## 2020-12-30 23:09:48 - issues channel

**D C**

Pure Maths [@U016535QCJ2](@U016535QCJ2) ? That is quite unusual. Usually pure maths is the abstract stuff that is of little direct use in modelling. Applied maths, particularly stuff like nonlinear optimisation and stats would be a far better background for a pro gambler.

---

## 2020-12-30 21:40:43 - issues channel

**Misha**

We are ramping up bet sizes on January 1 to a level that should easily exceed 2 full time wages, if the modelling is good. Have been betting at lower levels for about 3 months so :crossed_fingers:

---

## 2020-12-30 21:38:34 - issues channel

**Misha**

I also know the limits to my skills (I am definitely no gun modeller), as does my partner, who although has worked as a software developer for decades, leaves the system development to me

---

## 2020-12-30 21:30:31 - issues channel

**Misha**

The last client employs over 100 people. But the model is developed by only one person

---

## 2020-12-30 20:51:33 - issues channel

**Misha**

My client was one of the big ones. Biggest profit on Betfair was UK racing (running with their model on my software). They did horse racing worldwide, and their main source of income was Asian exotic bets (across multiple selections/races)

---

## 2020-12-30 17:38:58 - general channel

**Artur Gräfenstein**

Does anyone have any idea where to get the exact live time for a soccer event? Many providers are a little imprecise. The time on the Betfair website is about 1-2 minutes delayed. I need the time quite accurately for my model.

---

## 2020-12-30 16:13:28 - general channel

**Artur Gräfenstein**

I’m trying to develop my first model. I wanted to do it next year, but you can never start early enough. :smile:

---

## 2020-12-30 14:21:10 - issues channel

**river_shah**

Maybe talent acquisition and retention, formalizing risk management, modelling process benefits. I guess anytime the scale goes 20+ people need more formal procedures / corporatization in place. Not sure re tax benefits

---

## 2020-12-30 12:22:20 - random channel

**Oliver Varney**

nope, only if, but in this case (and thinking generally) the combination of the strength of all my separate models (operating on slightly different features + times), plus the doubling of price, raises the question of how to evaluate these situations. All typical metrics suggest that pre off it was a bad bet. Probably just falls under the category of not worth the time looking into.

---

## 2020-12-30 12:11:53 - issues channel

**Misha**

And no. I never had access to the model :joy:

---

## 2020-12-30 12:00:22 - random channel

**Oliver Varney**

there is a limit per strategy runner based on prediction strength / odds. This is preoff horses, even before the race has started. I guess im wondering how I could measure / quantify this scenario. To have the combination of me betting on something + the price increasing + the horse winning leaves me with a very small samples size as [@U4H19D1D2](@U4H19D1D2) has just said

---

## 2020-12-30 11:51:52 - random channel

**Misha**

Can't speak for horse racing but the model I currently have for tennis in-play (still working on it, nowhere near mature), often piles onto a player that, when you watch the match, looks to be throwing money down the toilet. And sometimes it does. Yet when I ran the numbers on the matches where I bet very one-sided, I have roughly the same POT% as other matches. So I just let the numbers be a guide

---

## 2020-12-30 10:12:44 - issues channel

**Mo**

I think your point that losing -2% was good because it's less than the spread which I agree with but I wanted to point out that -2% after commission would be close to gross break even and gross break even strategies can be net profitable when combined with a strategy that generates premium charge

---

## 2020-12-29 21:33:58 - issues channel

**Alessio**

let's say you go for a very simple strategy, in a binary market (say, over/under X) always back Under, fixed small stakes (say, 5 bucks)

---

## 2020-12-29 10:17:40 - strategies channel

**Mo**

My view is that you would be crazy to unnecessarily introduce 150ms of latency when betting in-play

---

## 2020-12-29 10:08:06 - strategies channel

**Oliver Varney**

just thinking as the view of the market will be different in terms of perceived volumes by the model vs live trading. I assume virtual prices will be show much larger volume due to crossmatching?

---

## 2020-12-29 09:58:14 - strategies channel

**Oliver Varney**

[@UBS7QANF3](@UBS7QANF3) so if you model trained on non virtual (with volume features), do you essentially have two market streams (virtual &amp; Non virtual)? If im understanding this correctly

---

## 2020-12-28 20:31:07 - general channel

**nthypes**

What about _*Hierarchical Bayesian Modeling*_

---

## 2020-12-28 13:37:07 - general channel

**Oliver Varney**

I found it very useful at the start, still nice and quick to use these days. I have all the historical pro data now so I can get more specific pricing stuff from that when building models

---

## 2020-12-28 13:22:46 - general channel

**Mo**

My point is that building a model (classifier) by weighting different features has nothing to do with Bayes

---

## 2020-12-28 13:21:57 - general channel

**Mo**

That’s not my point. The use of conditional probability to account for uncertainty in which horse will be the most traded is still an option (note that this is just a question of conditional probability and nothing to do with Bayes theorem) because you do not which horse will be the most traded at the time of betting

---

## 2020-12-28 13:09:18 - general channel

**Mo**

It sounds like you want to use the indicator whether a horse is the most traded horse as a feature in a model and then add more features

---

## 2020-12-27 15:15:14 - general channel

**Rory**

I still have the question of the best (flumine) way to get that data from the BackgroundWorker to the Strategy. In the simple case, I suppose the strategy could just have a queue of trades that gets pushed to.

---

## 2020-12-27 14:55:41 - general channel

**Oliver Varney**

For me I use a flumine process for everything apart from model prediction which I run in a separate process and use redis streams to push to and read from. If you not doing anything super complicated Flumine can handle quite a few strategies in one process.

---

## 2020-12-27 14:40:14 - general channel

**Rory**

quick question ...



I currently have separate processes for market streaming, decision making, order placement (and lots of other stuff) e.g.



Stream market updates-&gt;topic-&gt;Decision Maker-&gt;topic-&gt;Order Placement-&gt;Betfair



I use Bflw for streaming, order placement etc and this all works very well. However, I'd like to integrate with flumine. I'm thinking something like this based on the poll_market_catalogue pattern ...



Flumine Strategies-&gt;process_market_book-&gt;topic-&gt;Decision Maker-&gt;topic-&gt;Flumine Background Workers-&gt;???-&gt;Strategy-&gt;place_order



I've set up a quick test and this works fine. The custom BackgroundWorkers poll for messages. My question is, what's the best way place a trade, based on the message received by the BackgroundWorker and have that Trade available in Strategy.process_orders?

---

## 2020-12-27 13:54:28 - random channel

**Mo**

Probably explanations of specific models for different sports

---

## 2020-12-27 13:51:09 - random channel

**Mo**

Yeah that offer was related to the idea of a general betfairlightweight/automated betting knowledge base. Still waiting for [@U4H19D1D2](@U4H19D1D2) to organise it :wink:

---

## 2020-12-27 13:26:14 - strategies channel

**Oliver Varney**

can see advantages for both. pickling would be nice if you could see the state of the market (last market book)/ strategy  when trades were created, but that seems alot more work I guess

---

## 2020-12-27 13:15:21 - random channel

**Alessio**

[@UBS7QANF3](@UBS7QANF3) I was pointing out to your 'offer' that mandelbot reposted the other day about sport modelling.. on my side the only thing i can contriute is what i read and what i understood :stuck_out_tongue:

---

## 2020-12-27 13:13:42 - strategies channel

**mandelbot**

literally just starting thinking about this, how do you output such data frames? from from the strategy or the backtest itself? do you write them to a file or something?

---

## 2020-12-27 13:06:23 - strategies channel

**liam**

Yeah was going to add a dataframe which contains some stats such as profit/sharpe ratio/roi/match rate per strategy etc and then a series of graphs with text on what to look for etc.

---

## 2020-12-27 13:03:31 - strategies channel

**liam**

ha this is just the LowestLayer strategy on 30ish markets

---

## 2020-12-27 13:02:07 - strategies channel

**Unknown**

Working on a three line addition when using flumine to get a jupyter notebook to start on backtest completion :sunglasses:



Very much a work in progress but could form the start of an interactive strategy development tutorial or tear sheet:



```control = JupyterLoggingControl()

framework.add_logging_control(control)

...

control.launch()```

Welcome any thoughts?

---

## 2020-12-26 20:47:03 - random channel

**thambie1**

Congrats Alessio! Curious, what approach are you taking? Generating models from historical football data, statistical arbitrage, etc?

---

## 2020-12-26 20:45:56 - random channel

**Alessio**

I mean, in soccer, there are only a bunch of papers most of which get you worse results than Nate Silver's model :stuck_out_tongue_winking_eye:

---

## 2020-12-26 20:45:26 - random channel

**Alessio**

[@UBS7QANF3](@UBS7QANF3) before mentoring, i think maybe getting to some sport modelling for real would be good. happy to find something to contribute (if I can) to make sure it doesn't look like there's a bunch of newbies leeching from the more experienced people.

---

## 2020-12-26 20:43:57 - random channel

**Alessio**

Get my first profitable strategy :wink: And tbh, if i can contribute to something to basic things for others more than happy to. Flumine has really been a saver into understanding where my ideas would break

---

## 2020-12-26 18:02:26 - random channel

**Artur Gräfenstein**

1) Create an open API to connect different data providers.

2) Develop a mobile app that shows your betting earnings and some statistics (can be used by anyone).

3) Develop a new profitable strategy

---

## 2020-12-26 18:02:10 - general channel

**nthypes**

Folks, anyone with good statistics background that I can DM? I have a question abouta  probability model.

---

## 2020-12-26 18:00:41 - random channel

**Oliver Varney**

not sure it will happen next year but a reinforcement learning inplay model

---

## 2020-12-26 17:59:56 - random channel

**D C**

Scale up IP stuff and start trying to model pre-off horse SP / closing prices. Not sure how far I will get fitting that in around the day job but have to at least get it started.

---

## 2020-12-26 17:55:21 - random channel

**liam**

Anyone got any exciting 2021 plans/intentions/goals when it comes to betting? 



Personally I am looking to get flumine in a solid state as I am half way to migrating all my strategies to it. Also looking to roll my own container orchestration / auto scaling cluster / API so I can better monitor / spin up strategies and backtest pipelines  

---

## 2020-12-26 17:52:28 - general channel

**Oliver Varney**

kinda a similar topic but do you guys measure how one model impacts another ?

---

## 2020-12-26 17:50:12 - general channel

**Oliver Varney**

wouldnt be intentional in my case, the model is the brains in the outfit :joy:

---

## 2020-12-26 17:48:20 - general channel

**Mo**

It will depend on the context I am sure. If you are manipulating the market in the way [@UUE6E1LA1](@UUE6E1LA1) describes or you are using it for premium charge avoidance as I have been party to then they will shut it down quickly. If you have the situation you’re describing with a rare model disagreement then they probably don’t care or it’s less visible

---

## 2020-12-26 17:45:51 - general channel

**Oliver Varney**

thats not really out of the question for me, two models can disagree

---

## 2020-12-25 09:27:36 - strategies channel

**Oliver Varney**

I think its quite hard to use that param to control stuff if you have both backs and lays under the same strategy or if you have variable stake sizes / exposures in my opinion. The selection exposure function might be worth checking if you havent found it already [https://github.com/liampauling/flumine/blob/ab25ef0fcfd42cff461145c0f83fc43f8a9a0ca3/flumine/markets/blotter.py#L110](https://github.com/liampauling/flumine/blob/ab25ef0fcfd42cff461145c0f83fc43f8a9a0ca3/flumine/markets/blotter.py#L110)

---

## 2020-12-24 17:07:18 - strategies channel

**birchy**

Flumine validation checks should do that for you?

[https://github.com/liampauling/flumine/blob/ab25ef0fcfd42cff461145c0f83fc43f8a9a0ca3/flumine/strategy/strategy.py#L30|https://github.com/liampauling/flumine/blob/ab25ef0fcfd42cff461145c0f83fc43f8a9a0ca3/flumine/strategy/strategy.py#L30](https://github.com/liampauling/flumine/blob/ab25ef0fcfd42cff461145c0f83fc43f8a9a0ca3/flumine/strategy/strategy.py#L30|https://github.com/liampauling/flumine/blob/ab25ef0fcfd42cff461145c0f83fc43f8a9a0ca3/flumine/strategy/strategy.py#L30)

---

## 2020-12-24 14:47:42 - random channel

**Oliver Varney**

Hey chaps, techy question, currently I use SQL Server as my database software (locally). I am starting some work that will basically give me a chance to remodel all my database work going forward. I run everything locally atm but there is scope for this side project to be run on AWS / cloud and my stuff also down the line. Am I right in thinking there is high license fees for SQL server on AWS? If so what opensource/free SQL databases would people recommend

---

## 2020-12-24 14:15:12 - random channel

**Misha**

[@UPMUFSGCR](@UPMUFSGCR) - you don't have access to Liam's modelling :joy: The framework is just a tool

---

## 2020-12-24 11:58:39 - strategies channel

**Ruben**

Good morning everyone, I'm trying to test my first strategy with fixed stakes, and I would like to add an exposure control so that the maximum amount I bet into any selection is, for example, 5 EUR.



For back bets, I believe this would be equivalent to limiting the max exposure of the selection to 5, but for lay bets its a bit trickier since it the exposure depends on the odds.



Since I would like this control to happen in the same place for both back/lay bets, is the best way to go about this to just implement an instance of TradingControl that specifically handles this "max bet stakes"? This could be as simple as just allowing to bet once per selection_id, with fixed stakes.

---

## 2020-12-23 16:08:36 - general channel

**birchy**

That's with at least one fully matched order according to `process_orders()`  in my strategy.

---

## 2020-12-23 12:26:41 - issues channel

**mandelbot**

Not sure what mandatory field im missing?



```{"levelname": "ERROR", "message": "Execution error", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\flumine\\execution\\betfairexecution.py\", line 196, in _execution_helper\n    response = trading_function(order_package, http_session)\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\flumine\\execution\\betfairexecution.py\", line 39, in place\n    return order_package.client.betting_client.betting.place_orders(\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\betfairlightweight\\endpoints\\betting.py\", line 500, in place_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 55, in request\n    self._error_handler(response_json, method, params)\n  File \"C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 81, in _error_handler\n    raise self._error(response, method, params)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/placeOrders \nParams: {'marketId': '1.17', 'instructions': [{'orderType': 'LIMIT', 'selectionId': 2, 'side': 'BACK', 'handicap': 0, 'limitOrder': {'price': 6.0, 'persistenceType': 'LAPSE', 'size': 2, 'timeInForce': 30}, 'customerOrderRef': '662fae5f621ab-138280164330968924'}], 'customerRef': 'aa6e175d451311ebaa7f020100017805', 'customerStrategyRef': 'ID17805', 'async': False} \nException: None \nError: {'code': -32602, 'message': 'DSC-0018'} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}", "trading_function": "place", "response": "SportsAPING/v1.0/placeOrders \nParams: {'marketId': '1.17', 'instructions': [{'orderType': 'LIMIT', 'selectionId': 2, 'side': 'BACK', 'handicap': 0, 'limitOrder': {'price': 6.0, 'persistenceType': 'LAPSE', 'size': 2, 'timeInForce': 30}, 'customerOrderRef': '662fae5f621ab-138280164330968924'}], 'customerRef': 'aa6e175d451311ebaa7f020100017805', 'customerStrategyRef': 'ID17805', 'async': False} \nException: None \nError: {'code': -32602, 'message': 'DSC-0018'} \nFull Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}", "order_package": {"id": "aa6e175d-4513-11eb-aa7f-020100017805", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x000001F891D98820&gt;", "market_id": "1.177217695", "orders": ["138280164330968924"], "package_type": "Place", "customer_strategy_ref": "ID17805", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 1}}```

---

## 2020-12-23 09:32:21 - issues channel

**Michael**

If you're going to do that why not just take a stab at what you think your strategy will look like and try it with minimum stakes collecting the data as you go? That's far and away the best way to get a strategy going anyway. Real bets places are far more valuable than hypothetical historical ones.

---

## 2020-12-23 09:24:21 - issues channel

**Michael**

Think about what the purpose of your analysis is - it's to determine the best strategy and find the best bets right? It's not to tell you what your income will be next year (or it shouldn't be anyway). Viewed from that perspective your 'optimism discount' doesn't really matter.

---

## 2020-12-23 08:56:14 - issues channel

**Michael**

Just whatever you do don't close as a blanket strategy, that's a bad idea.

---

## 2020-12-23 08:52:15 - issues channel

**Michael**

For a whole heap of reasons you probably won't be able to use Kelly properly anyway though, so I wouldn't sweat it.

---

## 2020-12-23 08:50:24 - issues channel

**Michael**

Under Kelly there might be circumstances where you close particular bets but it wouldn't be a blanket strategy. If you want a blanket strategy then you let them all run.

---

## 2020-12-23 08:49:11 - issues channel

**liam**

using fixed kelly should remove some of the volatility but cashing out is only giving money away, I profit off this so I shouldn't really tell you not to but...

---

## 2020-12-23 08:48:03 - issues channel

**Mick**

[@U4H19D1D2](@U4H19D1D2): I may use kelly at some point

---

## 2020-12-23 08:29:55 - issues channel

**Oliver Varney**

the obvious issue, is you have no clue on available volumes, but it can be useful to see if you can build a profitable model with the assumption that there will be some volume around

---

## 2020-12-22 18:03:30 - random channel

**mandelbot**

Perhaps it's a good time for [@UBS7QANF3](@UBS7QANF3) to give a presentation on sports modeling  :nerd_face:

---

## 2020-12-22 16:04:51 - random channel

**Jonjonjon**

Isn't that dependent on strategy? I had an opposite experience to you this year.

---

## 2020-12-22 13:33:51 - random channel

**PeterLe**

Yes i was watching the prices and they seemed all over the place. there were two under 1.06 in the last too  :astonished: maybe someone is trying  new strategy !

---

## 2020-12-20 09:24:00 - random channel

**Alessio**

This whole world  of betting is evil. It's designed to extract money from you and barely help you when you are addicted. You should be proud that you are extracting money for yourself and fighting the system! :wink:

---

## 2020-12-20 05:41:53 - random channel

**Misha**

We have a very significant issue with problem gamblers in Australia. But that's across slot machines (the worst), sports betting, and to a lesser extent, casinos. Of those with problems, less than 0.01% (if that) would be people who do some sort of computer analysis and then use that to bet. We just aren't the problem group. Those pretending they are not problem gamblers aren't using euphemisms, they are denying an addiction

---

## 2020-12-19 14:04:25 - random channel

**Michael**

looks like his problem stemmed from cash transactions rather than it being betting winnings. There have been several test cases involving various bodies going after gamblers and the gambler always wins.

---

## 2020-12-19 13:03:49 - random channel

**Misha**

Given that pretty much everyone knows my maths and software development background I say developing automated sports betting systems based on mathematical models

---

## 2020-12-19 12:11:02 - random channel

**Mo**

Now I think you are just arguing for the sake of it. You think when he plays Keno to make money he is not professional gambling but mathematical modelling?

---

## 2020-12-19 12:06:27 - random channel

**Misha**

Mathematical modelling

---

## 2020-12-19 10:52:36 - random channel

**D C**

OK call it what you will. Even if you have the best model in the world and you have huge +EV long term what we do is still gambling. I just guess its one of those things we will never agree on.

---

## 2020-12-19 10:48:35 - random channel

**Misha**

I have a mate who started a hedge fund. The way he built his fund is no different to what I do in sports betting. Both of us have Pure Maths degrees. Both models use data analysis and automated trading. There is no difference

---

## 2020-12-18 21:45:36 - random channel

**John A**

Would be interested to know from the fellow full timers out there the answer to, this question. What do you tell people when they ask “What do you do for a living?” These days I just say I’m a Software Developer. Would love to say I’m a gambler but it’s not really gambling. Also, trying to explain what an automated betting exchange is beyond my communication skills.

---

## 2020-12-18 14:10:35 - random channel

**bb**

Just watched the replay and the winner jumping left severely hampered the progress of the second place horse at the final flight. My guess is people would be trading expecting it to go to stewards and the result be overturned, but given it was horse error rather than jockey error causing the interference it couldn't be protested and the market settled

---

## 2020-12-18 12:37:07 - random channel

**Oliver Varney**

ah okay, I guess the question still stands about the strange trading in the last few seconds

---

## 2020-12-18 12:35:45 - random channel

**Oliver Varney**

interesting in the 12.07, didnt watch the race but assume it was a tight finish. Was trading around 1.1 for about 10 mins then just before the result came in it shot out to 1.2. The lowest traded one was given the win but I find it interesting that 5 seconds before the actual close the price shot out. I was expecting a dead heat or something to be called by the trading activity in that last few seconds. Is it a viable strategy that people have a faster feed of the result data then betfair? I know there is an issue around non runner.

---

## 2020-12-18 10:39:42 - issues channel

**Mick**

I find that trading.keep_alive() usually works fine but occasionally it produces "betfairlightweight.exceptions.StatusCodeError: Status code error: 520" - any ideas?

---

## 2020-12-17 20:12:43 - general channel

**Jonjonjon**

I just started with a spray and pray strategy. Plotted lots of charts, and observed where my good and bad fills came from. I think [@UGV299K6H](@UGV299K6H) had some great tips for novices a week or two ago.

---

## 2020-12-17 14:55:20 - general channel

**Oliver Varney**

sounds like your at the start of the journey. Id say no, you dont need to know anything about horses at the start, I personally didnt. Having said this it might be easier to start with a sport you understand / have a passion for. In terms of betting/ trading strategies, this is something you will have to discover for yourself, as people wont be giving away their strategies for free. If you have specific questions about how markets operate, what is value/value betting, Betfair API, code examples for betfairlightweight and flumine then there are many great people in this chat.

---

## 2020-12-15 19:17:28 - general channel

**river_shah**

We can benchmark using the dummy strategy by the way. The patching method that [@UBS7QANF3](@UBS7QANF3) suggested is very easy. Using bz2, in some simple backtests I see runtime increase 3-6% but space saving is 8-10X. Well worth the speed vs space saving for my use case.

---

## 2020-12-15 17:23:21 - random channel

**Oliver Varney**

I use sql server, and I think they have something similar. I think it came down to performance in the end. I purely only use it for training models, basically pushes the historical files into it

---

## 2020-12-15 14:38:28 - strategies channel

**thambie1**

Completely depends on your strategy and the associated variance. High variance strategies need longer backtesting periods than lower variance strategies. In my case, I backtested over my full dataset, to get an idea of how long potential downswings may be. And then used that to determine the length of backtest I use for testing

---

## 2020-12-15 14:31:01 - strategies channel

**birchy**

When backtesting, at what point do you decide to pull the plug on a losing strategy? I'm never really sure whether to just let it run for 1000 markets/5000 bets/1000 matched bets/etc. Obviously the more data, the better but I guess the real question is: at what point do you decide that the strategy isn't going to work as expected?

This is for straight `check triggers -&gt; place simulated bets -&gt; calc P&amp;L's` backtests.

---

## 2020-12-15 13:22:18 - random channel

**Oliver Varney**

and it can be quite easy to muck it up when the number of source increase and the complexity of the model increases

---

## 2020-12-15 13:21:09 - random channel

**Alessio**

Side question though, how do you guys keep all your data around for joining and building models? If you get ~100K markets to train on + all the side data coming from other sources, the risk of data going stale/out-of-sync or mess-ups increase. Just SQL and some extra checks on top? Processing queues on top?

---

## 2020-12-15 13:02:02 - general channel

**river_shah**

```from unittest.mock import patch



import smart_open

from flumine import BaseStrategy, FlumineBacktest, clients





class ExampleStrategy(BaseStrategy):

    def start(self):

        # subscribe to streams

        print("starting strategy 'ExampleStrategy'")





    def check_market_book(self, market, market_book):

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True





    def process_market_book(self, market, market_book):

        # process marketBook object

        print(market_book.status)





client = clients.BacktestClient()

framework = FlumineBacktest(client=client)



strategy = ExampleStrategy(

    market_filter={"markets": ["./1.166912450.bz2"]}

)



framework.add_strategy(strategy)



with patch("builtins.open", smart_open.open):

    framework.run()```



---

## 2020-12-15 12:50:07 - random channel

**river_shah**

I have done so. For example there was one on halo / dark matter detection in synthetic large field galaxy pictures. the idea was that the presence of a black hole slightly bends light coming from distant  sources which allows one to pinpoint the presence of a black hole through indirect means. the signals were very faint which I found to have direct analogs for our domain (finance, betting, quasi efficient markets) I also ended up mastering some linear algebra and data compression techniques which ended up helping with the day job

---

## 2020-12-15 12:42:45 - general channel

**river_shah**

```from flumine import BaseStrategy, FlumineBacktest, clients





class ExampleStrategy(BaseStrategy):

    def start(self):

        # subscribe to streams

        print("starting strategy 'ExampleStrategy'")





    def check_market_book(self, market, market_book):

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True





    def process_market_book(self, market, market_book):

        # process marketBook object

        print(market_book.status)





client = clients.BacktestClient()

framework = FlumineBacktest(client=client)



strategy = ExampleStrategy(

    market_filter={"markets": ["./1.166912450.bz2"]}

)

framework.add_strategy(strategy)



framework.run()```



---

## 2020-12-15 12:29:13 - strategies channel

**liam**

Like Mike I have been using it since March 2018, I think execution is more important than getting a model working, surprised you haven’t found some success Peter 

---

## 2020-12-15 12:28:47 - general channel

**Mo**

```    ...

    stream = trading.streaming.create_historical_generator_stream(

        file_path=path,

        listener=listener

    )



    with patch("builtins.open", smart_open.open):

        g = stream.get_generator()

        for market_books in g():

            ...```

---

## 2020-12-15 12:23:37 - random channel

**Mo**

Does anyone here participate in Kaggle competitions?



I used to do a bit but I've always struggled with the idea because it feels like time better spent on developing my betting strategies as the processes are pretty similar (analyse some data and build a model). On the other hand, I think it can be good to expose yourself to other types of data and techniques as you may find crossover opportunities

---

## 2020-12-15 12:17:51 - general channel

**Jonjonjon**

I'm unsure at the moment. Just want to see if it is feasible to base a strategy on trading the final price before a race starts. But I don't want to take bsp.

---

## 2020-12-14 23:20:36 - strategies channel

**Michael**

It's not a coincidence that most of the successful TPD players were established IR horses players before it came along. To me using TPD does feel like printing money, but then I was already doing well on those markets before it existed. Having been betting blind on HR markets for years suddenly having a notion of what's actually happening in the race was miraculous. I wasn't troubled by lack of data because I could use my existing market analysis techniques to make sure I wasn't doing anything ludicrous and I already had a good idea of how to pitch the betting in terms of staking, pricing and so on. Absent all of that I can see it being much harder and I've heard similar experiences to [@UQL0QDEKA](@UQL0QDEKA) from a few people.

---

## 2020-12-14 22:41:27 - strategies channel

**Misha**

My view, and this is my view only, is that I find it hard to model if I am not a real expert in the field. I know that others can overcome this, but I would rather work on "solid ground" :wink:

---

## 2020-12-14 22:39:41 - strategies channel

**Misha**

My knowledge of horse racing, while fairly good, is not good enough (I reckon) to start from scratch in terms of modelling

---

## 2020-12-14 21:50:30 - strategies channel

**Jonjonjon**

I can't even get an in-running strategy to work without TPD. So adding TPD would just complicate matters anyway

---

## 2020-12-14 21:36:38 - strategies channel

**PeterLe**

Evening, I was recently fortunate enough to have the TPD GPS Switched on for me by my account manager.

A number of fellow users have proclaimed how useful this is, but hand on heart, I haven’t been able to capitalise on it. (Either as a standalone strategy or to enhance existing strategies)

So for the time being, I have switched back to my long term non TPD profitable stuff.

I don't how many licences Betfair have allocated in total but I expect that a number of those granted access will be on here, so a good place to ask.

So how have you found it? Appreciate any thoughts, reflections please.

Either-way I will be looking at this again over the holidays, just looking for a gauge rather than the secret sauce thanks :grinning:

---

## 2020-12-14 05:48:34 - random channel

**Mo**

My question is still this: what law is being broken by the person using an unlicensed exchange? I understand that an unlicensed exchange or bookmaker is breaking the law by offering betting services to UK customers. But I cannot find anything that says it is illegal for a UK citizen to use them. I am not saying this is the case but I am looking for some concrete evidence either way.

---

## 2020-12-13 08:29:54 - general channel

**bb**

The aggregation sites are unlikely to show odds from a bookmaker they dont have a commercial agreement in place with as it would be sending customers out of the  acquisition funnel that underpins their business model

---

## 2020-12-12 10:38:09 - strategies channel

**D C**

It is popular for everyone to talk about this in the context of ML stuff now, but it is most easy to explain in the context of polynomial approximation versus interpolation of a set of (x,y) pairs of data. It is also context dependent - there are times where interpolation is what you want even though this is overfitting (every residual is zero by definition). In the sense of approximation though it is usually crap. Fitting requires more thought than that. For example, you can sling a least-squares linear regression at data but model assumptions are that the error is normally distributed - you can still fit it but it breaks model assumptions. Just because you can doesn't mean you should. You have a couple of outliers in your data set and that totally screws a least-squares approximation in the sense of how useful it is. In such cases fitting a l1 approximation gives you a much better way to go. It is basically a trade off between too many parameters in your model (huge flexibility) amd too few (comparatively rigid form). Both ends of the spectrum give a shite representation of the underlying functional relationship between response and explanatory variables. But how you get at that functional relationship should be governed by the error distribution of your measurements.

---

## 2020-12-12 10:07:59 - strategies channel

**Misha**

So my views are only relevant to statistics models

---

## 2020-12-12 10:05:59 - strategies channel

**Misha**

But if you are modelling market movements, then that is a different type of model

---

## 2020-12-12 10:05:20 - strategies channel

**Misha**

I only work with sporting results models, but we don't use any odds in our model at all. We test against odds where we have them, but prices are kept separate from modelling

---

## 2020-12-12 10:00:26 - strategies channel

**Artur Gräfenstein**

I think you are both right. But that hits it pretty well: “Over fitting is simply when your model too closely matches the noise in your data!” Pretty easy to understand for a beginner!

---

## 2020-12-12 09:59:27 - strategies channel

**Misha**

In my view overfitting is the number one reason why models fail over time

---

## 2020-12-12 09:54:20 - strategies channel

**Misha**

Not really - over fitting is the process of modelling temporary trends and mistaking them for long-term trends

---

## 2020-12-12 09:52:43 - strategies channel

**Michael**

No wait that's wrong. Models can be under fitted.

---

## 2020-12-12 09:49:36 - strategies channel

**Michael**

As I understand it over fitting is simply when your model too closely matches the noise in your data. All model types are prone to it and in s sense all models are over fitted it's just a matter of degree.

---

## 2020-12-12 09:40:10 - strategies channel

**Michael**

I do exactly what [@U016TGY3676](@U016TGY3676) describes as part of my analysis. You can't fully separate profit from underlying edge so by analysing profit you are analysing probability discrepancies indirectly but with market factors on top. The answer to all of these questions is that you have to apply human intelligence and understanding to the problem and not just expect a black box model to make it all go away. Typically my approach would be to focus on areas of high or low profitability first, then drill down into those to see whether they are caused by the bets inherently having or not having the right amount of value or something to do with the matching. I analyse a lot of things separately, then I look at them together and how they interact. When I get to a general model I assume it's overfitted, dial it back a bit for real world use and randomise it slightly to generate data for the future.

---

## 2020-12-12 09:39:07 - strategies channel

**Stefan**

Therefor I do not build my models on odds. This is actually quite funny because I posted here something about ML, in screenshots or videos, I think I posted this article before as well: [http://bfexplorer.net/Articles/Content/502](http://bfexplorer.net/Articles/Content/502)

---

## 2020-12-12 09:29:04 - strategies channel

**Michael**

I don't think that's right. You can make anything the target of your optimisation. Overfitting describes the quality of your model.

---

## 2020-12-12 06:12:43 - strategies channel

**Oliver Varney**

yes and no, its likely that if your learning task is solely focused around profitability, it will learn that the longer the odds the higher the edge is (typically for me at least) and may give you a funny model that bets on 1000.0 horses, because when they eventually come in the have the largest edge (not factoring in volume available and market impact).

---

## 2020-12-12 01:30:18 - strategies channel

**Misha**

It's why with standard modelling you have a training set and an evaluation set that don't overlap. Use the training set to create the model, but only evaluate profitability on data that doesn't go into any model choices

---

## 2020-12-11 23:44:08 - strategies channel

**Misha**

[@UPMUFSGCR](@UPMUFSGCR) - but if you choose your optimisation based on profitability, you are, by the very definition, over fitting. It's a hard question with no easy answers, and something that I ask myself every day with my model

---

## 2020-12-11 23:20:18 - strategies channel

**Jonjonjon**

Suppose I have a trading strategy, where the profit-per-race is inversely correlated to the race-length. The profit-per-race is not normally distributed. Tending to be either -£1x or +£10x. What's the best optimisation algorithmn for choosing the maximum race length at which I should run the strategy?

---

## 2020-12-10 16:53:45 - general channel

**river_shah**

about to buy some historic horse racing data from betfair. are some months better to buy than others to back test models on please? i.e more liquid and important markets or some other criterion leading to better model generalizations.

---

## 2020-12-10 12:12:42 - issues channel

**Mick**

I am trying to read the adjustment factor associated with a race. I set price_filter = betfairlightweight.filters.price_projection(price_data=['EX_BEST_OFFERS']) then call market_books = trading.betting.list_market_book(market_ids=[mk_id],price_projection=price_filter) but if I then try and print(market_books[0].adjustment_factor) I get "'MarketBook' object has no attribute 'adjustment_factor'"... do I need to add something else to my price_data list? If so what?

---

## 2020-12-09 13:33:44 - strategies channel

**liam**

`strategy.context` or `market.context` if you want it for all strategies for a particular market

---

## 2020-12-09 13:32:46 - strategies channel

**mandelbot**

What's the best way to hang on to some historical info within a strategy? Create a global variable and modify within `process_market_book`?

---

## 2020-12-09 10:14:41 - general channel

**Aaron Smith**

Hey guys! Maybe its obvious in the code, but i couldnt figure it out right now :smile: :

Suppose i place an order in process_market_book (in a BaseStrategy instance), but then i continue processing stuff to maybe place a 2nd order. Is the first order delayed by the calculations coming afterwards in process_market_book or is it sent immediatly to betfair and then process_market_book continues?

---

## 2020-12-08 19:37:52 - general channel

**thambie1**

I like using it to just see what bets I have open, but doesn't seem to be working some of the time after I launched a more active strategy.

---

## 2020-12-08 17:00:07 - general channel

**river_shah**

```from flumine.utils import get_price

from betfairlightweight.resources.bettingresources import PriceSize

back_price = PriceSize(**{"price": 2.00, "size": 1024})

mock_book.ex.available_to_back = [back_price]

mock_back_price = get_price(mock_book.ex.available_to_back, 0)```



---

## 2020-12-08 12:05:56 - strategies channel

**user34**

For anyone interested, this paper ([https://www.researchgate.net/publication/262425087_Optimal_Betting_Under_Parameter_Uncertainty_Improving_the_Kelly_Criterion](https://www.researchgate.net/publication/262425087_Optimal_Betting_Under_Parameter_Uncertainty_Improving_the_Kelly_Criterion)) looks at how to reduce optimal stakes to account for uncertainty in the edge.

---

## 2020-12-07 19:42:05 - issues channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) Speaking of 500+ second delays, did you have any luck with finding a solution for Flumine handling a few thousand markets with one strategy?

---

## 2020-12-07 14:07:14 - strategies channel

**Oliver Varney**

agreed, was more thinking in terms of model building. For new strategies you will get feedback alot faster from BSP then the realising of the horse winning if your backing for example.

---

## 2020-12-07 13:15:17 - strategies channel

**Oliver Varney**

talking pre off [@U0160E9HS2G](@U0160E9HS2G) , if I was doing an inplay model I would likely capture a price very close to off and use it as a feature

---

## 2020-12-07 12:42:16 - strategies channel

**Oliver Varney**

for me at least, the more experienced may disagree but, BSP is on average a fairly okay representation of the implied probability of a horse winning the race (has cases where massively off and value can be found, overbacking / underbacking etc). So if you can come up with a model that gets you into positions that consistently achieves a better price (back side ) then the BSP your onto a profitable strategy in the long run. the reverse is true also for laying. The inplay guys might be able to shed more light on how they benchmark their inplay strategies

---

## 2020-12-07 11:23:01 - general channel

**Cagdas Yetkin**

We have put together some leagues and we will be testing a few things on the go :slightly_smiling_face: Plus, we started writing a blog regarding our 30-day-betting challenge. We are already on day-9. It is going to be fun. Our friendly project is here: [http://betalertpro.com/](http://betalertpro.com/) no login required... There is a feature using the betfairlightweight but it is not active yet.



it is only in-play... So the matches will be visible today evening only.

---

## 2020-12-07 08:27:07 - strategies channel

**liam**

Yeah for me it’s about even out the pnl across the odds range rather than optimising profit as market capacity makes Kelly pointless 

---

## 2020-12-07 08:23:41 - strategies channel

**jp**

Remember that Kelly is optimal only if you consider a fixed bank size. I you are in a position where you can adjust your bank size to the profitability of your strategy, Kelly may not be the right tool to decide bet size.

---

## 2020-12-07 08:21:57 - strategies channel

**Oliver Varney**

cool cheers, I havent used it thus far due to the style of prediction my model comes up with, which means I wouldn't for each individual bet know exactly my edge but I would have an expectation across a number of bets with a certain prediction strength. Im wondering what is the effect of using kelly if your edge is not fully accurate (but your bets +EV), id be interested to read up on that if you can find something [@U0135SLHQBW](@U0135SLHQBW)

---

## 2020-12-07 08:09:06 - strategies channel

**liam**

From what I have found the majority use fixed Kelly (I do) at a certain percentage 

---

## 2020-12-07 01:21:56 - strategies channel

**MacrcoPolo**

Also I think on betfair, you'll probably be constrained by scale much more than you need to worry about optimal kelly staking!

---

## 2020-12-07 01:20:01 - strategies channel

**MacrcoPolo**

reading blackjack theory is one place where kelly is discussed a huge amount with all the caveats and I recommend people see if they can find some old posts on old blackjack forums about this. Blackjack pros typically advocate 1/4th to 1/3rd kelly from what I remember for the reasons above (and others - such as the fact that if you're drawing life expenses from the bankroll, your 'effective' bankroll is much smaller)

---

## 2020-12-07 01:18:58 - strategies channel

**MacrcoPolo**

Short answer is this: with kelly there's 2 highly undesirable things happening, despite it being the optimal way to grow _log_ wealth. Firstly, the setting for kelly is that you're not constrained by the amount you can wager, and that you know the edge on the bet. If you have uncertainty in your edge, then wagering slightly smaller is optimal I believe (I don't have the proof at hand - can try and throw something together tomorrow if you want). Second, even if you are wagering at kelly where the relevant odds and proabilities are known, you still put yourself in a spot where your bankroll halfs before doubling 1/3rd (again, this is from memory, might be a little higher, a little less) of the time. That's terrifyingly large swings for most mortals, and not good for the mind. Cut to half kelly, and you dramatically reduce the chances this happens (I have no hard numbers and it's 1 am!).

---

## 2020-12-06 22:38:34 - strategies channel

**thambie1**

In my case, I just backtest using kelly. If profit goes up, and varience goes down, I must have got it reasonably right.

---

## 2020-12-06 21:49:12 - strategies channel

**Oliver Varney**

so if you said, with this typical prediction (and its associated strength however you define that), on average my edge is X. so in essence your not fully sure on the edge but you know across an average on backtesting the edge is X, or is this still too flimsy to use fractional kelly ?

---

## 2020-12-06 21:25:49 - strategies channel

**MacrcoPolo**

yes it does - this is one of the reasons people use fractional kelly, you should under stake rather than over stake in the presence of edge uncertainty

---

## 2020-12-06 21:05:12 - strategies channel

**Oliver Varney**

I guess what I mean is that doesn't Kelly stake sizes depend on knowing an accurate edge on each bet? Or is an approximation good enough?

---

## 2020-12-06 20:58:22 - strategies channel

**thambie1**

I don't think kelly would be useful for accuracy measurements. But rather to optimize profitability after you already have a model.

---

## 2020-12-06 20:57:39 - strategies channel

**thambie1**

I use brier score, logarithmic score, and profit/loss to gauge my models.

---

## 2020-12-06 18:47:22 - strategies channel

**Oliver Varney**

just out of interest, for those that build there own odds, how do you track how accurate they are. I assume you use some form of kelly which assume you know your edge

---

## 2020-12-06 18:37:21 - strategies channel

**liam**

[https://www.pinnacle.com/en/betting-articles/betting-strategy/pinnacle-sports-margins/lah22jal3xrpkq42|Pinnacle](https://www.pinnacle.com/en/betting-articles/betting-strategy/pinnacle-sports-margins/lah22jal3xrpkq42|Pinnacle) have some good resources although I don’t agree with Buchdahl most of the time 

---

## 2020-12-06 18:16:39 - strategies channel

**Oliver Varney**

as the model will learn when they are wrong ..

---

## 2020-12-06 18:15:49 - strategies channel

**Alessio**

this means on average, there's  (a subset of )events where your model outputs a probability that is more precise than the baseline odds themselves, though..

---

## 2020-12-06 18:14:09 - strategies channel

**Oliver Varney**

value in my mind is when you model finds a bet that beats the implied probability of the benchmark( bsp)

---

## 2020-12-06 18:13:31 - strategies channel

**Oliver Varney**

A profitable model is retaliative to the implied probability

---

## 2020-12-06 18:12:15 - strategies channel

**Oliver Varney**

yep, whereas if you have a model with only 20% accuracy but average odds of 6, your in the money even though your accuracy is much lower then the 50% model

---

## 2020-12-06 18:09:20 - strategies channel

**Oliver Varney**

you may have a model with a 50% accuracy, but the average odds is 1.75

---

## 2020-12-06 18:06:55 - strategies channel

**Alessio**

yes, the model will definitely go on the favorite, it's the best "prior" it has got

---

## 2020-12-06 18:06:26 - strategies channel

**Oliver Varney**

yep now imagine think one of your features is the price the bookmaker produced the night before. if your model goal is to predict the winner with the most accuracy, surely it will pick the bookie odd that is the lowest ?

---

## 2020-12-06 18:04:05 - strategies channel

**Oliver Varney**

forget the model

---

## 2020-12-06 18:03:43 - strategies channel

**Alessio**

It depends how you build the model, but you could have odds most_of_the_time and in certain cases other features could be overpowered. At least I'd expect decision-tree style models to be able to recognize that in certain situations you can refine the odds

---

## 2020-12-06 18:01:44 - strategies channel

**Oliver Varney**

so if all of your records have 2 as an input your model should be 50% accurate

---

## 2020-12-06 17:59:32 - strategies channel

**D C**

AFAIK, Pinnacle have good modelling but they change their lines based on laying bets from sharp customers. Not exactly sure how that gets weighted but whatever they do, the betting community seem to consider them as the gold standard. People like Joseph Buchdahl have a massive hard-on for Pinnacle closing prices.

---

## 2020-12-06 17:57:35 - strategies channel

**Oliver Varney**

but the implied probablity maybe lower then the accuracy and you have a model with a high accuracy  but is not profitable

---

## 2020-12-06 17:56:25 - strategies channel

**Oliver Varney**

if you have a model that trys to predict a winner with odds as an input

---

## 2020-12-06 17:43:04 - strategies channel

**bb**

If the odds are far more predictive of the outcome variable than any other feature a model will weight them very heavily. At the extreme the model could just be a proxy for backing the favourite and accuracy/profitability will be in line with this

---

## 2020-12-06 17:40:27 - strategies channel

**Oliver Varney**

so really if its based on incoming bets, surely its just like the exchange which is basically a price party from many participants with all separate models ?

---

## 2020-12-06 17:37:36 - strategies channel

**Alessio**

curiosity, these guys had a model, wanted to check if their accuracy was inline, better or worse than pinnacle closing odds

---

## 2020-12-06 17:33:29 - strategies channel

**Alessio**

ah sorry, (1) i didn't build the model (2) this is not for live bets, it's for pre-match prediction

---

## 2020-12-06 17:28:26 - strategies channel

**Oliver Varney**

surely your model would at least use the current exchange price? Isnt the bsp just the price parity of many thousands of participants (using models)

---

## 2020-12-06 17:26:27 - strategies channel

**Alessio**

[@ULDAVFDRP](@ULDAVFDRP) depends on model. If you are building something that fits to a specific distribution, not sure they have such a non-linear power

---

## 2020-12-06 17:25:18 - strategies channel

**bb**

A few transformations can turn decimal odds into a target variable that is much closer to a normal distribution and easier to model

---

## 2020-12-06 17:20:06 - strategies channel

**Oliver Varney**

if you have a set of features that is prices from various sources + additional features,with each odds provider being slightly better in certain race types (or other splits), the model will learn this and should be better overall

---

## 2020-12-06 17:18:47 - strategies channel

**bb**

As the impact of odds on a model's performance will differ according to each

---

## 2020-12-06 17:17:03 - strategies channel

**bb**

[@U01C12ZEADQ](@U01C12ZEADQ) How are you defining the model as being good or bad? Accuracy, profitability or using the loss function the model was trained with

---

## 2020-12-06 17:16:06 - strategies channel

**Oliver Varney**

i.e. if you creating a regression model to predict the value of your house, surely a good feature is the price the neighbours house sold at? Or even better the prediction from the estate agent?

---

## 2020-12-06 17:15:35 - strategies channel

**Alessio**

(assuming the model tries to do the same thing the odds do, i.e. predicting win/loss)

---

## 2020-12-06 17:15:09 - strategies channel

**Alessio**

it's not a bad thing, but in theory your model should be better than what you feed into it, no?

---

## 2020-12-06 17:13:54 - strategies channel

**Oliver Varney**

[@U01C12ZEADQ](@U01C12ZEADQ) why is using odds as an input to a model that predicts odds a bad thing?

---

## 2020-12-06 17:09:42 - strategies channel

**D C**

I swear I must be getting thicker as I get older. For those who have done this, what model would you even use to do this? I can't think of anything in the GLM family?

---

## 2020-12-06 17:08:23 - strategies channel

**Mo**

Possibly inappropriate model structure as [@UUE6E1LA1](@UUE6E1LA1) alludes to

---

## 2020-12-06 17:07:46 - strategies channel

**Alessio**

I asked them and they said they use odds as well. It's a bit interesting they come up with a model which is worse than their input.. so I wonder if the structure is instead the real thing that is different (i.e. how you model the sport itself)

---

## 2020-12-06 17:01:23 - strategies channel

**Mo**

Not just the techniques; you can do a lot more with less data if you are modelling probabilities rather than outcomes: there's more information in them

---

## 2020-12-06 16:59:46 - strategies channel

**D C**

Yes obviously the available techniques would be different. But from a regression perspective, what target distribution would odds even come from? Assuming decimal odds, you have a response that is a member of the set (1,infinity) from what I can see. Are we talking about ML or nonparametric approaches? I would not know where to start in trying to model someone else's model odds without trying to map the problem to one of implied probabilities.

---

## 2020-12-06 16:53:09 - strategies channel

**Mo**

[@UUE6E1LA1](@UUE6E1LA1) it’s modelling but you model the odds not the outcomes. For example you do a regression of various factors where the target is the odds, then you can see which factors are most highly weighted

---

## 2020-12-06 16:50:19 - strategies channel

**Oliver Varney**

May only be my opinion but anyone willing to give up their model details is either a fool or trying to mislead you

---

## 2020-12-06 16:46:11 - strategies channel

**D C**

What do you mean [@U01C12ZEADQ](@U01C12ZEADQ)? Surely this would just be modelling rather than reverse engineering?

---

## 2020-12-06 15:12:17 - strategies channel

**Alessio**

Random Q, did anybody try to reverse engineer some of the odds model that are around, i.e. try to figure out which are the features that mostly approximate the odds providers give you?

---

## 2020-12-06 10:47:25 - strategies channel

**JC**

When I was considering making a hedging strategy, I think [@U0128E7BEHW](@U0128E7BEHW) mentioned that one way to do it would be to have two flumine strategies running, one that backs and one that lays (hedges). After reading the +EV related discussions on here I decided to forget about hedging though

---

## 2020-12-06 09:51:21 - strategies channel

**liam**

Yes but you need to change the strategy.[https://github.com/liampauling/flumine/blob/dabcaab5853ed71e95eed1c076706a41ded334e9/flumine/strategy/strategy.py#L44|max_live_trade_count](https://github.com/liampauling/flumine/blob/dabcaab5853ed71e95eed1c076706a41ded334e9/flumine/strategy/strategy.py#L44|max_live_trade_count) 

---

## 2020-12-06 09:42:46 - strategies channel

**Ben**

[@U4H19D1D2](@U4H19D1D2) better way to ask my question, can I place two opposing orders simultaneously? And instead of hedge, say I wanted to implement a green up strategy?

---

## 2020-12-06 09:13:15 - random channel

**Oliver Varney**

so I guess what I want to design or improve is a data quality / checking service. I run models that use data from many sources + I further aggregate and build out more features. also I would like to build some kind of unit test that tests the built out aggregate features in SQL Server. With a large number of sources + features it can be easy to let a inner join slip through the net instead of being a left join and it might not be fully noticeable straight away.

---

## 2020-12-06 08:46:05 - strategies channel

**Ben**

Question for those who use Flumine. I've got a strategy I'd like to backtest that relies on placing a back bet, then hedging the stake with a lay order if the back bet is executed. I've managed to code up the back bet portion of the strategy just fine, but can't seem to figure out how to apply the logic to execute the lay order. Anyone able to share some tips or relevant code snippets (old strategies)

---

## 2020-12-05 17:35:45 - general channel

**liam**

Yeah because it shouldn’t be strategy specific 

---

## 2020-12-04 22:18:31 - general channel

**Charlie 303**

Does flumine do this by default (e.g. if I simply follow the readme example strategy and change the marketFilter, will all the runner meta data be available when process_market_book is called)?

---

## 2020-12-04 21:55:00 - issues channel

**Jonjonjon**

It's Top Power that I am having issues with. It refused the enter the stalls and was declared non runner. I guess Betfair did it later.



However, it had an adjustment factor of 75.18.



In a strategy I am testing, I layed at 3.2.



Applying the adjustment factor, the average price matched drops to 0.79, which is below 1.01 and therefore invalid.



Is 75.18 a valid adjustment factor?



The adjustment factor code is here:



[https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/markets/middleware.py#L104-L107](https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/markets/middleware.py#L104-L107)

---

## 2020-12-04 18:06:20 - issues channel

**Gabriel**

There was exactly 1 log regarding this order:

```{"asctime": "2020-12-04 17:43:32,949", "levelname": "CRITICAL", "message": "Unknown error 'MarketOnCloseOrder' object has no attribute 'size' in strategy_process_market_book &lt;bound method MyStrat.process_market_book of &lt;strategy_object object at 0x7f7981f08dd0&gt;&gt; 1.176351611", "exc_info": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.7/site-packages/flumine/order/order.py\", line 391, in size_remaining\n



    return self.current_order.size_remaining or 0.0\n



AttributeError: 'NoneType' object has no attribute 'size_remaining'\n



\n



During handling of the above exception, another exception occurred:\n



\n



Traceback (most recent call last):\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/utils.py\", line 208, in call_process_market_book\n



    strategy_process_market_book(market, market_book)\n



  File \"/home/jenkins-slave-strat/workspace/ProdTest/my_strat.py\", line 208, in process_market_book\n



    self.place_order(market, order)\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/strategy/strategy.py\", line 134, in place_order\n



    market.place_order(order)\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/markets/market.py\", line 53, in place_order\n



    order.place(self.market_book.publish_time)\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/order/order.py\", line 289, in place\n



    self.placing()\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/order/order.py\", line 86, in placing\n



    self._update_status(OrderStatus.PENDING)\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/order/order.py\", line 81, in _update_status\n



    [http://logger.info|logger.info](http://logger.info|logger.info)(\"Order status update: %s\" % self.status.value, extra=[http://self.info|self.info](http://self.info|self.info))\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/order/order.py\", line 266, in info\n



    \"size_remaining\": self.size_remaining,\n



  File \"/usr/local/lib/python3.7/site-packages/flumine/order/order.py\", line 396, in size_remaining\n



    return self.order_type.size\nAttributeError: 'MarketOnCloseOrder' object has no attribute 'size'"}```

For some reason it tries to get the size, which an MarketOnCloseOrder doesnt have

---

## 2020-12-04 16:40:24 - issues channel

**Gabriel**

[@UNQGKT0CR](@UNQGKT0CR) Thats how i understood it aswell, thanks for confirming :slightly_smiling_face: However, what am i doing wrong here?

```trade = flumine.order.trade.Trade(

                                    market_id=market_id, 

                                    selection_id=selection_id,

                                    handicap=handicap,

                                    strategy=self

                                )



                                liability = - matched_quantity      # this is &gt; 2

                                order = trade.create_order(

                                            side="BACK", 

                                            order_type=flumine.order.order.MarketOnCloseOrder(liability=liability)

                                        )



                                self.place_order(market, order)```

what am i missing here? It wont place the order, all variables seem correct.

---

## 2020-12-04 14:04:15 - strategies channel

**Amanda**

Excellent tip if you want to avoid backing horses that have already lost after the delay. There are more than one type of strategy.

---

## 2020-12-04 13:54:01 - strategies channel

**Michael**

That's not a great tip. Best use of BPE is strategy dependent.

---

## 2020-12-03 19:43:51 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) great features, and will definitely start using them. Probably missing something here, but I presume the MarketRecorder won't pick up any bets I've got placed as it's a different strategy, so what's the recommended way to save data from a live bot?

---

## 2020-12-03 18:48:25 - strategies channel

**birchy**

Thanks fellas. I've got no issues with laying runners at any price as the £10 payout target is a decent protection that allows sub-£2 bets.

Bearing in mind that I'm fairly new to this Flumine wizardry, what's the best way to save 'real' market data? I have a MarketRecorder running but that's a strategy of it's own, taken from the Flumine examples.

---

## 2020-12-03 18:32:13 - strategies channel

**PeterLe**

[@U016TGY3676](@U016TGY3676) once you have a concept of a new strategy (assuming it is well thought out and reasonable) Theres no substitute for placing real bets and gathering the data. Ive done exactly that today on something that is completely different to what Ive done before (in an attempt to increase matching rates). Whilst I have shown a slight loss I can already see how i might modify it tomorrow (and Ill be modifying it in such a way that is also counter-intuitive). Im not expecting to win much, but Im not expecting to lose much either. What I will have tomorrow is more data that I can look how to hone and refine. In the back ground Ill keep all my other bots churning away

---

## 2020-12-03 18:23:34 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) Not directly related to this issue, but am I using Flumine incorrectly by putting strategy functions in the strategy object? e.g.

```class SomeStrategy(BaseStrategy):

    """strategy"""

    def __init__(self, *args, **kwargs):

        BaseStrategy.__init__(self, *args, **kwargs)

        self.bet_age = 2



    def calc_lay_price(self, runner):

        # do some calcs....

        return



    def check_triggers(self, market_book, market):

        """returns list of bets"""

        bets = []

        # do some magical wizardy stuff...

        return



    def check_market_book(self, market, market_book):

        if not market_book.inplay: return

        if market_book.status != 'OPEN': return

        return True



    def process_market_book(self, market, market_book):

        bets = self.check_triggers(market_book, market)

        if not bets: return

        for bet in bets:

            trade = Trade(

                market_book.market_id, bet['id'], bet['hcp'], self,

            )

            order = trade.create_order(

                side=bet['side'],

                order_type=LimitOrder(

                    price=bet['price'],

                    size=bet['stake']

                ),

            )

            self.place_order(market, order)

        return



    def process_orders(self, market, orders):

        for order in orders:

            if (order.status == OrderStatus.EXECUTABLE

                and order.elapsed_seconds

                and order.elapsed_seconds &gt;= self.bet_age

            ):

                self.cancel_order(market, order)```

That was how I'd started off when I first used Flumine and I just carried it forward, but in hindsight, my functions should probably static?

---

## 2020-12-03 17:46:55 - issues channel

**Oliver Varney**

are you sure your not overriding this in your strategy class

---

## 2020-12-03 17:46:55 - issues channel

**liam**

Within your strategy can you print that :point_up:

---

## 2020-12-03 17:46:33 - issues channel

**Oliver Varney**

[https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/strategy/strategy.py#L229](https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/strategy/strategy.py#L229)

---

## 2020-12-03 17:43:31 - issues channel

**liam**

It should be a hash of your strategy name 

---

## 2020-12-03 17:43:08 - issues channel

**Aaron Smith**

the start is not named strat (i replaced that word, its the only thing i replaced, but it was showing my actual strategy name there)

---

## 2020-12-03 17:41:57 - issues channel

**Oliver Varney**

is your strategy hash called strat

---

## 2020-12-03 17:41:45 - issues channel

**liam**

Hang on [@U01DVUAE2G1](@U01DVUAE2G1) why is your customer strategy ref start with ‘Strat’ it should be a hash of Strat 

---

## 2020-12-03 17:41:41 - issues channel

**Oliver Varney**

whats returned from this line order_id = current_order.customer_order_ref[STRATEGY_NAME_HASH_LENGTH + 1 :]

---

## 2020-12-03 17:34:15 - issues channel

**Aaron Smith**

Thanks for looking into it! I didnt leave out any logs, after this the last log just repeats for a long time. I didnt fork flumine and am only importing my installed flumine version, so the flumine code is unchanged. For now, all i did was write a strategy and run the framework

---

## 2020-12-03 17:30:05 - strategies channel

**Dave**

But yeah, I've never looked at building a strategy focused on the asymmetry

---

## 2020-12-03 17:27:53 - strategies channel

**Dave**

It's useful for market making - if you're maintaining a spread then you can avoid getting swept where you anticipate the price to move sharply. Obvious and hypothetical example - if you have a realtime football feed you might want to cancel _fast_ whenever a player with the ball reaches a certain area of the pitch. I think it's just a feature you might want to take advantage of if your strategy suits (and use as protection), but not necessarily a source for inspiration.

---

## 2020-12-03 17:21:27 - issues channel

**liam**

```{"asctime": "2020-12-03 17:15:29,340", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.176254838", "selection_id": 19746489, "handicap": 0, "id": "138263085288320640", "customer_order_ref": "27cfde50caeb3-138263085288320640", "bet_id": "218400243460", "trade": {"id": "2428e4da-358b-11eb-8b34-a0999b054753", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138263085288320640"], "notes": "", "market_notes": "4.4,4.5,4.5"}, "order_type": {"order_type": "Limit", "price": 4.4, "size": 2.0, "persistence_type": "LAPSE", "time_in_force": "FILL_OR_KILL", "min_fill_size": 0.01, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 2, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 4.4}, "status": "Execution complete", "status_log": "Pending, Executable, Execution complete"}```

---

## 2020-12-03 17:12:18 - random channel

**birchy**

[@UQL0QDEKA](@UQL0QDEKA) already on the 2% basic package, but even if it turns out to be a break even strategy (which is why I pulled it ~6 years ago), it does at least help towards data recording and PC reduction.

---

## 2020-12-03 16:08:45 - issues channel

**Aaron Smith**

```{"asctime": "2020-12-03 15:00:04,154", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.176309310", "selection_id": 28615071, "handicap": 0, "id": "138263004041538760", "customer_order_ref": "strat-138263004041538760", "bet_id": null, "trade": {"id": "3979446e-3578-11eb-b83b-0a13a1974215", "strategy": "strat", "status": "TradeStatus.LIVE", "orders": ["138263004041538760"], "notes": "", "market_notes": null}, "order_type": {"order_type": "Limit", "price": 2.22, "size": 6.76, "persistence_type": "LAPSE", "time_in_force": "FILL_OR_KILL", "min_fill_size": 0.01, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 6.76, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Pending", "status_log": "Pending"}



{"asctime": "2020-12-03 15:00:04,155", "levelname": "INFO", "message": "1 order packages created", "order_packages": [{"id": "39799d2e-3578-11eb-b83b-0a13a1974215", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f9ca51b9b10&gt;", "market_id": "1.176309310", "orders": ["138263004041538760"], "package_type": "Place", "customer_strategy_ref": "ip-172-31-34-22", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}], "bet_delay": 0}



{"asctime": "2020-12-03 15:00:04,156", "levelname": "INFO", "message": "New requests.Session created", "sessions_created": 1, "session": "&lt;requests.sessions.Session object at 0x7f9c9c29ce90&gt;", "session_time_created": 1607007604.1561081, "session_time_returned": 1607007604.1561098}



{"asctime": "2020-12-03 15:00:04,329", "levelname": "INFO", "message": "[OrderStream: 1001]: 1.176309310 added, 3 markets in cache"}



{"asctime": "2020-12-03 15:00:04,330", "levelname": "WARNING", "message": "Order 218390745703 not present in blotter", "bet_id": "218390745703", "market_id": "1.176309310", "customer_strategy_ref": "ip-172-31-34-22", "customer_order_ref": "strat-138263004041538760"}



{"asctime": "2020-12-03 15:00:04,338", "levelname": "INFO", "message": "execute_place", "trading_function": "place", "elapsed_time": 0.18191218376159668, "response": {"customerRef": "39799d2e357811ebb83b0a13a1974215", "status": "SUCCESS", "marketId": "1.176309310", "instructionReports": [{"status": "SUCCESS", "instruction": {"selectionId": 28615071, "handicap": 0.0, "limitOrder": {"size": 6.76, "price": 2.22, "minFillSize": 0.01, "timeInForce": "FILL_OR_KILL"}, "customerOrderRef": "strat-138263004041538760", "orderType": "LIMIT", "side": "BACK"}, "betId": "218390745703", "placedDate": "2020-12-03T15:00:04.000Z", "averagePriceMatched": 2.236449704142012, "sizeMatched": 6.76, "orderStatus": "EXECUTION_COMPLETE"}]}, "order_package": {"id": "39799d2e-3578-11eb-b83b-0a13a1974215", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x7f9ca51b9b10&gt;", "market_id": "1.176309310", "orders": ["138263004041538760"], "package_type": "Place", "customer_strategy_ref": "ip-172-31-34-22", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}}



{"asctime": "2020-12-03 15:00:04,339", "levelname": "INFO", "message": "Trade status update: Pending", "id": "3979446e-3578-11eb-b83b-0a13a1974215", "strategy": "strat", "status": "TradeStatus.PENDING", "orders": ["138263004041538760"], "notes": "", "market_notes": "2.24,2.26,None"}



{"asctime": "2020-12-03 15:00:04,339", "levelname": "INFO", "message": "Order Place: SUCCESS", "bet_id": null, "order_id": "138263004041538760", "status": "SUCCESS", "error_code": null}



{"asctime": "2020-12-03 15:00:04,339", "levelname": "INFO", "message": "Order status update: Executable", "market_id": "1.176309310", "selection_id": 28615071, "handicap": 0, "id": "138263004041538760", "customer_order_ref": "strat-138263004041538760", "bet_id": "218390745703", "trade": {"id": "3979446e-3578-11eb-b83b-0a13a1974215", "strategy": "strat", "status": "TradeStatus.PENDING", "orders": ["138263004041538760"], "notes": "", "market_notes": "2.24,2.26,None"}, "order_type": {"order_type": "Limit", "price": 2.22, "size": 6.76, "persistence_type": "LAPSE", "time_in_force": "FILL_OR_KILL", "min_fill_size": 0.01, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 6.76, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 2.236449704142012}, "status": "Executable", "status_log": "Pending, Executable"}



{"asctime": "2020-12-03 15:00:04,340", "levelname": "INFO", "message": "Trade status update: Live", "id": "3979446e-3578-11eb-b83b-0a13a1974215", "strategy": "strat", "status": "TradeStatus.LIVE", "orders": ["138263004041538760"], "notes": "", "market_notes": "2.24,2.26,None"}



{"asctime": "2020-12-03 15:00:04,580", "levelname": "WARNING", "message": "Order 218390745703 not present in blotter", "bet_id": "218390745703", "market_id": "1.176309310", "customer_strategy_ref": "ip-172-31-34-22", "customer_order_ref": "strat-138263004041538760"}```

---

## 2020-12-03 15:52:10 - random channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) within expectations. It's a strategy I ran about 8 years ago. Difficult to backtest properly when offering prices due to match rates.

---

## 2020-12-03 12:48:43 - general channel

**jgnz**

hi guys, i am using flumine and i have got a basic strategy working well enough i can run it using the API client or back testing client. most of the behavior i have extended is from process_market_book. but my strategy actually requires that positions are closed after a certain amount of time(not yet implemented).



just wondering if someone could point me in the right direction for how to call this timed behavior?  an easy way is just to call a method at the very start of process_market_book, but it means that bets might be open for longer than i actually want. do you think i should look at BackgroundWorker and adding custom events to the handler_queue?

---

## 2020-12-03 12:18:50 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) Update:

The following runs for about 15 minutes with CPU at 100% and memory gradually increases until 80%+ and then starts using swap. Lots of 'High Latency' warnings in the logger ~700 (not sure if this is seconds or milliseconds?). This is on a Lightsail instance with 2GB RAM. Are you able to replicate?

```class Dummy(BaseStrategy):

    """dummy strategy"""

    def __init__(self, *args, **kwargs):

        BaseStrategy.__init__(self, *args, **kwargs)



    def check_market_book(self, market, market_book):

        return True



    def process_market_book(self, market, market_book):

        """only called if check_market_book() returns True"""

        return



    def process_orders(self, market, orders):

        return```

```strategy = Strat(

    conflate_ms=3000,

    market_filter=bflw.filters.streaming_market_filter(

        event_type_ids=['7', '1', '4339'],

    ),

)

framework.add_strategy(strategy)

framework.run()```



---

## 2020-12-03 09:10:33 - issues channel

**mandelbot**

any idea why i sometimes get this error in backtests?

```{"asctime": "2020-12-03 09:07:03,177", "levelname": "CRITICAL", "message": "Unknown error [&lt;class 'decimal.ConversionSyntax'&gt;] in strategy_process_market_book &lt;bound method test.process_market_book of &lt;strategies.test.test object at 0x000001E1A1A639D0&gt;&gt; 1.174842429", "exc_info": "Traceback (most recent call last):\n  File \"C:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\flumine\\utils.py\", line 208, in call_process_market_book\n    strategy_process_market_book(market, market_book)\n  File \"C:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python39\\Lib\\site-packages\\flumine\\examples\\strategies\\test.py\", line 47, in process_market_book\n    price_ticks_away(back, -20) and \\\n  File \"C:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\flumine\\utils.py\", line 125, in price_ticks_away\n    price_index = PRICES.index(as_dec(price))\n  File \"C:\\Users\\Admin\\AppData\\Local\\Programs\\Python\\Python39\\lib\\site-packages\\flumine\\utils.py\", line 55, in as_dec\n    return Decimal(str(value))\ndecimal.InvalidOperation: [&lt;class 'decimal.ConversionSyntax'&gt;]"}```

---

## 2020-12-02 13:50:16 - issues channel

**Aaron Smith**

[@ULDAVFDRP](@ULDAVFDRP), [@U4H19D1D2](@U4H19D1D2), or anyone else if he can/wants to help: I am still on the market.blotter problem (discussed if you scroll up a little, recap: Warning that order is missing in market.blotter is logged continously) :smile: I thought i d give you a quick update: It seems as if the orders actually are in the market.blotter. Looking at the order_ids in market.blotter._orders.keys(), i get the same order_ids as in the logging-message, for example:

```{"asctime": "2020-12-02 13:27:17,851", "levelname": "WARNING", "message": order_ids in market.blotter: "138262084251310400"}

{"asctime": "2020-12-02 13:27:17,851", "levelname": "WARNING", "message": order_ids in market.blotter: "138262084322493840"}

{"asctime": "2020-12-02 13:27:17,967", "levelname": "WARNING", "message": "Order 218299836481 not present in blotter", "bet_id": "218299836481", "market_id": "1.176256522", "customer_strategy_ref": "ip-xxx-xx-xx-xx", "customer_order_ref": "strat-138262084251310400"}

{"asctime": "2020-12-02 13:27:17,968", "levelname": "WARNING", "message": "Order 218299847629 not present in blotter", "bet_id": "218299847629", "market_id": "1.176256522", "customer_strategy_ref": "ip-xxx-xx-xx-xx", "customer_order_ref": "strat-138262084322493840"}```

So it seems to me like this warning is being logged even though the order is actually present in the market.blotter. The warning is being logged when in _process_current_orders_

```order = markets.get_order(

                market_id=current_order.market_id,

                order_id=order_id,

            )```

get_order returns None. But get_order is just checking in the market.blotter. I am still confused here :smile: I d appreciate if one of you guys has another look at it, thanks to everyone taking the time!

---

## 2020-12-02 12:18:26 - general channel

**jhaa**

Is there some sort of in-play streaming? I can only find [http://trading.in|trading.in](http://trading.in|trading.in)__play__service

---

## 2020-12-02 12:11:25 - general channel

**Thomas JAMET**

Is it a purely a trading strategy or do you take a side in the outcome?

---

## 2020-12-02 11:25:32 - general channel

**Thomas JAMET**

Hello everyone, I am new to sport betting, looking into tennis events. The first step for me is to gather historical information on tennis matches to feed into a model. My objective is to gather 20 years of data. I am scraping a few web-sites but I am getting blocked by Captchas. Did anyone resolve this scenario?

I am currently considering developing a Chrome extension to help facilitate the scraping while giving human access to the Captcha page. Any suggestion welcome. Thanks!

---

## 2020-12-01 20:44:31 - general channel

**Lennart**

Hey everyone, got another noob question -  Looks like I'm getting prices/odds through trading.betting.list_market_book() that are off from what I can see directly on Betfair's website. Generally it seems that these prices are better than those on the website. For instance, I might get 5.6 to back when I'm seeting 5.3 on the website. This is for in-game football matches, if that makes a difference.

Is this at all possible or should I be digging into/debugging my code?

---

## 2020-12-01 12:20:46 - strategies channel

**birchy**

Could be my strategy code but it's not doing anything intense. Just a couple of loops through the runners and some simple calculations. Will retry loading all markets with the dummy strategy when I get time.

---

## 2020-12-01 10:26:54 - general channel

**D C**

I guess what is actually useful depends on every person and their strategy. Its still good to know how to get at it even if it does end up being not so useful. Teach a man to fish... and all that.

---

## 2020-12-01 08:07:39 - general channel

**river_shah**

I really like the tone out of betfair lately. Outside of the occasional ban without warning, most of the steps they are taking are supportive of pro / tech savvy gamblers/ exchange eco system. They seem happy monetising via premium charge and let the best modelling / tech win.

---

## 2020-11-30 16:45:24 - strategies channel

**birchy**

Did test with conflate = 1000 last week but it seemed to be taking forever to startup, i.e. I pulled the plug after ~20 minutes. That was with no filters specified. Does the conflate also affect the polling workers, or just the stream?

From a personal design point, is it OK to run one strategy on a few thousand markets using one framework instance, or is it preferential to use smaller chunks?

---

## 2020-11-30 13:54:51 - general channel

**Dave**

I.e. if I am broadcasting market X internally then I can write a simple gui client that visualises the exact same data that some strategy is currently using as input

---

## 2020-11-30 13:28:46 - strategies channel

**Unknown**

Tested with dummy strategy and then re-implemented my strategy one step at a time. Now running full strategy on 453 markets with:

```market_filter=bflw.filters.streaming_market_filter(

    event_type_ids=['7'],

),```

---

## 2020-11-30 11:47:52 - general channel

**Lennart**

I was working on a strategy that would continue looking at prices during that delay period. Before trying to get around with some sort of parallel computation set-up, I thought I asked here whether there is a way around that.

---

## 2020-11-30 10:59:12 - strategies channel

**liam**

Interesting, how many markets did that subscribe to?  I would create a dummy empty strategy to isolate the issue and profile if necessary. I have similar subscriptions on even smaller instances 

---

## 2020-11-30 10:33:13 - strategies channel

**liam**

That. Create a dummy strategy with the same filter and see how that performs to confirm if it is flumine or your strategy code 

---

## 2020-11-30 10:27:31 - strategies channel

**birchy**

So I have a preplay strategy that I'm currently live testing on UK horse racing WIN markets. Long term, I want to extend this strategy to cover _every_ horse racing market, followed by implementation on other sports and ultimately coverage for ALL betfair markets.

Last week, during initial testing, I attempted to start Flumine with:

```market_filter=bflw.filters.streaming_market_filter(

    event_type_ids=['7'],

),```

...and managed to crash an AWS Lightsail instance when CPU &amp; RAM (2GB) hit 100% during startup. This is only a small % of where I actually want to be. I know Flumine creates a lot of objects, but is it actually THAT resource hungry?

Regarding implementing ALL markets, what's the recommended way to achieve this? Currently thinking that I may have to redesign as a polling bot instead. The strategy is not speed sensitive.

---

## 2020-11-30 09:03:29 - random channel

**Michael**

Assuming you have some idea how you intend to bet your best approach might be to code up some version of your likely strategy (however quick and dirty) and just go live at £2 stakes. That way you're generating useful data and not costing yourself much. Data from real bets placed is far more valuable than back-test data. Rather than trying to bet the absolute minimum without getting banned I would suggest you get a little money down in a lot of markets. If you have no strategy in mind then just put bets on in a good number of market as offers to backers - so you're laying at or slightly shorter than the best available to back price. Maybe have some check that the book is well made up to avoid very low liquidity markets.

---

## 2020-11-30 08:36:48 - random channel

**Misha**

I kept my account clocking over before running a strategy doing this - it cost me about $5 per $1K turnover on average

---

## 2020-11-30 08:30:21 - random channel

**Artur Gräfenstein**

Without a strategy, isn’t the risk always the same?

---

## 2020-11-30 08:09:53 - random channel

**Artur Gräfenstein**

Hi everyone, does anyone know how tolerant Betfair is with read-only live keys? I can’t really finish my development with a 2 minute delay. So I have to adjust the details with the live key without betting.

---

## 2020-11-29 22:57:03 - strategies channel

**Charlie 303**

Could anyone explain when/what sort of strategy it would be beneficial to turn off Best Price Execution as per [@U4H19D1D2](@U4H19D1D2) s comment in this thread in the bf forums [https://forum.developer.betfair.com/forum/sports-exchange-api/exchange-api/32967-issue-on-betting-in-ordinary-odd-ie-3-4-and-have-it-matched-with-odd-1000?p=32973#post32973](https://forum.developer.betfair.com/forum/sports-exchange-api/exchange-api/32967-issue-on-betting-in-ordinary-odd-ie-3-4-and-have-it-matched-with-odd-1000?p=32973#post32973) ?

---

## 2020-11-29 22:46:05 - general channel

**birchy**

In Flumine logs, I see: `BackgroundWorker poll_account_balance starting` but how do I access available balance from within a strategy? Want to add a check in `check_market_book()` along the lines of `if balance &lt; 'N': return`

I don't have an infinite balance like some of you... :joy:

EDIT: Found it! `self.client.account_funds.available_to_bet_balance`

---

## 2020-11-29 18:49:07 - issues channel

**Oliver Varney**

Are you sure you created the orders through flumine on the same computer, with the same strategy name ? the strategy name hash doesnt look like it has a match if the strategy returned is None, or you havent added a strategy if that's possible, or the order does not had an customer_order_ref. can you use the debugger to check the value of strategy_name_hash is in strategies.hashes.get(strategy_name_hash)

---

## 2020-11-29 18:20:46 - issues channel

**Aaron Smith**

I see. Still 2 things i didnt understand yet: How did the order escape from getting added to the blotter in the first place? I can see the restart argument, but the framework wasnt restarted (well, it was, but these warnings were already logged after the very first start). Also, how come the warning is being logged over and over again when the order should ve been added by the create_order_from_current  -function? Right now the only possibility to escape from being added to the blotter that i see is if

```if strategy is None:

        # todo log

        return```

it escapes here (that snippet is taken from the create_order_from_current  -function) . But i dont see how this would happen either.

---

## 2020-11-29 17:30:46 - random channel

**Newbie99**

I've been getting this all day and I can't figure it out, as it appears to occur when _process_close_market runs (which I haven't changed from the pip install of flumine)?



```  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/flumine.py", line 44, in run

    self._process_close_market(event)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/baseflumine.py", line 264, in _process_close_market

    market.blotter.process_closed_market(event.event)

  File "/home/ec2-user/trading/env/lib64/python3.7/site-packages/flumine/markets/blotter.py", line 86, in process_closed_market

    for runner in market_book.runners:

AttributeError: 'dict' object has no attribute 'runners'```

---

## 2020-11-29 16:56:38 - issues channel

**Aaron Smith**

Hello folks! I m having an error i currently cant explain, its certainly not an issue of flumine itself, but maybe one of you guys can help me out anyway :slightly_smiling_face:

I keeps getting the following warning:

```{"asctime": "2020-11-28 21:23:28,772", "levelname": "WARNING", "message": "Order 217999225444 not present in blotter", "bet_id": "217999225444", "market_id": "1.176099484", "customer_strategy_ref": "ip-xxx-xx-xxx-xx", "customer_order_ref": "stratname-138258912423034860"}```

I dont see how i managed to get orders which are not in the blotter, as with markets.place_order any order should automatically be added to the blotter?

Also on a complete diffrent topic: Sometimes i get prints and [http://logging.info|logging.info](http://logging.info|logging.info)() outputs in the console output, but mostly not. How can i choose which kind of outputs i want to get in my console?

Its is entirely possible i m overlooking the obvious, i m new to coding (corona made me do it :smile: )

Thanks to anyone taking the time to help me :slightly_smiling_face:

---

## 2020-11-29 10:26:03 - general channel

**liam**

Either is fine, [https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/markets/market.py#L52|market.place_order](https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/markets/market.py#L52|market.place_order) is the function, strategy.place_order is just a proxy for it. Only limitation is that a[https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/baseflumine.py#L153|process_market_orders](https://github.com/liampauling/flumine/blob/4f08f389a3c5c2722b60252055b143cfdfefb0f7/flumine/baseflumine.py#L153|process_market_orders) is called as this is when the orders get batched up and processed 

---

## 2020-11-28 06:30:31 - issues channel

**mandelbot**

Here's another example, it's not nonrunners...first date is market start time

`1.174235551 2020-10-16 13:53:00 23160590 2020-10-16 13:38:00.219000 OrderStatus.EXECUTION_COMPLETE BACK 30.0 10 0.0`



`{"asctime": "2020-11-28 06:21:33,082", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.174235551", "selection_id": 23160590, "handicap": 0, "id": "138258372930769969", "customer_order_ref": "c13a2832c6a96-138258372930769969", "bet_id": "100000000003", "trade": {"id": "f5c31430-3141-11eb-8cda-5c969d7d9766", "strategy": "Bot", "status": "TradeStatus.LIVE", "orders": ["138258372930769969"], "notes": "", "market_notes": "30,29,30"}, "order_type": {"order_type": "Limit", "price": 30, "size": 10, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 10, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 30.0}, "status": "Execution complete", "status_log": "Pending, Executable, Execution complete"}`

---

## 2020-11-27 13:21:56 - general channel

**mandelbot**

lol, I want to grab the amount matched from my orders within a strategy :clown_face:

---

## 2020-11-27 08:58:53 - issues channel

**Jonjonjon**

Ah, sorry. html encoding error:



`Oops no service available at [https://api.betfair.com/exchange/betting/json-rpc/v1](https://api.betfair.com/exchange/betting/json-rpc/v1)`

`&lt;urlopen error [Errno -2] Name or service not known&gt;`

`Traceback (most recent call last):`

  `File "/home/content/28/xxx/html/xxx/helpers.py", line 66, in callAping_direct`

    `).encode('utf-8'))`

  `File "/usr/local/lib/python2.7/urllib2.py", line 126, in urlopen`

    `return _opener.open(url, data, timeout)`

  `File "/usr/local/lib/python2.7/urllib2.py", line 400, in open`

    `response = self._open(req, data)`

  `File "/usr/local/lib/python2.7/urllib2.py", line 418, in _open`

    `'_open', req)`

  `File "/usr/local/lib/python2.7/urllib2.py", line 378, in _call_chain`

    `result = func(*args)`

  `File "/usr/local/lib/python2.7/urllib2.py", line 1215, in https_open`

    `return self.do_open(httplib.HTTPSConnection, req)`

  `File "/usr/local/lib/python2.7/urllib2.py", line 1177, in do_open`

    `raise URLError(err)`

`URLError: &lt;urlopen error [Errno -2] Name or service not known&gt;`

---

## 2020-11-27 08:42:50 - issues channel

**Jonjonjon**

On an old server, which hasn't been ported to BFLW, I am getting this error message:



`Oops no service available at [https://api.betfair.com/exchange/betting/json-rpc/v1](https://api.betfair.com/exchange/betting/json-rpc/v1) Traceback (most recent call last): File "/home/content/28/xxx/html/xxx/helpers.py", line 66, in callAping_direct ).encode('utf-8')) File "/usr/local/lib/python2.7/urllib2.py", line 126, in urlopen return _opener.open(url, data, timeout) File "/usr/local/lib/python2.7/urllib2.py", line 400, in open response = self._open(req, data) File "/usr/local/lib/python2.7/urllib2.py", line 418, in _open '_open', req) File "/usr/local/lib/python2.7/urllib2.py", line 378, in _call_chain result = func(*args) File "/usr/local/lib/python2.7/urllib2.py", line 1215, in https_open return self.do_open(httplib.HTTPSConnection, req) File "/usr/local/lib/python2.7/urllib2.py", line 1177, in do_open raise URLError(err) URLError: 2020-11-27`

---

## 2020-11-26 17:18:55 - random channel

**thambie1**

Depends on the strategy.

---

## 2020-11-26 14:18:18 - random channel

**Artur Gräfenstein**

Or do your models still work the same way?

---

## 2020-11-26 13:09:53 - issues channel

**Ryan Clapham**

```trading = betfairlightweight.APIClient(username, password, app_key=app_key, certs=cert_path)



trading.login()```

---

## 2020-11-25 20:36:25 - strategies channel

**Dave**

ROC/prec-recall AUC is usually a good indicator of how sensible your model is

---

## 2020-11-25 19:44:24 - strategies channel

**D C**

Hosmer–Lemeshow might work here too - its a test that shows how closely probability estimates of a logistic regression model match observed outcomes so is closely related to what you want. I used this years ago and it may not be applicable to this case for the reasons that [@UBS7QANF3](@UBS7QANF3) highlights but it might be an additional topic to explore.

---

## 2020-11-25 19:32:06 - strategies channel

**JC**

Hi guys, got a question about evaluating the performance of a model. What is the best way, mathematically, to evaluate how accurate a model is at spitting out probabilities in-play. I guess you could for example group together all occasions where the output is 0.6 implied probability and if close to 60% of these predictions are correct then it is a good model? Is there a better way of doing this?

---

## 2020-11-25 14:10:54 - general channel

**ricky**

Did you inject market_catalogue object into your exist strategy object? I have been google a while, but still not sure if possible in python.

---

## 2020-11-25 14:02:53 - general channel

**ricky**

[@UUCD6P13J](@UUCD6P13J) What middleware you are reference? For backtesting, i am not sure if i can inject market_catalogue object into a strategy or only inject at the beginning of file?

---

## 2020-11-25 12:48:46 - general channel

**birchy**

Looking for horse racing metadata in a Flumine strategy, but can't seem to locate it. Anyone able to point me in the right direction?

---

## 2020-11-24 19:46:31 - general channel

**liam**

It’s a typical design you see in trading systems, strategies have trades and trades have orders, a strategy has multiple trades and a trade can have multiple orders. For example you might want 1k on a runner but split across multiple orders to reduce impact 

---

## 2020-11-24 19:22:10 - general channel

**Oliver Varney**

customer_order_ref = strategy_hash + internal_trade_id + bet_id

---

## 2020-11-24 19:14:07 - general channel

**liam**

Can we make the assumption that each complete order had a single trade, link to the correct strategy class and let the user override if required? 

---

## 2020-11-24 16:41:55 - general channel

**liam**

Up to the user to store within the strategy or keen to create some analytics middleware to bring in this data but nothing public yet

---

## 2020-11-24 16:11:28 - general channel

**Oliver Varney**

in the add_market function in flumine I call list_current_orders. I Rebuild trades using the customer_order_ref for which I have altered to suit my requirements for now (likely to move to either logs or redis), then build the order from the current order object and add it to the blotter. I store trades in a "strategy market dictionary" (I think flumine has its own so probably not necessary for you). This should prevent double order / double trades

---

## 2020-11-24 16:10:26 - general channel

**birchy**

Not really practical when dedugging/developing a new strategy. The transition from backtest to live has highlighted a couple of issues that I need to rectify, so I'm in a bit of a run-&gt;stop-&gt;edit-&gt;run loop at the moment. Is that not normal procedure when developing/testing?

---

## 2020-11-24 15:28:55 - general channel

**birchy**

Currently testing my first live Flumine strategy. Have noticed that if I stop the bot and restart, bets are being repeated regardless of `max_trade_count` ,`max_live_trade_count` , `max_selection_exposure` , etc. Obviously the new instance handles its own bets but not any other bets that were previously placed. Same applies to bets that are manually cancelled - Flumine does not attempt to bet again until the instance is restarted. The latter is not a big issue, but obviously doubling exposure on restart is. What's the recommended procedure to avoid double betting when an instance is restarted? Is there a way to allow the new instance to take ownership of its previous bets and/or avoid re-betting based on the strategy_ref or similar?

---

## 2020-11-24 13:17:17 - general channel

**jgnz**

ok so it will have less of an effect on the strategy than my inefficeint coding choices everywhere else :slightly_smiling_face:

---

## 2020-11-24 13:09:38 - general channel

**jgnz**

hi guys, i am jumping back in after a couple of years away. i am trying to create a basic strategy using streaming data, which is dependent on the runner name. I have a couple of questions about that;

• In a market catalogue, is a selection id unique for each runner name across all markets and events? ie a can slowly build up a reliable mapping table of selection ids and runner names.

• is it possible to make a streaming filter request that returns the market catalogue? or does it need to be a separate list_market_catalogue call(i assume yes)?

Given that my strategy needs the runner name and it is slow to make a request just for that, i am planning on building a table of selection ids and runner names in local database. checking if the runner's selection id is present, and only call list_market_catalogue if it is not found. Does that sound like a reasonable action if i need the runner name for my strategy?

---

## 2020-11-24 10:49:05 - general channel

**sartux**

Hi guys,

I created a very trivial script that takes the last 100 operations and writes them to a MySQL table, in order to create a statistic of the account.



```balance = trading.account.get_account_statement()

b = json.loads(balance.json())

gc = b['accountStatement']

cc = json_normalize(gc)```

until a few hours ago it worked correctly, now I get it as an error



```TypeError: __init__() missing 1 required positional argument: 'marketName'```



I investigated the exception and the only difference is this new record



                "legacyData": {

                    "avgPrice": 0.0,

                    "betSize": 0.0,

                    "betType": "B",

                    "betCategoryType": "E",

                    "eventId": 0,

                    "eventTypeId": 0,

                    "fullMarketName": "Credit",

                    "grossBetAmount": 0.0,

                    "marketType": "NOT_APPLICABLE",

                    "placedDate": "2020-11-24T09:26:32.000Z",

                    "selectionId": 0,

                    "startDate": "0001-01-01T00:00:00.000Z",

                    "transactionType": "ACCOUNT_CREDIT",

                    "transactionId": 0,

                    "winLose": "RESULT_FIX",

                    "avgPriceRaw": 0.0

                },



could it be that the method goes into exception for this reason?



maybe I'm wrong in the analysis of the problem, possibly how can I simply extract the last 100 operations?

---

## 2020-11-23 23:00:27 - random channel

**qwerty.nat**

Indeed, i'm not even allowed to do volunteer work without sign off. I do work for a HFT but doing ultra low latency trading, and i disagree with Misha that sports is a lot more consistent. There are lots of times where we know the price will change with 100% certainty, so if you are fast enough you can scalp a tick here and there. Free money basically. However to get to that point you need massive investments in technology / market structure research etc.

---

## 2020-11-23 22:30:18 - random channel

**Dave**

[https://www.kaggle.com/c/jane-street-market-prediction/overview](https://www.kaggle.com/c/jane-street-market-prediction/overview) for the modelling enthusiasts out there

---

## 2020-11-23 21:55:46 - strategies channel

**D C**

[@U01EYDA8345](@U01EYDA8345) You will never get to the point where everything is modelled to perfection but this could be a philosophical argument as much as a tech argument. Perhaps if we can model things on a quantum level it could happen but in practical terms that is intractible. Even it if were possible, could quantum mechanics predict human behaviour such as corruption for thigs like match or spot fixing?? Maybe one day but we will all be in the ground by then!! As for using 1000 parameters, modelling favours less parameters for their greater generality. Consider a fairly simple mathematical example where you want to approximate a set of data using a polynomial curve - if you choose the degree of polynomial equal to the number of points, you get an interpolation (where the curve passes through every point) but this is seldom any good at predicting the general shape of the data points - better to choose a lower degree curve that is able to be acceptably "close" to the data. The first case is termed overfitting and building linear statistical models favours choosing SMALLER amount of parameters but ones that help "explain" the data wherever possible. I cannot speak for machine learning methods as I am a novice in that area. As for bookies they don't need to be that accurate in pricing (well soft books) because they will just ban winners. Pinnacle use profitable/savvy customers to adjust their prices accordingly but I believe that they have pretty good analytics too (just from what I hear).

---

## 2020-11-23 21:04:44 - strategies channel

**Misha**

So if you are good at modelling the sport, you will always be able to make money, and that will never change. Not to mention that on Betfair you aren't going up against a bookmaker, you are up against 1000s of others with their own ideas of who will win

---

## 2020-11-23 21:00:29 - strategies channel

**Misha**

Introduction of a new feature, unless very carefully considered, will often make the modelling worse

---

## 2020-11-23 20:59:32 - strategies channel

**Misha**

Even if two models use the same inputs, they won't use them the same way, or weight them the same way, or really do anything the same

---

## 2020-11-23 20:57:16 - strategies channel

**Artur Gräfenstein**

If I understand this correctly, you will make profit from value odds. Because you are using data (for example yellow cards) that the bookmaker does not include in their price. Or you have a better Model than the bookmaker. If the bookmaker would now include yellow cards and start using your model too, you will stay at +-0. Now you could say: “Ok, forget about the yellow cards, I will look only at the red cards(wich the bookmaker also does not include in their price for now)“. If the bookmaker includes the red cards too, you will not be profitable at both of these strategies anymore, right? Or the odds will move in an direction that the yellow card strategie will be now profitable at some point? Is it right to assume that the more data the bookmaker use, the less value can be found in the price? (Ignore the fact that bookmakers make mistakes) So any strategy will only work until the day your bookmaker takes over your calculations?(theoretical question) And maybe in 50 years there will no longer be a profitable strategy?

I don’t know if I’m understanding the price calculation right, so...! Also sorry for the bad explanation of translation.

---

## 2020-11-23 20:08:18 - strategies channel

**Misha**

I have seen a profitable model on Aussie Rules and Rugby League using basically one main feature. Of course, you have to identify that feature :wink:

---

## 2020-11-23 20:07:17 - strategies channel

**Misha**

For stats models, 90% of the profit comes from a few "features". Adding lots of features might fine tune a good model, and make it a great model, but if it isn't profitable just looking at a few variables, you aren't on the right track

---

## 2020-11-23 20:05:29 - strategies channel

**Misha**

The corporates aren't that great on the modelling side these days - they look at each other, and particularly Betfair, look at their exposure, and adjust accordingly. Of course the UK model is pretty much to ban winners, so they have very few on their books who have good predictions

---

## 2020-11-23 19:20:54 - strategies channel

**thambie1**

Also, per Dave's earlier comment; bookamakers just as any trader my not have the same goals or strategy as you. A bookmaker may want a balanced book to reduce risk, more than they want to offer the 'accurate' odds.

---

## 2020-11-23 19:14:37 - strategies channel

**birchy**

This is why I've never been 100% convinced that modelling probabilities yourself is worthwhile.

---

## 2020-11-23 19:14:15 - strategies channel

**Artur Gräfenstein**

My question is about: when the bookmaker would use 1000 parameters for price calculation, is it possible with lets say 5 parameters of the 1000 make profit? Its more a mathematical question that I am thinking about since some months. It’s also about whether betting has a future.

---

## 2020-11-23 19:01:25 - strategies channel

**Artur Gräfenstein**

A general question: would it ever be possible, that bookmakers (for examle we forget about the excange etc.) predict the price with all data awailable on planet so it would not be posible to make profit from betting?

---

## 2020-11-23 18:31:45 - strategies channel

**Michael**

You're agreeing that your bets are +EV when evaluated against the outcome (and you're right of course) - how do you account for that coming about unless your models identify +EV bets? You might not have conceptualised that as being it's purpose but that's what it does.

---

## 2020-11-23 18:05:42 - strategies channel

**Dave**

I think it's slightly more nuanced than that. Say I forecast the price 5s ahead to be higher than what it is now. I lay at the current price. 5s later the price is indeed higher. I redo my forecast and now my model says "no the price will now drop". So I back. In both cases I assess my positions as +EV relative to price movement 5s ahead. I could not careless about the event outcome. The techniques and skills applied are totally different to looking at value relative to event outcome. You might say that your fair price for a horse is 5.0 and won't back it any price below that. Someone forecasting prices might say I'm happy to back at 4.9 because I expect the price to be lower than 4.9 5s ahead. And while this would be -ev position for you and you'd never take it, it's still a value bet for this person because they assess +EV relative to price movement rather than event outcome, and totally reasonable for them to take it. So I don't think it's fair to unify the tasks if they end up in scenarios like this. (Edit: corrected trade directions)

---

## 2020-11-23 17:40:57 - strategies channel

**Michael**

Or to put it another-other way: If you understand that to make a profit your bets must show +EV when evaluated against final outcomes (and if you don't I can't help you) and you have a model of any kind that produces profitable results then your model must be identifying +EV bets whether you designed it to do that or not because how else did you get them? My opening comment was intended simply to reveal how this comes about. Hopefully I've put it enough ways now.

---

## 2020-11-23 17:16:48 - strategies channel

**Dave**

Just sounded like you were saying the two tasks are the same which I disagree with :sweat_smile:  one is modelling market microstructure (specifically if you do it over a small timeframe, e.g. 5 market ticks) whereas the other is modelling the actual event. The difference I suppose is that if you're betting on price changes 5 ticks ahead, you don't care _which_ of your trades are + EV /  -EV relative to the outcome of your event and believe that your model in general will lead to more +EV than -EV. As opposed to outright value betting where you aim for _each_ bet to be +EV.

---

## 2020-11-23 17:15:58 - strategies channel

**Michael**

Your model needn't forecast the outcome of an event to spot +EV. By successfully predicting that a price is about to move you're essentially saying 'I may not know what a 0EV price is but that's too high'.

---

## 2020-11-23 17:12:18 - strategies channel

**Dave**

But the original posts suggests that the two tasks (forecasting pricing and forecasting outcome) can be unified. But it's be unreasonable to use a model that's very good at predicting a price 5 ticks ahead that takes in order-book/trade features to forecast the outright outcome of event...

---

## 2020-11-23 17:07:28 - strategies channel

**D C**

Alessio there is a lot of talk about modelling recently. If you accept that savvy market participants in the market have a good estimate of a true probability of something happening, when those participants see a price that is value they will get their money in the game. If a price is too large, it is only logical that it will get taken advantage of and so the price corrects back to 0EV ?

---

## 2020-11-23 17:04:34 - strategies channel

**liam**

A while ago we were arguing about trading and finding profitable EV being different, [@UGV299K6H](@UGV299K6H) helped explain it best by saying if you are a profitable ‘trader’ you have to by definition be getting +EV or you wouldn’t be in profit as that is just simple addition 

---

## 2020-11-23 16:52:14 - issues channel

**Mo**

I'm willing to but probably don't have the time to do it justice right now. As [@U4H19D1D2](@U4H19D1D2) says, it's totally strategy dependent. If you don't care about the full market book - for example, your strategy is just deciding whether the best price is value - you can store these in simple CSV files that you can read in a fraction of the time compared to a scraped/historic Betfair prices file

---

## 2020-11-23 16:40:37 - issues channel

**liam**

I guess it’s all strategy dependant, I can create a strategy in two lines that would make double figure percentage ROI but in the real world I have no chance in hell getting matched enough to actually make it profitable. For me matching rates are crucial, [@UBS7QANF3](@UBS7QANF3) do you factor this in based on the book? I have always found this impossible when working with flat data hence going down the route of mimicking/simulating the betfair matcher but ignoring double counting of available liquidity 

---

## 2020-11-23 16:28:12 - issues channel

**thambie1**

It's a huge pain in my development cycle waiting for backtests to run. And I've already done a ton of optimizations on my code base.

---

## 2020-11-23 15:40:42 - issues channel

**Mo**

Yeah, personally I use pre-processed data for "backtesting"/strategy development and real data for implementation testing

---

## 2020-11-23 14:51:28 - strategies channel

**MacrcoPolo**

One of the standard techniques in modelling low-sample-size sports (NFL comes to mind...) is to benchmark your predictions based on the odds moves towards the start to measure how good your predictions are. You can use this to get an idea of whether your predictions are strong without needing to actually 'realize' the pnl on the outcome.

---

## 2020-11-23 14:46:43 - strategies channel

**AP**

I’m not as experienced as the other people on here but I just feel like I wasted a lot of time trying to create my own price whereas I found success a lot more easily just by analysing factors/variables and building some simple models that way 

---

## 2020-11-23 14:38:11 - issues channel

**liam**

Depends I know some ([@UBS7QANF3](@UBS7QANF3)?) backtest using simpler (quicker) / flat data but for me being able to test a strategy using real data is extremely valuable 

---

## 2020-11-23 14:31:04 - general channel

**Dave Simonds**

I do have controls in place but this just slipped through the net, it’s actually an old strategy that I brought back this weekend.... it was originally written before the controls were.



We all make mistakes and I’m not embarrassed or beating myself up over it, I just hope I don’t end up forking out a grand because of it.



To be honest tho, I’ve not heard back from either Neil or customer services. I’m not counting on getting this back.



I should really take a look at flumine, not done so yet because I’m not a fan of python. I only joined the page to see how many other people were perusing bot-trading and it’s been quite eye opening.

---

## 2020-11-23 14:22:37 - strategies channel

**liam**

Agreed one of these a day please, can already see this being a quote to start a section in the strategy docs

---

## 2020-11-23 13:02:10 - general channel

**Amanda**

A loss - started a new strategy, let It run and walked out the door. Very careful with anything new from then on.

---

## 2020-11-23 12:49:10 - general channel

**Dave Simonds**

Ouch!!!! Do you mind if I ask if that was a legit loss or a charge from BF? 



I only ask because I want to know if I’m likely to get this back (or at least reduced).



My worst unattended afternoon was -£300 but that was down to getting screwed by a non runner and a reduction factor turning me from green to red.... I don’t do that strategy any more 

---

## 2020-11-23 01:47:00 - issues channel

**Unknown**

Hi,



First of all, thank you for the betfairlightweight &amp; flumine libraries.



I am seeking advice from the community w/ respect to latency when backtesting w/ Flumine. The objective of the tests below is to compare the performance of Flumine in the context of backtesting with the performance of a simple, naive implementation.



Test1:

Using [https://github.com/liampauling/flumine/blob/master/examples/backtest.py](https://github.com/liampauling/flumine/blob/master/examples/backtest.py) with an empty strategy. The log level has been raised to CRITICAL



Test2:

A python script  iterates thru the same collection of files, reads each line and parses them as JSON. The JSON structure doesn’t get processed further.



Both tests run on the same machine sequentially. The machine has 60GB of memory and 16 CPUs.



Size on disk for data is 1.6M for `betfair/tennis/xds_nfs/edp_processed/BASIC/2019/Jan/15`



Test1 runs in ~2 minutes

Test2 runs in 5 seconds



I understand that Test1 does a lot more than Test2. Flumine will create data structures, maintain states, etc…



But am I doing it right? Before I go the route to run profiler, what would be some comments?



PS: I did try the multithreaded approach found here [https://betfairlightweight.slack.com/archives/C4HL6EZTQ/p1598171342144900](https://betfairlightweight.slack.com/archives/C4HL6EZTQ/p1598171342144900) courtesy of Jonjon &amp; Birchy and it did run in ~5 seconds. Would love to get some thoughts though. Thank you!

---

## 2020-11-22 19:32:47 - strategies channel

**Artur Gräfenstein**

I can offer my help. I am currently working full-time on bots for strategy development etc. but in nodejs.

---

## 2020-11-22 10:13:35 - strategies channel

**birchy**

Can creating a resource be automated? :joy:

Seriously though, lots of people could benefit from understanding the fundamentals, myself included. I guess the only thing to be wary of is if/when some asshole rips it off and starts selling on eBay. I speak from experience as I once published online, a free strategy called "lay the draw" in 2002. I may have been the twat who invented it as I've not found any evidence of it existing before then.

---

## 2020-11-22 09:46:36 - strategies channel

**Mo**

I'm happy to contribute material on sport specific probability models (rather than general purpose machine learning models)

---

## 2020-11-22 09:21:05 - strategies channel

**liam**

Boring is good but I guess it doesn’t sell, [@UGV299K6H](@UGV299K6H) are you still up for contributing to some sort of strategy development resource either on the bflw or flumine docs? 

---

## 2020-11-22 08:08:27 - strategies channel

**Michael**

It seems to be being taken as read that all the biggest operators use external data sources to model probabilities but this just isn't true.

---

## 2020-11-22 00:53:32 - strategies channel

**Dave**

The way I see it - not all participants in the market are looking to make money from every bet they offer or take, or consider EV in the same way as you might do. People skew from what would be considered your "true price" for all sorts of reasons: hedging existing risk (reducing exposure to a more palatable level, maybe having operational issues etc), or doing silly "offset greening by fixed X ticks"-type things. Computation of the true price also depends on your strategy - if you are predicting the outcome of the event then you'll be applying different techniques to predicting price change over the next X seconds. This also means that not every bet has a "winner" and a "loser" - the person you were matched with may just have a different target they are wagering on, and therefore the bet can have positive expected value to both sides as the target of their forecast is diffeeent. So you don't even need "mugs" to profit on - you just need to be able to pick a reasonable target to forecast (price movement, event outcomes etc), and figure out what data can provide you with decent signals to make your forecast.

---

## 2020-11-21 23:22:13 - strategies channel

**Misha**

[@U016TGY3676](@U016TGY3676) - modelling your own probabilities is as hard as it gets, but it's also the path to the biggest profits, basically because it is so hard to do well

---

## 2020-11-21 20:52:45 - general channel

**liam**

To reduce you cancel and to increase you replace, example in the example strategy 

---

## 2020-11-21 19:24:28 - strategies channel

**birchy**

Thank you all. Certainly given me a bit of direction.  So to summarise, using betfair prices as the only source of data IS possible, however modelling your own probabilities is far more lucrative IF you have a higher level understanding of maths and can build a decent model.

---

## 2020-11-21 17:07:39 - strategies channel

**Michael**

I don't use any of those things. In market based operations I just look for instability, then I have some special sauce that takes a stab at what a stable book ought to look like and bet on the differences. For GPS I have a GPS model for the race and I compare it to the book.

---

## 2020-11-21 15:57:27 - strategies channel

**D C**

Yes I agree but I think for some sports, such as football, the analytics available and the bespoke data around pretty much put the average "one man and his computer" way behind. Maybe for obscure leagues and markets like bookings/corners etc there is an edge to be obtained. I reckon even the man with the most sophisticated model in the world is going to be behind the guy with advance news of the team squad when it comes to profit making. Don't get me wrong, I am not downplaying ML/stats at all (I am/was a mathematician after all), I am just saying that to beat market prices in the bigger sports as a one man band going down the analytical route is a tough gig.

---

## 2020-11-21 15:48:19 - strategies channel

**D C**

The choice of tool depends on what you want to do. As some of the big guns say, "simple" things make them profit. But for example, if you wanted to try and build a probability model for each runner in greyhound races, you are going to need identify the right tools for the job. Part of the problem is knowing what you want to analyse, then digging around and finding the right tool. Trouble with ML (and statistics for that matter) is that there are so many methods and techniques and it can be bewildering at times. And as has been mentioned before, even if you FIND the right tool, chances are that there are others out there with access to bespoke data that puts them way ahead of you.

---

## 2020-11-21 15:31:56 - strategies channel

**Oliver Varney**

personally [@U016TGY3676](@U016TGY3676) if you dont have an idea for a strategy (learning task) before using AI/ML its unlikely to magic something up especially as the guys have mentioned if you dont understand what its doing. I think [@UGV299K6H](@UGV299K6H) gave some great advice about understanding market fundamentals. In my opinion the algorithm is always an after thought after you feel you have a solid idea (for which people wont hand to you as it will lead to them losing profit, after years of work).

---

## 2020-11-21 15:16:53 - strategies channel

**D C**

But again, depends on what you are trying to predict - if you want to try and model a time series of market data, it is a very different beast to trying to estimate probability of a sporting outcome.

---

## 2020-11-21 15:14:31 - strategies channel

**D C**

Totally agree with this. While ML is great for certain things, learning some techniques concerned with statistical inference is a good start. Trouble is that the entry level of mathematics is quite high to get a handle on even logistic regression (personally never came across GLMs until postgraduate levels of study). True, you don't need to know the theory to bang together a model in R/Python/Matlab/whatever, but having some appreciation of what you are modelling and the underlying assumptions of the techniques you are using is very important. Yes you can use a multitude of ML/stats tools blindly in the black box sense, but knowing how to interpret what comes out of them. It is not always about p-values. Trouble is the bar for entry is quite high.

---

## 2020-11-21 14:49:39 - strategies channel

**Dave**

As many ppl will tell you, build your model with context and understanding of the relationship between your input and target - just shoving some data into an algorithm without any context will most likely lead you to a nonsensical model

---

## 2020-11-21 14:47:57 - strategies channel

**Dave**

Important thing is to understand the fundamental relationship between your inputs and the thin you're forecasting - i.e. no point fitting a linear model to predict y from X if fundamentally X doesn't have a linear relationship to y. And to evaluate on out-of-sample data to understand if your model can actually generalise well.

---

## 2020-11-21 14:47:00 - strategies channel

**Dave**

Even RenTech started with plain ol' linear models :)

---

## 2020-11-21 14:46:36 - strategies channel

**Dave**

Linear models is where I got started. Logistic regression for classification is a decent starter if you're looking at binary problems ([http://e.g.as|e.g.](http://e.g.as|e.g.) win / no win) as it's a pretty transparent model (unlike something more black box like neural networks/trees etc). Linear regression for regression tasks (there are a variety of methods out there to implement such a model). Scikit learn has all the basic tools you need for all the stages of modelling; data cleaning, standardisation, model fitting and evaluation

---

## 2020-11-21 14:11:30 - strategies channel

**birchy**

So with all this chitter chatter about modelling data and probability prediction, I'm wondering where simpletons like me would get started on these approaches? What tools would you consider are essential? I'm not a complete dunce (some parts are missing!) but Google searches seem to muddy the waters even more and all these Greek symbols are...all Greek to me.

I've been experimenting with various strategies using nothing but market data, but am really struggling to find anything worth punting some real money. Truth is, I seem to be able to construct strategies very easily but _winning_ strategies are much harder to come by. And with you all saying that the last few months have been golden, I really do feel quite disheartened with the whole thing. :flushed:

---

## 2020-11-20 21:59:56 - random channel

**V**

Also, another idea is that since you have years worth of backtest results, then you can get an ideas as to the characteristics of the strategy. The max draw down, the typical return you can expect etc etc you can compare your results to various metrics in the backtest to see how out of line you are at a given moment  

---

## 2020-11-20 21:47:53 - random channel

**Oliver Varney**

i.e. beating bsp consistently is a good measure for most of my models

---

## 2020-11-20 21:47:33 - random channel

**Oliver Varney**

but with most of my model I like a metric for live to understand / identify any issue / how its performing

---

## 2020-11-20 21:44:01 - random channel

**Oliver Varney**

Yer might be able to devise something from there, could lead to a new feature for the model

---

## 2020-11-20 21:40:27 - random channel

**Oliver Varney**

I think its safe to say I trust my own model I built seeing as what its provided

---

## 2020-11-20 21:37:19 - random channel

**Oliver Varney**

depends whether you trust your model

---

## 2020-11-20 21:32:35 - random channel

**Jonjonjon**

I wouldn't want to trade a strategy that was based on laying long shots like that.

---

## 2020-11-20 21:31:52 - random channel

**Oliver Varney**

then 3 horses win and your actually on a losing strategy if you get my drift. obviously benchmarking vs bsp is normal for pre off but if your laying at bsp this metric isnt available

---

## 2020-11-20 21:30:38 - random channel

**Oliver Varney**

Im more wondering about how to judge how your model performing. if your lay high odds, its very easy to hit long winning streaks, which could give a false idea of performance.

---

## 2020-11-20 21:07:26 - random channel

**Oliver Varney**

question for the layers, but does anyone lay at bsp, and if so specifically on long prices is there a metric that you look out for to confirm that your model is performing inline with backtesting.

---

## 2020-11-20 13:39:36 - random channel

**Mo**

Their customer profiling models are almost certainly better than their pricing models (in most cases)

---

## 2020-11-20 13:39:01 - random channel

**Mo**

1. Bookmakers have extremely good models for customer profiling. They will be able to detect patterns of bad bets trying to disguise good ones

2. Arbs are so blatant I don't think you can hide them at all

---

## 2020-11-20 13:17:31 - strategies channel

**Stefan**

[@U013R0E7SUV](@U013R0E7SUV) Andrej yes I am looking for any tool helping to visualize or analyze, but when you end with last phase, so implementing bot data analyzing algorithm, you need  to use the same algorithm for data processing like your used tool is using, and that can be sometimes a problem. This way the code preprocessing data for visualization or analyzing can be used directly in the bot trigger, you can actually see that in my video where back-testing strategy/so bot, generates data to be shown on the charts, so helping me manually looking for some data patterns.

---

## 2020-11-20 11:35:32 - general channel

**Alessio**

then comes the coding challenge to put protections when the strategy goes haywire because something has changed into the assumptions

---

## 2020-11-20 11:33:09 - general channel

**Alessio**

It's like training a model on bitcoin vs usd in the last month. You don't want to do that :slightly_smiling_face:

---

## 2020-11-20 11:12:01 - general channel

**Alessio**

also what you care is value, rather than accuracy, so you probably want to frame it slightly different problem. Odds per se are a prior (slightly altered bythe need of the bookie to make money). It's almost adversarial: you want to classify the situations where their model is underpredicting / overpredicting.

---

## 2020-11-20 11:06:41 - general channel

**Mo**

[@U01C12ZEADQ](@U01C12ZEADQ) 100% would not make money. The model worked for about 6 years before reaching the stage where it was not profitable 

---

## 2020-11-20 10:38:11 - general channel

**Alessio**

and I agree with Mo data is king tbh. Think about those xG models for soccer. If you had the data to build one for leagues that currently aren't covered, you would be rich soon, probably. Independent of where you apply it

---

## 2020-11-20 10:34:49 - general channel

**Alessio**

[@U01093Z1KF0](@U01093Z1KF0) in general, though, it's very different. exchange trading is a bit like a simplified financial market, with the huge advantage that most of the data is openly accessible to many players. So you go fish for less informed players and take value out of them. For predicting the outcome it's different it's a pure probability game and it's one where you can't really play unless you have a sizeable bank, because the variance will hit and it may criplle your long term +EV strategy

---

## 2020-11-20 10:31:43 - general channel

**Alessio**

[@UBS7QANF3](@UBS7QANF3) out of curiosity, if you rolled out that model for tennis today, would it still have an edge? one thing it's not clear to me is how much the pricing of odds is getting more efficient year over year (say)

---

## 2020-11-20 10:30:47 - general channel

**Alessio**

Yeah you get basically into a bigger risk/rewards model

---

## 2020-11-20 10:06:07 - general channel

**Michael**

A good in-between example is using GPS for horse race betting. You have a data source but it's  of middling quality and a lot of other people have it too. So to make the most of it you need a data driven model grafted onto an understanding of the very particular market dynamics of in-running horse racing. In general market driven operations will be churning vast numbers of smaller bets and outright stats models will be more likely to take fewer, bigger bets. some people make lots of money in both ways but in both cases it's not many people.

---

## 2020-11-20 09:50:03 - strategies channel

**Stefan**

[@U01EYDA8345](@U01EYDA8345) That is not what I meant, actually on general thread  [@U01FSSHULHE](@U01FSSHULHE) asked as well similar question. Someone mentioned of using Tableau app to visual data, and yes back in 2015 I started to use it as well, just google "Betfair Tennis Trading and Data Visualization" and you find maybe my blog post about. So my question was how you use this python library in back-testing/data analyzing and bot testing? Can you show short video of workflow from beck-tesing to bot execution. My point is that as all of you maybe, I am open to any new suggestions and can learn something new. What I am for these days is find simple way to data visualization.

---

## 2020-11-20 09:45:37 - general channel

**Misha**

[@UBS7QANF3](@UBS7QANF3) - have you been listening in to my conversations :joy: Our strategy to a tee. We are currently in the growing organically stage

---

## 2020-11-20 09:44:23 - general channel

**Mo**

This was many years ago so I cannot remember all of the details but the model used the most basic easily available tennis data you can find. The value in the strategy was a sophisticated model, at least more sophisticated than the market makers. Testing was largely live testing against the market and growing stakes organically. 

---

## 2020-11-20 09:44:11 - general channel

**D C**

If you want some idea of how to map data to probabilities [@UPMUFSGCR](@UPMUFSGCR) look into generalised linear models - particularly logistic regression for binary stuff like US sports (lack of a draw makes US sport very attractive). I started with MLB and logistic regression with data scraped off Yahoo sports. Scraping that data (and cleaning it) was by far the hardest (and most boring) component of it all.

---

## 2020-11-20 09:40:28 - general channel

**Misha**

[@UPMUFSGCR](@UPMUFSGCR) - to make really big money you don't hedge. You trust your model, and some days are awful. My current points model looks good, but I can lose 1/4 of estimated monthly profits in one day, and go down at least 1/2 estimated monthly profits. I reckon over time I could probably have a losing month

---

## 2020-11-20 09:36:59 - general channel

**Mo**

Sample size of one but I can tell you this is exactly how I got started:



1) Find a tennis model in the academic literature

2) Identify a way to improve the model

3) Implement to have probabilities independent of the market to identify value prices



End result was a highly successful strategy

---

## 2020-11-20 09:30:06 - general channel

**Misha**

My colleague has been going part-time for 12 months on tennis modelling, which we are shortly rolling out. But we have only just "scratched the surface" as yet. So a big time investment

---

## 2020-11-20 09:28:38 - general channel

**Misha**

It's not common because it is very hard to get right. but rewards are huge. In essence you can have a model that can roll over year-in/year-out making huge sums

---

## 2020-11-20 09:24:59 - general channel

**Misha**

[@UPMUFSGCR](@UPMUFSGCR) - data driven is where you start out with the non-market based data (prior results, statistics, etc), come up with some way to assign probabilities, or something similar, and once you have a model, then test against pricing to see if you can make it profitable. Basically testing against the market is the last step, and shouldn't influence the model, lest you overfit

---

## 2020-11-20 07:22:53 - general channel

**Michael**

Technically I use a similar approach to what Mo suggests but rather than a database I just construct big CSVs and use Jupyter notebooks but then that's because I'm a bit basic. In terms of strategy development it depends on what you're interested in doing. I think it's easier for new players to do something market based rather than data driven, if that's your leaning I would suggest that you just start with something vanilla like lay everything at 1.5 or try to make a 1.2 (120%) book and simulate that - or better yet try it out. Obviously it won't work - if it seems like it does work then your data stet is too small or your methodology is flawed. Try to understand why it doesn't work both conceptually and in reality then try to work out the type of circumstances in which it might work or whether there's some sub-set of the bets that are profitable and work on that. Adapt accordingly, rinse and repeat. You can use any sport, if you're using horse racing avoid 'only for maidens' type filters, that's the wrong way to go.

---

## 2020-11-20 02:26:16 - general channel

**qwerty.nat**

one approach you could use is feed the raw data into bflw and modify it at X second intervals to dump each runners top Y levels of their order book (price and size ) then you can easily create an input for a machine learning system. this will nornalise the data somewhat to only information that is more relevant, then you can simply append data to this 'normalised' format with extra features you want to model on.

---

## 2020-11-20 02:10:23 - general channel

**Ben**

It's the thinking of a strategy that I was wanting to approach with a bit more structure. Coming up with a data driven hypothesis to test, for example if a bet over $x on the favourite is accepted, then the price of the second favourite will move by $y



Even look to load it into a neural network for time series analysis or some such, but I just can't seem to get my head around wrangling the data.

---

## 2020-11-20 01:43:28 - general channel

**Gary**

[@U01FSSHULHE](@U01FSSHULHE) think of a strategy, anything. Could be: bet on maidens whose prices moves in by 10% in the last two mins before the off.  Could be: back the fav .  Doesn't matter just code if. Then Test it by traking bet wins/losses.  Most likely, you won't find it works!  No sweat. Now tweak the strategy. Test again. Then tweak. Then learn. Then tweak. Then learn again.  Repeat.  Often.

---

## 2020-11-19 19:13:29 - strategies channel

**Stefan**

I am not so smart, so is here anyone able to show short video of strategy back-testing/data analyzing and bot testing? Just to see advantage of any technology used.

---

## 2020-11-19 11:49:54 - general channel

**Artur Gräfenstein**

ahh cool! Do you think js would be too slow for live betting on betfair? Im actually working on a project with js and want to add Betfair API. But don’t know if it would be better to switch to Python.

---

## 2020-11-19 11:44:42 - general channel

**Mo**

Ostensibly to provide support for users of the betfairlightweight Python package but in reality to discuss all aspects of (automated) betting

---

## 2020-11-18 19:50:30 - random channel

**Andrey Yunoshev**

&gt;In principle a break even strategy should be very appealing to anyone who pays premium charge. It depends how scalable it is though



on the backtest I checked up to 20 euros per bet, I can check and even more 100 for example -

but in my opinion it will not show anything, such amounts bets are not indicative for backtesting



run live with more bet size = more volatility, not sure what I can and want

even if everything fits together by the results of the month,

---

## 2020-11-18 19:33:10 - random channel

**Michael**

A break even strategy is a great place to start if it's real bets. Take your results, work on them and hopefully you can turn it into a profitable strategy. That's how you get going.

---

## 2020-11-18 19:22:31 - random channel

**Mo**

In principle a break even strategy should be very appealing to anyone who pays premium charge. It depends how scalable it is though

---

## 2020-11-18 19:20:34 - random channel

**Andrey Yunoshev**

Obviously, I'm just wondering if I can get any profit from such a strategy. for example generate a lot of commission and reduce it for yourself but to do this in a reasonable time frame, you need to bet much more than 2 per bet, and then the question of bankroll but not the point, it's not a question of what to do with it, but whether it is worth something by itself

---

## 2020-11-18 19:10:13 - random channel

**Alessio**

what's zero strategy for you?

---

## 2020-11-18 19:02:14 - random channel

**Andrey Yunoshev**

ok, already a little less than just interested. is the zero strategy worth something? let's say 200 bets on average per day on greyhounds, tested at 2 euro bets on live for ~30 days, approximately the same result at rates up to 20  euro bets (possible more) via backtesting

---

## 2020-11-18 18:26:56 - strategies channel

**MacrcoPolo**

Pipeline style works, each strategy maintains it's own book and consumes updates as required I think. The fundamental bottleneck will still be that serialization, or book construction though

---

## 2020-11-18 18:16:08 - strategies channel

**MacrcoPolo**

What about adding an optional number of levels to serialize? The serialization will be far slower when we have to serialize the entire book, but not every strategy needs that. If we only serialize the top n levels (where n is enough for your strat) that can probably shave a decent amount off

---

## 2020-11-18 16:44:25 - general channel

**Lee**

I think it's better to have exactly the same logic in a strategy for backtesting/unittests/live

---

## 2020-11-18 13:36:17 - general channel

**Oliver Varney**

does that remove the market across all strategies though? could be an issue down the line where one strategy wants the market and one is done. simply returning false from the check function could be an option

---

## 2020-11-18 13:24:43 - general channel

**birchy**

Doesn't have to be that specific function, but any function within the strategy. I've just found `market.close_market()` :man-facepalming:

---

## 2020-11-18 13:16:07 - general channel

**birchy**

In Flumine, if you have a strategy running and at some point in the future you decide you're finished with this market, is there a way to unsubscribe before market closure? This is currently for backtesting but will also be useful when live. More specifically, if code in `check_market_book()` identifies the market is no longer required, what's the best way to skip to the next market file? I know we can use `market_filter` in the framework setup, but sometimes the market changes after subscription, i.e. we've hit our exposure limit, too many runners withdrawn, etc.

---

## 2020-11-17 20:55:25 - general channel

**Lee**

```with futures.ProcessPoolExecutor(max_workers=multiprocessing.cpu_count()) as pool:

    results = [

        pool.submit(backtest_market, markets=[market], strategy_cls=strategy_cls)

        for market in markets

    ]

    for _ in tqdm(futures.as_completed(results), total=len(results)):

        pass```



---

## 2020-11-17 19:15:21 - strategies channel

**MacrcoPolo**

Just as an aside, in high-frequency trading this is a really big important problem (get the market update and re-arrange the data into a useful form very quickly). Typical approaches use things like b-trees for their log(n) complexity on a variety of opps. The key difference here is that on betfair we know _all_ possible prices in advance, and curcially there isn't many of them. If there's anything you can do to exploit this, you can speed things up

---

## 2020-11-17 07:42:52 - issues channel

**Michael**

Perhaps there's more that could be done to make it clear to new users that data harvesting without betting just isn't allowed. As far as warnings go my own experience was that I did get a warning when I pushed it a bit. We also know that there are plenty of small players who consume a lot of data and BF don't have a problem with them so it's perfectly feasible to start small, just don't take the piss. Given that it looks like the cancellations we've heard about here are edge cases or possibly mistakes (which will likely get sorted out).

---

## 2020-11-16 18:39:30 - general channel

**birchy**

Regarding Flumine, should we try to avoid bet violations, or is it a EAFP function? i.e. I presume that `strategy.max_selection_exposure` is a safeguard that is EXPECTED to violate once the limits are reached?

---

## 2020-11-16 13:20:38 - issues channel

**ricky**

I plan to use LoggingControl to store order data, i tried "LowestLayer" example in both backtesting and paper trade mode without success.

I can see orders.txt has been created but only with header information. No order data were generated. for some reason _process_cleared_orders_meta or _process_order never get call but i can see order data in market.blotter. Any idea?



from controls.backtestloggingcontrol import BacktestLoggingControl



logger = logging.getLogger()

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



strategy = LowestLayer(

    market_filter={"markets": [_market]},

    max_order_exposure=1000,

    max_selection_exposure=1000,

    context={"stake": 2},

)

control = BacktestLoggingControl()

framework.add_strategy(strategy)

framework.add_logging_control(control)



framework.run()

---

## 2020-11-15 23:08:22 - general channel

**Jonjonjon**

[@U4H19D1D2](@U4H19D1D2) Do you think it would be beneficial to add logging telling users why validation has failed in here?



[https://github.com/liampauling/flumine/blob/4dff28ab03969d8d17a9a031d8db5169df929794/flumine/strategy/strategy.py#L141-L158](https://github.com/liampauling/flumine/blob/4dff28ab03969d8d17a9a031d8db5169df929794/flumine/strategy/strategy.py#L141-L158)

---

## 2020-11-15 19:21:05 - general channel

**Ryan Clapham**

Thank you for that [@UFTBRB3F1](@UFTBRB3F1) On 'available_to_back' it prints out &lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x038D1148&gt;, &lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x038D1118&gt; This teaches me for jumping into the deep end. Only been learning python a couple of months. Think we need to swap usernames lol.

---

## 2020-11-14 20:02:53 - issues channel

**Ryan Clapham**

```[&lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x03D79FA0&gt;, &lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x03D79FB8&gt;, &lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x03D79FD0&gt;] [&lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x03D7C028&gt;]```

---

## 2020-11-13 19:33:34 - strategies channel

**Julio**

Let's hope it is not going to be a cliff. Thank you guys for your advice. I'll try to slightly increase and monitor ROI (hopefully variance wont get to much in the way).

Moreover, I slightly amended my code, to allow for several instances of the same strategy with much smaller stakes. Hopefully it will smooth a bit execution and I could stay a bit more under the radar... Thanks to flumine it is so easy to do. Thanks again. liam !!!!!!!!

---

## 2020-11-13 19:09:09 - issues channel

**thambie1**

I was betting a bit more earlier, but I'm testing a new strategy and have been betting about $100 per day for the past two weeks. I'm using the stream api to track up to 1000 markets, while hitting the rest api for metrics. Maybe I was hitting the rest api too often... I don't know.

---

## 2020-11-13 18:18:05 - strategies channel

**Michael**

Obviously it's better to have good code than bad code, but strategy is Batman, code is Robin.

---

## 2020-11-13 17:36:17 - strategies channel

**Michael**

I've always had bad code and good strategy and I've done fine. As long as your code isn't terrible the return on the bottom line of better optimised code diminishes quickly for my type of betting. At first I was worried about my code being crumby but then I decided to see how much difference slow code makes by deliberately slowing my code down. I stopped worrying after that. I can see that for someone like [@UBS7QANF3](@UBS7QANF3) it can be important to be well optimised but it does depend on how you're playing. In the end you can make money with good strategy and bad code but if your strategy is poor you will lose - or at least not win much. There's no point in posting bad bets very quickly.

---

## 2020-11-13 14:23:52 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) regarding code optimization, have you abandoned gofair? GO is not quite as fast as C, but certainly a big improvement over python.

---

## 2020-11-13 13:29:22 - strategies channel

**birchy**

I played with it about 7 or 8 years ago but Betfair seed the markets, so it's pretty much a casino. "Value" prices are rarely taken because Betfairs offers are in front of you. Did occasionally get 1 or 2 matched but that was only when some mug with more money than sense had gone deep into their martingale strategy. I only tried the exchange poker because I had a lookup table to quickly calculate the probabilities but could never get to the front of the queue. It's ok if you're happy with matching a couple of bets per day, but it wasn't for me.

---

## 2020-11-13 11:52:41 - strategies channel

**Julio**

Regarding strategy development. Assuming you have a winning strategy, how do you guys (try to) assess the capacity of a strategy (how much you can increase your bet size). Especially in an illiquid market. My fear is that if I am betting too big, I'll end up destroying the edge or worse being spotted by some algo taking advantage of me. In the first case, it is not that bad, as if i start losing i could just re-decrease the size. But the second case could be catastrophic, as I'd have to go back to the drawing board....

---

## 2020-11-13 11:43:05 - general channel

**Julio**

i had the same issue as you. I asked them to increase the limit to 1000. Unfortunately during weekends there are more than 1000 markets... So I had issues running my strategy when there was the most markets.

I re-write to them and they lifted the restriction...

Maybe before granting it they look at your usage (they want you to bet enough to generate enough revenue) and do not just record markets for instance

---

## 2020-11-13 10:54:39 - strategies channel

**Alessio**

Yeah i see your point. It's easy to hack up something and do some data science, but to really put the money on it you need extensive platform done spending the necessary time and optimizations.

---

## 2020-11-13 07:55:44 - strategies channel

**Michael**

Takes all sorts huh. Strategy development is the part I sort of enjoy. Very happy for someone else to sort the code. :pray:

---

## 2020-11-13 07:26:08 - strategies channel

**liam**

I hate strategy development, it’s so boring

---

## 2020-11-11 22:05:56 - general channel

**Unknown**

[@U017FQEPV1U](@U017FQEPV1U) Easiest way is to use Flumine MarketRecorder to gather data. Then create a strategy framework and use Flumine backtest. In theory you can change the framework to live without changing the strategy.

[https://betfairlightweight.slack.com/files/UPMUFSGCR/F013J0H5F3M/backtest_multi.py|https://betfairlightweight.slack.com/files/UPMUFSGCR/F013J0H5F3M/backtest_multi.py](https://betfairlightweight.slack.com/files/UPMUFSGCR/F013J0H5F3M/backtest_multi.py|https://betfairlightweight.slack.com/files/UPMUFSGCR/F013J0H5F3M/backtest_multi.py)

---

## 2020-11-11 17:07:06 - issues channel

**ricky**

How to display profit in *paper trade* mode? in below, "for market in framework.markets:" never execute.

Where is the best place to check the orders and profit from market.blotter? (i tried add method process_closed_market in class LowestLayer but without luck)



strategy = LowestLayer(

    market_filter=streaming_market_filter(market_ids=["1.175359552"]),

    max_order_exposure=50,

    max_selection_exposure=10,

    context={"stake": 2},

)

framework.add_strategy(strategy)

framework.run()



for market in framework.markets:

    print("Profit: {0:.2f}".format(sum([o.simulated.profit for o in market.blotter])))

    for order in market.blotter:

        print(

            market.market_id,

            order.selection_id,

            order.side,

            order.responses.date_time_placed,

            order.status,

            order.order_type.price,

            order.average_price_matched,

            order.size_matched,

            order.simulated.profit,

        )

---

## 2020-11-11 13:42:58 - issues channel

**Jorge**

Is it needed to send keepAlive requests to keep the trading client running while using MarketStreaming?

---

## 2020-11-10 14:48:49 - general channel

**Chris**

If it helps I was told this...



```Your account was closed due to your excessive amount of reading for your level of betting activity. You have made over 150 million data requests to the exchange which is not acceptable given your level of betting and this volume of reading is deemed to be for commercial usage. ```

That is probably over around a year to 18 months

---

## 2020-11-10 14:43:13 - general channel

**Remi**

And if you want to use multiple streams but process them with the same strategy. Do you just give them the same queue to push to?

---

## 2020-11-10 14:29:00 - general channel

**Remi**

The way it happened was that I had an idea for a strategy and made a small trial using the rest api. It worked well and so I scaled it to most event types without making a proper implementation first. They didn’t notice for a while (and I didn’t realize I was making a retarded number of requests) and then they cut me.

---

## 2020-11-10 09:18:48 - random channel

**Alessio**

(and yes, you need a soccer model that takes the lineup in account :wink:

---

## 2020-11-10 09:18:14 - random channel

**Alessio**

if they don't compete, it really doesn't matter for modelling, right?

---

## 2020-11-10 09:17:01 - random channel

**Misha**

I reckon tennis results are a bit all over the shop due to Covid-19. So having a model based on past results is not likely to be as good, if you are straight betting based on your own probabilities (or maybe you pick specific matches, in which case you may be thriving). US Open women's runner-up going out in the second round of the French Open. World #1 Djokovic having his worst ever career loss, a lot of the top players not even competing, etc

---

## 2020-11-09 19:23:43 - random channel

**JC**

I would agree that it seems financial indicators may be inappropriate to translate to betting. Not least because there are fundamental factors and external information (such as TPD feed for in running horses) driving price. However I have also seen some of the big in play guys in this group state that access to GPS data is not essential... implying that the fundamental method they are using is possible with only access to price data/market books. Maybe I have misunderstood but it seems the key that noobs like me need to grasp is how to define a value criteria, perhaps one more simple than would be expected?

---

## 2020-11-09 15:52:59 - random channel

**Jonjonjon**

Good question [@UBS7QANF3](@UBS7QANF3). Given it wouldn't really be possible to model the last traded price, I was thinking of looking at the high/low prices.

---

## 2020-11-09 15:52:03 - random channel

**Mo**

What time series would you be modelling?

---

## 2020-11-09 15:50:04 - random channel

**Jonjonjon**

Do you think econometric timeseries models are worth testing?

---

## 2020-11-08 17:41:14 - strategies channel

**PeterLe**

Basics: Just out of interest, I wonder how many of the most successful folk on here would own up to having a simple strategy(s). The difference between profitable and non profitable can be tiny. For my own part; I know Im not one of the top earners on here but Ive only ever used simple ideas and churn as much as I can through the markets.(After reading some of the posts on here today I know I need to push a bit harder though :grinning:). Ive always found that where possible try and keep things as simple as possible and then create variations of a theme.

Is there any other successful traders who would care to own up to simple strategies/ideas :grinning:

---

## 2020-11-08 13:37:18 - strategies channel

**birchy**

Not sure about anyone else, but for me, the fundamentals are things like what moves prices, when is the market most/least efficient, trading Vs betting, how to evaluate if a strategy is +EV, etc. Most likely the things that some of you take for granted. And probably more importantly, what NOT to read, i.e. trading "professionals", Betfair "education", etc.

---

## 2020-11-08 11:41:08 - strategies channel

**Jonjonjon**

To be honest I've found reading material to be pretty useless. Running a spray and pray strategy, and then analysing the results, has been more useful for me.

---

## 2020-11-08 11:39:47 - strategies channel

**liam**

The limit is frustrating, I have copied a few of the discussions with the plan to create a strategy development / faq on the flumine docs but haven’t found the time to put it all together 

---

## 2020-11-07 18:53:13 - general channel

**Oliver Varney**

[@U4H19D1D2](@U4H19D1D2) is there a minimum roi your looking for with a bsp strategy, I assume you move the price once you start the strategy

---

## 2020-11-07 15:27:27 - strategies channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) I'm used to placing only a handful of bets per market, so thought I'd already "upgraded". :grinning: 

How many bets per market would be normal? The strategy is for inplay GB horse racing, an area that is totally new to me at present.

---

## 2020-11-07 15:09:40 - strategies channel

**liam**

That looks like a tiny number of triggers for 1200 markets, obviously strategy dependant

---

## 2020-11-07 14:06:41 - strategies channel

**birchy**

I agree with all of the above, which is why I wanted confirmation. It's a Flumine backtest, so no commission. I have about 1200 UK horse racing markets at present, so the graph represents that full dataset as I currently have nothing else to test against.

[@UBS7QANF3](@UBS7QANF3) not sure what you mean regarding "remove matched bets to avoid double counting liquidity"? It's a Flumine backtest, so I'm just relying on the simulated matching, assuming it was already catered for?

The strategy is still very raw, i.e. unrefined as I threw it together just to get a ballpark figure, so it may be fine tuneable.

---

## 2020-11-07 13:10:02 - strategies channel

**birchy**

FYI, it's a £2 BACK strategy using nothing but price data for triggers

---

## 2020-11-07 12:52:24 - general channel

**liam**

Currently only what is in the blotter class which restricts to strategy but this needs to be expanded 

---

## 2020-11-06 12:13:19 - general channel

**Jonjonjon**

Suppose I have a Flumine Strategy with a single parameter.



I want to run that using 2 different values of parameter.



At a later date, I want to download my cleared orders, split them by the parameter value. And then do some analysis.



Would the recommended way to do that using this framework be:



• Add some `notes`, when creating the `Trade` objects.

• Use a custom `LoggingControl` to log the `notes` and `customer_order_ref`'s?

• Use the log to help me split up `cleared_orders`

?

---

## 2020-11-06 02:31:45 - random channel

**RichL**

Hey DC - interested in why you are both using C++, and in a python env forum? It’s a genuine question: my background has been in both high frequency and mid frequency trading for the last 10 years, and cannot justify to myself the overhead of C++ for a market that ‘clears’ once every 200ms. I’d happily share my trading env with you, but it’s entirely a WIP. I can share my thoughts on what I’m looking to build though if that would be of interest, perhaps as a soul familiar with host-on-premises C++ and my own experience of moving to cloudy python.

---

## 2020-11-05 17:39:31 - general channel

**Mo**

```import betfairlightweight

trading = betfairlightweight.APIClient(username='', password='', app_key='')

stream = trading.streaming.create_historical_generator_stream(file_path='/tmp/1.139219567', listener=betfairlightweight.StreamListener())

for mbs in stream.get_generator()():

    mb = mbs[0]

    for runner in mb.runners:

        print(mb.publish_time, runner.selection_id, runner.handicap, runner.last_price_traded)```

```2018-01-21 22:18:14.880000 8881 6.5 1.8

2018-01-25 14:54:03.321000 8881 6.5 1.8

2018-02-15 12:00:04.048000 8881 6.5 1.8

2018-02-15 12:00:22.621000 8881 6.5 1.8

2018-03-19 13:54:56.907000 8881 6.5 1.8

2018-03-19 13:54:56.907000 8875 -4.5 1.84

2018-03-19 14:12:12.995000 8881 6.5 1.8

2018-03-19 14:12:12.995000 8875 -4.5 1.84

2018-03-25 21:57:43.540000 8881 6.5 1.8

2018-03-25 21:57:43.540000 8875 -4.5 1.84

2018-03-25 21:57:43.540000 8875 -6.5 1.84

2018-03-25 22:01:39.401000 8881 6.5 1.8

2018-03-25 22:01:39.401000 8875 -4.5 1.84

2018-03-25 22:01:39.401000 8875 -6.5 1.84

2018-03-25 22:01:39.401000 8875 -5.5 1.77

2018-03-26 12:54:23.488000 8881 6.5 1.74

2018-03-26 12:54:23.488000 8875 -4.5 1.84

2018-03-26 12:54:23.488000 8875 -6.5 1.84

2018-03-26 12:54:23.488000 8875 -5.5 1.77

2018-03-28 15:20:20.765000 8881 6.5 1.74

2018-03-28 15:20:20.765000 8875 -4.5 1.84

2018-03-28 15:20:20.765000 8875 -6.5 1.84

2018-03-28 15:20:20.765000 8875 -5.5 1.77

2018-03-29 13:09:47.930000 8881 6.5 1.74

2018-03-29 13:09:47.930000 8875 -4.5 1.84

2018-03-29 13:09:47.930000 8875 -6.5 1.84

2018-03-29 13:09:47.930000 8875 -5.5 1.77

2018-03-29 13:09:47.930000 8875 -7.5 1.91

2018-03-29 23:15:06.301000 8881 6.5 1.74

2018-03-29 23:15:06.301000 8875 -4.5 1.84

2018-03-29 23:15:06.301000 8875 -6.5 1.84

2018-03-29 23:15:06.301000 8875 -5.5 1.77

2018-03-29 23:15:06.301000 8875 -7.5 1.97

2018-03-29 23:15:06.301000 8881 7.5 2.02

...```

---

## 2020-11-05 10:47:28 - general channel

**Jorge**

Is it a good practice to use the delayed AppKey when testing bots and only using the live AppKey when trading considerable amounts? Or do you guys just use the live AppKey all the time and there is no problem about that? I found that for pre-game strategies the delayed key does not have any delay on getting the odds/volume.

---

## 2020-11-05 09:18:37 - random channel

**D C**

OK I thought by "scale" it would be pretty obvious but I was specifically referring to market/data level scale - thousands of markets a day placing tens of thousands of bets across many different event types. Yes you could have an incredibly complicated strategy / analysis engine processing the it but if you were only dealing cricket for example, there are not many markets per day and you could probably get away with a single stream connection in term of the input data feed side. You could be placing 1 bet per event or 20000 bets per event and depending on which one you would probably expect a different designs. I realise there is not a precise line in the sand at which one approach becomes unworkable and more complicated or more distrubuted system becomes a requirement

---

## 2020-11-05 09:08:27 - random channel

**Misha**

Depends what you mean by scale. If it's a set of complex intertwined strategies, then you probably need a complex system. If you are referring to profit, I have seen a system that was making 8 figures per year profit from a single application that looked like a DOS application. The model behind it was incredibly complex, but the actual execution engine was pretty simple

---

## 2020-11-05 08:22:08 - issues channel

**liam**

Are you using the latest version? Running on branch release/1.14.4 I get this on the cancelled:



```{"asctime": "2020-11-05 08:19:21,236", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.175089224", "selection_id": 25092874, "handicap": 0, "id": "138238571553631800", "customer_order_ref": "27cfde50caeb3-138238571553631800", "bet_id": "100000000001", "trade": {"id": "97b62c12-1f3f-11eb-9cb4-a0999b054753", "strategy": "ExampleStrategy", "status": "TradeStatus.PENDING", "orders": ["138238571553631800"], "notes": "", "market_notes": "4.4,4.5,4.5"}, "order_type": {"order_type": "Limit", "price": 2.0, "size": 2.0, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 2.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Execution complete", "status_log": "Pending, Executable, Cancelling, Executable, Replacing, Execution complete"}```

And the new replacement order:



```{"asctime": "2020-11-05 08:19:21,237", "levelname": "INFO", "message": "Order status update: Executable", "market_id": "1.175089224", "selection_id": 25092874, "handicap": 0, "id": "138238571612366820", "customer_order_ref": "27cfde50caeb3-138238571612366820", "bet_id": "100000000002", "trade": {"id": "97b62c12-1f3f-11eb-9cb4-a0999b054753", "strategy": "ExampleStrategy", "status": "TradeStatus.PENDING", "orders": ["138238571553631800", "138238571612366820"], "notes": "", "market_notes": "4.4,4.5,4.5"}, "order_type": {"order_type": "Limit", "price": 2.02, "size": 1.5, "persistence_type": "LAPSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 1.5, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Executable", "status_log": "Pending, Executable"}```

---

## 2020-11-05 08:13:48 - random channel

**Misha**

Obviously vastly different approaches depending on your starting point. I'm testing a single model/strategy/idea that if works will next be updated in 2022 (tennis probabilities based on historical data). Also looking at a more specific model that would need a fair bit more fine-tuning than that, but that's in development. I think the different approaches reflect the different target markets

---

## 2020-11-05 08:02:24 - random channel

**liam**

I follow gitops, merge to master, test, build, push to ECR and then some lambdas to deploy to servers based on a json config file. The beauty of this is that I can spend 5 minutes fixing a bug and merge to master and that’s it, CI/CD is then automated with a few slack notifications on success / error.



I deploy about 3/4 times a week due to framework updates, strategy adjustments or new strategies for testing. I have about 15 instances running during the day at the moment each running 1/2 instances of my framework. 



RDS for my API and data lake with API Gateway used for a small django app.

---

## 2020-11-03 20:47:02 - random channel

**Misha**

There is another site that looks at all the different models. Of the 16 different models they had, Biden won in all 16

---

## 2020-11-03 20:17:30 - random channel

**Alex A**

It was just straight up gambling though, no models or anything.

---

## 2020-11-03 20:12:58 - random channel

**AP**

I think betting his model last time would've made you a healthy Trump profit

---

## 2020-11-02 16:30:58 - general channel

**Remi**

I don’t think any laws have changed. I was not doing matched betting but they did give me a bunch €50 free bets that I did use.

---

## 2020-10-31 13:45:23 - general channel

**Goldpan**

Normally I don't post here but this is quite interesting (and scary) as I've had an active  BF account since BF started as a business.  I was at first thinking it was a sportsbook related thing, but they would only throttle your bets if winning to much. If you're not using a VPN outside of the UK as you say you're not and your not breaking any of T&amp;C knowingly then this is very strange. To go straight to account closure is quite unusual indeed because normally they would suspend an account pending an investigation. There is something very wrong here either with what you are claiming or what they perceive is happening so you really need to contact BF again and keep trying.  My personal interest is that I'm about to start using a bot for betting and noticing your high amount of betting activity I also don't want to go foul for something wrong unknowing. In that regard I hope you share if possible what the problem is when you find out.

---

## 2020-10-31 12:57:59 - general channel

**Remi**

Was not leaching, always been betting. Had over 200 bets unmatched on 1 strategy and I think something like 150 of another. They didn’t even allow me to cancel those bets so those stayed open to be matched…

---

## 2020-10-31 12:56:39 - general channel

**birchy**

Yeah, they're not keen on "leaching". It's always safer to run at least one strategy while data mining.

---

## 2020-10-30 09:42:50 - general channel

**dan2002**

But for living trading using flumine, can the size reduction be handled?

---

## 2020-10-29 19:43:04 - general channel

**dan2002**

[@U4H19D1D2](@U4H19D1D2) I only run the example strategy on paper trading mode and backtesting mode, I don't see INVALID_PROFIT_RATIO, maybe when i go live it will show in the log. What puzzled me is that it seems flumine has changed the size reduction from 1,51 to 2 as i can see the whole £2 order has been cancelled. Do you know where flumine has make this adjustment?

---

## 2020-10-29 08:01:22 - general channel

**liam**

[@UNQGKT0CR](@UNQGKT0CR) customerStrategyRef is used to differentiate multiple running instances of flumine (hostname), flumine will package via the OrderPackage multiple orders from different strategies together. Expectation is the user logs orders through the LoggingControl.

---

## 2020-10-29 07:57:16 - general channel

**liam**

Regarding conflate, the default is None but can be changed:

```strategy = ExampleStrategy(

    market_filter=streaming_market_filter(market_ids=["1.174788821"]),

    conflate_ms=500,

)```

---

## 2020-10-29 07:56:15 - issues channel

**JonM**

No, going to give that a try now.  I think I've narrowed it down to a problem with just yesterday's account statement.  I moved some funds to my poker wallet (just so they're out of the way as I live test a new strategy).  Is there a known issue at all with this?

---

## 2020-10-28 22:34:45 - general channel

**AP**

Is there a way to add in a custom customer_strategy_ref to a new BaseStrategy class in Flumine?

---

## 2020-10-28 12:53:46 - issues channel

**jhaa**

I use this [https://github.com/liampauling/betfair/blob/master/examples/examplestreamingerrhandling.py](https://github.com/liampauling/betfair/blob/master/examples/examplestreamingerrhandling.py)



I have a bizarre bug where every other day there is a timeout and when the OrderStream restarts I do not seem to get orders for certain markets. For example earlier today there were connection issues and the bot was trading 61 markets, 2 of those the placed orders were not recorded and the bot kept placing the order again and again until it ran out of funds. The other 59 markets showed no such behaviour.



Has anybody seen stuff like this?

---

## 2020-10-28 11:00:16 - general channel

**river_shah**

I downloaded a lot of files, now I keep getting this when I invoke `trading.historic.get_file_list`

```[!DOCTYPE html](!DOCTYPE html)



&lt;html&gt;

&lt;head&gt;

    &lt;meta name="viewport" content="width=device-width" /&gt;

    &lt;title&gt;ngErrorRedirect&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;

    &lt;div&gt; 

        Error

    &lt;/div&gt;

&lt;/body&gt;

&lt;/html&gt;```

---

## 2020-10-28 08:52:32 - general channel

**river_shah**

```file_list = trading.historic.get_file_list(...)

requests.exceptions.ReadTimeout: HTTPSConnectionPool(host='[http://historicdata.betfair.com|historicdata.betfair.com](http://historicdata.betfair.com|historicdata.betfair.com)', port=443): Read timed out. (read timeout=16)```



---

## 2020-10-27 18:18:03 - issues channel

**Mai**

I'm trying to scrape 'totalMatched' vol info from betfair but my code keeps returning 0.0 but returns other tags correctly. Is betfair blocking these requests somehow? I've tried diff combinations of user-agents. Here's my code:



`ua = UserAgent(verify_ssl=False)`



`headers = {`

     `'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',`

    `'User-Agent': ua.random}`

`r = requests.get('[https://www.betfair.com/www/sports/exchange/readonly/v1/bymarket?_ak=nzIFcwyWhrlwYMrh&amp;currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.174684442&amp;rollupModel=STAKE&amp;types=MARKET_STATE,MARKET_RATES,MARKET_DESCRIPTION,EVENT,RUNNER_DESCRIPTION,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_METADATA,MARKET_LICENCE](https://www.betfair.com/www/sports/exchange/readonly/v1/bymarket?_ak=nzIFcwyWhrlwYMrh&amp;currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.174684442&amp;rollupModel=STAKE&amp;types=MARKET_STATE,MARKET_RATES,MARKET_DESCRIPTION,EVENT,RUNNER_DESCRIPTION,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_METADATA,MARKET_LICENCE)', headers = headers)`

`soup = bs(r.content, 'xml')`

`for horse in soup.select('RunnerNode'):`

    `name = horse.select_one('runnerName').text`

    `#matchedVol = 0.0`

    `matchedVol =  horse.select('totalMatched')`

    `print(name, matchedVol)` 

---

## 2020-10-27 17:09:28 - general channel

**Jono**

hey sorry to keep at this but in the properties i can see on each runner there is no sort_priority option, so i cant just do runner.sort_priority                                These are all the attributes i can see `['selection_id', 'status', 'total_matched', 'adjustment_factor', 'handicap', 'last_price_traded', 'removal_date', 'sp', 'ex', 'orders', 'matches', 'matches_by_strategy', '__module__', '__doc__', '__init__', '__str__', '__repr__', '__dict__', '__weakref__', '__hash__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']`

---

## 2020-10-27 10:05:20 - random channel

**Twatter**

Does a neat little job of downloading a ton of football stats history data from football-data and organise it for analysis easier. Certainly helping me understand a bit on stats and modeling...

---

## 2020-10-27 07:47:49 - issues channel

**liam**

This is due to the `OrderValidation` trading control, you either need to remove that control ([https://github.com/liampauling/flumine/blob/master/flumine/baseflumine.py#L70|added by default](https://github.com/liampauling/flumine/blob/master/flumine/baseflumine.py#L70|added by default)) completely or we can look to add a flag to the client `.min_bet_restriction` or similar

---

## 2020-10-27 04:39:52 - issues channel

**Misha**

Here are the API errors: [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-InstructionReportErrorCode](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-InstructionReportErrorCode)

---

## 2020-10-26 20:34:55 - general channel

**dan2002**

the strategy is the LowestLayer strategy in backtest.py, i get slightly different result(same number of rows/orders, but slightly different in terms of fills)

---

## 2020-10-26 20:27:09 - general channel

**liam**

What does the strategy look like? Are you saying you get completely different data written to the csv on each run?

---

## 2020-10-25 15:40:11 - issues channel

**Vitaly**

After updating flumine to 1.14.0. I've received error in my marketlogger:

Traceback (most recent call last):

  File "marketlogger.py", line 47, in &lt;module&gt;

    framework.run()

  File "/home/lvv77/.local/lib/python3.6/site-packages/flumine/flumine.py", line 44, in run

    self._process_close_market(event)

  File "/home/lvv77/.local/lib/python3.6/site-packages/flumine/baseflumine.py", line 269, in _process_close_market

    strategy.process_closed_market(market, event.event)

  File "/home/lvv77/bf6/strategies/marketrecorder.py", line 71, in process_closed_market

    file.write(market.market_catalogue.json())

TypeError: write() argument must be str, not bytes

---

## 2020-10-25 09:22:53 - general channel

**Alessio**

when it's done, shutdown the single strategy and its stream

---

## 2020-10-25 09:22:30 - general channel

**Alessio**

run a strategy with a streaming_filter with the markets

---

## 2020-10-25 09:17:37 - general channel

**Alessio**

OK, so there's no way to 'remove' a strategy and clean its stream, atm ?

---

## 2020-10-25 09:14:31 - general channel

**Alessio**

actually, if you do finish() on a strategy, does it also shut down the stream as well? With international matches that you cannot just filter for i was thinking of just spawning strategies and destroying them (maybe with a custom event), but i am not sure it cleans up everything when you finish()

---

## 2020-10-24 21:53:00 - general channel

**Lee**

you can still keep the process running, just filter out races you don’t want in a strategy

---

## 2020-10-24 21:40:20 - general channel

**dan2002**

Hi, I have a question about flumine. in example.py in flumine, framework.run() will never stop? if i want trading to stop after race finished, how shall i do it? Thanks.

---

## 2020-10-21 14:29:24 - general channel

**liam**

strategies have trades and trades have orders, we pass the strategy to the trade as its then used for exposure/reset calculations

---

## 2020-10-21 14:28:07 - general channel

**mandelbot**

can someone tell me what the `handicap` and `strategy` parameters do in the above?

---

## 2020-10-21 14:27:37 - general channel

**mandelbot**

`trade = Trade(`

    `market_id="1.2345678",`

    `selection_id=123456,`

    `handicap=1.0,`

    `strategy=strategy`

`)`

---

## 2020-10-21 12:35:00 - general channel

**ricky**

[@U4H19D1D2](@U4H19D1D2) Do you mean have duplicate strategy for champions league and manually enter market id as filter for each match?

---

## 2020-10-21 12:25:07 - general channel

**liam**

Or duplicate the strategy by country code 

---

## 2020-10-20 18:01:45 - general channel

**dan2002**

i am just wondering if anyone has used flumine for live trading?

---

## 2020-10-20 14:26:06 - random channel

**liam**

Yes because it's a [https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L216|list](https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L216|list), however you shouldn't count on it

---

## 2020-10-20 14:24:23 - random channel

**Jonjonjon**

Suppose , within a `FlumineBacktest`, I add numerous strategies.



When a market book update is received, is it safe to assume that `process_market_book` of each strategy, will be called in the same order that the strategies were added to the `FlumineBacktest` instance?

---

## 2020-10-19 20:32:42 - issues channel

**birchy**

Thanks [@U4H19D1D2](@U4H19D1D2), that's not a big issue. I presume it will be present when running live?

Also, I notice all of the examples use a single filepath for the list `strategy.market_filter['markets']` . I've been feeding it with a full list of 2000+ paths, which seems to be working fine, but I just wanted to confirm that I'm doing that correctly?

---

## 2020-10-19 16:33:30 - random channel

**JC**

[@U4H19D1D2](@U4H19D1D2) very late to the party on this one... I remember you saying that 95% of your strategies don't use modelling per se, but are just a series of if statements. And here you are arguing for only taking positions with +EV with respect to the outcome of the event. Without getting at your secret sauce, how do you calculate value using only if statements?

---

## 2020-10-19 15:04:27 - general channel

**liam**

np, `strategy.process_market_book` only gets called if the check returns True

---

## 2020-10-19 15:02:46 - general channel

**Jonjonjon**

I read there's a way, in Flumine, to only run a trading strategy at particular times. However, I'm having trouble finding the functionality in the code base. Does anyone know where it is?

---

## 2020-10-19 02:48:11 - general channel

**James Norman**

Hello all! Thanks for letting me join your Slack group :slightly_smiling_face: I've been betting full time for 3 1/2 years. My wife and I moved to Australia at the start of the year. It's always been an ambition to automate some strategies and I've used Lockdown (Still in it here) to learn Python. The lightweight wrapper looks awesome! Great job Liam! Although I'm struggling to log in with it... I went through the BetAngel forum and found some helpful information but saving the key in a .key format is currently alluding me! Probably a rookie question but any advice / direction would be appreciated. Many thanks again James

---

## 2020-10-18 10:55:31 - general channel

**Mo**

It's a map where the keys are the strategy name

---

## 2020-10-18 10:53:43 - general channel

**qwerty.nat**

No don't think so, looking at the Swagger streaming def file, smc = StrategyMatchChange which is an object (dict in python land)  with 2 keys 'mb' and 'ml' which are nullable. It seems they are sending an object withing an object that doesn't confirm to their own definition? just wondering if it's just me or everyone

---

## 2020-10-18 10:37:18 - general channel

**Mo**

I assume because you didn't set a customerStrategyRef on that bet

---

## 2020-10-17 11:12:34 - issues channel

**Rob (NZ)**

```import betfairlightweight

from flumine import Flumine, clients



trading = betfairlightweight.APIClient("username")

client = clients.BetfairClient(trading)



framework = Flumine(

    client=client,

)```



---

## 2020-10-17 11:10:03 - issues channel

**Newbie99**

you should just be able to do this:



```trading = betfairlightweight.APIClient(account_name, account_password, account_key, certs=cert_path)```

---

## 2020-10-16 12:08:28 - general channel

**dan2002**

Hi Liam,  I have a strategy generate a signal for an order, so i place an order, only after the order get filled i place an hedge order. How can i keep track of which order is hedged(can i tag "headged" to an order? or do i have to keep a table in my strategy to know which order is hedged). Thanks.

---

## 2020-10-16 11:58:41 - random channel

**river_shah**

This is a very interesting feature / dependence. [https://betgps.com/betting-library/Gibson-etal-The-Best-Probability-Model-for-Exacta.pdf](https://betgps.com/betting-library/Gibson-etal-The-Best-Probability-Model-for-Exacta.pdf) must break pricing hard if one naively projected win probs to place

---

## 2020-10-16 09:35:38 - general channel

**Rob (NZ)**

```#Look at all NZ and Aussie Markets for the next day and bring back Market Descriptions

market_catalogue_filter = betfairlightweight.filters.market_filter(market_countries=['NZ','AU'],event_type_ids=['7'],market_start_time={ 'to': (datetime.datetime.now() + datetime.timedelta(days=1)).strftime("%Y-%m-%dT%TZ") },market_type_codes = ['WIN'])



market_catalogues = trading.betting.list_market_catalogue( filter=market_catalogue_filter, max_results='100', market_projection = ['MARKET_DESCRIPTION','RUNNER_METADATA','MARKET_START_TIME'], sort='FIRST_TO_START' )



#Create a DataFrame for each market catalogue

market_types_markets = pd.DataFrame({ 'Market Name': [market_cat_object.market_name for market_cat_object in market_catalogues], 'Market ID': [market_cat_object.market_id for market_cat_object in market_catalogues], 'Start Time': [market_cat_object.market_start_time for market_cat_object in market_catalogues], })



market_types_markets```

outputs 100 rows but im just wondering if there is a way to get the total days racing

---

## 2020-10-15 16:18:55 - general channel

**Seabass**

Hi, I'm a beginner with betfair but familar with tick trading data. I'am trying to create essentially a time and sales file using the Pro historical data. But when I merge the order book data and the time and sales file I generate, the results look a little strange. Generally, you can see the exact traded size removed from the order book. But occasionaly, there seems to be a trade that was adjusted later on (size doesn't match order book) and occasionally I see exactly half of the reported trade size being removed from the book. To calculate the trades I just take the difference from the current trd cache and the newest trd cache. What is the correct way to calculate the amount that was traded? And am I overlooking something in my calculation?

---

## 2020-10-15 15:06:49 - general channel

**river_shah**

`python -m cProfile -s cumtime launch_racing_strategy.py` very helpful in profiling the code, no flumine hotspots (found some nasty things in mine though)

---

## 2020-10-15 14:43:00 - general channel

**river_shah**

what would be the impact of moving validation forward? lot more redundant validation checks? when / which code section is the earliest a strategy can know after calling `place_order` that a `VIOLATION` has been generated

---

## 2020-10-15 13:37:56 - general channel

**river_shah**

how can a strategy know if `place_order` successfully met all validation checks please? currently this returns `None`

```def place_order(self, market: Market, order) -&gt; None:

    runner_context = self.get_runner_context(*order.lookup)

    if self.validate_order(runner_context, order):

        runner_context.place()

        market.place_order(order)```

want to put some additional logic to handle order placement validation failures, please let me know how best to handle. thanks

---

## 2020-10-15 13:26:53 - random channel

**agberk**

I put together a new desktop a few months ago; there was no way I was moving to Win10 so it was time to make the switch to Linux only for me. I came across Entroware and made an enquiry with them since I wanted a bit of customisation from the desktops they offered.



On their About Us page they literally say "No challenge is too big." I asked to use a different case and they wouldn't accommodate. They also didn't list the exact motherboard model (was considering doing some horrible GPU passthru for a Windows VM for gaming and mobos need supporting virtualisation features) and they wouldn't tell me what it was because I might mess around with it and void the warranty? I appreciate getting a laptop is slightly different but it still completely put me off them.



As an aside, gaming on Linux has been surprisingly painless. Lots of games run natively and most that don't run in Steam's Linux runtime or Proton (just an option to select in Steam). The only remaining annoyance is that most anti-cheat software doesn't run on Linux so you can't play certain online games without getting banned. I haven't tried it yet but my plan for those types of games (and anything which isn't compatible) is to go for one of these cloud gaming services like GeForce NOW.

---

## 2020-10-14 09:06:01 - strategies channel

**Mo**

Which is a shame because it's a very sound strategy

---

## 2020-10-12 17:52:43 - strategies channel

**birchy**

I have found a couple of inplay strategies via Flumine backtesting that are showing a positive return over 500 markets/~4000 bets. Going to test against a bigger sample, but am just wondering how backtesting compares to live betting? I've not (yet) run any live betting with Flumine as I'm taking cautious steps due to the sheer speed of streaming, which means a small mistake can quickly become expensive. What would you consider as a "goer"?

---

## 2020-10-12 10:52:48 - strategies channel

**Michael**

Essentially once a strategy is well developed for me it's not dependent on 'bank' at all because I have more appetite to bet than the market will stand.

---

## 2020-10-12 10:36:16 - strategies channel

**birchy**

Ironically, I only calculate ROI every few months as more of a sanity check than anything else. As long as my balance goes up steadily, I don't really check ANYTHING, although I should probably do more analysis and optimization.

---

## 2020-10-12 10:33:31 - strategies channel

**Michael**

Yeah I just wonder why ROI gets talked about so much. If you're doing some sort of Kelly type scaling then yeah - but are many people doing that?

---

## 2020-10-12 08:12:29 - general channel

**river_shah**

I am passing the event historic file. `market = "xxx/betfair_data/football/ADVANCED/2020/Jan/19/29637723/29637723"` is replicable with `ExampleStrategy`

---

## 2020-10-12 07:21:47 - general channel

**river_shah**

Have a strategy that trades `Over/Under 0.5 Goals` and `Over/Under 2.5 Goals`. I need to be able to consume both markets together as the trading decision for one market is dependent on the other. If I provide a list of the historic markets. the data is run through one by one and the market streams are not merged together. To counter this issue I just provide the event_id and file for the backtest to be run on. But this is causing a huge amount of log spamming as soon as the first goal gets scored and the market is closed. What is best way to handle this please? `logging.getLogger('flumine').setLevel(logging.WARNING)` is not an option as it kills my visibility into what flumine is doing. however the following logs are also very disruptive (event_file: `ADVANCED/2020/Jan/19/29637723/29637723`). the displayed log spamming continues till the end of the match. the first goal happens in the first 15 minutes.

```2020-10-12 07:13:53.094 INFO  Market closed

2020-10-12 07:13:53.104 INFO  Market 1.167019680 closed

2020-10-12 07:13:53.104 INFO  Market closed

2020-10-12 07:13:53.105 INFO  Market 1.167019598 closed

2020-10-12 07:13:53.105 INFO  Market closed

2020-10-12 07:13:53.107 INFO  Market 1.167019670 closed

2020-10-12 07:13:53.107 INFO  Market closed

2020-10-12 07:13:53.132 INFO  Market 1.167019681 closed

2020-10-12 07:13:53.132 INFO  Market closed

2020-10-12 07:13:53.141 INFO  Market 1.167136003 closed

2020-10-12 07:13:53.141 INFO  Market closed

2020-10-12 07:13:53.150 INFO  Market 1.167019680 closed

2020-10-12 07:13:53.150 INFO  Market closed

2020-10-12 07:13:53.151 INFO  Market 1.167019598 closed

2020-10-12 07:13:53.151 INFO  Market closed

2020-10-12 07:13:53.153 INFO  Market 1.167019670 closed

2020-10-12 07:13:53.153 INFO  Market closed

2020-10-12 07:13:53.178 INFO  Market 1.167019681 closed

2020-10-12 07:13:53.179 INFO  Market closed

2020-10-12 07:13:53.189 INFO  Market 1.167136003 closed

2020-10-12 07:13:53.189 INFO  Market closed

2020-10-12 07:13:53.199 INFO  Market 1.167019680 closed

2020-10-12 07:13:53.199 INFO  Market closed

2020-10-12 07:13:53.200 INFO  Market 1.167019598 closed

2020-10-12 07:13:53.200 INFO  Market closed

2020-10-12 07:13:53.202 INFO  Market 1.167019670 closed

2020-10-12 07:13:53.202 INFO  Market closed

2020-10-12 07:13:53.230 INFO  Market 1.167019681 closed

2020-10-12 07:13:53.230 INFO  Market closed

2020-10-12 07:13:53.239 INFO  Market 1.167136003 closed

2020-10-12 07:13:53.240 INFO  Market closed

2020-10-12 07:13:53.249 INFO  Market 1.167019680 closed

2020-10-12 07:13:53.249 INFO  Market closed

2020-10-12 07:13:53.250 INFO  Market 1.167019598 closed

2020-10-12 07:13:53.250 INFO  Market closed```



---

## 2020-10-11 22:44:25 - strategies channel

**birchy**

[@U011VL3CA2Y](@U011VL3CA2Y) the idea is to increase stakes to maximize return but market capacity defines the point at which increasing stakes is no longer +EV. Unfortunately, betfair doesn't offer infinite volume and quite often, the capacity changes because the punter(s) who are feeding your strategy reduce their stakes or change their strategy to something else.

---

## 2020-10-11 22:39:33 - strategies channel

**Ruben**

any considerations on the trade-off between withdrawing vs increasing the stakes of your model?

---

## 2020-10-11 22:38:32 - strategies channel

**Misha**

Basically I would withdraw funds as often as the variance in my model allows (although no point doing so more often than once every month or two)

---

## 2020-10-11 21:40:49 - strategies channel

**Misha**

Rule of thumb for me: minimum 5% profit / size pre-commission, would always aim for 10% profit / size pre-commission, ideally 10% and large volume is the "gold standard". But that is betting on a statistical model (on results) - not "trading"

---

## 2020-10-10 15:50:49 - general channel

**Lee**

ah that would probably be the reason, could you remove the event_ids filter from there and filter within the strategy instead in `check_market_book`?

---

## 2020-10-10 15:44:29 - general channel

**ricky**

Question on the max number of connections / sockets in flumine,

i used flumine for price recording, becasue i want to manage customised price calculation for different market, i need create few instance of PriceRecorder as example below:



my_event_id = [30050835]

strategy1 = PriceRecorder(

    market_filter = betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["1"], market_types=["MATCH_ODDS", "OVER_UNDER_25"], event_ids=my_event_id

    ),

    market_data_filter = betfairlightweight.filters.streaming_market_data_filter(

        fields=["EX_BEST_OFFERS", "EX_MARKET_DEF", "EX_TRADED", "EX_TRADED_VOL", "EX_LTP"], ladder_levels=3

    ),

)



my_event_id = [30050836]

strategy2 = PriceRecorder1(

    market_filter = betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["1"], market_types=["MATCH_ODDS", "OVER_UNDER_25"], event_ids=my_event_id

    ),

    market_data_filter = betfairlightweight.filters.streaming_market_data_filter(

        fields=["EX_BEST_OFFERS", "EX_MARKET_DEF", "EX_TRADED", "EX_TRADED_VOL", "EX_LTP"], ladder_levels=3

    ),

)



framework.add_strategy(strategy1)

framework.add_strategy(strategy2)

...



When i tested with 10 or more strategies, I got exceed max number of connection error, expect 10 got 11. I thought there is not limitation in terms of number of strategies? in this example, Did each strategies create separate socket connection to befair? any possible work around?

---

## 2020-10-09 21:11:13 - issues channel

**Lee**

Looks a bit of a silly example :slightly_smiling_face:

```from flumine import BaseStrategy

from flumine.order.ordertype import LimitOrder

from flumine.order.trade import Trade

from flumine.utils import get_price





class ExposureIssue(BaseStrategy):

    def check_market_book(self, market, market_book):

        if market_book.status not in ["CLOSED", "SUSPENDED"] and market_book.inplay:

            return True



    def process_market_book(self, market, market_book):

        for runner in market_book.runners:

            lay = get_price(runner.ex.available_to_lay, 0)

            trade = Trade(

                market_book.market_id, runner.selection_id, runner.handicap, self,

            )

            order = trade.create_order(side="LAY", order_type=LimitOrder(lay, 2))

            self.place_order(market, order)```

---

## 2020-10-09 17:34:34 - issues channel

**Lee**

Just come across this error on flumine==1.13.0

```  File "/Users/leeunsworth/git/sports-betting/.venv/lib/python3.7/site-packages/flumine/markets/blotter.py", line 135, in selection_exposure

    unmatched_exposure = calculate_unmatched_exposure(ub, ul)

  File "/Users/leeunsworth/git/sports-betting/.venv/lib/python3.7/site-packages/flumine/utils.py", line 164, in calculate_unmatched_exposure

    lay_exp = sum((i[0] - 1) * -i[1] for i in ul)

  File "/Users/leeunsworth/git/sports-betting/.venv/lib/python3.7/site-packages/flumine/utils.py", line 164, in &lt;genexpr&gt;

    lay_exp = sum((i[0] - 1) * -i[1] for i in ul)

TypeError: unsupported operand type(s) for -: 'NoneType' and 'int'```

---

## 2020-10-08 22:40:57 - issues channel

**Newbie99**

```{"asctime": "2020-10-08 21:05:56,243", "levelname": "ERROR", "message": "_get_cleared_markets error", "exc_info": "Traceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 381, in _make_request\n    self._validate_conn(conn)\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 978, in _validate_conn\n    conn.connect()\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connection.py\", line 362, in connect\n    self.sock = ssl_wrap_socket(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 384, in ssl_wrap_socket\n    return context.wrap_socket(sock, server_hostname=server_hostname)\n  File \"D:\\Python38\\lib\\ssl.py\", line 500, in wrap_socket\n    return self.sslsocket_class._create(\n  File \"D:\\Python38\\lib\\ssl.py\", line 1040, in _create\n    self.do_handshake()\n  File \"D:\\Python38\\lib\\ssl.py\", line 1309, in do_handshake\n    self._sslobj.do_handshake()\nsocket.timeout: _ssl.c:1106: The handshake operation timed out\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\requests\\adapters.py\", line 439, in send\n    resp = conn.urlopen(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 726, in urlopen\n    retries = retries.increment(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\util\\retry.py\", line 403, in increment\n    raise six.reraise(type(error), error, _stacktrace)\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\packages\\six.py\", line 735, in reraise\n    raise value\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 670, in urlopen\n    httplib_response = self._make_request(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 384, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 335, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 36, in request\n    response = [http://session.post|session.post](http://session.post|session.post)(\n  File \"D:\\Python38\\lib\\site-packages\\requests\\api.py\", line 119, in post\n    return request('post', url, data=data, json=json, **kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\api.py\", line 61, in request\n    return session.request(method=method, url=url, **kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\sessions.py\", line 530, in request\n    resp = self.send(prep, **send_kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\sessions.py\", line 643, in send\n    r = adapter.send(request, **kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\adapters.py\", line 529, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\flumine\\worker.py\", line 200, in _get_cleared_market\n    cleared_markets = betting_client.betting.list_cleared_orders(\n  File \"D:\\Python38\\lib\\site-packages\\betfairlightweight\\endpoints\\betting.py\", line 432, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"D:\\Python38\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 45, in request\n    raise APIError(None, method, params, e)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.173991824'], 'customerStrategyRefs': ['BlueOcean'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)", "trading_function": "list_cleared_orders", "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.173991824'], 'customerStrategyRefs': ['BlueOcean'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=3.05)"}



{"asctime": "2020-10-08 21:12:32,721", "levelname": "ERROR", "message": "get_account_funds error", "exc_info": "Traceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 381, in _make_request\n    self._validate_conn(conn)\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 978, in _validate_conn\n    conn.connect()\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connection.py\", line 362, in connect\n    self.sock = ssl_wrap_socket(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 384, in ssl_wrap_socket\n    return context.wrap_socket(sock, server_hostname=server_hostname)\n  File \"D:\\Python38\\lib\\ssl.py\", line 500, in wrap_socket\n    return self.sslsocket_class._create(\n  File \"D:\\Python38\\lib\\ssl.py\", line 1040, in _create\n    self.do_handshake()\n  File \"D:\\Python38\\lib\\ssl.py\", line 1309, in do_handshake\n    self._sslobj.do_handshake()\nsocket.timeout: _ssl.c:1106: The handshake operation timed out\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\requests\\adapters.py\", line 439, in send\n    resp = conn.urlopen(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 726, in urlopen\n    retries = retries.increment(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\util\\retry.py\", line 403, in increment\n    raise six.reraise(type(error), error, _stacktrace)\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\packages\\six.py\", line 735, in reraise\n    raise value\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 670, in urlopen\n    httplib_response = self._make_request(\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 384, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n  File \"D:\\Python38\\lib\\site-packages\\urllib3\\connectionpool.py\", line 335, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=6.05)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 36, in request\n    response = [http://session.post|session.post](http://session.post|session.post)(\n  File \"D:\\Python38\\lib\\site-packages\\requests\\api.py\", line 119, in post\n    return request('post', url, data=data, json=json, **kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\api.py\", line 61, in request\n    return session.request(method=method, url=url, **kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\sessions.py\", line 530, in request\n    resp = self.send(prep, **send_kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\sessions.py\", line 643, in send\n    r = adapter.send(request, **kwargs)\n  File \"D:\\Python38\\lib\\site-packages\\requests\\adapters.py\", line 529, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=6.05)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\Python38\\lib\\site-packages\\flumine\\clients\\betfairclient.py\", line 56, in _get_account_funds\n    return self.betting_client.account.get_account_funds()\n  File \"D:\\Python38\\lib\\site-packages\\betfairlightweight\\endpoints\\account.py\", line 35, in get_account_funds\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"D:\\Python38\\lib\\site-packages\\betfairlightweight\\endpoints\\baseendpoint.py\", line 45, in request\n    raise APIError(None, method, params, e)\nbetfairlightweight.exceptions.APIError: AccountAPING/v1.0/getAccountFunds \nParams: {} \nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=6.05)", "error": "AccountAPING/v1.0/getAccountFunds \nParams: {} \nException: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=6.05)"}```

---

## 2020-10-08 21:29:56 - random channel

**birchy**

Minimising losses is just as important as maximising profits, so taking the "optimal" path will rarely have a negative impact on the bottom line. Anyone who has ever played Heads Up poker will have heard of Nash equilibrium and that is basically a -EV strategy that becomes +EV if the other player plays sub-optimally. As with all things related to gambling, profits are made from others making mistakes...

---

## 2020-10-08 19:47:13 - random channel

**river_shah**

the thing with gambling unlike equity portfolio trading is that we are talking of unit dim covariance matrix, hence kelly and markowitz both result in the same answer and you really should not be doing -ev bets / trades

---

## 2020-10-08 19:44:38 - random channel

**river_shah**

[@UU1URJ8L8](@UU1URJ8L8) the problem setup you have would better be seen as a multivariate markowitz portfolio optimisation problem. if leverage is allowed and there is guaranteed payoffs then both multivariate kelly or markowitz would say to invest to max of allowed leverage to get the risk on. regarding doing negative ev trades, for bets or assets with known covariance matrix, it is very much permissible (infact recommended) to do negative ev trades to maximize risk reward. please notice in equations on page 4 and 5 that there is absolutely no requirement to clamp weights to 0 or negative for assets where asset return is negative ([https://ocw.mit.edu/courses/mathematics/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/lecture-notes/MIT18_S096F13_lecnote14.pdf](https://ocw.mit.edu/courses/mathematics/18-s096-topics-in-mathematics-with-applications-in-finance-fall-2013/lecture-notes/MIT18_S096F13_lecnote14.pdf))

---

## 2020-10-08 19:25:34 - random channel

**Remi**

&gt;  Making a decision to place a ‘closing’ bet before placing an ‘opening’ bet (as in the classic ‘trading’ scenario) is a bad proposition.

That is actually exactly what I suggested in the example I gave. You could even (in theory) back 10x your bankroll and hedge it all away at negative EV. But you need to place a closing bet first because otherwise you can’t reach that volume.

---

## 2020-10-08 19:19:19 - random channel

**Michael**

2: After placing a bet any decision about placing further bets on the same selection must be contextual if it is to increase profits or optimise growth of bankroll. Making a decision to place a 'closing' bet before placing an 'opening' bet (as in the classic 'trading' scenario) is a bad proposition.

---

## 2020-10-08 19:19:04 - random channel

**Michael**

1: All profitable betting that is sustained over a large number of bets is dependant on those bets having positive expected value at the time of placement on aggregate and there is no exception to this.

---

## 2020-10-08 16:56:15 - random channel

**Michael**

Your example above is very specific, quite theoretical and omits a few home truths (for example assuming that it's possible to scale stakes according to Kelly without sacrificing value). That doesn't make it wrong, but it limits its application to the general case - I think you've shown that in a few special cases there might be a reason to make a -EV bet, but for practical application for the 99.99% I think 'always bet with +EV' is the rule to go with.

---

## 2020-10-08 16:50:41 - random channel

**Michael**

Yeah I don't have any problem with that and you're much better qualified on the Bayesian stuff than I am so I'm not even going to go there. My purpose in the discussion above was to address really basic subjects like the idea that it might be wise to decide to trade out of a bet whatever happens before you've even placed it, that trading 'isn't betting' and the basic concept that your bets have to be +EV or you can't win and I don't think you'd disagree with me on any of those things?

---

## 2020-10-08 14:28:20 - random channel

**Remi**

This is much like a vanilla short-volatility strategy on the stock exchange, e.g. short-VIX

---

## 2020-10-08 14:07:19 - random channel

**Misha**

My view is that if your model is good you just bet as much as you can within the variance that you can expect. That's how all the really big players run - they trust the model implicitly and just let it go

---

## 2020-10-08 14:04:02 - random channel

**Misha**

I think you are getting into circular arguments making assumptions using accuracy that isn't possible. Any modelling you do on any market is so variable that you can't guarantee anything close to a set percentage. Real EV plots can be pretty much all over the place, and if your returns increase with EV then you are doing well

---

## 2020-10-08 14:02:59 - random channel

**D C**

You don't need to use kelly if you can get 2.1 on a coin toss every time. Maybe you should but its not compulsory. I mean in your scenario, every price mentioned is +EV so you can't fail to make money anyway unless you have very poor stake management!! I would be happy taking that 2.06 as a fire and forget and count my money at the end of the year (barring some extreme variance that killed my bankroll)

---

## 2020-10-08 14:00:37 - random channel

**Remi**

No you can’t, then you would bet more than kelly suggest.

---

## 2020-10-08 13:59:39 - random channel

**D C**

Yes but what you are modelling here is price movement direction. I mean you could add strategy 3 into this - back at 2.1 and take the value, then in your 5% of cases where the price drifts out more, back again at even more positive EV.

---

## 2020-10-08 13:53:04 - random channel

**D C**

You need to know your expected loss in the 5% of cases where you don't get things fall your way (and anyway what is the CI around that 95%??). If such info were available you could make an informed decision on your expected returns based on strategy X but without them who knows?

---

## 2020-10-08 13:45:06 - random channel

**Remi**

Suppose that you are betting on something which you know is a fair coin. We are pre-play, coin is not in the air yet. You are 95% sure that the market will be stable where you can back at 2.1 and lay at 2.06. What do you do?



You might see the positive EV, perhaps do the kelly thingy, and back 3.62% of your bank at odds 2.1. Great, you made a positive EV bet. Congrats.



You could also back 10% of you bank, then hedge at 2.06 (insert nEgAtIvE eV spongebob meme) and go for another course of the same. You estimate that there is enough volume and stability to do this round trip many times on average. Okay, so you can make your initial bet bigger than kelly because you expect to be able to get out and you get to round trip this a few more times.



You end up with more money by making negative EV bets.

---

## 2020-10-08 13:08:36 - random channel

**Michael**

[@UBS7QANF3](@UBS7QANF3) thanks that's a nice reply. I can't get into this much right now because I'm doing something else but quickly: I've got two point to make. 1: Your example closes selectively and I think that's not fair - IE you're not accounting for the other scenarios where the market goes in your favour and you close out for a loss anyway. You've answered the general case with a specific case. The 'open, wait close' strategy is decided before the opening bet is placed, you don't get to wait and see how your event goes. The 'open' bet is triggered by a signal of value but the 'close' bet is just triggered by the 'open' bet matching. 2: You haven't refuted any of my points or the structure  of my argument.

---

## 2020-10-08 10:41:55 - random channel

**Mo**

[@U016535QCJ2](@U016535QCJ2) if you have a winning model you are going to achieve some positive ROI over the long term. Using half Kelly is an excellent way to protect yourself against model inaccuracies. Using a smaller fraction is even more protection. I like to use 1/6th. Adapting the example to a different fraction is left as an exercise to the reader

---

## 2020-10-08 10:39:40 - random channel

**Misha**

Alas, no model gets EV correct - the better the model, the closer you get on average. But no individual bet is ever guaranteed to be correct, or even close

---

## 2020-10-08 10:31:11 - random channel

**Mo**

`Why hedging at negative EV is optimal - a rebuttal`

_Including math for [@UGV299K6H](@UGV299K6H)’s delectation_



Imagine the following scenario:



• You have backed a selection pre-event at odds of 2.0

• Your model gave the fair probability as 52% (and it's right)

• You calculate the Kelly fraction to be 4% of your bankroll

• But you're sensible and are using half Kelly so you actually bet 2% of your bankroll

The match goes in-play:



• Unfortunately, your selection performs poorly and the odds move against you

• The best lay on your selection is now 3.0

• Your model gives the fair probability as 33.5% (and it's right)

• This means laying the selection has an EV of -0.5%

• The optimal Kelly stake given your existing position is approximately 1% of your bankroll!

• Kelly is telling you to hedge at negative EV! :scream:

• Again, you're sensible so you actually bet the half Kelly stake of 0.5%

Application of Bayes theorem gives us the probability that your selection hits odds of 3 as 0.72180 (5 d.p.) so we can work out that your selection wins without ever hitting odds of 3 as 0.27820.



Now let's simulate this, generating 10,000 runs of 10,000 successive bets each. We'll do this for both hedging and no hedging:



```no_hedge_bets = np.random.choice([1.02, 0.98], size=(10000, 10000), p=[0.52, 0.48])

hedge_bets = np.random.choice([1.02, 1.01, 0.985], size=(10000, 10000), p=[0.278195489, 0.241804511, 0.48])



no_hedge_cumulative_bank = np.cumprod(no_hedge_bets, axis=0)

hedge_cumulative_bank = np.cumprod(hedge_bets, axis=0)



print(np.median(no_hedge_cumulative_bank[9999,:]))

print(np.median(hedge_cumulative_bank[9999,:]))```

```403.69789599466213

739.0367526793249```

The _median_ terminal bank of the hedging strategy is 83% larger than no hedging.

---

## 2020-10-08 09:39:50 - general channel

**liam**

[https://github.com/liampauling/betfair/blob/63b119ddda855572a4f436810e719e4b70dd22bb/betfairlightweight/resources/bettingresources.py#L304](https://github.com/liampauling/betfair/blob/63b119ddda855572a4f436810e719e4b70dd22bb/betfairlightweight/resources/bettingresources.py#L304)

---

## 2020-10-07 23:23:05 - random channel

**D C**

[@U016535QCJ2](@U016535QCJ2) "Why minimise profits if the model is successful overall?" - this is a key point though. How many recreational users on Betfair have the skills to gather a dataset and generate a statistical model and then validate it to the extent that you are confident enough in your estimates that you would "know" the size of your edge? It might even be argued that to get a REALLY successful model you need access to bespoke data that hardly anyone else has access to. Yes, with a good model you can "know" how +EV a particular bet is going to be and even optimise profit with Kelly staking, but the key is knowing what the true 0EV price actually is (or at least a tight confidence interval around it). Understanding the concept of value IS just basic probability but that may well be beyond a lot of users of the exchanges - but almost everyone would see the merits of piling onto a steamer and (hoping) that they can get off before it reverses so it is completely understandable why many people hedge. I am currently hedging +EV positions and I acknowledge that what I am doing is foolish but I do so purely to help counter the variance. As [@UGV299K6H](@UGV299K6H) says, this can be alleviated by appropriate staking and I am working to correct this element of my strategy and long term I will stop doing so (assuming the edge disappears).

---

## 2020-10-07 22:48:02 - random channel

**Misha**

On the "hedging issue. One thing I have learnt is that if you have a successful model, you never hedge (learnt that by working for big clients). Why minimise profits if the model is successful overall?

---

## 2020-10-07 22:08:14 - random channel

**Michael**

Here's where this problem comes from: A bunch of software vendors have a vested interest in getting people to 'trade' on their platforms, and Betfair are into that too. And the vendors and betfair want to target people who wouldn't be caught dead spunking a hundred quid on backing a dog because that's gambling and gambling is for mugs. So they make up a load of shit about how placing bets somehow isn't betting even though you're doing it on a site called BETfair and they say that the maths of gambling (which is really pretty simple) doesn't apply because  somehow it's not gambling even though it's regulated by the gambling commission who's only job is to regulate gambling (there is no 'trading commission') . Then for years on end they pump out their crap to people who want to hear it and those people repeat it and other people somehow start to think it's true even though when you step back from it it's obviously just horse shit and anyone who can do basic maths (like adding and subtracting) can prove it with a pencil. It honestly makes me furious.

---

## 2020-10-07 21:43:42 - random channel

**Newbie99**

That was nicely articulated, you've made it very easily to visualise there, much appreciated...although I do have one question if I may...



If you have 2 strategies for value betting, 1 only ever backs, 1 only ever lays (but independent) and execution is only if value is there (i.e. you never close out simply because you have a position), are you eroding value there? I'm sort of confusing myself thinking 1 has to be -EV, but also if the price moves, could they not both be +EV at the point of execution?

---

## 2020-10-07 21:32:23 - random channel

**Michael**

I'm going to expand on why 'closing' bets are inherently loss making because it illustrates a fundamental feature of profitable betting that is terribly important but isn't generally well understood and it might help some people.

---

## 2020-10-07 19:20:00 - random channel

**PeterLe**

Enjoyed reading the posts this afternoon. Just to throw my hat into the ring, although there are always exceptions to the rule, there are many very successful long term traders who have used nothing more complicated that GCSE maths (probably not even that), myself included. Ive said it before that if I were to sell my strategy on Ebay, people would probably want their money back when I disclosed it! :grinning: Simplicity is often overlooked IMHO

---

## 2020-10-07 16:15:00 - random channel

**Oliver Varney**

when I say give up I mean lets say you have a strategy that has 20% ROI on bet to win vs 18% ROI on hedging out

---

## 2020-10-07 16:13:53 - random channel

**Oliver Varney**

Michael I agree 100% with what your saying, but would you say there are strategy combined with bankrolls that can outperform even by giving up value on the hedge?

---

## 2020-10-07 15:14:58 - random channel

**Dave**

It's nothing groundbreaking or different to what the guys are saying here really, but sure

```A strategy only has positive expected value if each bet that you take is a value bet (e.g. you think there's an 80% chance of something happening, market thinks there's only a 50% chance, so you back it).



Assuming your opening trades *do* take value then you should not trade out of it _unless_ your closing trade is ALSO a value trade. If you close 100% of your opening trades by default without considering value then your closing trades are going to have negative value over time (due to fees and spread), and you'll lose money through them.



Ideally, forget the idea of "closing" a trade. Just run two strategies independently, a backing strategy and laying strategy. Ensure each of them only takes a position when there's value, and that'll make sure they have positive EV in long term. Sure, there'll be cases when you back something cus you think there's value, and 10 mins lay it because you think there's value given new stuff that's happened in the game. It looks like you closed your original back, but really you just took two value bets.



Unless you take the same approach with scalping, you're just taking an uneducated guess and over time will lose money. To apply the same principle to scalping, you ought to think: my prediction of no goal over next 5 mins is X% and the market says Y%. If X% &gt; Y% then open your scalping position as this is value. Then when the 5 mins is over, revaluate your forecast. If X% &gt; Y% then there's no reason to close your scalp. If X% &lt; Y%, then you will close your scalp with a value bet.





Of course this assumes that your detection of value is actually somewhat sensible.```

---

## 2020-10-07 15:05:00 - random channel

**Michael**

[@U01B8031PM1](@U01B8031PM1) I'm not sure about Star Lizard specifically, but the world of big stakes betting is very interesting and unknown to most people. There are networks of agents connecting people to counter-parties, foreign skins on Betfair with amplified liquidity and much more besides. Much of it is quite murky. I had a little insight into it when I helped out a footie syndicate and it was totally fascinating.

---

## 2020-10-07 14:27:37 - random channel

**liam**

just override `validate_order` in the strategy, I think [@ULDAVFDRP](@ULDAVFDRP) does this

---

## 2020-10-07 14:00:24 - random channel

**Twatter**

Hahaha - to be honest I'd be pleased if I could reach a mediocre profitable strategy! I'm way off at the moment...

---

## 2020-10-07 13:47:14 - random channel

**Twatter**

Whether the value is squandered or not - isn't it a case that someone may want to squander larger profits by hedging and overall drawdowns and variance? i.e. Value sacrificed for variance as per a strategy

---

## 2020-10-07 11:36:14 - random channel

**Twatter**

[@UFTBRB3F1](@UFTBRB3F1) I agree with you. Although I'm a newbie to the science and maths of it, Value betting for me is very different to Trading/scalping. I could manually trade 4 or 5 horses pre race and make a profit based on odds movement that I might be able to in theory create an automated strategy out of it. But why would I want to simply back those 4 or 5 horses to win and let the bet ride?

---

## 2020-10-07 11:31:47 - random channel

**Oliver Varney**

my point is this, with at strike rate of 70% you can easily run a trading strategy with 50 points, and that is conservative. So at the early stage you can virtually compound stakes every day

---

## 2020-10-07 11:30:45 - random channel

**liam**

kelly stakes (sort of)

---

## 2020-10-07 11:11:35 - random channel

**Newbie99**

[@UUE6E1LA1](@UUE6E1LA1) thats actually how I arrived at my first strategy, ha! I intended for it to be trading and based on that logic realised that it didn't make sense to close out the trades!

---

## 2020-10-07 10:46:28 - random channel

**liam**

Not sure if I like the idea of the framework making offset orders anymore and pushing to maybe have the strategy itself handle any offsetting/hedging etc.

---

## 2020-10-06 21:31:00 - random channel

**Jonjonjon**

[@U4H19D1D2](@U4H19D1D2) Would it be possible to change



```def customer_order_ref(self) -&gt; str:

    return "{0}-{1}".format(self.trade.strategy.name_hash, self.id)```

to:



```def customer_order_ref(self) -&gt; str:

    return "{0}{1}{2}".format(self.trade.strategy.name_hash, self.sep, self.id)```

, where self.sep defaults to '-'



?

---

## 2020-10-06 17:09:10 - general channel

**river_shah**

for less liquid runners not receiving many streaming updates this `get_price(runner.ex.available_to_back, 0)` can remain None for a while, despite there being valid prices for the selection. is it possible to get the state snapshot using api-ng when the framework / strategy comes up?

---

## 2020-10-06 15:35:31 - general channel

**Oliver Varney**

```@property

def customer_order_ref(self) -&gt; str:

    return "{0}-{1}".format(self.trade.strategy.name_hash, self.id)

@property

def name_hash(self) -&gt; str:

    return create_cheap_hash(self.name, 13)```



---

## 2020-10-06 15:34:50 - general channel

**Oliver Varney**

might of been slightly less but essentially I stole some of the characters from the strategy_name_hash

---

## 2020-10-06 15:31:35 - general channel

**Oliver Varney**

off memory I did something like strategy_hash-internal_trade_id-order_id, with it being 6-6-18

---

## 2020-10-06 14:40:33 - general channel

**Newbie99**

(as in 1 strategy, but split into 2 strategies in flumine terms)

---

## 2020-10-06 14:39:54 - general channel

**Newbie99**

hmmm, one other approach (not saying its optimal, but it could work) is to seperate out back and lay orders by strategy, i.e. strategy A only ever backs on entry, strategy B only ever lay's on entry, so you then know the an opposite trade was an exit.

---

## 2020-10-06 14:36:16 - general channel

**Oliver Varney**

[@UPMUFSGCR](@UPMUFSGCR) I changed the customer_order_ref to include strategy, trade and order id components

---

## 2020-10-06 14:20:11 - general channel

**Jonjonjon**

I have a strategy that trades in and out of positions.



It can back or lay to enter positions.



After it has backed or layed, it can place an order to exit at my estimate of "fair value".



Without storing any state inside my Python code, is there a way to tag orders, to identify whether or not they are "entry" or "exit trades"?



I'm aware of the "customerStrategyRef" field, and would like that to be the same for both all orders.



The customerOrderRef field is used by Flumine, and uses up all 32 permitted characters.



Is there anything else I could try?

---

## 2020-10-06 11:18:57 - general channel

**river_shah**

for bflw how may I get the stream generator to only print market_books when 10 minutes left for start please?

```stream = trading.streaming.create_historical_generator_stream(

    file_path='horse-racing-pro-sample',

)



g = stream.get_generator()



for market_books in g():

    print(market_books)```



---

## 2020-10-05 13:34:06 - general channel

**Lee**

I'll answer based on how i use Flumine

1. For recording I use the S3 market recorder from the examples and use the same recorder to record all sports. So for football i'd run it using something like below. This will record all GB football matches to individual files and upload to S3. I personally wouldn't restrict by date as the streaming will subscribe to new markets to the recorder as and when they become available.

```framework.add_strategy(

    S3MarketRecorder(

        market_filter=streaming_market_filter(

            event_type_ids=[1],

            market_types=[

                "MATCH_ODDS",

                "OVER_UNDER_25",

            ],

            country_codes=["GB"],

        )

        stream_class=datastream.DataStream,

        context={//add config here}

    )

)```

2. There's no limit (afaik) in Flumine so just depends on what your strategies are doing and how long they take to process each update.

3. There's also no limit on how many instances of Flumine you can run, you're only limited by betfair streaming connections which is 10.

---

## 2020-10-05 13:08:36 - general channel

**ricky**

I only begin to use Flumine, I want to do price recorder for Football MATCH_ODDS, OVER_UNDER_25 and more market type per match. I prefer to save each football match price data to separate txt file.



My question:

1) If i want to record all premier League match today, what is the recommend way to do it, should i create new strategy for each match (e.g each strategy has different market filter and file name?)

2) What is the max number of strategy i can add into framwork?

3) What is the max number of instance i can run Flumine?

thanks

---

## 2020-10-04 14:44:04 - general channel

**Ruben**

I'm trying to understand the design of flumine a bit better: how come there is a distinction between `Trade`  and `Order` ? Is it not enough to model only individual orders?

---

## 2020-10-03 00:37:41 - general channel

**Dave**

FWIW - I tried republishing market data internally over zmq pub/sub and latency impact is negligible. So if you wanted a setup where you had say, one process per market, then you can't use a dedicated streaming session per market if you plan on trading more than 10 markets concurrently (for the reason Misha mentioned above). But republishing internally is a way around that, and the added latency is dwarfed by external network latency. Decided not to opt for Redis now given zmq is sufficient

---

## 2020-10-02 21:34:19 - issues channel

**Jonjonjon**

If I look at the example PRO data, for the flumine integration test in /tests/resources/PRO-..., I see runner names:



`{"op":"mcm","clk":"1306210655","pt":1585638069280,"mc":[{"id":"1.170258213","marketDefinition":{"bspMarket":true,"turnInPlayEnabled":true,"persistenceEnabled":true,"marketBaseRate":6.0,"eventId":"29761984","eventTypeId":"7","numberOfWinners":1,"bettingType":"ODDS","marketType":"WIN","marketTime":"2020-04-01T05:30:00.000Z","suspendTime":"2020-04-01T05:30:00.000Z","bspReconciled":false,"complete":true,"inPlay":false,"crossMatching":false,"runnersVoidable":false,"numberOfActiveRunners":17,"betDelay":0,"status":"OPEN","runners":[{"adjustmentFactor":6.86,"status":"ACTIVE","sortPriority":1,"id":13269170,"name":"1. Duecourse"},{"adjustmentFactor":14.71,"status":"ACTIVE","sortPriority":2,"id":25646051,"name":"2. Kooweerup"},{"adjustmentFactor":6.86,"status":"ACTIVE","sortPriority":3,"id":26222589,"name":"3. Lankan Star"},{"adjustmentFactor":6.86,"status":"ACTIVE","sortPriority":4,"id":27788383,"name":"5. Stravain"},{"adjustmentFactor":11.44,"status":"ACTIVE","sortPriority":5,"id":25179363,"name":"6. Street Icon"},{"adjustmentFactor":0.95,"status":"ACTIVE","sortPriority":6,"id":27203134,"name":"7. Graceful Storm"},{"adjustmentFactor":0.95,"status":"ACTIVE","sortPriority":7,"id":24337837,"name":"8. Australian Design"},{"adjustmentFactor":6.86,"status":"ACTIVE","sortPriority":8,"id":24974771,"name":"9. Lickopaint"},{"adjustmentFactor":1.48,"status":"ACTIVE","sortPriority":9,"id":16654159,"name":"10. Miss Skeptical"},{"adjustmentFactor":3.0,"status":"ACTIVE","sortPriority":10,"id":24644431,"name":"11. Here De Fox"},{"adjustmentFactor":3.0,"status":"ACTIVE","sortPriority":11,"id":24619456,"name":"12. Snitz And The City"},{"adjustmentFactor":10.29,"status":"ACTIVE","sortPriority":12,"id":23630960,"name":"13. Wild Vixen"},{"adjustmentFactor":18.72,"status":"ACTIVE","sortPriority":13,"id":28273728,"name":"14. Shilo Lass"},{"adjustmentFactor":1.98,"status":"ACTIVE","sortPriority":14,"id":28273729,"name":"15. Fortune Rose"},{"adjustmentFactor":3.0,"status":"ACTIVE","sortPriority":15,"id":28273730,"name":"16. Belzella"},{"adjustmentFactor":1.48,"status":"ACTIVE","sortPriority":16,"id":28273731,"name":"17. Super Hussey"},{"adjustmentFactor":1.48,"status":"ACTIVE","sortPriority":17,"id":28273732,"name":"18. Ultra Smart"}],"regulators":["MR_NJ","MR_INT"],"venue":"Sandown","countryCode":"AU","discountAllowed":true,"timezone":"Australia/Sydney","openDate":"2020-04-01T02:00:00.000Z","version":3233644674,"name":"R7 1200m Hcap","eventName":"Sand (AUS) 1st Apr"},`

---

## 2020-10-02 14:36:58 - random channel

**Mo**

I don't know who is making those correct score markets. I agree that there doesn't seem to be much action but with the wide spreads you are going to be getting good value on any bets you book. So it's probably about scalability so that you're market making as many matches as possible and picking up the odd bet here and there on each one.



Importance of model probably depends how dynamic the markets are; if you're talking pre-event football then it's probably more important that you have a good market feed that's plugged into Asia and you're not posting prices when the lineups are announced - i.e. you're looking for times when there is no price trend and you can just profit from volatility. In some markets maybe it's enough to assume the true price is the middle of the spread, or adjusted for the weight of money on either side, but in a trending market you'll probably get killed without your own opinion of what the true price. Of course, the ideal situation is a good model where you're happy to take a position.

---

## 2020-10-02 12:45:50 - random channel

**azevedo**

I like that philosophy [@UBS7QANF3](@UBS7QANF3) , agree :+1:



I definitely noticed people market making markets like correct score in football (pre-match) in less liquid games; where they would quote decent sizes at widish spreads without much actually matched on that market or even Match Odds for that event. But in those cases they must be relying on their own model quite heavily? (or possibly wider market/bookies)



what’s your view on models (or perhaps importance of models) in market making?

---

## 2020-09-28 16:10:17 - random channel

**river_shah**

how do I get strategy’s runner limit orders please inside `process_market_book` ? `runner.orders` seems to not be populated despite outstanding limit orders

---

## 2020-09-28 11:14:49 - general channel

**liam**

```strategy = ExampleStrategy(market_filter={"markets": [_market]})```

---

## 2020-09-28 11:13:54 - general channel

**river_shah**

```{"asctime": "2020-09-28 10:04:00,062", "levelname": "INFO", "message": "Adding market middleware &lt;flumine.markets.middleware.SimulatedMiddleware object at 0x1116272e8&gt;"}

{"asctime": "2020-09-28 10:04:00,062", "levelname": "INFO", "message": "Adding trading control ORDER_VALIDATION"}

{"asctime": "2020-09-28 10:04:00,062", "levelname": "INFO", "message": "Adding trading control STRATEGY_EXPOSURE"}

{"asctime": "2020-09-28 10:04:00,062", "levelname": "INFO", "message": "Adding client control MAX_ORDER_COUNT"}

{"asctime": "2020-09-28 10:04:00,063", "levelname": "INFO", "message": "Adding strategy ExampleStrategy"}

{"asctime": "2020-09-28 10:04:00,063", "levelname": "WARNING", "message": "No markets found for strategy ExampleStrategy"}```



---

## 2020-09-28 11:13:24 - general channel

**river_shah**

```client = clients.BacktestClient()

framework = FlumineBacktest(client=client)



_market = "/XXX/betfair_data/ADVANCED/2020/Jan/31/29677355/1.168130637"



market_filter = streaming_market_filter(market_ids=[_market])

strategy = ExampleStrategy(market_filter=market_filter)

framework.add_strategy(strategy)



framework.run()```



---

## 2020-09-27 19:43:45 - random channel

**Jonjonjon**

I'm currently using bflw/flumine. But was wondering if something like redis would help with analysis.



For example, if I wanted to query the average trading range of prices, the prior day before a race, would Redis be better than just pumping the files through BFLW and getting the results using plain Python code?

---

## 2020-09-25 13:20:11 - issues channel

**richard**

Really sorry, probably a stupid question here, but I’m having issues with creating the filter to cancel orders. My code:

betId = *‘212122833595’*

 instructions_filter = betfairlightweight.filters.cancel_instruction(bet_id=str(betId))

 print(instructions_filter)

 result = trading.betting.cancel_orders(instructions=instructions_filter)

 print(result._data)

But I’m getting this error:

“betfairlightweight.exceptions.APIError: SportsAPING/v1.0/cancelOrders

Params: {‘instructions’: {‘betId’: ‘212122833595’}}

Exception: None

Error: {‘code’: -32602, ‘message’: ‘DSC-0018’}

Full Response: {‘jsonrpc’: ‘2.0’, ‘error’: {‘code’: -32602, ‘message’: ‘DSC-0018’}, ‘id’: 1}” Can anyone tell me what I’m doing wrong - I’m looking to cancel just this specific bet?

---

## 2020-09-24 14:44:51 - general channel

**river_shah**

```from flumine import FlumineBacktest, clients



client = clients.BacktestClient()

framework = FlumineBacktest(client=client)



strategy = ExampleStrategy(

    market_filter={"markets": ["/tmp/marketdata/1.170212754"]}

)

framework.add_strategy(strategy)



framework.run()```

isn’t it more hassle to spin up own data recorders? I guess depends on use case

---

## 2020-09-24 10:48:15 - random channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2), that violation issue (appears) to have resurfaced (i.e. once a violation occurs no further orders are placed on that strategy via Flumine). Am wondering if they are picked up here:



```market.blotter.strategy_orders```

and being shown as executable, even though they never actually made it to Betfair (as my check looks at strategy orders and if 0 places new ones, but if I've had a violation it doesn't)?

---

## 2020-09-23 13:02:26 - general channel

**JC**

True, nice find. So this is how betfair update their visualisations etc... do you think they also use the info in this feed to input into models in their sportsbook?

---

## 2020-09-23 10:16:05 - general channel

**D C**

[@U0154JA98TH](@U0154JA98TH) if it is third party data, they are possibly not allowed to sell it on but why would they store it themselves anyway. Are betfair in the business of modelling markets themselves? Do they actually do modelling for their sportsbook or buy the prices from a place such as bet genius?

---

## 2020-09-23 10:05:41 - general channel

**Jono**

thanks for the clarification fellas, has anyone ever had success actually trying to gain more data from betfair directly? I imagine bf does store this info as its invaluable for model training and data analysis

---

## 2020-09-22 13:12:51 - general channel

**liam**

obviously very strategy specific but you can't make accurate decisions on certain courses / race types without a lot of data 1 year+ minimum in my view

---

## 2020-09-22 13:10:19 - general channel

**Newbie99**

...unless everyone else adjusts their strategy too :wink: Then presumably people may not bet in the same scenarios, so your fill rate could change (as an example)

---

## 2020-09-22 03:24:42 - random channel

**Chris**

Hey all - is a t3.nano (2 vCPU @ 2.5ghz, 0.5 gb ram) a reasonable choice for running a simple strategy on ~50 liquid markets with 0 conflation?

---

## 2020-09-21 16:46:29 - issues channel

**liam**

It doesn't currently, see this [https://github.com/liampauling/flumine/blob/3728274bce91cf3d56f42da67b43d116bc2f860e/flumine/baseflumine.py#L132|line](https://github.com/liampauling/flumine/blob/3728274bce91cf3d56f42da67b43d116bc2f860e/flumine/baseflumine.py#L132|line), instead `strategy.process_closed_market` is [https://github.com/liampauling/flumine/blob/3728274bce91cf3d56f42da67b43d116bc2f860e/flumine/strategy/strategy.py#L101|called](https://github.com/liampauling/flumine/blob/3728274bce91cf3d56f42da67b43d116bc2f860e/flumine/strategy/strategy.py#L101|called) but not always, was thinking of changing it this morning

---

## 2020-09-21 16:44:45 - issues channel

**JonM**

Hi all, almost certainly doing something dim here.  Using flumine, I seem unable to access market_books with a "CLOSED" status (so can't pick out the winner for example).  Illustrative code here:



```class ExamplePrinter(BaseStrategy):

    

    def start(self) -&gt; None:

        print("starting strategy 'ExamplePrinter'")

    

    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

        # process_market_book only executed if this returns True

        return True



    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:

        # process marketBook object

        if market_book.status != 'OPEN':

            print(f'status: {market_book.status}')



client = clients.BetfairClient(trading)



framework = Flumine(

    client=client,

)



strategy = ExamplePrinter(

    market_filter=streaming_market_filter(

        market_ids=['1.173247293']

    ),

)



framework.add_strategy(strategy)



framework.run()```

This only outputs when the market_book is "SUSPENDED", it never outputs "CLOSED". I can tell from logging that the market closes and the stream stops, so how would I access closed market books?

---

## 2020-09-18 09:04:21 - random channel

**Jorge**

Does anyone have a recommendation on any technical podcast about strategy's execution? I'm looking more into the developing tasks rather than the Math/backtesting

---

## 2020-09-17 21:37:13 - issues channel

**Dave**

perhaps a stupid question - I've been hitting some timeouts when running a strategy on flumine. I'm just recording some data but subscribing to all WIN markets in GB/ire/us/aus. Is there a recommended value for the "streaming_timeout" param when subscribing to a large number of markets?

---

## 2020-09-17 13:56:24 - general channel

**D C**

I usually pull the overall profit/loss by event type ID for each market and store that as an absolute then take if off the strategy aggregate

---

## 2020-09-17 13:54:40 - general channel

**D C**

I've always had some issues with the commission it seems to return the entire market commission even when you split by strategy ref. So I can see a losing race with respect to particular strategy ref but still have positive commission reported. I personally calculate commission myself per strategy as otherwise you think you are worse off than you actually are if you look at it at face value.

---

## 2020-09-17 10:17:47 - general channel

**D C**

I have some node scripts that I use that allows me to extract profits by event type/strategy ref and pattern match by event names so I can drill down very easily. I use the event type ID one for daily P&amp;L. I don't use bflw either but its just basic API listClearedOrders operation so you should be able to code it yourself easily. I can give you my scripts if you want but its rather clunky (6 CLI args) and just dumps to console so you might be better off writing one as part of your own setup.

---

## 2020-09-17 10:09:28 - general channel

**Jonjonjon**

Thanks DC. This is almost making my heard pound. I think it only really started for me a few weeks ago. I had a trading error in my favour for £5x, amongst many other trivial trades, but the total for the day only showed £4x, which definitely did not agree.

---

## 2020-09-17 09:31:56 - general channel

**liam**

[https://github.com/liampauling/betfair/blob/63b119ddda855572a4f436810e719e4b70dd22bb/betfairlightweight/resources/bettingresources.py#L587|publish time epoch](https://github.com/liampauling/betfair/blob/63b119ddda855572a4f436810e719e4b70dd22bb/betfairlightweight/resources/bettingresources.py#L587|publish time epoch)

---

## 2020-09-17 09:10:38 - general channel

**Jono**

"stream = trading.streaming.create_historical_generator_stream(

        directory="new_historic/tmp/1_169317568.bz2", listener=listener,

    )



    # create generator

    gen = stream.get_generator()



    # print marketBooks

    for market_books in gen():

        for market_book in market_books:

            print(market_book)"

---

## 2020-09-16 14:25:57 - issues channel

**jhaa**

I am trying to find the memory leak with tracemalloc from the std lib. I run coarse order and market stream for like 1500 markets. After a few hours the python process uses 900gb in ram. This is the tracemalloc output sorted by memory used :



/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/streaming/listener.py:105: size=16.6 MiB, count=274719, average=63 B

/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/streaming/cache.py:346: size=15.6 MiB, count=51110, average=320 B

/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/resources/bettingresources.py:651: size=10.7 MiB, count=55851, average=200 B

/home/code/PycharmProjects/venv/lib/python3.8/site-packages/betfairlightweight/streaming/cache.py:36: size=6651 KiB, count=63150, average=108 B



That does not add up to 900gb. What am I missing? Anybody has a best practice how to do this?

---

## 2020-09-16 06:25:05 - random channel

**liam**

Yeah I could but going to use it as my strategy analysis box so want it available whenever, if I have to turn it on first I won’t use it 

---

## 2020-09-15 09:29:37 - general channel

**Misha**

I start with a target, then work out what I need to do to reach that target. In-play allows you multiple bets per event so in some respects it's easier to turnover a higher volume, but often there is less of a statistical model to rely upon

---

## 2020-09-15 09:13:24 - general channel

**D C**

I still don't get it. AFAIK you can't lay on the tote. If your model price is any good then the current price should converge to it by offtime. If the current price is 10-1 and your model is 6-1 then your price should only be coming in - in which case ignoring the 10-1 is not sensible. Even if you are just taking £2 potshots of what is available on the exchanges I can't see how that would reduce your profits betting late. I don't know maybe there is much more to it but refusing value early to bet late at shorter odds I don't understand - unless you have something that predicts that price will get bigger. But if you believe in CLV then I don't understand it.

---

## 2020-09-15 09:04:38 - general channel

**D C**

For me, I am operating in a more crude manner. I don't yet have a decent pricing model. You guys are using scalpels and I am using a bread knife at present. I find it hard when the sensor feed dies - you can infer a NR from it but also dodgy sensor. I block any race action if I get a dodgy sensor because I cannot guarantee that its a NR and could get into trouble.

---

## 2020-09-15 08:57:07 - general channel

**Michael**

You don't need a model for this it's basic maths.

---

## 2020-09-15 08:52:43 - general channel

**D C**

Surely early prices could provide the biggest opportunities? Admittedley the volumes are not great but it you have got a highly accurate model and the morning price is way off why would you not take it while it is available?

---

## 2020-09-14 22:23:51 - general channel

**Misha**

It will be similar to this - [https://help.tab.com.au/s/article/Tabcorp-Schedule-of-Deductions-for-Fixed-Odds-Racing-Betting](https://help.tab.com.au/s/article/Tabcorp-Schedule-of-Deductions-for-Fixed-Odds-Racing-Betting)

---

## 2020-09-14 07:01:21 - random channel

**Peter**

[@UFTBRB3F1](@UFTBRB3F1) I think you're going to be out of luck. This for the 18:15 works, `race_cards = trading.race_card.get_race_result(market_ids=['1.172974372'])` but stick '1.172950042' in there instead and it's still throwing an http 500 (server error) response. So def. a problem at the Betfair end and one likely to affect everybody.

---

## 2020-09-13 20:21:35 - general channel

**Ruben**

seeing as the market subscription limit is giving me some trouble, is it possible with flumine, to have a strategy resubscribe to a new stream? i.e., update the streaming_market_filter of the strategy

---

## 2020-09-13 20:17:57 - random channel

**Newbie99**

By chance does anyone have the race result (in the format from the racecard end point) for the 18:45 from Musselburgh yesterday ('1.172950042').



For some reason I can get every other race, but that one throws up an error (I'm guessing Betfair did something at their end) and purely for OCD purposes it would be handy to have it if anyone has it to hand?



```Traceback (most recent call last):

  File "D:/Python37/webpages/bingo.py", line 41, in &lt;module&gt;

    race_cards = trading.race_card.get_race_result(market_ids=['1.172950042'])

  File "D:\Python38\lib\site-packages\betfairlightweight\endpoints\racecard.py", line 94, in get_race_result

    (response, response_json, elapsed_time) = self.request(

  File "D:\Python38\lib\site-packages\betfairlightweight\endpoints\racecard.py", line 113, in request

    check_status_code(response)

  File "D:\Python38\lib\site-packages\betfairlightweight\utils.py", line 31, in check_status_code

    raise StatusCodeError(response.status_code)

betfairlightweight.exceptions.StatusCodeError: Status code error: 500```

---

## 2020-09-13 10:19:56 - general channel

**Remi**

I have seen this mentioned a few times but I fail to see why this would be an obviously profitable strategy

---

## 2020-09-12 12:43:44 - general channel

**Michael**

To be honest if they are filling up the 1.01s I couldn't say I'd be that bothered. If that's the best you can do as a strategy I don't think you deserve much.

---

## 2020-09-12 12:13:30 - general channel

**Michael**

I'd like to know whether there is a 'Bolt' at that game - or just a ton of wannabees and each of them flukes it sometimes and not others. It's such an obvious strategy that there must be a lot of people having a crack.

---

## 2020-09-12 10:49:47 - general channel

**PeterLe**

I think that anyone who is relying on speed as the major factor  in their strategy is on a long and tortuous road these days, especially if you are offering money to the market. (not to say that it hasn't worked in the past). There is no point being first to a party only to find that there is no one else to talk to....and just as you leave, someone else turns up. You could for example still get there first, but wait around a little longer..or any other combination

---

## 2020-09-12 08:46:38 - general channel

**Misha**

In terms of consistency, their model was brilliant, and consistently so. In theory it's simple - get better probabilities than the market, and when you bet, bet as big as you can (in multiple chunks). UK racing has very high liquidity, so works well for UK racing

---

## 2020-09-12 08:04:12 - general channel

**Misha**

My general view is to never have a strategy that relies on you being the fastest - because that is a tenuous proposition at best. I know in-play horse racing is a very different market than pre-play, but my former client made huge amounts on UK racing (possibly more than anyone else) and their strategy was to rely on probabilities that were generated some hours in advance and just betting late (in terms of minutes, not seconds)

---

## 2020-09-12 04:41:56 - random channel

**damon.p.hill**

[@UU1URJ8L8](@UU1URJ8L8) I’d love to chat with you offline about your F1 strategy. I love motorsport and would like to learn more about strategy logic from you if your open to it?

---

## 2020-09-12 02:11:23 - general channel

**Chris**

Also, I think it is more dependent on strategy than player type and the strategy is potentially indicative of player type. If you are betting outright on the market then it probably doesn't matter, if you are making markets then it probably matters a lot more

---

## 2020-09-11 21:24:48 - general channel

**Chris**

good point - not super worried but mine is bad now so I definitely have to buy server space somewhere.



I know if you are really trying to squeeze out performance you have to move to a compiled language like C++ and that's what most HFT firms use but do you have any idea how big of a difference it actually makes? For example, do you have stats on your average time difference between receiving a message and trading on that info? Is it &lt;10 ms or is it more in the neighborhood of 50 ms? I was assuming it was &lt; 10 ms but I am genuinely not sure

---

## 2020-09-11 21:08:05 - general channel

**Chris**

Alright - thanks I will take a look at both. I am leaning toward AWS as I believe [@U4H19D1D2](@U4H19D1D2) uses some of their auxiliary services as well but would be interested to hear if there are specialty host services specifically for trading on the exchange

---

## 2020-09-11 16:56:39 - general channel

**Chris**

Alright - I am holding that the exposure info is not propagated into any of the objects in a way that is easily routinely accessible. Will proceed by calling all of the current orders via bflw (trading.betting.list_current_orders()) and then writing that info down in the strategy

---

## 2020-09-11 15:57:46 - general channel

**Chris**

I see the correct oc / mb message make it in the door and the corresponding market (1.72246112) get added to the OrderStream and Stream. However, I don't see that market get added to flumine.baseflumine until a later mc message that gets processed _after_ the oc message. Is it possible that the implementation depends on the mc message arriving first?



2020-09-11 14:44:08,606 - flumine.baseflumine - INFO - Adding trading control ORDER_VALIDATION

2020-09-11 14:44:08,606 - flumine.baseflumine - INFO - Adding trading control STRATEGY_EXPOSURE

2020-09-11 14:44:08,607 - flumine.baseflumine - INFO - Adding client control MAX_ORDER_COUNT

2020-09-11 14:44:08,607 - flumine.baseflumine - INFO - Adding strategy NaiveMarketMakerStrategy

2020-09-11 14:44:08,607 - flumine.streams.streams - INFO - Creating new &lt;class 'flumine.streams.marketstream.MarketStream'&gt; (2000) for strategy NaiveMarketMakerStrategy

2020-09-11 14:44:08,607 - flumine.baseflumine - INFO - Starting flumine

2020-09-11 14:44:08,609 - urllib3.connectionpool - DEBUG - Starting new HTTPS connection (1): [http://identitysso-cert.betfair.com:443|identitysso-cert.betfair.com:443](http://identitysso-cert.betfair.com:443|identitysso-cert.betfair.com:443)

2020-09-11 14:44:09,372 - urllib3.connectionpool - DEBUG - [https://identitysso-cert.betfair.com:443](https://identitysso-cert.betfair.com:443) "POST /api/certlogin HTTP/1.1" 200 87

2020-09-11 14:44:09,377 - urllib3.connectionpool - DEBUG - Starting new HTTPS connection (1): [http://api.betfair.com:443|api.betfair.com:443](http://api.betfair.com:443|api.betfair.com:443)

2020-09-11 14:44:10,085 - urllib3.connectionpool - DEBUG - [https://api.betfair.com:443](https://api.betfair.com:443) "POST /exchange/account/json-rpc/v1 HTTP/1.1" 200 176

2020-09-11 14:44:10,088 - urllib3.connectionpool - DEBUG - Starting new HTTPS connection (1): [http://api.betfair.com:443|api.betfair.com:443](http://api.betfair.com:443|api.betfair.com:443)

2020-09-11 14:44:10,653 - urllib3.connectionpool - DEBUG - [https://api.betfair.com:443](https://api.betfair.com:443) "POST /exchange/account/json-rpc/v1 HTTP/1.1" 200 158

2020-09-11 14:44:10,656 - flumine.worker - INFO - BackgroundWorker keep_alive starting

2020-09-11 14:44:10,656 - flumine.worker - DEBUG - BackgroundWorker keep_alive executing

2020-09-11 14:44:10,656 - flumine.worker - INFO - BackgroundWorker poll_account_balance starting

2020-09-11 14:44:10,656 - flumine.worker - INFO - BackgroundWorker poll_market_catalogue starting

2020-09-11 14:44:10,657 - flumine.worker - INFO - BackgroundWorker poll_cleared_orders starting

2020-09-11 14:44:10,657 - flumine.streams.streams - INFO - Starting streams..

2020-09-11 14:44:10,657 - flumine.streams.orderstream - INFO - Starting OrderStream

2020-09-11 14:44:10,657 - flumine.streams.orderstream - INFO - Starting output_thread &lt;Thread(OrderStream_output_thread, initial daemon)&gt;

2020-09-11 14:44:10,658 - betfairlightweight.streaming.listener - INFO - Register: orderSubscription 1001

2020-09-11 14:44:10,658 - betfairlightweight.streaming.stream - INFO - [Stream: 1001]: "OrderStream" created

2020-09-11 14:44:10,658 - flumine.streams.marketstream - INFO - Starting MarketStream

2020-09-11 14:44:10,658 - flumine.streams.marketstream - INFO - Starting output_thread &lt;Thread(MarketStream_output_thread, initial daemon)&gt;

2020-09-11 14:44:10,659 - betfairlightweight.streaming.listener - INFO - Register: marketSubscription 2001

2020-09-11 14:44:10,659 - betfairlightweight.streaming.stream - INFO - [Stream: 2001]: "MarketStream" created

starting strategy 'ExampleStrategy'

2020-09-11 14:44:11,333 - betfairlightweight.streaming.betfairstream - DEBUG - [Subscription: 2002] Sending: '{"op": "authentication", "id": 2002, "appKey": "bOP9A5Vmp8n8K48d", "session": "XIlFe2j97G/m11sC7MXvyXllXn+/pQA3q/6nRSlqnf8="}\r\n'

2020-09-11 14:44:11,333 - betfairlightweight.streaming.betfairstream - DEBUG - [Subscription: 2002] Sending: '{"op": "marketSubscription", "id": 2001, "marketFilter": {"marketIds": ["1.172246112"]}, "marketDataFilter": {"fields": ["EX_ALL_OFFERS", "EX_TRADED", "EX_TRADED_VOL", "EX_LTP", "EX_MARKET_DEF", "SP_TRADED", "SP_PROJECTED"]}, "initialClk": null, "clk": null, "conflateMs": null, "heartbeatMs": null, "segmentationEnabled": true}\r\n'

2020-09-11 14:44:11,335 - betfairlightweight.streaming.listener - INFO - [Connect: 2001]: connection_id: 103-110920144408-1944934

2020-09-11 14:44:11,335 - betfairlightweight.streaming.betfairstream - DEBUG - [Subscription: 1002] Sending: '{"op": "authentication", "id": 1002, "appKey": "bOP9A5Vmp8n8K48d", "session": "XIlFe2j97G/m11sC7MXvyXllXn+/pQA3q/6nRSlqnf8="}\r\n'

2020-09-11 14:44:11,335 - betfairlightweight.streaming.betfairstream - DEBUG - [Subscription: 1002] Sending: '{"op": "orderSubscription", "id": 1001, "orderFilter": {"includeOverallPosition": false, "customerStrategyRefs": ["DESKTOP-PUCIJ46"], "partitionMatchedByStrategyRef": true}, "initialClk": null, "clk": null, "conflateMs": null, "heartbeatMs": null, "segmentationEnabled": true}\r\n'

2020-09-11 14:44:11,336 - betfairlightweight.streaming.listener - INFO - [Connect: 1001]: connection_id: 104-110920144408-1957086

2020-09-11 14:44:11,455 - betfairlightweight.streaming.listener - INFO - [Subscription: 1002]: SUCCESS (9 connections available)

2020-09-11 14:44:11,455 - betfairlightweight.streaming.listener - INFO - [Subscription: 1001]: SUCCESS (9 connections available)

2020-09-11 14:44:11,463 - betfairlightweight.streaming.listener - INFO - [Subscription: 2002]: SUCCESS (8 connections available)

*2020-09-11 14:44:11,475 - betfairlightweight.streaming.listener - DEBUG - [Subscription: 1001]: SUB_IMAGE: {'op': 'ocm', 'id': 1001, 'initialClk': 'FI60s4gDFZzFy4EDFcDZ+IUDFMup9YoDFLfurYQD', 'clk': 'AAAAAAAAAAAAAA==', 'conflateMs': 0, 'heartbeatMs': 5000, 'pt': 1599835448156, 'ct': 'SUB_IMAGE', 'oc': [{'id': '1.172246112', 'orc': [{'fullImage': True, 'id': 56323, 'smc': {'DESKTOP-PUCIJ46': {'mb': [[1.31, 9], [1.3, 9]]}}}]}]}*

*2020-09-11 14:44:11,475 - betfairlightweight.streaming.stream - INFO - [OrderStream: 1001] 1.172246112 added, 1 markets in cache*

*2020-09-11 14:44:11,476 - betfairlightweight.streaming.stream - INFO - [Stream: 1001]: 1 oc added*

2020-09-11 14:44:11,479 - betfairlightweight.streaming.listener - INFO - [Subscription: 2001]: SUCCESS (8 connections available)

2020-09-11 14:44:11,503 - betfairlightweight.streaming.listener - DEBUG - [Subscription: 2001]: SUB_IMAGE: {'op': 'mcm', 'id': 2001, 'initialClk': 'whrdibCSB8wa//HplwfFGo7WiZkH', 'clk': 'AAAAAAAA', 'conflateMs': 0, 'heartbeatMs': 5000, 'pt': 1599835448182, 'ct': 'SUB_IMAGE', 'mc': [{'id': '1.172246112', 'marketDefinition': {'bspMarket': False, 'turnInPlayEnabled': True, 'persistenceEnabled': True, 'marketBaseRate': 5, 'eventId': '29969294', 'eventTypeId': '1', 'numberOfWinners': 1, 'bettingType': 'ODDS', 'marketType': 'MATCH_ODDS', 'marketTime': '2020-09-12T16:30:00.000Z', 'suspendTime': '2020-09-12T16:30:00.000Z', 'bspReconciled': False, 'complete': True, 'inPlay': False, 'crossMatching': True, 'runnersVoidable': False, 'numberOfActiveRunners': 3, 'betDelay': 0, 'status': 'OPEN', 'runners': [{'status': 'ACTIVE', 'sortPriority': 1, 'id': 56323}, {'status': 'ACTIVE', 'sortPriority': 2, 'id': 48317}, {'status': 'ACTIVE', 'sortPriority': 3, 'id': 58805}], 'regulators': ['MR_INT'], 'countryCode': 'GB', 'discountAllowed': True, 'timezone': 'GMT', 'openDate': '2020-09-12T16:30:00.000Z', 'version': 3356134545, 'priceLadderDefinition': {'type': 'CLASSIC'}}, 'rc': [{'atb': [[10, 422.04], [10.5, 556.23], [9.8, 141.82], [9.4, 2], [1.01, 73767.48], [9.6, 20], [1.04, 18699.25], [1.02, 62403.5], [1.03, 44624.06], [2, 1.47], [1.1, 10000], [1.05, 14000], [1.09, 10000], [1.08, 10000], [1.07, 14000], [1.06, 14000]], 'atl': [[11, 120.65], [11.5, 603.9], [12, 511.84], [12.5, 568.7], [15.5, 17.5], [13.5, 749.87], [1000, 7.9], [14, 422.21], [13, 490.67], [15, 117.5], [16, 2]], 'trd': [[11, 3916], [10.5, 1267.23], [11.5, 7465.42], [13.5, 60.63], [13, 168.73], [12.5, 5668.28], [12, 9072.82], [10, 22.17], [9.6, 10.32], [9.8, 29.56]], 'ltp': 11, 'tv': 27681.16, 'id': 48317}, {'atb': [[1.32, 8095.3], [1.29, 36848.2], [1.3, 27113.82], [1.31, 9545.35], [1.01, 148763.48], [1.27, 30772.3], [1.28, 34136.61], [1.04, 18699.25], [1.24, 30010.9], [1.22, 25824.06], [1.02, 137403.5], [1.25, 50201.35], [1.23, 20937.03], [1.26, 50513.1], [1.03, 59624.06], [1.21, 25], [1.09, 10100], [1.1, 10000], [1.08, 10000], [1.07, 14000], [1.06, 14000], [1.05, 14000]], 'atl': [[1.33, 1193.27], [1.34, 1675.23], [1.35, 2113.48], [1.4, 20], [1.38, 600], [1.36, 1436.29], [2, 11.85], [1.45, 6.53], [1.8, 3.66], [1000, 5.05], [10, 82]], 'trd': [[1.32, 13620.02], [1.33, 42973.12], [1.34, 1499.87], [1.31, 36034.48], [1.29, 31452.81], [1.3, 64317.62], [1.27, 3095.66], [1.28, 22549.18]], 'ltp': 1.32, 'tv': 215542.76, 'id': 56323}, {'atb': [[6.6, 103.43], [6.4, 449.32], [6.2, 499.94], [5.8, 2], [5.9, 139.33], [6, 464.6], [1.01, 43.45], [1.03, 2], [3.5, 5]], 'atl': [[6.8, 391.26], [7.2, 1193.74], [7, 1406.89], [7.8, 708.38], [1000, 7.9], [8, 677.37], [7.4, 1667.71], [7.6, 892.78], [950, 2.2], [13.5, 2]], 'trd': [[6.6, 4780.12], [6.8, 11467.19], [6.4, 1194.02], [6.2, 26.38], [7, 12286.69], [7.4, 1110.62], [7.2, 3942.68], [7.6, 127.79], [6, 8], [7.8, 0.2]], 'ltp': 6.6, 'tv': 34943.69, 'id': 58805}], 'img': True, 'tv': 278167.61}]}

2020-09-11 14:44:11,503 - betfairlightweight.streaming.stream - INFO - [MarketStream: 2001] 1.172246112 added, 1 markets in cache

2020-09-11 14:44:11,505 - betfairlightweight.streaming.stream - INFO - [Stream: 2001]: 1 mc added

2020-09-11 14:44:11,506 - flumine.baseflumine - INFO - Adding: 1.172246112 to markets

---

## 2020-09-11 14:05:41 - general channel

**Unknown**

[@U4H19D1D2](@U4H19D1D2) or others - Got it, fully matched orders don't come through the stream as orders given they are execution_complete. However, I see the resulting net position information coming in the door in an order change message within the matched bets field.



How do I access this information at the top level flumine.run() loop?



There's a reasonable chance I am just looking in the wrong place but I have searched numerous objects for it (the blotter, the market, the strategy, etc. and now I am looking into the runner). Note that I am using the same machine/strategy that the orders were originally sent from.



ocm message:

```{"op":"ocm","id":1001,"initialClk":"FMDN+IcDFfqk/oADFYmTtIUDFNWit4oDFP+m7oMD","clk":"AAAAAAAAAAAAAA==","conflateMs":0,"heartbeatMs":5000,"pt":1599791822669,"ct":"SUB_IMAGE","oc":[{"id":"1.172246112","orc":[{"fullImage":true,"id":56323,"smc":{"DESKTOP-PUCIJ46":{"mb":[[1.31,9],[1.3,9]]}}}]}]}```

Here is a view of the runner a few updates after the above message was received, which shows nothing matched (the blue boxed are where I would intuitively expect this information to be stored):

---

## 2020-09-11 08:54:21 - issues channel

**Jonjonjon**

Not sure if I'm reading the code correctly, but I'd find it easier to read the code if Blotter.selection_exposure returned 2 numbers... "profit if selection wins", "profit it selection loses" (matched PIW ad matched PIL).



The the code in StrategyExposure._validate could do something similar, calculating each new order's PIW and PIL. (new PIW and new PIL)



Then the exposure, as a result of the current matched orders, and proposed new order, would be



min(matched PIW+new PIW, matched PIL + new PIL).



However, given that Blotter.selection_exposure only considers matched sizes, could a user's exposure go over the limit if they have unmatched bets?

---

## 2020-09-10 21:40:22 - issues channel

**Jonjonjon**

[@U4H19D1D2](@U4H19D1D2) I have situations where I have backed a horse at high odds. Then I try to lay the horse at lower odds. StrategyExposure prevents me from doing so, in a way that I believe is unjustified.



e.g. If I back £2 @ 1000, I should be able to lay £2 @ 500, as that is decreasing my exposure. However, I can't do that in this unit test:



```@mock.patch("flumine.controls.tradingcontrols.StrategyExposure._on_error")

def test_validate_selection2(self, mock_on_error):

    mock_market = mock.Mock()

    blotter = Blotter(mock_market)

    mock_market.blotter = blotter



    mock_strategy = mock.Mock()

    mock_lookup = mock.Mock()



    mock_matched_order = mock.Mock()

    mock_matched_order.order_type.ORDER_TYPE = OrderTypes.LIMIT

    mock_matched_order.side = 'BACK'

    mock_matched_order.order_type.size = 2

    mock_matched_order.size_matched = 2

    mock_matched_order.average_price_matched = 1000.

    mock_matched_order.id = 123

    mock_matched_order.trade.strategy = mock_strategy

    mock_matched_order.lookup = mock_lookup



    blotter._orders = {123:mock_matched_order}



    self.mock_flumine.markets.markets = {"1.234": mock_market}



    order = mock.Mock()

    order.trade.strategy = mock_strategy

    order.trade.strategy.max_order_exposure = float('inf')

    order.trade.strategy.max_selection_exposure = 10

    order.order_type.ORDER_TYPE = OrderTypes.LIMIT

    order.side = "LAY"

    order.order_type.size = 2

    order.order_type.price = 500.

    order.lookup = mock_lookup

    order_package = mock.Mock()

    order_package.market_id = "1.234"

    order_package.package_type = OrderPackageType.PLACE

    order_package.__iter__ = mock.Mock(return_value=iter([order]))



    self.trading_control._validate(order_package)



    self.assertEqual(0, mock_on_error.call_count)```

Apologies in advance if I've made a mistake and am making a false accusation.

---

## 2020-09-10 11:35:55 - general channel

**Lee**

Some of my API calls in `_process_order`  LoggingControl failed to post to an API successfully (a bug i've now fixed), but is there a way to fill these in? I was trying to use `list_cleared_orders` but as it's missing the flumine trade property i'm not sure how i'll know which strategy placed that order.

---

## 2020-09-10 09:28:51 - strategies channel

**Gary**

How do you decide if your strategy is outdated/stopped working as compared with a statistical slump? Is it as simple as waiting for a statistically meaningful number of outcomes or something else?

---

## 2020-09-09 16:32:39 - general channel

**Jonjonjon**

At a later point I can download my orders, and use pandas to aggregate the results by customer_strategy_ref and market.

---

## 2020-09-09 16:32:01 - general channel

**Jonjonjon**

As part of my code, I have a function that gets the parameters that I want to run. The parameters predominantly choose the size per bet and max position. e.g. I might trade in clips of £2, up to £10 of risk. Before I run a strategy on a market, I randomly choose 1 of 2 sets of parameters. I use the customer_strategy_ref (might be a typo there) field to tag a trade to a strategy. e.g. doggies_2_10, or doggies 10_40.

---

## 2020-09-09 14:36:43 - general channel

**liam**

1. Yes an order is live if betfair consider it EXECUTABLE ie. unmatched 

2. All orders will be in the blotter, you can get your strategy orders from that function you have mentioned or the exposure using `selection_exposure` the plan is to add more helpful functions [https://github.com/liampauling/flumine/blob/274c002debbaf875e0d954fc366ba8d7b3e2a512/flumine/markets/blotter.py#L96|here](https://github.com/liampauling/flumine/blob/274c002debbaf875e0d954fc366ba8d7b3e2a512/flumine/markets/blotter.py#L96|here) so welcome any ideas

---

## 2020-09-09 10:02:07 - random channel

**Remi**

BTW, that last race was a wonderful test for my model/strategy. Even with the total chaos I came out ahead nicely :slightly_smiling_face:

---

## 2020-09-09 01:11:05 - general channel

**Chris**

Hopefully a quick two-parter regarding live orders  (Market --&gt; Blotter --&gt; Live Orders) and market/runner exposure. My goal here is to calculate exposure at the runner level so I can handle inventory at that level (ex. if I already have X exposure on a runner then don't buy/sell any more [I don't know where to get the X number])

1. Is an order only considered live if it has at least some unmatched size in the market?

2. Once an order has been completely filled is it then considered where can I access them? Do I need to use market.blotter.strategy_orders(strategy) and then parse it down to the runner / market level?

---

## 2020-09-05 19:34:23 - issues channel

**Jonjonjon**

Has anyone seen this issue before?



Oops no service available at [https://api.betfair.com/exchange/betting/json-rpc/v1](https://api.betfair.com/exchange/betting/json-rpc/v1) HTTP Error 502: Bad Gateway Traceback

---

## 2020-09-03 11:15:04 - strategies channel

**JC**

[@U0128E7BEHW](@U0128E7BEHW) that sounds like a good way of doing it, my code is pretty messy atm doing it all in one. Is there a function that gives your overall aggregated position on a selection in a market across all orders, or do you just loop over orders in `process_orders` in the second strategy?

---

## 2020-09-03 09:57:08 - general channel

**Oliver Varney**

I do for model training but limit it to 60 seconds

---

## 2020-09-02 19:41:57 - strategies channel

**JC**

Hi guys I know that this is something that has been mentioned before but just wondering if there are plans to add hedging/take profit/stop loss functionality to flumine? I see that from the value perspective it doesn’t make much sense, but for trading order flow and also for reducing drawdowns it might be useful. What I am looking at implementing is an adjustable take profit and stop loss price for each successful order. If it’s not on the cards for an official commit, for reasons previously mentioned, any advice on the cleanest way for me to add it in to my code? Cheers 

---

## 2020-09-02 13:16:06 - general channel

**liam**

Not sure what you mean [@U016535QCJ2](@U016535QCJ2), I like many are just processing streaming data as it comes and making decisions based off it. The only system generated data I have is all in cloudwatch such as latencies / request and response logs and strategy specific details. Market / Order data I log but also store in a db through an API for later processing 

---

## 2020-09-01 13:09:08 - random channel

**PeterLe**

Just a reminder; the new transaction conditions kick in today : _What are the changes?_

_•            5,000 Transactions per hour – the first 5,000 transactions within any given hour will be free of charge._  

_ _

_•            £0.002 cost per transaction – each transaction that exceeds the 5,000 transactions per hour threshold will incur a cost of £0.002._

_ _

_•            Commission Generated Offset – we will offset any fee against any commission generated (Commission Paid + Implied Commission)/2._

_ _

_•            Transaction = Bet Placed or Failed Transaction._

_ _

_A placed bet consists of any bet that is matched, cancelled or lapsed._

_Failed transaction is an action that results in a bet not being placed on the Betfair Exchange. Full descriptions of each failed transaction type can be found in the link below:_

_[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-ExecutionReportErrorCode](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-ExecutionReportErrorCode)_

---

## 2020-08-31 11:40:22 - issues channel

**qwerty.nat**

Anyone ever had any issues sending data too fast to the REST endpoint ?

`{"faultcode":"Client","faultstring":"ANGX-0004","detail":{"APINGException":{"requestUUID":"ie1-ang12a-prd-08061002-003376d0e9","errorCode":"NO_APP_KEY","errorDetails":""},"exceptionname":"APINGException"}}`

even if it is something as simple as listEventTypes (  `[https://api.betfair.com/exchange/betting/rest/v1.0/listEventTypes/](https://api.betfair.com/exchange/betting/rest/v1.0/listEventTypes/)"`  ) I get the error above, If i put a sleep in between the 2 calls they will both work,  managed to replicate it with a quick 'c' libcurl app as well, so it's not bflw issue, but a general betfair issue i think. more curious than anything else

---

## 2020-08-29 18:48:23 - general channel

**birchy**

The only downside I can see with making it an installable package is that I'd have to recompile every time I edit the botpkg, although that's not frequent. My `botpkg/__init__.py` file looks like this:

```import os

import botpkg.betfair.api

import botpkg.betfair.racecard_api

import botpkg.betfair.price_mod

import botpkg.logger

import botpkg.testbed

import botpkg.trading

import botpkg.compile

import botpkg.filing

import botpkg.utils

import botpkg.credentials



path = os.path.dirname(os.path.dirname(__file__))

api = botpkg.betfair.api.API()

pricemod = botpkg.betfair.price_mod

logger = botpkg.logger.Logger()

testbed = botpkg.testbed.TestBed()

trading = botpkg.trading.Trading()

racecard_api = botpkg.betfair.racecard_api.API()

compile = botpkg.compile.Compile()

filing = botpkg.filing.Filing()

utils = botpkg.utils.BotFunctions()```

The main reason I took that route is because I like minimal code and wanted to avoid having lots of imports at the top of each bot. With this method, each bot only needs `import botpkg` and everything becomes available. I know it's a bit weird, but it's also very convenient. Obviously, that is the way I do things in my own library, but now I'm looking at bflw/flumine, I'm researching the best way to implement something similar.

Regarding making the package installable, which method do you recommend?

---

## 2020-08-28 11:16:44 - general channel

**Jono**

# login

trading.login_interactive()

# event_type_ids_list = [1]

event_ids = [29975922]





live_events_with_scores = trading.scores.list_available_events(event_ids=event_ids)

for live_event in live_events_with_scores:



    print(live_event.__dict__)

    # event_ids.append(live_event.event_id)





# score request (provide list / returns list)

scores = [http://trading.in|trading.in](http://trading.in|trading.in)_play_service.get_scores(event_ids=event_ids)

print(scores)

for score in scores:

    print(

        score,

        score.description,

        score.status,

        "%s-%s" % (score.score.home.score, score.score.away.score),

    )  # view resources or debug to see all values available

---

## 2020-08-27 18:38:56 - random channel

**Newbie99**

`{"asctime": "2020-08-27 17:28:52,375", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.172407748", "selection_id": 24110964, "handicap": 0, "id": "138178421323748982", "customer_order_ref": "27cfde50caeb3-138178421323748982", "bet_id": null, "trade": {"id": "c6a05675-e88a-11ea-8728-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138178421323748982"], "notes": "1.172407748,2020-08-27 17:30:00,2020-08-27 17:26:42.946000,OPEN,False,24110964,Walk It Talk It,0,7.6,7.4,7.6,7.2,7.8,15228.77,54.539999999997235,7.3562828939581335,7.3548410230981025,7.51219521213161e-05,0.0005672825912416327,-0.485228770809155,-1.6962085742376443,-1.1856819494519342,1.5158875740819253,-1.1856819494519342,402.8352149156427,0.009164996444333584,7.6,8", "market_notes": null}, "order_type": {"order_type": "Limit", "price": 8, "size": 2.14, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Pending", "status_log": "Pending"}`

`{"asctime": "2020-08-27 17:28:52,521", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.172407748", "selection_id": 11562443, "handicap": 0, "id": "138178421325218981", "customer_order_ref": "27cfde50caeb3-138178421325218981", "bet_id": null, "trade": {"id": "c6b6c4a4-e88a-11ea-a5ec-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138178421325218981"], "notes": "1.172407748,2020-08-27 17:30:00,2020-08-27 17:26:42.946000,OPEN,False,11562443,Bailarico,0,26,25,26,24,27,5153.51,32.36000000000058,28.535445913411476,28.548128733377446,-0.0001627451517698249,-0.02293902095003263,-0.6511582668772105,10.045226723497908,-0.1199440789187813,-41.791918890313944,-0.1199440789187813,-41.791918890313944,0.0078068834946611,29,32,29", "market_notes": null}, "order_type": {"order_type": "Limit", "price": 32, "size": 0.43, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Pending", "status_log": "Pending"}`

`{"asctime": "2020-08-27 17:28:52,581", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.172407748", "selection_id": 24420530, "handicap": 0, "id": "138178421325818936", "customer_order_ref": "27cfde50caeb3-138178421325818936", "bet_id": null, "trade": {"id": "c6bfec37-e88a-11ea-a189-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138178421325818936"], "notes": "1.172407748,2020-08-27 17:30:00,2020-08-27 17:26:42.946000,OPEN,False,24420530,Selsey Sizzler,0,11.5,11,11.5,10.5,12,8648.15,12.989999999999782,11.418560202853765,11.419067823979393,-1.4023312049340216e-05,-8.680345957619678e-05,-0.49187450420717704,-0.9872627534678625,-0.5703850484523233,-1.0597854728689005,-0.5703850484523233,-1.0597854728689005,0.03665404088008629,12.5,13.5,12.5", "market_notes": null}, "order_type": {"order_type": "Limit", "price": 13.5, "size": 1.1, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Pending", "status_log": "Pending"}`

`{"asctime": "2020-08-27 17:28:52,721", "levelname": "INFO", "message": "1 order packages created", "order_packages": [{"id": "c6d54903-e88a-11ea-b947-2016d8944b85", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x0000014904B43670&gt;", "market_id": "1.172407748", "orders": ["138178421323748982", "138178421325218981", "138178421325818936"], "package_type": "Place", "customer_strategy_ref": "BlueOcean", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}]}`

---

## 2020-08-27 18:10:53 - random channel

**mlpanda**

Hey [@U4H19D1D2](@U4H19D1D2), in the tennis example you provided ([https://github.com/liampauling/flumine/pull/264/files|example](https://github.com/liampauling/flumine/pull/264/files|example)) you hardcoded the market_id. When I try to treat it similarly to horse racing, i.e. automatically obtain all markets, Flumine doesn't seem to be able to find any tennis markets. I tried with country_codes=["IT"] first since there is an Italian challenger match, but also tried including a bunch like below:



```strategy = TestStrategy(

    market_filter=streaming_market_filter(

        event_type_ids=["2"],

        country_codes=['AX', 'AL', 'DZ', 'AS', 'AD', 'AO', 'AI', 'AQ', 'AG', 'AR', 'AM', 'AW', 'AU', 'AT', 'AZ', 'BS', 'BH', 'BD', 'BB', 'BY', 'BE', 'BZ', 'BJ', 'BM', 'BT', 'BO', 'BQ', 'BA', 'BW', 'BV', 'BR', 'IO', 'BN', 'BG', 'BF', 'BI', 'CV', 'KH', 'CM', 'CA', 'KY', 'CF', 'TD', 'CL', 'CN', 'CX', 'CC', 'CO', 'KM', 'CG', 'CD', 'CK', 'CR', 'CI', 'HR', 'CU', 'CW', 'CY', 'CZ', 'DK', 'DJ', 'DM', 'DO', 'EC', 'EG', 'SV', 'GQ', 'ER', 'EE', 'SZ', 'ET', 'FK', 'FO', 'FJ', 'FI', 'FR', 'GF', 'PF', 'TF', 'GA', 'GM', 'GE', 'DE', 'GH', 'GI', 'GR', 'GL', 'GD', 'GP', 'GU', 'GT', 'GG', 'GN', 'GW', 'GY', 'HT', 'HM', 'VA', 'HN', 'HK', 'HU', 'IS', 'IN', 'ID', 'IR', 'IQ', 'IE', 'IM', 'IL', 'IT', 'JM', 'JP', 'JE', 'JO', 'KZ', 'KE', 'KI', 'KP', 'KR', 'KW', 'KG', 'LA', 'LV', 'LB', 'LS', 'LR', 'LY', 'LI', 'LT', 'LU', 'MO', 'MG', 'MW', 'MY', 'MV', 'ML', 'MT', 'MH', 'MQ', 'MR', 'MU', 'YT', 'MX', 'FM', 'MD', 'MC', 'MN', 'ME', 'MS', 'MA', 'MZ', 'MM', 'NR', 'NP', 'NL', 'NC', 'NZ', 'NI', 'NE', 'NG', 'NU', 'NF', 'MK', 'MP', 'NO', 'OM', 'PK', 'PW', 'PS', 'PA', 'PG', 'PY', 'PE', 'PH', 'PN', 'PL', 'PT', 'PR', 'QA', 'RE', 'RO', 'RU', 'RW', 'BL', 'SH', 'KN', 'LC', 'MF', 'PM', 'VC', 'WS', 'SM', 'ST', 'SA', 'SN', 'RS', 'SC', 'SL', 'SG', 'SX', 'SK', 'SI', 'SB', 'SO', 'ZA', 'GS', 'SS', 'ES', 'LK', 'SD', 'SR', 'SJ', 'SE', 'CH', 'SY', 'TW', 'TJ', 'TZ', 'TH', 'TL', 'TG', 'TK', 'TO', 'TT', 'TN', 'TR', 'TM', 'TC', 'TV', 'UG', 'UA', 'AE', 'GB', 'US', 'UM', 'UY', 'UZ', 'VU', 'VE', 'VN', 'VG', 'VI', 'WF', 'EH', 'YE', 'ZM', 'ZW'],

        market_types=["WIN"],

    ),

    market_data_filter=streaming_market_data_filter(fields=["EX_LTP", "EX_ALL_OFFERS", "EX_MARKET_DEF", "EX_TRADED"]),

    max_order_exposure=10000,

    max_selection_exposure=105,

    context={"stake": 100},

)```

When I run this, `framework.markets._markets` is empty. Might be a stupid mistake on my side, but if I change the event_type_id to "7" then I do get a bunch of markets. Any idea why this is happening?



I haven't included your scores fixes in the example above as I don't see it helping given that it finds the event_id from the market_id - and if the market_id is never present it wouldn't matter.

---

## 2020-08-27 15:59:27 - random channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2) I seem to have been able to replicate that issue where a pending order never appears:



```{"asctime": "2020-08-27 14:56:02,323", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.172406553", "selection_id": 22583996, "handicap": 0, "id": "138178329623238566", "customer_order_ref": "27cfde50caeb3-138178329623238566", "bet_id": null, "trade": {"id": "6cd997a5-e875-11ea-8295-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138178329623238566"], "notes": "1.172406553,2020-08-27 15:00:00,2020-08-27 14:53:16.392000,OPEN,False,22583996,Go Hard Or Go Home,0,3.7,3.7,3.75,3.65,3.8,24071.260000000002,44.0,3.640561751239103,3.6228700238460068,0.0027530273204042087,0.0028067051365076334,0.5678797216934938,0.502030814968028,-0.7126908839976814,-1.4514553590612573,-0.7126908839976814,-1.4514553590612573,0.013439251525677598,3.65,3.75,3.65", "market_notes": null}, "order_type": {"order_type": "Limit", "price": 3.65, "size": 5.66, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Pending", "status_log": "Pending"}

{"asctime": "2020-08-27 14:56:02,323", "levelname": "INFO", "message": "1 order packages created", "order_packages": [{"id": "6cd997a7-e875-11ea-a46f-2016d8944b85", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x000001E40D033970&gt;", "market_id": "1.172406553", "orders": ["138178329623238566"], "package_type": "Place", "customer_strategy_ref": "BlueOcean", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}]}```

That was (and still is as I write) the last message to appear

---

## 2020-08-26 18:34:32 - general channel

**birchy**

Refreshing to see that [@U4H19D1D2](@U4H19D1D2) is having success with simple "if this condition" type strategies as that's exactly what I do. I basically have a set of functions that check various market conditions and then combine the return values to make a decision. In the early days I would create a strategy based on my understanding of the markets and then go straight to live testing at minimum stakes. I still do that occasionally but mostly gain some confidence first by backtesting against historical data. The one thing you really have to understand is the power of big numbers... i.e. 1000 bets or markets is a reasonable starting point but even that can sometimes be showing a loss for a strategy that is actually profitable over a much larger sample. Variance is both our enemy and our best friend.



There was a time when I would write off bots if they lost £100 at £2 stakes (which was day one in some cases!), but learnt quite a few years ago that you realistically need a bank of at least 1000 bets just to cover the variance.

---

## 2020-08-26 17:18:40 - general channel

**liam**

I like to break down like Mike with simple maths, either by modelling the market and finding value or simply placing orders where you think there might be value. The former requires some stats which gets boring very quickly and the latter requires a lot of trial and error and after the time analysis which I prefer 

---

## 2020-08-26 17:15:47 - general channel

**Twatter**

hahaha- Problem is with the way my luck goes, when I start betting I'll have less than nothing!

---

## 2020-08-26 17:13:47 - general channel

**Michael**

You can forget about online guides, books or whatever. No one who knows how to do it is going to tell you. Use your common sense and maths that you understand - and get betting. Until you've got bets you've got nothing.

---

## 2020-08-26 17:11:39 - general channel

**Twatter**

[@U4H19D1D2](@U4H19D1D2) Yeah strategy i'm trying to start with won't require a model either - just interested in knowing where to start

---

## 2020-08-26 17:07:46 - general channel

**liam**

95% of my strategies are if statements, no modelling as such

---

## 2020-08-26 17:07:10 - general channel

**Twatter**

The thing that baffles me is where to start when building a model - seems that a lot of docs/blogs/tutorials and such surrounding it online either boil it down into simple terms (Step1 collect data, step 2 bunch of things in R, Step3 profit!) or dive into a stupid amount of maths straight off.. Anyone know of any resources (text books/uni courses) that kind of explains "what" goes into a model?

---

## 2020-08-26 16:44:55 - general channel

**JC**

Hi guys - also a maths graduate (specialising in pure maths). Been employed as an analyst/data scientist at a start up this year. Recently left my job due to starting a masters in computational neuroscience in October. Using this time in between to learn sports trading having had an interest in matched betting (like how many people start) as an undergrad. Hoping to support my studies with betfair trading this year, failing that to at least learn more about automation and modelling! :sunglasses:

---

## 2020-08-26 13:56:37 - random channel

**Newbie99**

```from flumine import BaseStrategy, clients, Flumine

from flumine.order.trade import Trade

from flumine.order.order import OrderStatus

from flumine.order.ordertype import LimitOrder

from flumine.utils import get_price

import account_info as ai

import betfairlightweight

from betfairlightweight.filters import streaming_market_filter

import logging

from pythonjsonlogger import jsonlogger

import time



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



time_to_open_execution_in_seconds = 900

time_to_close_execution_in_seconds = 0



class test_violation(BaseStrategy):



    def check_market_book(self, market, market_book):

        if market_book.status not in ["CLOSED", "SUSPENDED"]:

            return True



    def process_market_book(self, market, market_book):



        if market.market_catalogue is not None and \

                market.seconds_to_start &lt;= time_to_open_execution_in_seconds and \

                market.seconds_to_start &gt;= time_to_close_execution_in_seconds:

            print('Open for orders')



            prices = [

                (r.selection_id, r.last_price_traded)

                for r in market_book.runners

                if r.status == "ACTIVE"

            ]

            prices.sort(key=lambda tup: tup[1])

            selection_id = prices[0][0]



            for runner in market_book.runners:

                if runner.selection_id == selection_id:

                    # lay at current best lay price

                    lay = 1.2

                    trade = Trade(

                        market_book.market_id, runner.selection_id, runner.handicap, self,

                    )

                    order = trade.create_order(

                        side="LAY", order_type=LimitOrder(lay, 2),

                    )

                    self.place_order(market, order)



                    runner_data = self.get_runner_context(market_id=market_book.market_id,

                                                              selection_id=runner.selection_id,

                                                              handicap=runner.handicap)

                    live_trade_count = runner_data.live_trade_count

                    trade_count = runner_data.trade_count

                    print({'selection_id': runner.selection_id,

                           'live_trade_count': live_trade_count, 'trade_count': trade_count})



    def process_orders(self, market, orders):

        if market.market_book.status not in ['CLOSED', 'SUSPENDED']:

            for order in orders:

                print({'selection_id': order.selection_id, 'customer_order_ref': order.customer_order_ref,

                       'trade_complete': order.trade.complete, 'trade_status': order.status})



trading = betfairlightweight.APIClient(ai.accname, ai.accpass, ai.acckey, certs=ai.path)

client = clients.BetfairClient(trading)



framework = Flumine(client=client)





strategy = test_violation(

    market_filter=streaming_market_filter(

        event_type_ids=[7],

        country_codes=['GB'],

        market_types=['WIN'],

    ),

    streaming_timeout=2,

    # max_selection_exposure=50,

    max_order_exposure=0.1

)



framework.add_strategy(strategy)

framework.run()```



---

## 2020-08-26 11:34:42 - general channel

**Misha**

Not sure if it will take time for things to settle down for those type of models

---

## 2020-08-26 11:31:03 - general channel

**Misha**

Based on a statistical model, yes, because the fundamentals of the sport don't change much, or at least they take a long time to change (years)

---

## 2020-08-26 11:29:17 - general channel

**Misha**

In terms of scale it's really down to how deep your pockets are and how good is your model. I reckon the upper limit on Betfair might be somewhere in the order of £20M/year profit

---

## 2020-08-26 11:29:02 - general channel

**Jorge**

[@U016535QCJ2](@U016535QCJ2) I guess a quant model can suddenly stop working in both places: sports trading and stock market

---

## 2020-08-26 11:24:01 - general channel

**Misha**

There is no equivalent to building a statistical results model in financial trading (which is the way I do it). A good model will make good money for years. And you can just recirculate the money as the return is near instant

---

## 2020-08-26 11:23:14 - issues channel

**birchy**

[@U0160KZB6QP](@U0160KZB6QP) check the traded volume as well. It's not uncommon to see a few spikes when someone with more money than sense gets deep into their martingale strategy. :grinning:

---

## 2020-08-25 14:50:23 - general channel

**Twatter**

i.e. it's a short lived strategy (well across a few years)

---

## 2020-08-25 14:38:54 - general channel

**Twatter**

Suppose what I'm worried about is implementing it, and then finding that the markets per race are too efficient (which I sort of suspect they are), and so there's no value in my strategy - and that the value only lies at the bookies... at which point I need to start again!

---

## 2020-08-25 14:36:01 - general channel

**Twatter**

[@UUCD6P13J](@UUCD6P13J) Lack of time to properly get coding on my strategy.... so haven't been able to paper trade it yet (not sure how it differs to most other strategies around here but it's intra market based, so I'm comparing prices across 3 maybe 4 markets per race). But I like how BFLW makes it easy to grab the data and stuff.

---

## 2020-08-25 13:31:01 - general channel

**Twatter**

Just a general question out of curiosity - do most of you guys do betfair automated trading as part of your job (i.e. you work for companies/hedge fund type companies that do sports trading), or are you doing it for side profit or is it your personal job/sole source of income etc?

---

## 2020-08-25 13:12:09 - issues channel

**Lee**

started getting the following exception

```  File "/Users/leeunsworth/git/sports-trading/.venv/lib/python3.7/site-packages/flumine/markets/middleware.py", line 63, in __call__

    self._process_simulated_orders(market, market_analytics)

  File "/Users/leeunsworth/git/sports-trading/.venv/lib/python3.7/site-packages/flumine/markets/middleware.py", line 125, in _process_simulated_orders

    order.simulated(market.market_book, runner_analytics)

  File "/Users/leeunsworth/git/sports-trading/.venv/lib/python3.7/site-packages/flumine/backtest/simulated.py", line 49, in __call__

    market_book.publish_time_epoch, runner_analytics.traded

AttributeError: 'NoneType' object has no attribute 'traded'```

---

## 2020-08-25 10:57:19 - random channel

**liam**

where is `strategy` coming from?

---

## 2020-08-25 10:50:29 - random channel

**Newbie99**

```def process_market_book(self, market, market_book):

                total_live_trade_count = 0

                for runner in runner_list:

                    runner_data = strategy.get_runner_context(market_id=market_book.market_id,

                        selection_id=runner['selection_id'],

                                handicap=runner['handicap'])

                    live_trade_count = runner_data.live_trade_count

                    print({'selection_id': runner['selection_id'], 'runner_name': runner['runner_name'], 'live_trade_count': live_trade_count})

                    total_live_trade_count = total_live_trade_count + live_trade_count



                if total_live_trade_count == 0:

                    for runner in runner_list:

                        if 'price' not in runner.keys():

                            pass



                        else:

                            price = runner['price']

                            if price &gt; absolute_min_price and price &lt; absolute_max_price:

                                stake = 2



                                trade = Trade(

                                    market_id=market_book.market_id,

                                    selection_id=runner['selection_id'],

                                    handicap=runner['handicap'],

                                    strategy=strategy,

                                    notes=runner

                                )

                                order = trade.create_order(

                                    side="LAY", order_type=LimitOrder(price=price, size=stake, persistence_type=persistence_type)

                                )

                                self.place_order(market, order)```

---

## 2020-08-24 20:37:42 - random channel

**liam**

Can you share what the code looks like for the order / trade in the strategy? Without revealing the secret sauce :wink:

---

## 2020-08-24 20:34:19 - random channel

**Newbie99**

```{"asctime": "2020-08-24 19:29:22,513", "levelname": "WARNING", "message": "Order has violated ORDER_VALIDATION and will not be placed", "control": "ORDER_VALIDATION", "error": "Order size is less than min bet size (2) or payout (10) for currency", "order": {"market_id": "1.172363533", "selection_id": 19763676, "handicap": 0, "id": "138175901625116463", "customer_order_ref": "27cfde50caeb3-138175901625116463", "bet_id": null, "trade": {"id": "1ce2672e-e640-11ea-9229-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138175901625116463"], "notes": "1.172363533,2020-08-24 19:30:00,2020-08-24 19:29:22.551000,OPEN,False,19763676,Hush Buffy,0,2.88,2.88,2.9,2.84,2.92,384.1600000000001,39.120000000000005,2.9232699537837674,2.9232699537837674,-0.00016599506431987516,-0.0018108429044144984,0,-0.43546624108134707,-1.0,-1.020314057737078,-1.0,-1.020314057737078,0.012721252976427583,2.82,2.9,2.82", "market_notes": "2.88,2.9,2.88"}, "order_type": {"order_type": "Limit", "price": 2.9, "size": 0.73, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Violation", "status_log": "Pending, Violation"}}

{"asctime": "2020-08-24 19:29:22,515", "levelname": "WARNING", "message": "Empty package, not executing", "id": "1ce28e3d-e640-11ea-905c-2016d8944b85", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x000001BC1E36D100&gt;", "market_id": "1.172363533", "orders": ["138175901625116463"], "package_type": "Place", "customer_strategy_ref": "BlueOcean", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}```

---

## 2020-08-24 16:25:35 - random channel

**Newbie99**

[@U4H19D1D2](@U4H19D1D2), I haven't been able to replicate the issue with pending orders from the other day, but came across this today and wanted to check the correct way it's intended to be handled:



```{"asctime": "2020-08-24 15:11:49,150", "levelname": "INFO", "message": "Order status update: Violation", "market_id": "1.172319685", "selection_id": 26578374, "handicap": 0, "id": "138175747090349752", "customer_order_ref": "27cfde50caeb3-138175747090349752", "bet_id": null, "trade": {"id": "21e4feb7-e61c-11ea-8071-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138175747090349752"], "notes": "1.172319685,2020-08-24 15:15:00,2020-08-24 15:11:48.783000,OPEN,False,26578374,Phoenix Strike,0,32,32,34,30,36,1116.3899999999999,4.0,34.20734773394412,34.20734773394412,-0.00017030046190238602,-0.015229531148119538,0,-0.34410707742395563,-1.0,-0.9994686305661997,-1.0,-0.9994686305661997,0.04510370240413563,32,36,32", "market_notes": "32,34,32"}, "order_type": {"order_type": "Limit", "price": 32, "size": 2, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Violation", "status_log": "Pending, Violation"}

{"asctime": "2020-08-24 15:11:49,151", "levelname": "WARNING", "message": "Order has violated STRATEGY_EXPOSURE and will not be placed", "control": "STRATEGY_EXPOSURE", "error": "Order exposure (62) is greater than strategy.max_order_strategy (20)", "order": {"market_id": "1.172319685", "selection_id": 26578374, "handicap": 0, "id": "138175747090349752", "customer_order_ref": "27cfde50caeb3-138175747090349752", "bet_id": null, "trade": {"id": "21e4feb7-e61c-11ea-8071-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138175747090349752"], "notes": "1.172319685,2020-08-24 15:15:00,2020-08-24 15:11:48.783000,OPEN,False,26578374,Phoenix Strike,0,32,32,34,30,36,1116.3899999999999,4.0,34.20734773394412,34.20734773394412,-0.00017030046190238602,-0.015229531148119538,0,-0.34410707742395563,-1.0,-0.9994686305661997,-1.0,-0.9994686305661997,0.04510370240413563,32,36,32", "market_notes": "32,34,32"}, "order_type": {"order_type": "Limit", "price": 32, "size": 2, "persistence_type": "PERSIST", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "LAY", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Violation", "status_log": "Pending, Violation"}}```

So that order failed validation, which makes sense, all looks correct...however,

```runner_data = strategy.get_runner_context(market_id=market_book.market_id,

    selection_id=runner['selection_id'],

            handicap=runner['handicap'])

live_trade_count = runner_data.live_trade_count```

live_trade_count returned 1 until the close.



If an order fails validation, does the live_trade_count need to be manually adjusted and is that intentional?

---

## 2020-08-23 13:18:30 - general channel

**birchy**

All of my strategies are based on some form of "value" betting, so as such my bots already have a pre-calculated "true price" they work from. Obviously the trigger prices change as the market develops/new info is acquired, etc. For that reason, I'm only really backtesting if the bets would of been matched and for that, 1 second intervals is sufficient. 

I want to investigate trading and for that, I think streaming is pretty much essential and it seems pointless writing my own when bflw/flumine exists.

---

## 2020-08-23 12:37:17 - general channel

**Misha**

If you aren't "trading" so much as checking the price at certain intervals, having a second-by-second summary is very useful. I do this for tennis as I am only interested in the price at a particular time for back testing/modelling

---

## 2020-08-23 10:20:41 - general channel

**birchy**

I've got workers=multiprocessing.cpu_count(), which in this case is 1. When testing the same strategy against pickled data gathered by my bespokebots polling library at 1 second intervals, backtesting 100 markets completes in a few seconds, which is why I'm wondering if 3.5 minutes is normal. The bigger issue is when I test against 1000+ markets as it's going to take hours rather than minutes. :thinking_face:

---

## 2020-08-21 17:33:32 - general channel

**Lee**

```&gt;&gt;&gt; competition_filter = betfairlightweight.filters.market_filter(event_type_ids=[1], market_start_time={'to': datetime_in_a_week})

&gt;&gt;&gt; competition_filter

{'eventTypeIds': [1], 'marketStartTime': {'to': '2020-08-28T16:31:02Z'}}

&gt;&gt;&gt; competitions = trading.betting.list_competitions(filter=competition_filter)

&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; soccer_competitions = pd.DataFrame({

...     'Competition': [competition_object.competition.name for competition_object in competitions],

...     'ID': [competition_object.competition.id for competition_object in competitions]

... })

&gt;&gt;&gt; 

&gt;&gt;&gt; soccer_competitions[soccer_competitions.Competition.str.contains('English Premier')]

               Competition        ID

48  English Premier League  10932509

&gt;&gt;&gt; soccer_competitions

                 Competition        ID

0        Swedish Allsvenskan       129

1       Spanish Copa del Rey     12801

2                   Specials   2608550

3     Danish Women's Matches  12016693

4               Czech 3 Liga    892425

..                       ...       ...

82           French National   1081960

83    Irish Premier Division  12203971

84  Belgian First Division A     89979

85            UEFA Euro 2020  11997260

86         Icelandic 1 Deild  12010570



[87 rows x 2 columns]```

---

## 2020-08-20 21:33:52 - general channel

**Oliver Varney**

bank size can be like 5-6 times smaller when trading odds and hedge vs bet to win. For me its worth giving up 1-2% on the strategy, for smaller bank roll with higher consistent strike rate.

---

## 2020-08-20 21:28:23 - general channel

**Oliver Varney**

I think it comes down to the strategy. Ill always argue for hedge over bet to win purely because of bank size, but there does become a point where you move the market too much, weaker horses can be a nightmare

---

## 2020-08-20 15:45:10 - general channel

**john walsh**

I have never had a problem with horse racing.  It brings back the data whether it is UK, Ireland or US every time.  In fact, the Timeform  data Betfair produces is an excellent way of betting against the favourite because the horses they choose are always nominated (unless non-runners) as favourites by all the press and the number of favourites they choose which actually win in UK is abysmally small.

---

## 2020-08-20 08:32:24 - issues channel

**Unknown**

Hi [@U0198BFR9GR](@U0198BFR9GR), flumine ingests historical files either purchased from betfair or recorded yourself, there are [https://github.com/liampauling/flumine/tree/69d68904b4ae0c8ba3c0d60991c3a6a38066040d/tests/resources|two](https://github.com/liampauling/flumine/tree/69d68904b4ae0c8ba3c0d60991c3a6a38066040d/tests/resources|two) in the package itself used for the integration tests, however attached is the example I have used in that example. Paper trading uses live data but records orders / position locally.

---

## 2020-08-20 00:23:53 - issues channel

**Chris**

*Context:* New to using this package. Have a hopefully quick question regarding recording market data in a manner that is consistent with the Backtesting and Paper Trading components of Flumine.



*Narrow question*: Does anyone have the MarketRecorder data file that is referenced in the marketrecorder.py file located in the flumine examples? ([https://github.com/liampauling/flumine/blob/69d68904b4ae0c8ba3c0d60991c3a6a38066040d/examples/marketrecorder.py#L8](https://github.com/liampauling/flumine/blob/69d68904b4ae0c8ba3c0d60991c3a6a38066040d/examples/marketrecorder.py#L8))



*Broader question*: What is the standard data interface to ensure backtesting/paper trading works with Flumine?

An interface is alluded to in a few different places. One example is in the following code snippet at the following link:



...

trading = betfairlightweight.APIClient("username")

client = clients.BetfairClient(trading, paper_trade=True)

framework = Flumine(client=client)



strategy = ExampleStrategy(

    market_filter={"markets": [_*"/tmp/marketdata/1.170212754"*_]}

)

framework.add_strategy(strategy)

...



[https://liampauling.github.io/flumine/quickstart/#backtesting](https://liampauling.github.io/flumine/quickstart/#backtesting)

---

## 2020-08-19 19:25:13 - issues channel

**JojoBeans**

Thanks for getting back! The code I'm running is from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter,

)



trading = betfairlightweight.APIClient(username, password, app_key=api_key)

trading.login_interactive()

betfair_socket = trading.streaming.create_stream()

market_filter = streaming_market_filter(

    event_type_ids=['29946086']

)

market_data_filter = streaming_market_data_filter(

    fields=['EX_ALL_OFFERS', 'EX_MARKET_DEF'],

    ladder_levels=1

)



betfair_socket.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

)



betfair_socket.start()  # blocking

---

## 2020-08-19 12:59:59 - strategies channel

**JC**

Just doing some backtesting on a strategy using flumine and seem to have run into an order violation error related to MAX_ORDER_COUNT, as the total number of orders for this hour has exceeded 1016. I can't imagine my strategy would reach this number in an hour in real time, just wondering if this limit should be disabled for backtesting, and what the safest way to disable it would be? Cheers

---

## 2020-08-19 08:19:08 - random channel

**liam**

```{"asctime": "2020-08-19 07:16:22,242", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.172171556", "selection_id": 8329902, "handicap": 0, "id": "138171141822420430", "customer_order_ref": "27cfde50caeb3-138171141822420430", "bet_id": null, "trade": {"id": "e28912a4-e1eb-11ea-86ee-a0999b054753", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138171141822420430"], "notes": "", "market_notes": null}, "order_type": {"order_type": "Limit", "price": 10, "size": 2, "persistence_type": "MARKET_ON_CLOSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Pending", "status_log": "Pending"}

{"asctime": "2020-08-19 07:16:22,242", "levelname": "INFO", "message": "1 order packages created", "order_packages": [{"id": "e28930c2-e1eb-11ea-86ee-a0999b054753", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x104826b20&gt;", "market_id": "1.172171556", "orders": ["138171141822420430"], "package_type": "Place", "customer_strategy_ref": "Liams-MBP", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}]}

{"asctime": "2020-08-19 07:16:22,243", "levelname": "INFO", "message": "New requests.Session created", "sessions_created": 1, "session": "&lt;requests.sessions.Session object at 0x10485e850&gt;", "session_time_created": 1597821382.243398, "session_time_returned": 1597821382.2433999}

{"asctime": "2020-08-19 07:16:22,488", "levelname": "INFO", "message": "execute_place", "trading_function": "place", "elapsed_time": 0.24187803268432617, "response": {"customerRef": "e28930c2e1eb11ea86eea0999b054753", "status": "SUCCESS", "marketId": "1.172171556", "instructionReports": [{"status": "SUCCESS", "instruction": {"selectionId": 8329902, "handicap": 0.0, "limitOrder": {"size": 2.0, "price": 10.0, "persistenceType": "MARKET_ON_CLOSE"}, "customerOrderRef": "27cfde50caeb3-138171141822420430", "orderType": "LIMIT", "side": "BACK"}, "betId": "208759879486", "placedDate": "2020-08-19T07:16:22.000Z", "averagePriceMatched": 0.0, "sizeMatched": 0.0, "orderStatus": "EXECUTABLE"}]}, "order_package": {"id": "e28930c2-e1eb-11ea-86ee-a0999b054753", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x104826b20&gt;", "market_id": "1.172171556", "orders": ["138171141822420430"], "package_type": "Place", "customer_strategy_ref": "Liams-MBP", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}}

{"asctime": "2020-08-19 07:16:22,488", "levelname": "INFO", "message": "Trade status update: Pending", "id": "e28912a4-e1eb-11ea-86ee-a0999b054753", "strategy": "ExampleStrategy", "status": "TradeStatus.PENDING", "orders": ["138171141822420430"], "notes": "", "market_notes": "3.05,3.15,3.1"}

{"asctime": "2020-08-19 07:16:22,488", "levelname": "INFO", "message": "Order Place: SUCCESS", "bet_id": null, "order_id": "138171141822420430", "status": "SUCCESS", "error_code": null}

{"asctime": "2020-08-19 07:16:22,488", "levelname": "INFO", "message": "Order status update: Executable", "market_id": "1.172171556", "selection_id": 8329902, "handicap": 0, "id": "138171141822420430", "customer_order_ref": "27cfde50caeb3-138171141822420430", "bet_id": "208759879486", "trade": {"id": "e28912a4-e1eb-11ea-86ee-a0999b054753", "strategy": "ExampleStrategy", "status": "TradeStatus.PENDING", "orders": ["138171141822420430"], "notes": "", "market_notes": "3.05,3.15,3.1"}, "order_type": {"order_type": "Limit", "price": 10, "size": 2, "persistence_type": "MARKET_ON_CLOSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Executable", "status_log": "Pending, Executable"}

{"asctime": "2020-08-19 07:16:22,488", "levelname": "INFO", "message": "Trade status update: Live", "id": "e28912a4-e1eb-11ea-86ee-a0999b054753", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138171141822420430"], "notes": "", "market_notes": "3.05,3.15,3.1"}```

---

## 2020-08-18 20:10:53 - random channel

**Newbie99**

```{"asctime": "2020-08-18 18:54:33,224", "levelname": "INFO", "message": "Order status update: Pending", "market_id": "1.172181073", "selection_id": 26836902, "handicap": 0, "id": "138170696732214253", "customer_order_ref": "27cfde50caeb3-138170696732214253", "bet_id": null, "trade": {"id": "411783ec-e184-11ea-8bfc-2016d8944b85", "strategy": "ExampleStrategy", "status": "TradeStatus.LIVE", "orders": ["138170696732214253"], "notes": "1.172181073,2020-08-18 18:56:00,2020-08-18 18:53:46.472000,OPEN,False,26836902,4. Energize Bingo,0,2.94,2.88,2.94,2.86,2.96,3693.63,355.2099999999996,2.757220771341723,2.7819444254664205,0.008706128457104802,0.012755260522776427,-0.5531056874468805,1.0469958809755968,-1.5485176472436966,-2.423454304332246,0,0,0.03303360044899266,2.54,2.74,True", "market_notes": null}, "order_type": {"order_type": "Limit", "price": 2.88, "size": 5.21, "persistence_type": "MARKET_ON_CLOSE", "time_in_force": null, "min_fill_size": null, "bet_target_type": null, "bet_target_size": null}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Pending", "status_log": "Pending"}

{"asctime": "2020-08-18 18:54:33,230", "levelname": "INFO", "message": "1 order packages created", "order_packages": [{"id": "4118e32b-e184-11ea-aace-2016d8944b85", "client": "&lt;flumine.clients.betfairclient.BetfairClient object at 0x000001B04D3CFDF0&gt;", "market_id": "1.172181073", "orders": ["138170696732214243", "138170696732214245", "138170696732214247", "138170696732214249", "138170696732214251", "138170696732214253"], "package_type": "Place", "customer_strategy_ref": "BlueOcean", "bet_delay": 0, "market_version": null, "retry": true, "retry_count": 0}]}```

---

## 2020-08-18 13:11:38 - general channel

**birchy**

Thanks [@UBS7QANF3](@UBS7QANF3) and [@U4H19D1D2](@U4H19D1D2), have it working now. Hard work on a phone cos copy/paste goes wanky in the nano terminal. What's the easiest way to push this into the strategy market_filter as a path?

---

## 2020-08-18 00:33:56 - issues channel

**qwerty.nat**

Just did a pip install flumine. filled in my login details in the example market recorder application to test all is ok.

`trading = betfairlightweight.APIClient(username="user",password="pass",app_key="slkfj", certs="/path/to/cert",lightweight=True)`

It fails after running for about 30 seconds,

`Traceback (most recent call last):`

  `File "marketrecorder.py", line 36, in &lt;module&gt;`

    `framework.run()`

  `File "/home/nathan/.local/lib/python3.8/site-packages/flumine/flumine.py", line 23, in run`

    `self._process_market_catalogues(event)`

  `File "/home/nathan/.local/lib/python3.8/site-packages/flumine/baseflumine.py", line 200, in _process_market_catalogues`

    `market = self.markets.markets.get(market_catalogue.market_id)`

`AttributeError: 'dict' object has no attribute 'market_id'`

If i set lightweight to False in the APIClient it all works without any error.

---

## 2020-08-16 20:35:37 - general channel

**mlpanda**

Hi [@U4H19D1D2](@U4H19D1D2), is there any take-profit/stop-loss functionality in Flumine? I'm currently planning to implement it in the strategy under `process_orders()` , but it would be cool to have an order type where you could define take-profit and stop-loss odds which would then trigger a hedge

---

## 2020-08-16 18:14:16 - general channel

**Lee**

Out of interest, what does elapsed_time include and does the following time seem slow?

```{

	"message": "execute_place",

	"trading_function": "place",

	"elapsed_time": 1.1396217346191406

}```

I mainly ask because a few of my offered prices did not match in live and if I increase `PLACE_LATENCY`  in simulatedexecution.py it seems to match live more accurately.

---

## 2020-08-15 17:34:08 - strategies channel

**Remi**

So I wonder what should the strategy be to make the best use of these free bets with 50 stakes

---

## 2020-08-15 17:30:13 - strategies channel

**Michael**

Liam's strategy locks in a return but you lose on the spread.

---

## 2020-08-14 17:11:59 - random channel

**Lee**

```from flumine import BaseStrategy

from flumine.order.ordertype import LimitOrder

from flumine.order.trade import Trade





class ExampleMultipleOrders(BaseStrategy):

    def check_market_book(self, market, market_book):

        if market_book.status != "CLOSED":

            return True



    def process_market_book(self, market, market_book):

        for runner in market_book.runners:

            if runner.status == "ACTIVE" and runner.selection_id == 35527773:

                trade = Trade(

                    market_id=market_book.market_id,

                    selection_id=runner.selection_id,

                    handicap=runner.handicap,

                    strategy=self,

                )

                order = trade.create_order(

                    side="BACK", order_type=LimitOrder(price=1000, size=2.00)

                )

                self.place_order(market, order)```

---

## 2020-08-14 16:42:34 - random channel

**liam**

By default it will look to see if the runner already has live/pending orders for that strategy aka [https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L121|invested](https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L121|invested), if you want to prevent this logic just override the `def validate_order` function to return True.



Strongly recommend testing this via the backtester or paper trading as it will fire in a lot of orders very quickly!

---

## 2020-08-14 15:57:38 - random channel

**Newbie99**

Just playing around with Flumine and I was testing placing live orders, but I can't seem to place multiple orders against the same runner, is that by design, or is there a parameter I'm missing?



```import time

import logging

import betfairlightweight

from betfairlightweight.filters import streaming_market_filter

from pythonjsonlogger import jsonlogger



from flumine import Flumine, clients, BaseStrategy

from flumine.order.trade import Trade

from flumine.order.ordertype import LimitOrder

from flumine.order.order import OrderStatus

import account_info as ai



logger = logging.getLogger()



custom_format = "%(asctime) %(levelname) %(message)"

log_handler = logging.StreamHandler()

formatter = jsonlogger.JsonFormatter(custom_format)

formatter.converter = time.gmtime

log_handler.setFormatter(formatter)

logger.addHandler(log_handler)

logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))





class ExampleStrategy(BaseStrategy):

    def start(self):

        # subscribe to streams

        print("starting strategy 'ExampleStrategy'")



    def check_market_book(self, market, market_book):

        # process_market_book only executed if this returns True

        if market_book.status != "CLOSED":

            return True



    def process_market_book(self, market, market_book):

        # process marketBook object

        for runner in market_book.runners:

            if (

                runner.status == "ACTIVE"

                #and runner.last_price_traded

                and runner.selection_id == 5512138

            ):

                trade = Trade(

                    market_id=market_book.market_id,

                    selection_id=runner.selection_id,

                    handicap=runner.handicap,

                    strategy=self,

                )

                order = trade.create_order(

                    side="BACK", order_type=LimitOrder(price=1000, size=2.00)

                )

                # self.offset_orders= []

                # self.customer_order_ref='t'

                self.place_order(market, order)

        print(market_book.publish_time)



    def process_orders(self, market, orders):

        for order in orders:

            if order.status == OrderStatus.EXECUTABLE:

                # if order.elapsed_seconds and order.elapsed_seconds &gt; 2:

                #     self.cancel_order(market, order)

                # if order.elapsed_seconds and order.elapsed_seconds &gt; 5:

                #     # print(order.bet_id, order.average_price_matched, order.size_matched)

                #     if order.size_remaining == 2.00:

                #         self.cancel_order(market, order, size_reduction=0.01)

                # self.update_order(market, order, "PERSIST")

                # if order.order_type.price == 1.01 and order.size_remaining == 0.49:

                #     self.replace_order(market, order, 1.02)

                # if order.order_type.price == 1.02:

                #     self.replace_order(market, order, 1.03)

                # if order.order_type.price == 1.03:

                #     self.replace_order(market, order, 1.05)

                pass





trading = betfairlightweight.APIClient(ai.accname, ai.accpass, ai.acckey, certs=ai.path)

client = clients.BetfairClient(trading)



framework = Flumine(client=client)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(market_ids=["1.172039988"]),

    streaming_timeout=2,

    # max_selection_exposure=5000,

    # max_order_exposure=2000

)

framework.add_strategy(strategy)

framework.run()```

I can place, cancel, update etc successfully, but I assumed the above would try to fire off multiple orders, but it only ever seems to place one (obviously there's not a real world use for this script, I was just trying to play around to place multiple orders). Have I missed something, or is this intended behaviour?

---

## 2020-08-13 12:23:21 - issues channel

**Remi**

A few weeks ago I made a script to go through the account statements to evaluate performance for different markets etc. This is the call I am making:

```account_statement = Trading.account.get_account_statement(item_date_range=time_range(from_=from_date, to=to_date),

                                                                      from_record=from_counter)```

---

## 2020-08-12 22:00:07 - strategies channel

**Troy Edwards**

Oh customerOrderRef did not see this in Betfair documentation.   I guess I will test in coming days that I can have duplicate customerStrategyRefs as well as characters allowed.    I do store my bets placed in a bet table with my unique rule index (pID) however i would like to use the CSR so I can review Betfair profit and loss or 3 month bet report.   Will also check out COR.  

---

## 2020-08-12 13:24:00 - strategies channel

**Misha**

As a general rule I use customerStrategyRef as a broad category, and customerOrderRef to uniquely identify the bets. Between the two you can be very creative without resorting to special characters. I use the customerOrderRef to uniquely identify every bet over the lifetime of any of my systems, no matter where and when the bet was placed

---

## 2020-08-12 13:20:04 - strategies channel

**Mo**

It's unclear whether those restrictions also apply to the `customerStrategyRef` field

---

## 2020-08-12 12:40:05 - issues channel

**Lee**

I think i might not be understanding the MarketOnCloseOrder correctly. I'm trying to take SP just before going inplay but can't seem to get any money matched (flumine backtesting). I've removed my trigger and try to place an order on all runners and still get zero matched.

I've also set my strategy exposure high and not getting any voilation errors on the orders in the logs.

I'm creating an order using the following

```order = trade.create_order(

    side="BACK", order_type=MarketOnCloseOrder(liability=20)

)```

Any idea where i'm going wrong or if it's just a misunderstanding



here's a log too

```{"asctime": "2020-08-12 11:32:33,047", "levelname": "INFO", "message": "Order status update: Execution complete", "market_id": "1.170576255", "selection_id": 19436243, "handicap": 0, "id": "138165247530344110", "customer_order_ref": "890b98c67ce74-138165247530344110", "bet_id": "100000000007", "trade": {"id": "83599e5e-dc8f-11ea-80ef-d45d6453ef52", "strategy": "xxxxxxx", "status": "TradeStatus.LIVE", "orders": ["138165247530344110"], "notes": "", "market_notes": "15.5,16,15.5"}, "order_type": {"order_type": "Market on close", "liability": 20}, "info": {"side": "BACK", "size_matched": 0.0, "size_remaining": 0.0, "size_cancelled": 0.0, "size_lapsed": 0.0, "size_voided": 0.0, "average_price_matched": 0.0}, "status": "Execution complete", "status_log": "Pending, Executable, Execution complete"}```

---

## 2020-08-12 12:07:46 - strategies channel

**Troy Edwards**

Hi all in relation to the 15 character "customerStrategyRef" used in placeOrders can we use any characters ie &gt;&lt;() ????

---

## 2020-08-11 20:03:42 - issues channel

**liam**

It depends on the market capacity and volatility as you would expect. I find on inplay racing it underplays the match rate compared to live which I prefer as it means I know that if I am breaking even or making profit backtesting then it’s time to get some money in the market.



With flumine you use the exact same strategy code live as you do backtesting so it also acts as a good integration test as well.

---

## 2020-08-10 17:30:54 - general channel

**PeterLe**

Hi,

A very quick question please..(im still learning :slightly_smiling_face:) in the code below, is there a simple way to replace the parameter in the market start time such that it always defaults to today?

ie listing all eventids for today (GB)

Many thanks in advance



def todaysmarkets():

    racing_filter = filters.market_filter(

        event_type_ids=[7],

        market_countries=["GB"],

        market_type_codes=["WIN"],

        market_start_time={"to":"2020-08-10T22:45:00Z"},

    )

    results = trading.betting.list_market_catalogue(

        market_projection=[

            "RUNNER_DESCRIPTION",

            "RUNNER_METADATA",

            "COMPETITION",

            "EVENT",

            "EVENT_TYPE",

            "MARKET_DESCRIPTION",

            "MARKET_START_TIME",

        ],

        filter=racing_filter,

        max_results=100,

    )

---

## 2020-08-09 10:35:14 - issues channel

**liam**

Ah bollocks, that fixes it for backtesting but not for paper trading 

---

## 2020-08-09 00:09:14 - strategies channel

**ricky**

# create queue

output_queue = None



market_filter = streaming_market_filter(

    event_type_ids=["1"], market_types=["MATCH_ODDS"], market_ids=["1.171324077"]

)

market_data_filter = streaming_market_data_filter(

    fields=["EX_BEST_OFFERS", "EX_MARKET_DEF", "EX_TRADED"], ladder_levels=10

)



# create stream listener

listener = betfairlightweight.StreamListener(output_queue=output_queue)



# create stream

stream = trading.streaming.create_stream(listener=listener)



market_books = listener.snap(

    market_ids=["1.171324077"]

)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



# create streaming object

streaming = Streaming(trading, market_filter, market_data_filter)



# start streaming (runs in new thread and handles any errors)

streaming.start()



...

while True:

    market_books = streaming.output_queue.get()

    print(market_books)

---

## 2020-08-08 10:35:30 - general channel

**john walsh**

I am getting this message for each entry "[&lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x0B4D7A30&gt;]".  Does anybody know how to fix it?

---

## 2020-08-08 10:22:58 - strategies channel

**Mo**

Thanks [@UGV299K6H](@UGV299K6H), now I have the missing piece for my GPS strategy!

---

## 2020-08-08 09:11:20 - general channel

**liam**

[https://github.com/liampauling/betfair/blob/a639787bee11e0cbd135bf0e7bfeb171217f78d7/betfairlightweight/resources/bettingresources.py#L586|https://github.com/liampauling/betfair/blob/a639787bee11e0cbd135bf0e7bfeb171217f78d7/betfairlightweight/resources/bettingresources.py#L586](https://github.com/liampauling/betfair/blob/a639787bee11e0cbd135bf0e7bfeb171217f78d7/betfairlightweight/resources/bettingresources.py#L586|https://github.com/liampauling/betfair/blob/a639787bee11e0cbd135bf0e7bfeb171217f78d7/betfairlightweight/resources/bettingresources.py#L586)

---

## 2020-08-08 08:54:29 - strategies channel

**Michael**

That said: Experience tells me that if you're finding almost 100% lay bets from a model that attempts to re-price a whole market then you're doing something seriously wrong.

---

## 2020-08-07 18:08:23 - issues channel

**mlpanda**

Yes I am:



```trading = betfairlightweight.APIClient("username", "password", app_key="appkey")



client = clients.BetfairClient(trading, interactive_login=False, paper_trade=True)



framework = Flumine(client=client)```



---

## 2020-08-07 17:58:52 - issues channel

**mlpanda**

Hey, has anyone had issues with getting last_price_traded/total_matched through Flumine?

I am using the fields ["EX_ALL_OFFERS", "EX_MARKET_DEF", "EX_TRADED"] which should be sufficient, so I think the issue is related to login. Note that I do get the market_id, publish_time and selection_id.



For logging in, I have tried both interactive and non-interactive login. If I stop the run and try e.g. client._get_account_details() I do get an "INVALID_APP_KEY" error, however if I manually try to login with trading.login() it returns "SUCCESS".



I am using the app_key from [https://docs.developer.betfair.com/visualisers/api-ng-account-operations/](https://docs.developer.betfair.com/visualisers/api-ng-account-operations/) which historically has worked fine. I did notice that trading.login() returns a session_token which is different from the one in the link above. Any suggestions would be super helpful, thanks.

---

## 2020-08-07 11:08:08 - strategies channel

**Mo**

[@UQL0QDEKA](@UQL0QDEKA) it took me 3 months to go from having access to the data to running a strategy at test stakes and you know what my level of experience and time commitment is like.



But I was coming from a cold start with no existing horse racing strategies - either in running or pre-event - so that may help you get going faster. 



A very important point that anyone starting now should consider is that the historically available GPS data undergoes some significant transformations from what you would have received live which seriously limits its usefulness for back testing. Guys like [@U4H19D1D2](@U4H19D1D2) who have been doing this from the start and collected their own data are in a much better position in this regard. 



You definitely have to account for trackers on the wrong horse, horses running without trackers, seriously miscalibrated trackers (horse running outside the track, starts the race 10m behind the stalls, appears to be leading when is actually in second place, etc)

---

## 2020-08-07 09:03:33 - issues channel

**liam**

Btw easier to view the docs on the dedicated site [https://liampauling.github.io/flumine/quickstart/#paper-trading](https://liampauling.github.io/flumine/quickstart/#paper-trading)

---

## 2020-08-07 09:03:09 - issues channel

**liam**

Ah yes that is incorrect, ignore the strategy part as it should be the same as live, the only change for paper trading is

```client = clients.BetfairClient(trading, paper_trade=True)```

---

## 2020-08-06 23:16:43 - issues channel

**mlpanda**

Hey [@U4H19D1D2](@U4H19D1D2), first of all thanks for creating Flumine! I have so far used the backtesting module (and matched the results close enough to my own simple backtester) and I am now looking to use the paper trading functionality. I am currently looking at the example here: [https://github.com/liampauling/flumine/blob/7b50f7e8672c4c5e7c46ac5684617374f1e58c61/docs/quickstart.md](https://github.com/liampauling/flumine/blob/7b50f7e8672c4c5e7c46ac5684617374f1e58c61/docs/quickstart.md)

I don't really understand why the strategy is passed the path to a file rather than the streaming_market_filter() which is passed during live mode. I would expect  the paper trading to look exactly like the live mode except that the trades wouldn't be executed. Am I misunderstanding something here?

---

## 2020-08-06 22:02:52 - strategies channel

**Mo**

This sounds more like a bug than a poor model

---

## 2020-08-06 22:01:26 - strategies channel

**Ruben**

yes, most likely my model is just terrible :man-facepalming:

---

## 2020-08-06 19:37:40 - strategies channel

**Ruben**

I would appreciate your input on something...I'm testing a strategy that uses a ML model to calculate the underlying probabilities of events; the system decides to bet when it detects value. However, I am finding that almost all bets (&gt; 99%) are lay bets. On a typical market, I would expect inefficiencies to appear equally likely on the back/lay side; this makes me think that my model is heavily biased towards lay bets

---

## 2020-08-06 14:18:52 - strategies channel

**Twatter**

So I'm guessing that if the sensor was off at the start of the race in the stalls, I'm guessing could you not add a check to say if the gps readings don't map up within a certain percentage, and if your strategy is to bet in-play, then best just void the whole race just in case?

---

## 2020-08-06 12:07:10 - general channel

**Misha**

My advice is to keep it as simple as you can. You only ever learn from experience so it isn't till you actually get going that you start to get an idea of what you need. The syndicates making money have surprisingly simple setups beyond using hosted servers (none of the ones I worked for used AWS services at the time). I know because I ran a few of them. It's the model that makes the money, and the operational system can increase the profits (but can never overcome a poor model)

---

## 2020-08-06 11:27:48 - general channel

**Twatter**

I haven't used docker myself, but wouldn't that just make it easy to deploy a working bot? i.e. if you've already got it running on a server, and it's a bot/strategy that won't benefit from deploying the same code to a 2nd/3rd server etc, then I would have thought that containerising your code and deployment into docker would only help with speed of deployment and speed of recovery if the server fell over?

---

## 2020-08-06 11:17:05 - general channel

**Twatter**

Flumine setup and use sounds great - might sound basic for a lot of people but would be great for newbies like myself. So far, although you guys recommended to start plugging my strategy and stuff into flumine, i've started using trying to do it all in betfair lightweight, but still at the pre-requisite stages of simply grabbing market data and prices that I need and trying to analyse them. The way I see it is that since BFLW is so close to the Betfair API, it's giving me a great understanding of how the Betfair API itself works and how it returns data, and then I can look at how Flumine then wraps more of the trading and strategy around BFLW..

---

## 2020-08-06 11:13:25 - general channel

**Twatter**

Haha - My infrastructure so far is a laptop. With internet. And power supply. Sometimes use a mouse when at a desk. Still putting together just the very basics of grabbing market prices on horses for the strategy I need. Not even sure whether the strategy I use will translate into Betfair markets as it depends on how efficient all the pricing is inter market. It's all an interesting learning experience though so far as first time properly using Betfair APIs etc

---

## 2020-08-06 10:17:13 - general channel

**Twatter**

I joined here so I can get an idea of what everyone else is doing for Betfair bots and how they using Liam's BFLW/flumine and to get help whilst developing.... to be honest over the history of what i've been reading i've been completely blown away by how sophisticated all your trading set-ups are. I was expecting a few hobbyists like my self trying to write a bot for a bit of side income - and instead found a bunch of people using bits of AWS that i've never come across, ML, real time GPS feeds from races that I didn't even know existed, and god knows what else going on. Crazy...

---

## 2020-08-06 09:51:19 - general channel

**Misha**

I wouldn't pay myself to develop my own model :joy: (even though I reckon I could make a good go of it). So I have split the system in two; I fetch and clean all the data, the modeller takes that and generates probabilities, and I then take that and build the execution engine. My partner has only one job

---

## 2020-08-06 09:44:45 - general channel

**Misha**

So I won't go into racing and football, which is where the big syndicates go. They make all their money on statistical models pre-play

---

## 2020-08-06 09:44:01 - general channel

**Misha**

When you work in the industry for the big guys you see what is possible if you have a good model. But the really successful ones have been at it for 20 years. Easy enough to fill a niche (which would be good money), but very hard to get to their level

---

## 2020-08-06 09:42:32 - general channel

**Misha**

So after 10 years, when my last client exited Australia, I thought why not have a go. So I have teamed up with a modeller and we are about to go live. Have spent the last 7 months updating the system in preparation. I specialise in the execution engine (my code) which I then update for clients and they can use it. When I part ways I just take the generic bits and keep developing

---

## 2020-08-06 09:39:53 - general channel

**Misha**

A number or reasons: 1) I am a professional developer so a nerd (into sports) and not a risk taker: 2) I get paid a reasonably good amount to do this with no risk; 3) I don't have a big pot of money behind me; 4) I need a good model which I'm not as comfortable with

---

## 2020-08-06 09:21:09 - general channel

**Twatter**

[@U016535QCJ2](@U016535QCJ2) I don't quite understand why you haven't been using it yourself since you started - esp. if it was showing to make lots of money? Was it a case that although you had the code, you didn't have access to the models it ran off?

---

## 2020-08-06 08:43:14 - general channel

**Peter**

Well 40 years ago I was programming linear regression models. But as I was doing so on a mainframe using punch cards, I don't think I'll be claiming that as a huge influence on what I do now :slightly_smiling_face:

---

## 2020-08-06 08:30:13 - general channel

**Misha**

I partner with other people who develop models so I concentrate solely on developing and refining the operational system

---

## 2020-08-06 08:23:45 - general channel

**Misha**

Previous client was probably the most successful on UK racing. I only supplied the operational system that took inputs from their model. Was making an eye-watering amount. I was the developer, so none of that went to me unfortunately

---

## 2020-08-06 08:18:25 - general channel

**liam**

So there are guys on here that care about milliseconds, have code that is very close to the metal and operate at the same level as those in the equity markets. Many (including myself) focus on the nuances of the matching engine and have execution models to be able to take advantage with a view to maximise pnl / matching rates.

Others are running ML models in real time based on multiple data sources across numerous domains feeding into a single system, behind these models are teams of people.

No offence but being able to process 5000 markets is not sophisticated, its a pre requisite.

---

## 2020-08-06 08:09:22 - general channel

**Misha**

The system can monitor &gt;5000 markets concurrently (and execute any strategy) using only a 4 CPU VM

---

## 2020-08-06 06:54:15 - general channel

**Mo**

My trading platform is made up of multiple components each of which is a separate Python process. For example, a Betfair price feed, a market catalogue feed, and each event traded is its own process. Communication between them is done primarily using Redis pubsub but other features are useful - e.g. storing the market catalogues for easy lookup by the different components. For your use case a Redis Set would be perfect for keeping track of which markets you're trading

---

## 2020-08-05 22:27:48 - general channel

**birchy**

What's the best way to achieve interprocess control between bots in python? I basically have a strategy that locks into one market until closure and then moves on to the next available market. If I run multiple instances of the same bot, what's the easiest way to avoid them locking onto the same market? I currently pickle the market ids and check the pickle file to confirm that no other bots are already working on the market but it's a bit clunky and I'd like to use something less error prone.

---

## 2020-08-05 07:41:58 - general channel

**liam**

Yep so customer_strategy_ref is used to differentiate different running instances hence hostname rather than strategies, this allows multiple instances to run using the same strategies. It then uses the customer_order_ref to store the strategy name



```@property

def customer_order_ref(self) -&gt; str:

    return "{0}-{1}".format(self.trade.strategy.name_hash, self.id)```



---

## 2020-08-05 06:49:56 - general channel

**Oliver Varney**

I might be missing something but, could we not make customer_strategy_ref a param for the base_strategy or some variation of account + base strategy?

---

## 2020-08-05 06:39:55 - general channel

**Oliver Varney**

[@U4H19D1D2](@U4H19D1D2) Am I right in seeing that customer strategy ref is determined by the oshostname?

---

## 2020-08-04 19:16:03 - general channel

**Oliver Varney**

[@U4H19D1D2](@U4H19D1D2) If flumine process is restart, is there a process to load back in strategy orders ? Also is customerStrategyRef implemented ?

---

## 2020-08-03 09:57:10 - general channel

**Lee**

looks great, thanks! within the strategy i should just manually read the file right?

---

## 2020-08-02 13:21:20 - strategies channel

**Dave**

It would suggest the strategy is only profitable if I added a markup of ~0.1-0.2+ to guarantee I only take when price improvement would be of that size or higher. So you can then implement that in your strategy. It's applicable to other metrics that are treated as thresholds.

---

## 2020-08-02 12:57:34 - strategies channel

**Lee**

Yeah, it's frustrating but at least i'm enjoying the process and love watching a strategy trade

---

## 2020-08-02 12:44:38 - strategies channel

**Michael**

Personally I would make a hypothesis (and write it down), something along the lines of: By reducing threshold X from 0.05 to 0.04 I anticipate that the strategy will generate 10% more bets at an earlier stage in the race with and increase in transactions and matching rates offsetting a decrease in expected value estimated at 2% (all made up - just whatever's relevant). Then you let it go, check it's not doing anything nuts at about 200 markets in, then leave it 'till you've got 1000 markets, then analyse.

---

## 2020-08-02 12:29:40 - strategies channel

**Michael**

I think it depends how you do it. Your bets have an effect on the market and if your two strategies are similar then they'll be competing with each-other, so if you're effectively running two bots simultaneously then you'll confuse things (at best). Depending on how you're operating it'd be better to make sure that only one version is executing at a time. If you're trying to optimise prices with a fixed trigger then that's easy and you can do a very simple a v b, if you're trying to optimise a trigger then you can't. In that case I'd either run them on separate markets or (more often) just measure the relative performance of each strategy looking deeply at the various metrics and comparing both data sets to the hypothetical performance of a fixed strategy that shows how promising the markets were but doesn't place any bets at all.

---

## 2020-08-02 12:07:42 - strategies channel

**Lee**

When trying to optimise a strategy on low stakes, i've duplicated and deployed both the original side by side with the new variant to have something to compare again. Basically an AB test. Does this seem a reasonable approach?

---

## 2020-07-30 22:27:12 - issues channel

**mlpanda**

Hey, has anyone had the issue of receiving an empty list when using the historical data example in betfair lightweight: [https://github.com/liampauling/betfair/blob/master/examples/examplehistoricdata.py](https://github.com/liampauling/betfair/blob/master/examples/examplehistoricdata.py)



In `my_data` I have the following data purchased:

`{'sport': 'Horse Racing', 'plan': 'Advanced Plan', 'forDate': '2020-05-01T00:00:00', 'purchaseItemId': 48406}`



But when I use the following function:

```# get file list

file_list = trading.historic.get_file_list(

    "Horse Racing",

    "Advanced Plan",

    from_day=1,

    from_month=5,

    from_year=2020,

    to_day=31,

    to_month=5,

    to_year=2020,

    market_types_collection=["WIN", "PLACE"],

    countries_collection=["GB", "IE"],

    file_type_collection=["M"],

)

print(file_list)```

I get an empty list in `file_list`. If I try to expand the dates to e.g. `to_month=6` I get an error (probably because I haven't purchased data for June), but I'm puzzled why I get an empty list for the above example.

---

## 2020-07-30 17:18:28 - general channel

**Newbie99**

something like this:



```market_stream = se.Streaming(trading, market_filter, market_data_filter, conflate_ms=conflate)```



---

## 2020-07-30 13:09:56 - issues channel

**Twatter**

[@U016535QCJ2](@U016535QCJ2) Hahaha - I should try that... "I'm struggling to make loadsa money out of this betfair strategy... can anyone spot the mistake in it?"

---

## 2020-07-29 09:50:18 - issues channel

**Newbie99**

```

Replace Error: RELATED_ACTION_FAILED

Exception in thread Thread-1:

Traceback (most recent call last):

  File "/usr/lib64/python3.7/threading.py", line 926, in _bootstrap_inner

    self.run()

  File "/usr/lib64/python3.7/threading.py", line 870, in run

    self._target(*self._args, **self._kwargs)

  File "racing.py", line 568, in combined_queue

    replaced_orders_report = rf.replace_orders(market_id, replace_list, market_info, trading, filters)

  File "/home/ec2-user/trading/env/projects/racing_functions.py", line 1941, in replace_orders

    'selection_id': place_instruction_report.instruction.selection_id,

AttributeError: 'NoneType' object has no attribute 'selection_id'```

---

## 2020-07-28 15:26:27 - issues channel

**mlpanda**

Any suggestions why this code snippet



```market_catalogues = trading.betting.list_market_catalogue(

    filter=filters.market_filter(

        event_type_ids=["7"],  # filter on just horse racing

        market_countries=["GB"],  # filter on just GB countries

        market_type_codes=["WIN"],  # filter on just WIN market types

    ),

    market_projection=[

        "MARKET_START_TIME",

        "RUNNER_DESCRIPTION",

        "EVENT",

    ],  # runner description required

    max_results=100,

)```

gives me the error



`Exception: Timeout value connect was (3.05, 16), but it must be an int or float.`



It's rather strange as it works on my local mac, but when I run it on an EC2 instance in AWS (location: London) it fails with the above message. I'm also located in London locally, so seems odds.



Any suggestions would be very much appreciated :)

---

## 2020-07-27 20:25:26 - strategies channel

**Lee**

For tracking which strategy places which orders in flumine, should I add my own LoggingControl and post to an API on CLEARED_ORDERS event?

---

## 2020-07-27 19:17:54 - random channel

**Frankz**

hi, im new here. after building a crypto arbitrage bot back in 2016 I started shifting towards sports betting. how about you? who else is betfairlight streaming the games tonite?? :slightly_smiling_face:

---

## 2020-07-27 15:18:28 - general channel

**Twatter**

Quick question - I'm slowly getting to grips with Betfairlightweight, and figuring out how to use Flumine, and looking at the BaseStrategy class, does this work on one market book at a time? e.g. process_market_book(self, market, market_book) - would I have to overwrite the BaseStrategy class if I wanted to get it working with two separate markets as an input ?

---

## 2020-07-27 11:39:50 - strategies channel

**Misha**

I can't speak for Python or Linux, but I can run my entire system inside a VM on my laptop, with over 50 threads running across all applications, but because most are idle at any time, it still takes less than a millisecond to pass from one thread to another. I see no reason why this wouldn't be the case for Linux, and Python (to a point). The key is not to do anything time intensive in the chain from price to calculation to betting

---

## 2020-07-27 09:52:50 - general channel

**liam**

are you overriding the strategy validate order functionality?

---

## 2020-07-27 08:38:54 - strategies channel

**richard**

I plan to, but at the moment it’s just one at a time.

I have a neural net doing price predications and scalp based on that.

Working quite well at the moment but need to cash out when things go wrong which is why I need this.

I tried this equation out, am I right in saying it calculates a ‘win / no bet’ result eg. no loss but only one result gives a profit?

I’m hoping for something like: layAmount = (backOdds / layOdds) * backAmount Or backAmount = (layOdds / backOdds) * layAmount

Which gives a arbitrage bet where you generate a profit on either side.

How’s your strategy working?

---

## 2020-07-26 23:41:46 - strategies channel

**mlpanda**

Totally agree Dave, but if it’s not illegal it’s quite an important thing to be aware of when I’m creating new models/strategies as I doubt those who do it will care about the spirits of the markets :sunglasses:

---

## 2020-07-26 22:18:31 - general channel

**Mo**

So I have copies of my GitHub repos checked out to a Dropbox folder and any changes I make to my working copies are automatically synced with Dropbox. 



I push my commits to GitHub about once a day to make sure my collaborators have access in case I get hit by a bus etc. Or I’ll push if the changes need to be deployed to production. 



Managing infrastructure with ansible means that the setup of my servers is described in code that can similarly be version controlled. Deploying trading code to production is a case of running ansible tasks that will pull the relevant code from GitHub. 

---

## 2020-07-26 11:30:54 - strategies channel

**birchy**

Just wondering how you're all implementing tracking for each strategy? I am currently saving the bet IDs by strategyRef and combining with getAccountStatement settled bet calls to identify the gross P&amp;L for each strategy and then pickling that as a dict for future analysis. Downside is that it's difficult to match up commission rates for net profit calcs, particularly where bets have been placed on Aus markets which have variable rates rather than my usual 2%.

---

## 2020-07-26 11:25:28 - strategies channel

**Mo**

Well, there's this which prevents a new rogue strategy from wiping out your entire account if it blows up

---

## 2020-07-26 09:40:17 - strategies channel

**Misha**

As noted, there isn't anything you can't do with the strategy ref and order ref properties and logging all bets to a table periodically

---

## 2020-07-26 09:29:00 - strategies channel

**SrFabio**

Cool that makes sense! Thanks for the insight that's really useful. I think sub account is probably overkill for now as the customerStrategyRef should cater for it + some internal logic to build performance metrics which I already have

---

## 2020-07-26 09:16:03 - strategies channel

**Mo**

Yeah, important to mention that MSA predated the customerStrategyRef field and that nowadays Betfair want you to use that field if all you need to do is differentiate strategies. MSA has other use cases such as allowing multiple users e.g. traders

---

## 2020-07-26 09:15:16 - strategies channel

**Dave**

Yeah sorry I wasn't clear - if you have all the underlying bets grouped by strategy then you can do whatever aggregation you want (e.g. performance over time). Given Betfair's pnl tracking at account level is pretty basic you might as well do it yourself anyway, for which customerStrategyRef is totally sufficient to look at performance by strategy at whatever granularity/aggregation level IMO. Besides, betfairs orders only persist for 90 days so you ought to write em to a file anyway, at which point self-aggr is the way to go. Same advantages of the field apply to bankroll management, e.g. computing your exposure and whatnot.

---

## 2020-07-26 09:11:14 - strategies channel

**Mo**

In principle MSA structure is very useful for having a per strategy absolute exposure limit but in practice I rarely use more than one of my subaccounts

---

## 2020-07-26 09:09:47 - strategies channel

**Michael**

I think [@U013Z24LD0U](@U013Z24LD0U) is thinking about how to track the absolute performance of a strategy over time rather than the individual bets so that he can scale automatically according to performance (or something like that). For that he needs to keep some sort of overall record and write it out to a file.

---

## 2020-07-26 09:06:30 - strategies channel

**Dave**

For tracking the "customerStrategyRef" argument when placing an order is totally sufficient. Though it's limited to 16 chars i think so you will want to keep it in mind when generating these references (e.g I would encode my strategy parameters into a hash and keep the mapping somewhere so I can easily reverse the hash and figure out which params are responsible for the order. )

---

## 2020-07-26 09:03:14 - strategies channel

**Michael**

Depending on your account status and KYC you might be allowed be allowed MSA but you don't need it just to differentiate strategy liabilities. Just keep some kind of track and handle for it internally.

---

## 2020-07-26 08:37:28 - strategies channel

**SrFabio**

How do you guys manage multiple live strategies running in parallel (in terms of bankroll management)? Are you allowed to create sub-accounts and run a strategy per account or do you create some "virtual balance" and assign a portion to each bot

---

## 2020-07-25 18:32:10 - strategies channel

**Mo**

Also worth mentioning that fundamental modelling is one angle but understanding market behaviour is another

---

## 2020-07-25 17:03:26 - strategies channel

**Mathias Tejs**

Wow. Cool. That surprises me quite a bit :) Are you saying that no additional data is needed because it's possible to win small amounts without additional data or because you don't think that additional data is worth much to a strategy?

---

## 2020-07-25 17:01:25 - strategies channel

**Mo**

There are academic papers worth reading to give you ideas for how to model specific sports. For example, [https://tolstoy.newcastle.edu.au/R/e8/help/att-6544/dixoncoles97.pdf|Dixon and Coles](https://tolstoy.newcastle.edu.au/R/e8/help/att-6544/dixoncoles97.pdf|Dixon and Coles) is the seminal paper for modelling football pre-event and [https://wwwf.imperial.ac.uk/~ejm/M3S4/Problems/football.pdf|Dixon and Robinson](https://wwwf.imperial.ac.uk/~ejm/M3S4/Problems/football.pdf|Dixon and Robinson) extends the idea to in-running.



For tennis, a good but increasingly dated starting point is [http://www.strategicgames.com.au/PhD.pdf|Tristan Barnett's PhD thesis](http://www.strategicgames.com.au/PhD.pdf|Tristan Barnett's PhD thesis). The various papers coming out of [https://www.imperial.ac.uk/people/w.knottenbelt/publications.html|Will Knottenbelt](https://www.imperial.ac.uk/people/w.knottenbelt/publications.html|Will Knottenbelt)'s group at Imperial College are more recent additions.



But thinking about how to take these models and build automated trading platforms that utilise them is a whole other ball game. There aren't really any books out there to recommend. Personally, I think you are already utilising the best available resource by being part of this Slack channel.

---

## 2020-07-25 16:46:39 - general channel

**Jorge**

Aha I see, so I would need to make 2 calls per iteration in my strategy: listMarketBook for prices and listMarketCatalogue for start_time updates :L

---

## 2020-07-25 16:34:17 - general channel

**Jorge**

Hi guys! How do you querie for the marketStartTime? Is it possible to get this information with a call to listMarketBook endpoint? I want my strategy to finish some minutes before the market goes "inplay" as I have the feeling that odds get worse when it does, but sometimes marketStartTime can be changing

---

## 2020-07-25 16:09:12 - strategies channel

**Mathias Tejs**

Hi all, thanks for letting me join the group :) I want to get into betting and I'm wondering if there are any resources (e.g. books, blogs, etc.) that you guys can recommend? I'm an "expert" in algorithms, software development, machine learning and probability theory but I know very little about the world of betting (and also very little about trading) - I'm only saying that to say that I'm not too interested in general programming books and so on :)



Another related newbie question: I'm especially interested in football (soccer) betting. My guess is that my biggest chance for betting profitably there would be through live betting (I want to bet 100% programmatically). Are there any live feed sources that you can recommend? I have saved up around 30k euro that I plan to risk on getting started - is that enough, or do you need a higher volume to avoid all of your winnings going to paying monthly live feed APIs? (I can see from the slack history that some of you guys are winning considerably more than that)

---

## 2020-07-25 12:18:30 - general channel

**Michael**

I'm all for educated guesses too. You never know how a strategy is  going to do until you get some bets on so I just check that what I'm thinking isn't daft then give it a go.

---

## 2020-07-25 10:17:00 - strategies channel

**Aaron**

do you count as supplementary if your strategy is losing YTD :stuck_out_tongue:

---

## 2020-07-25 09:23:43 - strategies channel

**Michael**

I really think a lot of people become irrational when it comes to PC. Minimising PC is not a desirable end in itself, what's desirable is maximising your income. You know what's worse than paying PC? NOT paying PC. Whatever your situation the prescription is the same: Maximise your betting profits. If you have a high variability strategy that generates a lot of comm that's fine, but you'll still take more money home if you can reduce that variability. Variability is losing, losing isn't winning, it's that simple.

---

## 2020-07-24 23:27:42 - general channel

**birchy**

Actually, now that I've written that down, I'm questioning my own ability. I've not watched a betfair market for at least 5 years, so as such I'm developing strategies blindly, using nothing but educated guesses. I do test them on historical data before going live, but in reality everything is based on assumptions that I've accumulated over the last 30 years, mixed with a handful of new ideas I've read on various forums and betting blogs.

---

## 2020-07-24 17:35:40 - strategies channel

**Amanda**

Good one Lee, “first strategy live” and your worrying about premium charges, that’s optimism for you, I like it.

---

## 2020-07-24 15:29:07 - issues channel

**Jon**

this seems to work:

`market_catalogue_filter = betfairlightweight.filters.market_filter(market_ids=[id])`



`market_catalogues = trading.betting.list_market_catalogue(`

    `filter=market_catalogue_filter,`

    `market_projection=[`

        `"RUNNER_DESCRIPTION"`

        `],`    

`)`



`# Create a DataFrame containing runners for the market catalogue`

`golf_runners_df = pd.DataFrame({`

    `'Selection ID': [runner.selection_id for runner in market_catalogues[0].runners],`

    `'Runner Name': [runner.runner_name for runner in market_catalogues[0].runners],`

`})`

---

## 2020-07-24 15:05:53 - issues channel

**Jon**

i can't find anywhere that explains how to get additional data with trading.betting.list_market_catalogue

---

## 2020-07-24 14:47:19 - issues channel

**Jon**

`# Create a price filter. Get all traded and offer data`

`price_filter = betfairlightweight.filters.price_projection(`

    `price_data=['EX_BEST_OFFERS']`

`)`



`market_books = trading.betting.list_market_book(`

    `market_ids=['1.171523770'],`

    `price_projection=price_filter`

`)`



`market_book_to_data_frame(market_books[0])`

---

## 2020-07-24 14:32:31 - issues channel

**Mo**

Also you can read the package source code on GitHub: [https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L542](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L542)

---

## 2020-07-24 13:49:24 - strategies channel

**Lee**

Finally got my first strategy live which seems to be going well so far. My betfair rewards is set to Basic (2% commission), is this something i should change to increase my commission / reduce premium charge if/when it comes or not something to worry about yet?

---

## 2020-07-22 19:07:18 - general channel

**birchy**

[@U016GUPM2UR](@U016GUPM2UR) Totally agree with [@UBS7QANF3](@UBS7QANF3). 20 bets is nowhere near meaningful. You could achieve similar or better results with a completely random strategy. Personally, I don't even check my P&amp;L until 1000+ markets and even then, I'm fully aware that it could all go pear-shaped with a handful of "unlucky" bets. In particular, watch out for the bigger wins as they can make a massive difference to the ROI. For example, if you were backing 100/1 shots and the first bet won, you'd have a massive ROI initially but it's highly likely that the next 99 will lose...leaving the strategy -EV after commission.

---

## 2020-07-22 18:48:39 - general channel

**steve**

if we assume the model has changed for that specific segment. what would be the first thing you look at? i understand statistically its possible for this to happen, but the SD over the last few years has been quite consistant

---

## 2020-07-22 18:44:23 - general channel

**steve**

i have a model that splits into very high prob 90%+, mid prob 70-90+ and 50-70% prob, and its been quite consistant over the last 3 years, but this year (half way thru) has shown my 70-90% segment to be significantly off

---

## 2020-07-22 18:37:07 - general channel

**steve**

my model has 3 segments. 2/3 segments are ok but the other is well off

---

## 2020-07-22 18:33:02 - general channel

**Mo**

I’ll answer it tangentially by saying in my experience good data is way more important than the model 

---

## 2020-07-22 17:31:13 - general channel

**steve**

is anyone having trouble with their models atm? im having trouble with one of mine and not sure what to do with it. one segment is just the polar opposite of what the last 3 years of stats were. what do you do when this happens?

---

## 2020-07-22 13:40:04 - general channel

**D C**

That is very interesting. Personally I think IP really needs a exchange model but I suppose bookie punters will bet on anything at times

---

## 2020-07-22 13:39:40 - general channel

**Mo**

The TPD CEO mentions the model in his interview on the business of betting podcast: [https://m.soundcloud.com/businessofbetting/ep-107-ceo-of-total|https://m.soundcloud.com/businessofbetting/ep-107-ceo-of-total](https://m.soundcloud.com/businessofbetting/ep-107-ceo-of-total|https://m.soundcloud.com/businessofbetting/ep-107-ceo-of-total)

---

## 2020-07-22 13:36:07 - general channel

**Mo**

The model is based on machine learning of sectional times

---

## 2020-07-22 13:33:15 - general channel

**azevedo**

I noticed the TPD also offer an inplay price feed on their website. Like a bookie product I guess. Anyone used/seen that feed? Any comments on the quality of the model behind those prices?

---

## 2020-07-22 13:01:54 - general channel

**Michael**

If I were you I wouldn't quit for the day - if you're worried then maybe block Yarmouth and keep betting at Bath? These problems often sort themselves out after a couple of markets.

---

## 2020-07-21 11:50:09 - issues channel

**JC**

When working with the inplayservice endpoint in bflw, if I don't set `_lightweight_=True` for my trading instance, the JSON response returned triggers an InvalidResponse exception (I think due to single quotes being used for strings instead of double?). Not sure if I'm missing something here. Also when working with the scores API for tennis, `trading.scores.list_available_events()` returns an empty list. Not sure if this is because my key isn't authorised or whether there actually are no matches on the scores API atm lol.

---

## 2020-07-20 20:31:27 - general channel

**liam**

Yeah need to improve the readme on flumine, bflw is a wrapper for the API and flumine is a fully functioning trading framework which happens to use bflw 

---

## 2020-07-20 20:27:27 - general channel

**Twatter**

Hi All.. Stumbled upon the betfairlightweight library recently, and so just starting out trying to write my own Betfair bot. Slowly trawling through the history of these slack channels to pick up some info. Quick Q - I got an idea for a strategy that involves intra market trading across a horse races Win/EW/Place(s) markets. I'm confused as to whether I should be coding it with Flumine, or Betfairlightweight? What's the guide on choosing Flumine or just rely on betfairlight?

---

## 2020-07-20 18:24:29 - general channel

**liam**

Btw paper trading is now implemented so you can simulate trading against live markets, makes debugging matching a lot easier as you can use the betfair site 

---

## 2020-07-20 14:29:34 - general channel

**Oliver Varney**

[@U016535QCJ2](@U016535QCJ2) problem is if your simulating a hedge against a non adjusted entry trade then your numbers are way off. Also if you have a concept of min price you will accept in a strategy that also needs adjusting.

---

## 2020-07-20 14:18:41 - random channel

**Newbie99**

Just be a bit careful with this year's model, I had to send 2 back because of defective trackpad's and looking at you tube and other reviews it seems to be an issue with the 2020 XPS 15 (not sure if the whole line up uses the same trackpad). So personally based on that, I wouldn't get a 2020 XPS until they announce they've fixed that issue.

---

## 2020-07-17 14:30:03 - strategies channel

**Jono**

Hey everyone got pointed to here after problems with keepAlive functionality. I am wondering the exact request I should have in this function (taken from examples in the bf developer library) in order for my session to never time out:





------------------------------------------

def callApi(jsonrpc_req, appKey, sessionToken, initialHeaders):



url = "[https://api.betfair.com/exchange/betting/json-rpc/v1](https://api.betfair.com/exchange/betting/json-rpc/v1)"



initialHeaders = {'X-Application': appKey, 'X-Authentication': sessionToken, 'content-type': 'application/json'}



request = urllib.request.Request(url, jsonrpc_req. encode('utf-8'), initialHeaders)



response = urllib.request.urlopen(request)

jsonResponse = response.read()



return jsonResponse.decode('utf-8')



------------------------------------------



I have read the keep live documentation but unfortunately am very inexperienced with other programming languages other than python and was therefore wondering if there is a simple change I can make to the code above in order to keep my session live, or if there is a much more straightforward function that is applicable to my situation. Thank you for any help.

---

## 2020-07-17 09:59:41 - general channel

**sartux**

you're absolutely right :slightly_smiling_face:



can I ask you one last thing?

I am automating the generation of the daily report, which method should I call?



I tried with these 4 lines but I can't get the market result in economic terms



On every single game run between 20 and 30 bets and I just wanted to load the list of the day and then make an aggregate and add



get_account_statement gives me different information but not the outcome



```'idx','avgPrice','betSize','betType','betCategoryType','commissionRate','eventId','eventTypeId','fullMarketName','grossBetAmount','marketName','marketType','placedDate','selectionId','selectionName','handicap','startDate','transactionType','transactionId','winLose','deadHeatPriceDivisor','avgPriceRaw'```



`four_days_ago = (datetime.datetime.utcnow () - datetime.timedelta (days = 4)). strftime ("% Y-% m-% dT% TZ")`

`acct_statement_date_filter = betfairlightweight.filters.time_range (from_ = four_days_ago)`



`account_statement = trading.account.get_account_statement (item_date_range = acct_statement_date_filter)`



`class_data = [json.loads (account_statement.account_statement [i] .item_class_data ['unknownStatementItem'])`

     `for i in range (len (account_statement.account_statement))]`

---

## 2020-07-15 11:09:38 - strategies channel

**Unknown**

Here is a similar example of one of my own, note the massive difference in number of bets, not sure you can base anything on [@USDCJS1CK](@USDCJS1CK) strategy without more info on the odds/ev. All relative on stake size/odds but my example probably has a larger percentage drawdown but over a much larger sample, not sure I would base any decisions on PW's graph.

---

## 2020-07-15 10:30:21 - strategies channel

**mandelbot**

im dealing with the same lately, found a strategy that would do 1000x stake in a year but with a drawdown of up to -250x stake

---

## 2020-07-15 10:30:20 - strategies channel

**Mo**

There's no way I'd exclude a strategy just because of that graph.



If you want to work out the impact of luck on a strategy's returns use one of the Monte Carlo methods that have previously been discussed.



I do like to look at these plots when assessing a potential new strategy as it reveals aspects that are hidden by just looking at e.g. total return/ROI, such as how long and how bad are drawdown periods, and dependence on big wins.

---

## 2020-07-15 10:24:34 - strategies channel

**Lee**

Just been reading an old blog post from Peter Webb where he posted the following profit/loss graph. [https://www.betangel.com/blog_wp/wp-content/uploads/2013/07/26-07-2013-What-is-value.png](https://www.betangel.com/blog_wp/wp-content/uploads/2013/07/26-07-2013-What-is-value.png)

With the massive drawdown in the middle would this strategy seem to be profitable based on luck or can losses like this be normal?

I mainly ask because i've had graphs that look similar to this but i've canned them on the basis that the strategy might be based on luck and wouldn't work in the long term.

---

## 2020-07-14 09:06:22 - strategies channel

**Stefan**

[@U0143UVG294](@U0143UVG294) yes, I used this type of data when implementing chart visualization tool to my app. that second chart which appears on right side in my video. You can try to make simple trigger for that and test your strategy. For me it was just use case scenario to show any type of data in time series:



[http://bfexplorer.net/Community/BlogContent/530#Signal%20Value%20Trend%20Line%20-%20PriceTradedHistory.MyValues](http://bfexplorer.net/Community/BlogContent/530#Signal%20Value%20Trend%20Line%20-%20PriceTradedHistory.MyValues)

---

## 2020-07-12 10:03:38 - general channel

**Oliver Varney**

in BaseStrategy

---

## 2020-07-12 09:33:22 - general channel

**Oliver Varney**

Liam, might be incorrectly reading the code, but just looking at the flumine example on the github home/front page, I think you must have added market: Market as an additional param to cancel /update / place in BaseStrategy. the example passes in order in the first param position, which is now the market.

---

## 2020-07-10 10:58:55 - general channel

**Robert**

Hi all, I’m a software developer at a sports algo trading company which uses this slack group and the betfair library. We’re currently hiring and I thought this might be of interest to some of you.  Based in Cambridge, UK. You can find out more at [http://www.seamlessml.com|www.seamlessml.com](http://www.seamlessml.com|www.seamlessml.com) or email me at [mailto:robert@seamlessml.com|robert@seamlessml.com](mailto:robert@seamlessml.com|robert@seamlessml.com) if you have questions.

---

## 2020-07-08 20:18:51 - general channel

**PeterLe**

No I dont use strategyRef parameter, without getting too deep.. I have the option of creating many systems with each account (the gent who created this for me Ive known a long time now and he is a brilliant programmer c#). So for each account, say I have five strategies, the first maybe £2.00 stakes, the second £2.01, the third £2.02 etc...So its easy to see what's working and whats not.  Id strongly agree with Liam's sentence above - "...just play the numbers game".  Im here because I want to learn this for myself and Python seems easier than c#, plus there are many generous people on here keen to help, hopefully I can contribute more in the future

---

## 2020-07-08 20:05:48 - general channel

**birchy**

[@UQL0QDEKA](@UQL0QDEKA) was just thinking...you mentioned earlier that you use multiple accounts. I have 2 accounts, but only because I use one for testing and the other for my production bots. I don't have any issues with multiple bots placing bets on the same markets. It used to be beneficial to use one account as it boosted the commission discount, but of course they have the 2% package now. Do you not use the strategyRef parameter to identify bots?

---

## 2020-07-08 18:07:39 - general channel

**birchy**

[@UQL0QDEKA](@UQL0QDEKA) Interesting that you mentioned your main profits were in the period 2011-2013, because I experienced exactly the same thing! I was averaging £3K a month profit for about 15 months in 2011/2012 from a single £2 strategy that was basically placing Lay bets at silly prices on low liquidity markets. I did once lose around £600 in a space of 2 hours (at £2 a bet!) and it turned out that someone had worked out how to exploit my strategy on Aussie greyhound races at 4am when everyone else, including myself, was fast asleep. Soon patched that up and continued to profit for several months after, but then the bot slowly started to decline and I pulled the plug when my P&amp;L graph started to flat-line. Using a graph to plot the P&amp;L showed a definite change in the markets. Tried lots of fine-tuning, etc but never got back to that golden period. Betfair launched the Sportsbook in 2012, so I can only assume that the "mugs" I was profiting from were attracted by the Lucky 15's, 6-fold accumulators, etc.



Regarding the £2 thing, I've found that 5x £2 bets are more likely to get matched than one £10 bet. Doesn't make much sense because £10 is a tiny drop in the ocean, although it may just be a psychological thing and in fact £10 is £10, whether it be in one lump or 5 parts...

---

## 2020-07-08 12:43:53 - general channel

**liam**

It’s open to abstraction, you could handle this either in the trade itself .create_order (check others or raise error) or maybe in strategy.validate_order 

---

## 2020-07-08 11:08:26 - general channel

**Mo**

But nevertheless you could expect the logic of the strategy on the other side to react differently

---

## 2020-07-08 11:06:59 - general channel

**PeterLe**

Thanks Gents, Yes, Ive found that too [@U4H19D1D2](@U4H19D1D2), running the exact same strategy, same settings, can have different results at the end of the day (there is no clear pattern when you compare the betid’s against accounts). Just thinking out loud really; Im looking at the options available to me to make best use of the master/sub account set up. I guess that’s what keeps us all interested, because there is always something else to test :grinning:

---

## 2020-07-08 11:00:10 - general channel

**liam**

[@UQL0QDEKA](@UQL0QDEKA) you don't need to use different accounts just duplicate the strategy but with the same size stakes, even ms in differences in placing/cancelling orders is enough to limit the market impact of a strategy inplay

---

## 2020-07-07 20:52:34 - general channel

**liam**

Great, yeah readme can be improved on what it does and doesn’t do, I think the real selling point is being able to move from backtesting to live with no changes to your strategy (betfair are still giving 2020 q1 data away for free if you want to try it out) Classes can certainly help abstract away the low level stuff, I find reading code is the best way to find new ways of doing stuff (and sometimes how not to do it!) 

---

## 2020-07-07 20:03:32 - general channel

**birchy**

[@U4H19D1D2](@U4H19D1D2) I *thought* you did, but wasn't sure. I remember us all discussing betting shit on that crappy Lefora forum many years ago. I'm still admin of that site but only because I don't know how to abandon it. lol.

Nice work by the way, well impressed. In fact so impressed that I don'y know WTF I'm doing with it.

---

## 2020-07-05 18:08:49 - strategies channel

**D C**

I had not formally analysed it to that depth. It was something that was working nicely for me on the UK jumps racing earlier in the year before the racing suspension. I decided to give it a try on the US markets after looking at some inplay charts as it looked like it might work. It did but as soon as the UK racing was back it dropped like a stone. The only difference I noticed was lower volume and liquidity although I can't say for sure why. Could have been pure luck in the first place - a month is not a long time for testing a strategy.

---

## 2020-07-05 17:12:54 - strategies channel

**Lee**

Did your strategies require any changes or optimisations because of the market volume or the strategy had the fundamentals that would make profit regardless of volume

---

## 2020-07-05 12:01:01 - strategies channel

**Sandy Caskie**

So I have streamed horse racing data saved this and used this to build a predictive price model. My streamed data is not of a super high latency though. I will have to look in more detail the reason for this though it seems pretty accurate on a first glance. My question relates to historical data. I also built a predictive model using the free package but this was pretty useless with a frequency of per minute. For anyone else who has done something similar was the pro data particularly useful for building a predictive model?

---

## 2020-07-04 22:30:11 - general channel

**Michael**

Any type of back-testing will tend to exaggerate the edge that you will get on real bets because the strategies that look best from the back-test are also likely to be the ones that benefited from random variation in that data set. There are techniques to minimise that and more data always helps but you can never fully escape it. You may well have had better ideas that you discounted because they had an unlucky run in your back-test data but how would you ever know? If you're going to generate a strategy purely out of back testing then you need to make sure it has much more edge than you need to make a profit in order to cover that discrepancy.

---

## 2020-07-04 12:39:54 - general channel

**Michael**

Also - no one who knows a feckin thing posts a graph of their new strategy's winning run.

---

## 2020-07-04 12:38:41 - general channel

**Michael**

_"How many times do you see people showing charts that have run for many events with a nice upwards equity curve only to find out further down the line that it doesn't work after all."_ The reason for this is usually that the 'winning' run was some kind of back test and the downturn is when they start betting. It happens because of the way they generate their strategies. What people tend to do is trawl every permutation they can think of until they get something that looks like a win. If you do this for long enough you will inevitably find something that looks like a solid winning strategy when all you're really seeing is a random bit of variance. You find what you look for. What I suggest above about examining ones methodology would rid one of this delusion but who wants to hear it? In my experience good strategies win from the start and just keep winning or else peter out gradually. Unless something fundamental in the markets you're operating in changes they don't go bad all of a sudden. The best way to have confidence in your strategies is to have well founded confidence in yourself. If your last strategy was good then your next one has a good chance, and if it wasn't, well, don't be too confident.

---

## 2020-07-03 22:23:57 - general channel

**PeterLe**

Thanks Michael, Yes some of that does resonate with me. Ive been doing this successfully now of 14 years and Ive never used statistics to form a strategy. Ive always used small stakes (on a sensible theory) then test, hone and refine as I go along. What the MC simulation is good at is for confirmation. How many times do you see people showing charts that have run for many events with a nice upwards equity curve only to find out further down the line that it doesn't work after all.

---

## 2020-07-03 19:45:17 - general channel

**Michael**

I think people sometimes want to use statistical tests in situations when they're neither necessary nor helpful. Before you apply a test (especially one you don't really understand) I think you should stop and ask yourself: Will the outcome of this test make any difference to my future actions regarding this strategy? If you've made a profit after 1000 markets then you're going to keep going whatever the tests say and if you haven't then you're not going to keep going for much longer whatever the tests say. So what are the tests for? So that you can feel more confident? So that you can kid yourself into raising your stakes when you already know perfectly well that you shouldn't? If you're betting at normal odds then 1000 markets is usually plenty to get a good feeling of the efficacy of your strategy. Job done.

---

## 2020-07-03 19:33:43 - general channel

**Michael**

If I understand your situation correctly then you are trying to evaluate a semi-hypothetical strategy – in other words what would have happened if you had done things differently. If this is the case then rather than looking for statistical tests it might be be better to flip the problem around and evaluate your methodology for generating the revised strategy. Come up with a simple estimate of how likely your methodology was to produce a false result and take your confidence to be 1 – that. For example if you somehow filtered your past results until they showed a profit then your confidence in that result should be very low because your methodology was extremely likely to show a false result. The more different filters you tried the less likely it is that you've come to a representative result so you'd adjust accordingly. Likewise an incidental discovery should be treated with great scepticism. On the other hand if you understood the situation in some new way, had one new idea and an evaluation of that idea appeared to confirm it then you're on much better ground.

---

## 2020-07-03 18:41:39 - general channel

**PeterLe**

Ive been doing something similar this afternoon looking at the results of back bets for a revision of a strategy

Id be interested in getting the opinion of someone who knows more about stats than I do.

If you were to compare your actual results across a number of bets (in my case there were 739 back bets, lets call this season 1) and then run it in a monte carlo simulation for a 1000 seasons (uses a random generated number and compares that against the IP of the odds matched)

Isnt this a good way of determining if you are generally getting obtaining value?

In my case, my 'season' was better than the Monte Carlo results 93% of the time which is a very good indication of value and might fit what lee is trying to achieve?

(PS I cant take the credit for this method as it was introduced to me by JamesT but i use it a lot now, Lee happy to share my spreadsheet with you if it would help you? You would need a decent sample size though)

---

## 2020-07-03 10:16:58 - general channel

**Eswyn**

Absolutely, but the pre-race strategy I want to use is just for the 24 hours before the race starts, hence why I'm trying to filter the stream

---

## 2020-07-02 18:05:37 - general channel

**liam**

There are some limitations but you can restart and the live order will be pulled into the strategy on restart 

---

## 2020-07-02 16:54:19 - general channel

**Oliver Varney**

I guess the use case is how do I add a new strategy without stopping the process and restarting it? What would happen if I had positions against a strategy? I havent checked the code but would these reload?

---

## 2020-06-30 19:20:03 - general channel

**liam**

Big [https://forum.developer.betfair.com/filedata/fetch?id=32354|changes](https://forum.developer.betfair.com/filedata/fetch?id=32354|changes) in transaction charges 



```Transaction Charge Changes

Over the years, the Exchange has processed an increasing number of transactions at an ever-increasing cost to infrastructure and stability.

Therefore, from 1st September 2020, Betfair will be changing the thresholds of the Transaction Charge. The changes are as follows:

• The new limit of “free” transactions will be set at 5,000 transactions per hour. o A “transaction” shall include all bets placed and all failed transactions.

• Every transaction that exceeds the limit will incur a cost of £0.002 (a fifth of a penny). o This cost will be offset by a user’s commission generated.

• There will be no exemptions from this charge.

We have modelled the new charge to disincentivise wasteful transactional behaviour and promote platform stability on a level playing field. It is possible to trade multiple events and markets without ever incurring any of these charges.

Your account manager will be in touch if you would have incurred these charges in the past, giving you an opportunity to update trading strategies and fix bugs before the charge goes live on 1st September.```

---

## 2020-06-30 13:07:23 - general channel

**Jono**

Inside the racecard example on line 9 &amp; 10 where the trading instance is created it says that "don't need username/password" so was under the impression this was an example of connection to live data without credentials. As for why, i want to share some of my scripts with a friend and it would be convenient if there was a way of me sending him logic that would run without requiring inputs from them

---

## 2020-06-29 10:54:22 - issues channel

**liam**

well you could just duplicate the strategy with a different stream per

---

## 2020-06-29 10:46:45 - issues channel

**Andrey Yunoshev**

```        market_filter=streaming_market_filter(

            event_type_ids=["4339"],

            market_types=["WIN"],

            bsp_market=True,

            turn_in_play_enabled=False,

            # country_codes=["AU"],

            # country_codes=["GB"],

            # betting_types=["ODDS"],

            country_codes=["AU", "GB", "US"],

        ),```

---

## 2020-06-28 20:12:44 - general channel

**sartux**

```td = trading.betting.list_current_orders(lightweight=True)



for i,dd in td['currentOrders']:

    print(dd['marketId'])```

Where is the error?

ValueError: too many values to unpack (expected 2)

---

## 2020-06-28 15:38:12 - general channel

**sartux**

In documentation example, I am unable to transform the _data into an array and therefore I cannot read the odds and the size



```trading.betting.list_current_orders(customer_strategy_refs=['back_the_fav']).__dict__

Out[311]:

{'_data': {'currentOrders': [{'averagePriceMatched': 0.0,

    'betId': '142384852665',

    'bspLiability': 0.0,

    'customerStrategyRef': 'back_the_fav',

    'handicap': 0.0,

    'marketId': '1.150038686',

    'orderType': 'LIMIT',

    'persistenceType': 'LAPSE',

    'placedDate': '2018-10-26T00:46:46.000Z',

    'priceSize': {'price': 7.0, 'size': 5.0},

    'regulatorCode': 'MALTA LOTTERIES AND GAMBLING AUTHORITY',

    'selectionId': 21283271,

    'side': 'BACK',

    'sizeCancelled': 0.0,

    'sizeLapsed': 0.0,

    'sizeMatched': 0.0,

    'sizeRemaining': 5.0,

    'sizeVoided': 0.0,

    'status': 'EXECUTABLE'}],

  'moreAvailable': False},

 '_datetime_created': datetime.datetime(2018, 10, 26, 2, 14, 56, 84036),

 '_datetime_updated': datetime.datetime(2018, 10, 26, 2, 14, 56, 84036),

 'elapsed_time': 1.327456,

 'more_available': False,

 'orders': [&lt;betfairlightweight.resources.bettingresources.CurrentOrder at 0x23e0e7acd30&gt;],

 'publish_time': None,

 'streaming_unique_id': None,

 'streaming_update': None}```



---

## 2020-06-28 15:14:23 - general channel

**sartux**

I'm wasting time on something that will definitely be a banal.

in part with

trading.betting.list_current_orders () .__ dict__

I get the dictionary of all open orders.



my intention would be to take the size and initial odds to calculate the exit.



therefore in fact a for loop with all the orders that, when it arrives at the market (example 1.XXXXXXX), takes the data calculates the size and executes the opposite bet.



the problem is very simple, I cannot cycle the elements obtained from trading.betting.list_current_orders () .__ dict__  using them as an array

---

## 2020-06-28 14:01:59 - issues channel

**Andrey Yunoshev**

```AU

PLACE ORDER BACK

INFO:flumine.order.order:Order status update: Pending

PLACE ORDER LAY

INFO:flumine.order.order:Order status update: Pending

INFO:flumine.markets.blotter:1 order packages created

	BACK/PENDING 0.0 price, 0.0 size

	LAY/PENDING 0.0 price, 0.0 size

INFO:flumine.execution.betfairexecution:execute_place

INFO:flumine.order.trade:Trade status update: Pending

INFO:flumine.execution.baseexecution:Order Place: SUCCESS

INFO:flumine.order.order:Order status update: Executable

INFO:flumine.order.trade:Trade status update: Live

INFO:flumine.order.trade:Trade status update: Pending

INFO:flumine.execution.baseexecution:Order Place: SUCCESS

INFO:flumine.order.order:Order status update: Executable

INFO:flumine.order.trade:Trade status update: Live

INFO:flumine.order.order:Order status update: Execution complete

INFO:flumine.order.trade:Trade status update: Complete

REPLACE PRICE, FROM 4.0 TO 3.7

INFO:flumine.order.order:Order status update: Replacing

	BACK/REPLACING 0.0 price, 0.0 size

	LAY/EXECUTION_COMPLETE 3.7 price, 2.16 size

INFO:flumine.markets.blotter:1 order packages created

INFO:flumine.execution.betfairexecution:execute_replace

INFO:flumine.order.trade:Trade status update: Pending

INFO:flumine.execution.baseexecution:Order Cancel: SUCCESS

INFO:flumine.order.order:Order status update: Execution complete

INFO:flumine.execution.baseexecution:Order Replace: SUCCESS

INFO:flumine.order.order:Order status update: Pending

INFO:flumine.order.order:Order status update: Executable

INFO:flumine.order.trade:Trade status update: Live

INFO:flumine.streams.orderstream:Stopped OrderStream 1001

INFO:flumine.streams.marketstream:Stopped MarketStream 2001

INFO:flumine.streams.marketstream:Stopped output_thread (MarketStream 2001)

INFO:flumine.execution.baseexecution:Shutting down Execution (SimulatedExecution)

INFO:flumine.execution.baseexecution:Shutting down Execution (BetfairExecution)

INFO:flumine.streams.orderstream:Stopped output_thread (OrderStream 1001)

INFO:flumine.baseflumine:Exiting flumine

Traceback (most recent call last):

  File "./pydogs/greyscout2live.py", line 727, in &lt;module&gt;

    framework.run()

  File "/usr/local/lib/python3.7/site-packages/flumine/flumine.py", line 32, in run

    self._process_current_orders(event)

  File "/usr/local/lib/python3.7/site-packages/flumine/baseflumine.py", line 183, in _process_current_orders

    strategy_orders = market.blotter.strategy_orders(strategy)

  File "/usr/local/lib/python3.7/site-packages/flumine/markets/blotter.py", line 27, in strategy_orders

    return [order for order in self if order.trade.strategy == strategy]

  File "/usr/local/lib/python3.7/site-packages/flumine/markets/blotter.py", line 27, in &lt;listcomp&gt;

    return [order for order in self if order.trade.strategy == strategy]

RuntimeError: dictionary changed size during iteration```

---

## 2020-06-28 13:01:53 - general channel

**fjt1973**

So this is my handler, very basic to return the balalce of my account.



def lambda_handler(event, context):

    # TODO implement

    trading = betfairlightweight.APIClient(username=my_username,

                                       password=my_password,

                                       app_key=my_app_key,

                                       certs=certs_path)



    trading.login()

    account_funds = trading.account.get_account_funds()

    balance = account_funds.available_to_bet_balance

    return balance

    #return {

    #    'statusCode': 200,

    #    'body': json.dumps('Hello from Lambda!')

    #}



And this is the execution results



Response:

{

  "errorMessage": "None \nParams: None \nException: join() argument must be str or bytes, not 'tuple'",

  "errorType": "APIError",

  "stackTrace": [

    "  File \"/var/task/lambda_function.py\", line 33, in lambda_handler\n    trading.login()\n",

    "  File \"/opt/python/lib/python3.7/site-packages/betfairlightweight/endpoints/login.py\", line 31, in __call__\n    self.url, session=session\n",

    "  File \"/opt/python/lib/python3.7/site-packages/betfairlightweight/endpoints/login.py\", line 53, in request\n    raise APIError(None, exception=e)\n"

  ]

}



Request ID:

"f4b6780c-fb3a-485f-881d-3fc75f1cfddd"



Function Logs:

START RequestId: f4b6780c-fb3a-485f-881d-3fc75f1cfddd Version: $LATEST

[ERROR] APIError: None

Params: None

Exception: join() argument must be str or bytes, not 'tuple'

Traceback (most recent call last):

  File "/var/task/lambda_function.py", line 33, in lambda_handler

    trading.login()

  File "/opt/python/lib/python3.7/site-packages/betfairlightweight/endpoints/login.py", line 31, in __call__

    self.url, session=session

  File "/opt/python/lib/python3.7/site-packages/betfairlightweight/endpoints/login.py", line 53, in request

    raise APIError(None, exception=e)

END RequestId: f4b6780c-fb3a-485f-881d-3fc75f1cfddd

REPORT RequestId: f4b6780c-fb3a-485f-881d-3fc75f1cfddd	Duration: 19.17 ms	Billed Duration: 100 ms	Memory Size: 128 MB	Max Memory Used: 85 MB	Init Duration: 782.62 ms

---

## 2020-06-28 11:50:30 - general channel

**fjt1973**

Exception: join() argument must be str or bytes, not 'tuple'

Traceback (most recent call last):

  File "/var/task/lambda_function.py", line 37, in lambda_handler

    trading.login()

  File "/opt/python/lib/python3.7/site-packages/betfairlightweight/endpoints/login.py", line 31, in __call__

    self.url, session=session

  File "/opt/python/lib/python3.7/site-packages/betfairlightweight/endpoints/login.py", line 53, in request

    raise APIError(None, exception=e)

---

## 2020-06-27 17:12:51 - issues channel

**Lee**

is there a reason why i sometimes get the market catalogue response? my understanding was i'd get an error response if i was requesting too much data or calling too quickly. all 3 requests are the same

```&gt;&gt;&gt; trading.betting.list_market_catalogue(

    filter=filters.market_filter(

        event_type_ids=[7],

        market_countries=["GB"],

        market_type_codes=["WIN"],

        market_ids=["1.171017510"],

    ),

    market_projection=["RUNNER_METADATA"],

)

[]

&gt;&gt;&gt; trading.betting.list_market_catalogue(

    filter=filters.market_filter(

        event_type_ids=[7],

        market_countries=["GB"],

        market_type_codes=["WIN"],

        market_ids=["1.171017510"],

    ),

    market_projection=["RUNNER_METADATA"],

)

[&lt;MarketCatalogue&gt;]

&gt;&gt;&gt; trading.betting.list_market_catalogue(

    filter=filters.market_filter(

        event_type_ids=[7],

        market_countries=["GB"],

        market_type_codes=["WIN"],

        market_ids=["1.171017510"],

    ),

    market_projection=["RUNNER_METADATA"],

)

[]```

---

## 2020-06-25 18:40:08 - strategies channel

**Stefan**

[@U7E6NE1DM](@U7E6NE1DM), any progress in testing forecast strategy in any form for horse racing?

---

## 2020-06-25 17:31:21 - general channel

**Stefan**

@[https://app.slack.com/team/UT2P36CLW|MrBIN](https://app.slack.com/team/UT2P36CLW|MrBIN), you have got nearPrice and farPrice, estimations of SP prices. The first one includes any bets placed, the last one only SP bets. What kind of strategy do you want to execute?

---

## 2020-06-24 07:02:35 - general channel

**Mo**

Yeah in the cold light of morning I could see how if you have some price driven model you might want to do something with ticks but maybe it's possible for you to do something with probability instead which can then be mapped to either price ladder

---

## 2020-06-23 22:29:34 - general channel

**Mo**

Not sure why you would need to do anything special in your model

---

## 2020-06-23 22:10:38 - general channel

**Johnny**

Hi guys, very basic question here.  I see the Asian Handicap (football) markets have arbitrary pricing, i.e. not aligned to the normal Betfair tick prices.  Do any other markets have thi sas well?  How do you deal with the many additional possibilities in your models?

---

## 2020-06-22 08:20:25 - issues channel

**Mo**

The timeout will help, whether it's enough will depend on your level of betting activity

---

## 2020-06-22 08:20:18 - issues channel

**JK**

i tried doing `client.betting.read_timeout = 45` where client is an `APIClient` object, but that returned

```Error: {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie1-ang07b-prd-05191058-003bfd', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}} Full Response: {'jsonrpc': '2.0', 'error': {'code': -32099, 'message': 'ANGX-0010', 'data': {'APINGException': {'requestUUID': 'ie1-ang07b-prd-05191058-003d', 'errorCode': 'TIMEOUT_ERROR', 'errorDetails': ''}, 'exceptionname': 'APINGException'}}, 'id': 1}```

---

## 2020-06-22 08:18:58 - issues channel

**liam**

Can you try bumping the timeout



```from betfairlightweight.endpoints.betting import Betting



Betting.read_timeout = 32```

---

## 2020-06-22 08:14:26 - issues channel

**JK**

```Traceback (most recent call last):

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/connectionpool.py", line 387, in _make_request

    six.raise_from(e, None)

  File "&lt;string&gt;", line 2, in raise_from

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/connectionpool.py", line 383, in _make_request

    httplib_response = conn.getresponse()

  File "/usr/lib/python3.6/http/client.py", line 1356, in getresponse

    response.begin()

  File "/usr/lib/python3.6/http/client.py", line 307, in begin

    version, status, reason = self._read_status()

  File "/usr/lib/python3.6/http/client.py", line 268, in _read_status

    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")

  File "/usr/lib/python3.6/socket.py", line 586, in readinto

    return self._sock.recv_into(b)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/contrib/pyopenssl.py", line 317, in recv_into

    raise timeout('The read operation timed out')

socket.timeout: The read operation timed out



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "/home/ubuntu/.local/lib/python3.6/site-packages/requests/adapters.py", line 449, in send

    timeout=timeout

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/connectionpool.py", line 641, in urlopen

    _stacktrace=sys.exc_info()[2])

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/util/retry.py", line 368, in increment

    raise six.reraise(type(error), error, _stacktrace)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/packages/six.py", line 686, in reraise

    raise value

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/connectionpool.py", line 603, in urlopen

    chunked=chunked)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/connectionpool.py", line 389, in _make_request

    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/urllib3/connectionpool.py", line 307, in _raise_timeout

    raise ReadTimeoutError(self, url, "Read timed out. (read timeout=%s)" % timeout_value)

urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=16)



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 43, in request

    timeout=(self.connect_timeout, self.read_timeout)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/requests/api.py", line 116, in post

    return request('post', url, data=data, json=json, **kwargs)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/requests/api.py", line 60, in request

    return session.request(method=method, url=url, **kwargs)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/requests/sessions.py", line 533, in request

    resp = self.send(prep, **send_kwargs)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/requests/sessions.py", line 646, in send

    r = adapter.send(request, **kwargs)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/requests/adapters.py", line 529, in send

    raise ReadTimeout(e, request=request)

requests.exceptions.ReadTimeout: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=16)



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "get_new_bets_minutely.py", line 159, in &lt;module&gt;

    main1()

  File "get_new_bets_minutely.py", line 48, in main1

    include_item_description = "true"

  File "/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/betting.py", line 288, in list_cleared_orders

    (response, elapsed_time) = self.request(method, params, session)

  File "/home/ubuntu/.local/lib/python3.6/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 48, in request

    raise APIError(None, method, params, e)

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders 

Params: {'recordCount': 500, 'fromRecord': 1500, 'includeItemDescription': 'true', 'settledDateRange': {'to': None, 'from': None}, 'betStatus': 'SETTLED'} 

Exception: HTTPSConnectionPool(host='[http://api.betfair.com|api.betfair.com](http://api.betfair.com|api.betfair.com)', port=443): Read timed out. (read timeout=16)```

---

## 2020-06-21 12:27:22 - general channel

**Stefan**

[@UFTBRB3F1](@UFTBRB3F1) just google text from such strategy:



I want to back the second horse to trade below 2 and if the selection should drift I would want to lay the same selection say &gt;16.

*

In a similar vein can you please tell me how to back the favourite at Betfair SP. I am having problems when the favourite changes late in betting.



Of course we developers can do anything with api, and do so, but common people come with such strategies.

---

## 2020-06-21 10:44:40 - general channel

**Stefan**

[@UT2P36CLW](@UT2P36CLW) It is more about different strategies people try to execute using trading software, not all of them offer simple way to place sp bet in automation. SP is calculated from back/lay offers of already placed SP bets, so you cannot estimate it exactly, well, yes betfair api offers estimates of those prices through api, but as the moment of race turning in-play is not accurate, even race status api is plus minus 2-3 seconds behind, and not all races starts from starting stalls.



So if you read on forum, that people try to place bets at SP, it is not actually they place SP bets, but try to place a bet as soon as possible after race start, and as close as possible to sp price.

---

## 2020-06-21 07:56:03 - general channel

**liam**

You can however do `market.replace_order(order, new_price)` which is the same as can be seen [https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L115|here](https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L115|here)

---

## 2020-06-20 18:17:03 - general channel

**gprokisch**

Sorry man.. For the silly question. I'm new to this betting world. This API still confusing me a bit.

---

## 2020-06-20 14:18:51 - general channel

**Andrey Yunoshev**

```REPLACE PRICE, FROM 9.0 TO 8.6

{'bet_id': '202759245511',

 'customer_order_ref': 'da32eac47a66a-138119515919016440',

 'handicap': 0,

 'id': '138119515919016440',

 'info': {'average_price_matched': 0.0,

          'side': 'BACK',

          'size_cancelled': 0.0,

          'size_lapsed': 0.0,

          'size_matched': 0.0,

          'size_remaining': 2,

          'size_voided': 0.0},

 'market_id': '1.170903586',

 'order_type': {'bet_target_size': None,

                'bet_target_type': None,

                'min_fill_size': None,

                'order_type': 'Limit',

                'persistence_type': 'LAPSE',

                'price': 9.0,

                'size': 2,

                'time_in_force': None},

 'selection_id': 28741430,

 'status': 'Executable',

 'status_log': 'Pending, Executable',

 'trade': {'id': UUID('cae6e176-b2f7-11ea-8807-d0034bcc9d7d'),

           'market_notes': '8.2,8.6,9',

           'notes': '8.6,8.2,9.0,Henlow,2020-06-20 13:17:00,Layton Jim,4',

           'orders': ['138119515919016440'],

           'status': &lt;TradeStatus.LIVE: 'Live'&gt;,

           'strategy': &lt;__main__.LiveStrategy object at 0x10ffbf4d0&gt;}}

INFO:flumine.order.order:Order status update: Replacing```

---

## 2020-06-19 18:07:45 - strategies channel

**Stefan**

It was not so couple years back when I first heard about timeform api. If you think there is some value in forecast prices then just setup simple bot strategy and run it for couple days to see some results.

---

## 2020-06-19 08:15:32 - strategies channel

**Stefan**

@[https://app.slack.com/team/U013Z24LD0U|SrFabio](https://app.slack.com/team/U013Z24LD0U|SrFabio) of course betfair will not optimize, actually think clearly, why would they avoid additional fees on such bets, it is betfair business model to earn on winning bet fees, really just use common sense.

---

## 2020-06-19 08:08:11 - strategies channel

**SrFabio**

[@U013MLED3V1](@U013MLED3V1) That's a very good point, I don't think even the betfair cashout does that optimization (for the correct score example) and it's certainly way too much work for me to do it at this point and feels beyond the scope of the app. What I'll do is simply remove the individual selection cashouts that would make the overall market PL worst, and still thinking about the option of not using the best price, but the 3rd best price for the calculations as a way to avoid orders not being matched (since they will be matched at the best price available anyway)

---

## 2020-06-18 17:14:21 - strategies channel

**Stefan**

[@U0155J92A7Q](@U0155J92A7Q) Really it does not matter for how many selections you are closing bet position. Have a look at here on app I use for manual trading: [https://bit.ly/3fzrNm6](https://bit.ly/3fzrNm6) and of course you can use dutching as well. You can take it as inspiration, or just reverse engineer app's algorithms. [@U013Z24LD0U](@U013Z24LD0U), yes when you trade in-play where odds moves very rapidly, there is need to recalculate closing bets and update them again, till all bets are matched, or level profit is gained on all selections, therefor we call such short programs bots, they do simple work, and can be reused in more complicated strategy. For instance in football correct score market it makes no sense to close bet position on when opened on already unrealistic scores, so you need live score for the match and feed close market bet position just by selections with possible score lines...

---

## 2020-06-18 05:26:02 - general channel

**gprokisch**

Hi guys, I had deployed a script using Google cloud but I'm getting this error [https://stackoverflow.com/questions/25817167/betfair-api-betting-restricted-location-when-logging-in-from-google-app-engine|BETTING_RESTRICTED_LOCATION](https://stackoverflow.com/questions/25817167/betfair-api-betting-restricted-location-when-logging-in-from-google-app-engine|BETTING_RESTRICTED_LOCATION) cause google ip address, in my local computer it's works fine.

---

## 2020-06-17 20:55:12 - random channel

**mandelbot**

I am learning to build models so I figure it might come in handy in the future. Would be nice to have a nice cache. I already have this data for a few years back.

---

## 2020-06-15 20:42:20 - random channel

**JonJonJon**

A user would typically receive orders when backtest.py calls strategy.process_orders here:



```for strategy in self.strategies:

    strategy_orders = blotter.strategy_orders(strategy)

    strategy.process_orders(market, strategy_orders)```

My code change does not effect the contents of strategy_orders.



It just changes what gets sent to process.process_current_order:



```for bet_id in potentially_incomplete_order_ids:

    process.process_current_order(blotter[bet_id])```

From my understanding of the code, the orders that it omits won't get affected by process_current_order. However, I am not 100% sure.

---

## 2020-06-15 20:28:44 - random channel

**JonJonJon**

The backtest is run on the example I added to flumine. So it is just a modified version of your LowestLayer strategy, but runs PE, and therefore has a lot of cancelled orders in the blotter. Such a profile would be realistic for someone quoting/changing lots of prices. Such as someone who quoted limit orders at the bollinger bands

---

## 2020-06-15 14:03:28 - issues channel

**liam**

but are you running separate python processes? Or just adding another strategy with the different market filter?

---

## 2020-06-15 09:23:47 - strategies channel

**liam**

Depends on the strategy, I can normally tell what the commission will be depending on the strategy type and it can get complicated when you factor in PC

---

## 2020-06-15 09:08:18 - strategies channel

**Remi**

[@U0155J92A7Q](@U0155J92A7Q), you could create a small, separate lib which takes the bflw trading object and does the cash out, if it doesn’t become part of bflw. Or some other code separate from bflw

---

## 2020-06-14 19:39:33 - issues channel

**Rich**

Yes, I've been pickling my ML models to disk in another project i'm playing with.

---

## 2020-06-14 19:38:44 - issues channel

**JonJonJon**

For example, I used to work in a quant team where the models took 6 hours to run. So they would start the model at the beginning of the day. Do something else. And then when they wanted to analyse the results later, they could just load them from disk/database.

---

## 2020-06-14 17:43:10 - random channel

**Michael**

The nearest I've come to resolving the dilemma is to speak plainly about it to people who ask, tell them the truth and avoid euphemisms like all the _'investment'_ terminology, you know: _'trading'_ all of that. We know that the great majority of those who try this game will fail and that includes people reading these groups. I'd like them to fail as gently as possible and not to get sucked in to a world of self delusion.  I worry that it might be easier for people to be blind to a gambling problem if the stuff that surrounds it looks less like the stereotype image of a gambler. Graphs, machine learning, code - all sensible stuff for clever people, it can blind you to the reality that you're wasting your money and your time.

---

## 2020-06-14 09:48:57 - issues channel

**Peter**

`from unittest.mock import patch`

`from concurrent import futures`

`import os`

`import time`

`import logging`

`import multiprocessing`



`from pythonjsonlogger import jsonlogger`



`import pandas as pd`

`import smart_open`



`from flumine import FlumineBacktest, clients`

`from strategies.lowestlayer import LowestLayer`





`logger = logging.getLogger()`



`custom_format = "%(asctime) %(levelname) %(message)"`

`log_handler = logging.StreamHandler()`

`formatter = jsonlogger.JsonFormatter(custom_format)`

`formatter.converter = time.gmtime`

`log_handler.setFormatter(formatter)`

`logger.addHandler(log_handler)`

`logger.setLevel([http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))`





`def run_backtest(market):`



    `client = clients.BacktestClient()`

    `framework = FlumineBacktest(client=client)`



    `strategy = LowestLayer(`

        `market_filter={"markets": [market]},`

        `max_order_exposure=1000,`

        `max_selection_exposure=10,`

        `context={"stake": 2},`

    `)`

    `framework.add_strategy(strategy)`



    `with patch("builtins.open", smart_open.open):`

        `framework.run()`



    `market = next(iter(framework.markets))`



    `data = []`

    `for order in market.blotter:`

        `datum = [`

            `order.market_id,`

            `order.selection_id,`

            `order.responses.date_time_placed,`

            `order.status,`

            `order.order_type.price,`

            `order.average_price_matched,`

            `order.size_matched,`

            `order.simulated.profit,`

        `]`

        `data.append(datum)`



    `return pd.DataFrame(`

        `data,`

        `columns = ['market_id', 'selection_id', 'time_placed', 'status', 'price', 'average_price_matched', 'size_matched', 'simulated_profit']`

    `)`



`data_folder = os.path.expanduser('~/data/betfair/test')`

`markets = []`

`_markets = os.listdir(data_folder)`

`_markets = [x for x in _markets if x.endswith('.zip')]`

`_markets = [os.path.join(data_folder, x) for x in _markets]`

`markets.extend(_markets)`



`multiprocessing.set_start_method('fork')`



`print('Running strategy across %i markets' % len(markets))`

`with futures.ProcessPoolExecutor(max_workers=24) as pool:`

    `all_futures = [`

        `pool.submit(`

            `run_backtest,`

            `market=market`

        `)`

        `for market in markets`

    `]`



`all_dfs = []`

`for i, future in enumerate([http://futures.as|futures.as](http://futures.as|futures.as)_completed(all_futures)):`

    `print('Future %i of %i completed' % (i+1, len(all_futures)))`

    `# all_dfs.append(future.result())`

    `all_dfs.append(future.result())`



`df = pd.concat(all_dfs)`

`print(df)`



`print(df.groupby('market_id')['simulated_profit'].sum().sum())`

---

## 2020-06-13 18:17:23 - general channel

**Sandy Caskie**

I am now moving over to the blw. I have set up my certificate key as outlined here [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Certificate+Generation+With+XCA](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Certificate+Generation+With+XCA).



I have uploaded a .pem file to *Automated Betting Program Access* on the Betfair security page.



I then use the following code to access my account using blw:



```# Change this certs path to wherever you're storing your certificates

certs_path = r'/Users/Sandy/Desktop/CodingLightWeight/TestApp1.pem'



# Change these login details to your own

my_username = "XXXXX"

my_password = "XXXXX"

my_app_key = "XXXXX"



trading = betfairlightweight.APIClient(username=my_username,

                                       password=my_password,

                                       app_key=my_app_key,

                                       certs=certs_path)



trading.login()```

The path is to the .pem file I created. Though I get the following error:



```APIError: None 

Params: None 

Exception: Certificate folder not found in /Users/Sandy/Desktop/CodingLightWeight/TestApp1.pem```

I appear to be missing something due to the above error. Can anyone help?

---

## 2020-06-13 08:39:11 - issues channel

**liam**

Np, exactly what it’s for, I will look to cleanup that strategy and improve the docs 

---

## 2020-06-12 21:38:54 - random channel

**James T**

I agree with everything you say and at the same time I’m sort of consciously hypocritical about it. 



I think I’m slightly biased though, because I fall into that small category of people who have been successful having been inspired by other people, whether they were/are real or not. If I weren’t inspired them I don’t think I’d have got into sports betting and won as much as I have. 



I also personally feel that what I/we do as winning professionals is a bit of a grey area in itself. We essentially win money from people stupid enough to bet against us. Perhaps they gain some entertainment value, but essentially they are sold the idea of winning, but they won’t in the long run. At the same time I continue to do it for a living. So even though I feel that I want to cast judgement on others doing possibly questionable things like selling courses, I personally don’t feel like I’m in a position to do so. 

---

## 2020-06-12 21:37:15 - issues channel

**Rich**

Yes, running from a Jupyter notebook. no name=='main', and have replaced the root folder path to be relevant to where my folder is (and just put the ExampleStrategy in)

---

## 2020-06-12 20:06:21 - random channel

**JonJonJon**

I've been experimenting with tracking completed trades in my personal strategy code, and therefore being able to quickly find executable trades.

---

## 2020-06-12 17:32:56 - random channel

**James T**

In a way, us replying to threads on a “strategy” channel is effectively “training” competitors. I’m sure there’s info on there people would have paid for. We choose not to charge for it, but I don’t think whether we do or don’t reflects on whether we are really profitable or not. Maybe we’re just more generous? :stuck_out_tongue_winking_eye: But again, maybe he does have a legitimate reason. 



Anyway, I stay open minded about what people can do in sports betting. I wouldn’t have believed myself if I told myself 10 years ago what I’d be able to do now. 

---

## 2020-06-12 14:37:51 - issues channel

**Mo**

Example to read bz2 files directly using `smart_open` package:





```import smart_open

from unittest.mock import patch



...



stream = trading.streaming.create_historical_generator_stream(

    directory=path,

    listener=listener

)



with patch("builtins.open", smart_open.open):

    g = stream.get_generator()

    for market_books in g():

        ...```



---

## 2020-06-12 14:34:56 - issues channel

**Newbie99**

Not sure if this will help you (its what I use for processing the flumine data, so you'll need to add in another line for the unzipping, but allows you to process multiple folders):



```root_folder = 'xyz'

completed_folder = 'xyz'

folders = os.listdir(root_folder)

market_list = []

for folder in folders:

    folder = os.path.join(root_folder, folder)

    folder_path = os.listdir(folder)

    market_file_list = [market_file for market_file in folder_path if not market_file.endswith('.zip')]

    file_dict = [{'full_path': os.path.join(folder, x), 'market_id': x} for x in market_file_list]

    market_list.extend(file_dict)



for market in market_list:

    file_path = market['full_path']

    file_name = market['market_id']



    # create historical stream (update directory to your file location)

    stream = trading.streaming.create_historical_generator_stream(

        directory=file_path, listener=listener,

    )



    # create generator

    gen = stream.get_generator()



    # Creates a list of market_ids within the generator

    market_ids = [market_book.market_id for market_books in gen() for market_book in market_books]



    # Creates a list of market_books within the generator

    market_books = [market_book for market_books in gen() for market_book in market_books]```



---

## 2020-06-12 14:19:18 - strategies channel

**Michael**

[@U4H19D1D2](@U4H19D1D2) What I mean is: You model a horse as having 10% chance of winning but you match it at 50. Under your definitions the 'edge' in your bet is 400% (which I would call your expected value) - so what's your name for the 8% that I would call 'edge'?

---

## 2020-06-12 14:09:47 - strategies channel

**Michael**

[@U4H19D1D2](@U4H19D1D2) So now I'm curious - what term do you use for the difference between implied and modelled probabilities?

---

## 2020-06-12 12:14:16 - strategies channel

**Dave**

[@UUCD6P13J](@UUCD6P13J) I won't lie, it takes a lot of effort to make a model that makes any reasonable predictions (reasonable being anything better than random). I suggest arming yourself with various statistical test that can give you confidence that your model actually makes sense (stuff like precision-recall, Area under the ROC curve, etc etc.). Good luck!

---

## 2020-06-12 11:39:38 - strategies channel

**Dave**

[@UGV299K6H](@UGV299K6H) - indeed, you pretty much hit the nail on the head there. If you want to be putting through decent volume then you most definitely need to look at market impact. The only optimization I've made is to bet over a longer time period rather than go in with a large swipe.

---

## 2020-06-12 11:38:26 - strategies channel

**Lee**

Is the model purely based on the current state of events? (no historic data)

---

## 2020-06-12 11:38:16 - strategies channel

**Dave**

[@U01093Z1KF0](@U01093Z1KF0) - if I were to quantify I'd say 50% of my bets only see value of around 10% of the forecast probability, i.e. market says an event is 60% likely and my models say 66%.

---

## 2020-06-12 11:13:42 - strategies channel

**Dave**

[@UUCD6P13J](@UUCD6P13J) - correct, my logic is as follows: take current state of the event (could be football match, race) -&gt; encode to machine understandable values (aka features) -&gt; get the model to forecast an outcome -&gt; convert the forecast probability to a price -&gt; take in the market if there is value. And no I never green up, greening up doesn't make sense in 99% of situations IMO.

---

## 2020-06-12 11:04:29 - strategies channel

**Dave**

To offer some contrast, my strategies work primarily by using models to generate prices based on in play activity, and just take if the the diff between market prices and mine is &gt;=x% (without paying attention to market dynamics)

---

## 2020-06-11 16:44:15 - issues channel

**Unknown**

```{

    "asctime": "2020-06-11 12:17:19,379",

    "levelname": "ERROR",

    "message": "_get_cleared_markets error",

    "filename": "accounthandler.py",

    "funcName": "_get_cleared_markets",

    "module": "accounthandler",

    "process": 6,

    "threadName": "account_handler",

    "exc_info": "Traceback (most recent call last):\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/connectionpool.py\", line 597, in urlopen\n    httplib_response = self._make_request(conn, method, url,\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/connectionpool.py\", line 386, in _make_request\n    six.raise_from(e, None)\n  File \"[string](string)\", line 2, in raise_from\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/connectionpool.py\", line 382, in _make_request\n    httplib_response = conn.getresponse()\n  File \"/usr/local/lib/python3.8/site-packages/sentry_sdk/integrations/stdlib.py\", line 102, in getresponse\n    rv = real_getresponse(self, *args, **kwargs)\n  File \"/usr/local/lib/python3.8/http/client.py\", line 1332, in getresponse\n    response.begin()\n  File \"/usr/local/lib/python3.8/http/client.py\", line 303, in begin\n    version, status, reason = self._read_status()\n  File \"/usr/local/lib/python3.8/http/client.py\", line 264, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n  File \"/usr/local/lib/python3.8/socket.py\", line 669, in readinto\n    return self._sock.recv_into(b)\n  File \"/usr/local/lib/python3.8/ssl.py\", line 1241, in recv_into\n    return self.read(nbytes, buffer)\n  File \"/usr/local/lib/python3.8/ssl.py\", line 1099, in read\n    return self._sslobj.read(len, buffer)\nConnectionResetError: [Errno 104] Connection reset by peer\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.8/site-packages/requests/adapters.py\", line 413, in send\n    resp = conn.urlopen(\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/connectionpool.py\", line 648, in urlopen\n    retries = retries.increment(method, url, error=e, _pool=self,\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/util/retry.py\", line 347, in increment\n    raise six.reraise(type(error), error, _stacktrace)\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/packages/six.py\", line 685, in reraise\n    raise value.with_traceback(tb)\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/connectionpool.py\", line 597, in urlopen\n    httplib_response = self._make_request(conn, method, url,\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/connectionpool.py\", line 386, in _make_request\n    six.raise_from(e, None)\n  File \"[string](string)\", line 2, in raise_from\n  File \"/usr/local/lib/python3.8/site-packages/requests/packages/urllib3/connectionpool.py\", line 382, in _make_request\n    httplib_response = conn.getresponse()\n  File \"/usr/local/lib/python3.8/site-packages/sentry_sdk/integrations/stdlib.py\", line 102, in getresponse\n    rv = real_getresponse(self, *args, **kwargs)\n  File \"/usr/local/lib/python3.8/http/client.py\", line 1332, in getresponse\n    response.begin()\n  File \"/usr/local/lib/python3.8/http/client.py\", line 303, in begin\n    version, status, reason = self._read_status()\n  File \"/usr/local/lib/python3.8/http/client.py\", line 264, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n  File \"/usr/local/lib/python3.8/socket.py\", line 669, in readinto\n    return self._sock.recv_into(b)\n  File \"/usr/local/lib/python3.8/ssl.py\", line 1241, in recv_into\n    return self.read(nbytes, buffer)\n  File \"/usr/local/lib/python3.8/ssl.py\", line 1099, in read\n    return self._sslobj.read(len, buffer)\nrequests.packages.urllib3.exceptions.ProtocolError: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.8/site-packages/betfairlightweight-0.0.0b13-py3.8.egg/betfairlightweight/endpoints/baseendpoint.py\", line 36, in request\n    response = session.post(\n  File \"/usr/local/lib/python3.8/site-packages/requests/api.py\", line 110, in post\n    return request('post', url, data=data, json=json, **kwargs)\n  File \"/usr/local/lib/python3.8/site-packages/requests/api.py\", line 56, in request\n    return session.request(method=method, url=url, **kwargs)\n  File \"/usr/local/lib/python3.8/site-packages/requests/sessions.py\", line 488, in request\n    resp = self.send(prep, **send_kwargs)\n  File \"/usr/local/lib/python3.8/site-packages/requests/sessions.py\", line 609, in send\n    r = adapter.send(request, **kwargs)\n  File \"/usr/local/lib/python3.8/site-packages/requests/adapters.py\", line 473, in send\n    raise ConnectionError(err, request=request)\nrequests.exceptions.ConnectionError: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.8/site-packages/equine-1.11.2-py3.8.egg/equine/account/accounthandler.py\", line 130, in _get_cleared_markets\n    cleared_markets = client.betting_client.betting.list_cleared_orders(\n  File \"/usr/local/lib/python3.8/site-packages/betfairlightweight-0.0.0b13-py3.8.egg/betfairlightweight/endpoints/betting.py\", line 438, in list_cleared_orders\n    (response, response_json, elapsed_time) = self.request(method, params, session)\n  File \"/usr/local/lib/python3.8/site-packages/betfairlightweight-0.0.0b13-py3.8.egg/betfairlightweight/endpoints/baseendpoint.py\", line 43, in request\n    raise APIError(None, method, params, e)\nbetfairlightweight.exceptions.APIError: SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.170718126'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))",

    "trading_function": "list_cleared_orders",

    "response": "SportsAPING/v1.0/listClearedOrders \nParams: {'betStatus': 'SETTLED', 'marketIds': ['1.170718126'], 'settledDateRange': {'from': None, 'to': None}, 'groupBy': 'MARKET'} \nException: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))"

}```

---

## 2020-06-11 14:32:41 - strategies channel

**liam**

tbh not something I can expand on openly but as you know markets have a tendency to overreact especially to certain signals/events so delaying can result in a better price, however very strategy dependant

---

## 2020-06-11 06:34:17 - random channel

**liam**

Are you able to share an example strategy which exhibits similar times? Interested to know how many times it’s being called and if we can reduce that instead.



Considering this is just a lookup I am very surprised it’s taking that much time :thinking_face:

---

## 2020-06-10 22:45:48 - strategies channel

**JonJonJon**

Surely lots of automated betting has an element of iceberging to it anyway? For example, I'm currently working on a strategy that quotes £10 of bets either side of the best price. It gets filled in clips under £10. So in a way, that is being iceberged too.

---

## 2020-06-10 22:34:31 - strategies channel

**James T**

Perhaps I need to evolve my strategy onto offering rather than taking. But it seems to work as take so I thought I’d try that first. 

---

## 2020-06-08 12:00:40 - issues channel

**liam**

`RunnerContext.invested` is your golden source in knowing if you have a live trade in the market, if you override it then you need another way to prevent your strategy from placing trades/orders on every update

---

## 2020-06-08 11:54:39 - issues channel

**liam**

it will block the second because it limits one live trade per selection per strategy, you can override the [https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L118|validate](https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L118|validate) function, test first!

---

## 2020-06-08 10:30:42 - strategies channel

**Remi**

So I finally got a live key activated a few days ago (thank you [@U4H19D1D2](@U4H19D1D2)!) and the first results look good though this is just a single weekend. Mean is around 7 cents per trade (a single trade can be multiple orders/markets for this strategie), value at risk on that 7ct is low but sometimes I do have small negative returns, and I calculated the probability that the mean is higher than 0 with a one-sided T-test and that came out very close to 1. I feel pretty confident this thing is working (for now). 



I have a few questions though. 



1. Do you optimize order size for rounding+commission? Sometimes you can get one extra cent for free because of rounding. Is this a micro optimization or worth some effort?

2. I don’t mean to be impolite but, do you see markets being manipulated? E.g. in more regulated markets you are not allowed to match your own orders but on Betfair you can (I don’t know if it is allowed on bf). I don’t plan on doing this but I’d like to know better what I am dealing with.

3. What are some strategies to lower the commission? Right now I have 0% commission discount and my Betfair Points isn’t growing.



---

## 2020-06-07 08:43:02 - general channel

**Will Morrison**

I'm testing the MarketRecorder example strategy, and it seems like it saves a list of all trades on each runner under trd, with price - volume pairs. Is there a way to identify the time of each trade?

---

## 2020-06-06 17:34:51 - general channel

**Ruben**

```stream = trading.streaming.create_stream(listener=listener)

streaming_unique_id = stream.subscribe_to_markets(market_filter=market_filter,

                                                  market_data_filter=market_data_filter,

                                                  heartbeat_ms=500)



t = threading.Thread(target=stream.start, daemon=True)

t.start()



event_db = {}

market_db = {}

before_queue_get = time.time()

count = 0

while True:

   count += 1

    market_books = output_queue.get()

    current_time = time.time()

   print(f"Average time: {(current_time - before_queue_get)/count}")```



---

## 2020-06-06 13:07:28 - random channel

**Sandy Caskie**

Ye fair points.



1. This is hardcoded as I want to implement the strategy in a rigid way. Also do you not always need a unique customer ref if you place a certain number of orders over a specific period? I remember something along those lines when developing this.

2. JSON is specified once as it is passed directly to make an order.

3. Ye that is the format though when I was developing it I specified this way and don't see why I should change it as I am implementing my code in with these inputs every time the code is executed with variability around z and i.

This all said the next project I will be using bflw.



Why is f-strings better, I've always used + operator never really thought why should change that though I am more than happy to if it is much better. Though how much benefit can you gain from concatenate strings differently in the whole scheme of things.



I also thought to place this question in random as it not directly related to bflw.



Thanks for your comments and assistance :slightly_smiling_face:

---

## 2020-06-06 12:29:29 - random channel

**Mo**

It's jarring to see that code here because anyone who uses bflw wouldn't do that:



1. Why hard code some of these things? What if you want to place a LIMIT_ORDER? What if you don't want to use a customerRef?

2. It's unecessarily verbose, how many places in your code base do you have "jsonrpc": "2.0"?

3. JSON has a well defined key:value format so why are you generating the string yourself from data? Just use json.dumps on a dict

Obviously bflw solves all of that for you.



I'm just explaining why I think it's gross. I think legacy constraints are an understandable reason for you to do it that way and I totally understand that it would have been a valuable learning experience. I'm someone who has written multiple trading platforms and Betfair wrappers over his career so I too came to bflw with my own codebase and I'd wholeheartedly recommend you make the switch. Don't waste your time developing/maintaining your own Betfair API implementation. Reserve that time for developing actual strategies.

---

## 2020-06-06 11:05:38 - general channel

**Will Morrison**

By running just

client = clients.BetfairClient(trading)



framework = Flumine(client=client)



strategy = ExampleStrategy(

    market_filter=streaming_market_filter(market_ids=["1.170643189"]),

    streaming_timeout=2,

)

at the end, but not the framework.run(), I think I was able to get what I needed!

---

## 2020-06-06 10:49:55 - general channel

**Will Morrison**

Worked like a charm, now I'm using flumine for the first time! If the following is too much "teach me Python", I apologize, and please feel free to tell me to just go learn more basics: I'm trying to make my first example custom strategy object, where I would like to modify the flumine example.py class to try to place a BACK on a single player if his batb is above a certain threshhold. In betfairlightweight, I was able to get these values by looping through the market book and using lines like

market_book._data["runners"][x]["ex"]["availableToBack"][lvl]["price"], where x and lvl are loop variables

which I was able to figure out by using the variable explorer in my Spyder IDE too dig into the market_book object after running one loop of examplestreaming.py. Now in flumine I don't know how to get a similar thing to investigate. I want to take a conditional like this from the example -

if (

                runner.status == "ACTIVE"

                and runner.last_price_traded

                and runner.selection_id == 11946248



and instead of runner.last_price_traded, say something like

                and runner.ex.availableToBack[0]["price"] &gt;= 3.0



Is there an easy way for me to figure out what all the runner.[things] available are named?

---

## 2020-06-06 09:42:01 - general channel

**liam**

Need to improve the docs on this but here is a simple example:



```strategy = MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE"],

        market_types=["WIN"],

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/tmp",

        "force_update": False,

        "remove_file": True,

    },

)```

---

## 2020-06-06 09:28:11 - general channel

**Will Morrison**

Does anyone have an example of calling the MarketRecorder class in the flumine examples (or similar)? What I mean is something like the marketrecorder.py example where it creates an S3MarketRecorder object:

strategy = S3MarketRecorder(

    name="WIN",

    market_filter=betfairlightweight.filters.streaming_market_filter(

        event_type_ids=["7"],

        country_codes=["GB", "IE"],

        market_types=["WIN"],

        # market_ids=["1.169056942"],

        # event_ids=[29671376]

    ),

    stream_class=DataStream,

    context={

        "local_dir": "/tmp",

        "bucket": "fluminetest",

        "force_update": False,

        "remove_file": True,

    },

)

but for the MarketRecorder class instead.

I'm relatively comfortable with writing small scripts and functions, but I'm a bit overwhelmed trying to figure out what arguments I do and don't have to hand to a big class like MarketRecorder which inherits the BaseStrategy class when I instantiate it. Is learning to use the inspect module the right path for me to get more comfortable with this problem in the future?

---

## 2020-06-05 16:13:33 - issues channel

**Stefan**

So you you listen to streaming api for new published market/s, then you place 1.01 lay bets on any market selection. If you say betfair adds just 10 of markets in batch, how you can go in thousands of bets placed in 1 second? This strategy makes sense only for some market types, limit that to reduce amount of placed bets.

---

## 2020-06-05 14:21:51 - issues channel

**Mo**

True but it’s always hard to balance between spending time on something new that might not pan out versus improving an established strategy that you know works

---

## 2020-06-05 13:44:17 - issues channel

**Mo**

Is your strategy really reliant on that?

---

## 2020-06-05 13:42:48 - issues channel

**Dave Simonds**

Hi everyone, been a member for a month or so, great insightful group, really happy to be here.



I do have a quick question….“TOO_MANY_REQUESTS” error.

This was introduced a few months back (just before the lockdown) and until now i’ve not really paid too much attention to it…. however its screwing me over big time now that racing is back. Your orders basically get denied if you attempt more than 1000 per second



I was just wondering is this something that applies across the board or is it only for non PC users? I remember someone once saying upper-tier PC users don’t pay a transactions charge and this kind of feels similar.



This really sucks because it looks like i am going to lose my only viable strategy, I’ve had a great 18 months out of it but to see things end because of a crappy rule change is a real shame

---

## 2020-06-04 19:58:03 - general channel

**Mo**

[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-RollupModel](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Enums#BettingEnums-RollupModel)

---

## 2020-06-04 19:55:25 - general channel

**Remi**

`rollup_model='NONE'` doesn’t do it. E.g. [https://www.betfair.com/exchange/plus/e-sports/market/1.170652449](https://www.betfair.com/exchange/plus/e-sports/market/1.170652449) I don’t see the available to lay 2€ at 1.38 but I see 13.99 at 1.39

---

## 2020-06-04 19:51:58 - general channel

**Mo**

`rollup_model='NONE'`

---

## 2020-06-04 19:49:19 - general channel

**Remi**

I am trying to get high resolution pricing data on available to back/lay. This is the call that I am using:

```list_market_book(market_ids=[market_id],

                                                       price_projection=filters.price_projection(

                                                           rollover_stakes=True,

                                                           ex_best_offers_overrides=filters.ex_best_offers_overrides(

                                                               rollup_model="STAKE",

                                                               best_prices_depth=3,

                                                               rollup_limit=0,

                                                           ),

                                                           price_data=filters.price_data(ex_best_offers=True, ),

                                                       ),```

But the price data that I am getting is not more precise than the minimum bet size.



Is this as expected or is there a way to get higher resolution (other than scraping the website)?

---

## 2020-06-04 11:52:45 - random channel

**Mo**

Someone recommended this site to me: [https://www.betconnect.com/](https://www.betconnect.com/). Seems like an interesting new take on the exchange model. Anyone used it?

---

## 2020-06-03 08:17:50 - general channel

**Oliver Varney**

which I guess is just the same as holding in the Strategy.context which the value of the market_id being a class

---

## 2020-06-03 08:14:46 - general channel

**Oliver Varney**

one example from my code is strategy market schedules / events, which can be a list of time based events specific to both the market and strategy. Ive added a list into the strategy to hold strategy markets, which in turn hold strategy market schedules. this then opens up the possibility for strategy market schedules to have specific associated trades

---

## 2020-06-03 08:08:48 - general channel

**liam**

Yeah, I normally create a dictionary in the context `Strategy.context = {marketId: xyz}`

---

## 2020-06-03 08:07:32 - general channel

**Oliver Varney**

the edge case is the combination where you need something that is specific to both a strategy and a market right?

---

## 2020-06-03 08:04:32 - general channel

**Oliver Varney**

and just have a list within  the strategy that retrieves the relevant strategy market within the check_market_book / process_market_book

---

## 2020-06-03 08:03:39 - general channel

**Oliver Varney**

I think I might just create a class called StrategyMarket

---

## 2020-06-03 08:00:36 - general channel

**liam**

You have `Strategy.context` and `Market.context` as a user store that flumine won't touch. When you want it specific to both I guess its up to you. I see this being a crucial part of flumine as external data sources are likely to become more and more important so welcome any thoughts on this.

---

## 2020-06-03 07:04:14 - general channel

**Oliver Varney**

Morning guys, just been looking through flumine and have a couple of question on where is best to put some code to extend the functionality. Where would I put external data that I would need for a strategy that is specific to a market (Market class?). Secondly where would I put code that is specific to both a strategy and a market (Strategy class?)?

---

## 2020-06-02 23:15:11 - random channel

**Dave**

Yes forgot to mention I run a mysql server on it too. It's 20 USD (DO charge USD so it happens to be under £20). I could probably do with just a dual core machine (rather than quad) which is 10 USD I think, but needed the extra RAM that comes with the quad core to train various models.

---

## 2020-06-02 16:48:03 - random channel

**JonJonJon**

How much does it cost to run an instance of AWS per month, running a bflw horse trading bot 24x7?

---

## 2020-06-02 14:45:18 - general channel

**Andrey Yunoshev**

start framework == .run? so, I can run, wait 10s and add strategy after?

---

## 2020-06-02 14:33:51 - general channel

**Andrey Yunoshev**

```-&gt; % pip3 show flumine

Name: flumine

Version: 1.5.4

Summary: Betfair trading framework

Home-page: [https://github.com/liampauling/flumine](https://github.com/liampauling/flumine)

Author: Liam Pauling

Author-email: UNKNOWN

License: MIT

Location: /usr/local/lib/python3.7/site-packages

Requires: python-json-logger, betfairlightweight, requests, tenacity

Required-by: ```

---

## 2020-06-02 14:33:07 - general channel

**Andrey Yunoshev**

```    strategy = LiveStrategy(

        market_filter=streaming_market_filter(

            event_type_ids=["4339"],

            market_types=["WIN"],

            bsp_market=True,

            country_codes=["GB", "UK", "AU"],

        ),

        streaming_timeout=0,

        max_order_exposure=20,

        max_selection_exposure=10,

    )



    client = clients.BetfairClient(trading)

    framework = Flumine(client=client)

    framework.add_strategy(strategy)```

---

## 2020-06-02 14:13:16 - general channel

**liam**

anything closed will get processed in `Strategy.process_closed_market` rather than `process_market_book`

---

## 2020-06-02 14:11:19 - general channel

**Andrey Yunoshev**

&gt;flumine seems to be getting some users



this is a lot of work, and most importantly is done by a person who understands the subject

I, as usual, wrote the parser myself, and then I caught bugs - and then I decided to google it :)



in general, at the moment, it bothers me a little that everything is slow - it takes 2-3 hours to process a month of greyhounds records

on the other hand, it's almost 10 gigabytes of data :)



I have a couple more questions - you can somehow immediately get the name of the runners?

currently, I call client.betting_client.betting.list_market_catalogue in check_market_book



And second, for backtesting, I do not receive any market with CLOSED status - for getting WIN/LOSE runners status - but need dig more, possible my bug

---

## 2020-06-02 11:52:57 - strategies channel

**Troy Edwards**

With "it doesn't matter if the runner wins or loses", I think I understand what you are saying.   When I test my systems I just apply the system which returns the highest amount of dollars.  I also check win loss ratio and number of bets to make that that dollar amount but its the dollar amount that concerns me most.  With finding value to me that is more about optimising my strategy to maximise wins and minimises losses. I'll do some reading on those links you posted which I assume are about value etc.     Thanks [@U4H19D1D2](@U4H19D1D2)

---

## 2020-06-02 10:26:38 - general channel

**liam**

Could look to handle a [https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L103|list of orders](https://github.com/liampauling/flumine/blob/master/flumine/strategy/strategy.py#L103|list of orders) if you want?

---

## 2020-06-02 06:29:49 - strategies channel

**liam**

[@U0143UVG294](@U0143UVG294) regarding your first paragraph, I think you are thinking about things wrong. It doesn’t matter if the runner wins or loses it’s about finding value ([https://www.pinnacle.com/en/betting-resources|pinnacle](https://www.pinnacle.com/en/betting-resources|pinnacle) have some good blog posts on this)



It’s entirely possible to back more winners than losers and still lose money and visa versa. In order to beat the market you need to take value, the trick is 



a) calculating what is and isn’t value 

b) getting matched 



A can be helped by analysing data and/or getting money through the markets and then analysing what does and doesn’t work, [https://www.betfairtradingblog.com/|Peter Webb](https://www.betfairtradingblog.com/|Peter Webb) has made a few blog posts on this.

---

## 2020-06-02 00:43:51 - strategies channel

**Troy Edwards**

Currently I am testing strategies to determine final outcome, either runner wins (backable) or runner loses (layable) and this seems an endless process of dream up strategy/test strategy/pass-fail/implement strategy.



I am also looking at pre-race green up strategies to trade the market in and out before the race has even run?  I have done this plenty of times however not because of strategy but more luck, ie I place a bet, I noted the odds moved in my direction so I greened up.  I note when charting runners prices (especially higher odds) the lay-to- back spread is wide and narrows up only in the final 10 minutes as money comes in (even on Australian Saturday races) however I don't believe I can apply any TA to these charts?   OR can I ????   If I was should I be using the Back price, OR average of Back and Lay price?



Oh and I would love to be able to work out if a runner is a true favourite or a false favourite.  Currently I can work this out once a race is complete which is too late :laughing::laughing::laughing:

---

## 2020-06-01 09:37:24 - random channel

**Troy Edwards**

This sounds right SrFabio

1. I place a high odds (or low odds) bet 

2. I then reduce this size calling the CancelBetfairOrder. In Australia min is $5 bet so I can cancel $4 of it to place a $1 bet

3. Then I change the odds such that the bet is matched using RepaceBetfairOrder

I have been doing this for a while (2 months - 200 bets a day) and have not got in trouble as [@UBS7QANF3](@UBS7QANF3) mentioned.  Maybe its ok in Oz :wink:



    '##################################################################################################

    '### PLACE LOW VALUE BETFAIR ORDER - IF SUCCESSFUL RETURNS BET ID                               ###

    '###    IF BET IS UNDER $5 LETS SAY $1                                                          ###

    '###        WE NEED TO SEND AN UNMATCHED LAY BET AT ODDS 1.01 FOR $5                            ###

    '###        WE THEN CALL CANCEL-ORDER AND REDUCE THIS LAY BET TO $1                             ###

    '###        WE THEN CALL REPLACE ORDER WITH OUR ORIGINAL ODDS                                   ###

    '##################################################################################################

    Public Function PlaceLowBetSizeBetfairOrder(sMarketID As String, sSelectionID As String, dBetOdds As Double, dBetSize As Double, BetSide As Side, BetPersistence As PersistenceType, Optional customerStrategyRef As String = Nothing) As ReplaceExecutionReport

        PlaceLowBetSizeBetfairOrder = Nothing

        Try

            Dim BetfairMinBet As Integer = 5

            Dim placeBet As PlaceExecutionReport = Nothing

            Select Case BetSide

                Case Side.BACK

                    'PLACE $5 BET AT HIGH ODDS WHICH WE BE UNMATCHED, SO $5 @ 1.01

                    placeBet = PlaceBetfairOrder(sMarketID, sSelectionID, "500", BetfairMinBet, BetSide, BetPersistence, customerStrategyRef)



                Case Side.LAY

                    'PLACE $5 BET AT LOW ODDS WHICH SO THAT IT WILL BE UNMATCHED, SO $5 @ 1.01

                    placeBet = PlaceBetfairOrder(sMarketID, sSelectionID, "1.01", BetfairMinBet, BetSide, BetPersistence, customerStrategyRef)

            End Select



            If placeBet.Status = ExecutionReportStatus.SUCCESS Then

                'NOW REDUCE THE BET FROM $5 @ 500 TO &lt;dBetSize&gt; @ 500 - THIS WILL KEEP THE SAME BET ID

                Dim myReduceSizeBet As CancelExecutionReport = THREAD_CancelBetfairOrder(sMarketID, placeBet.InstructionReports(0).BetId, BetfairMinBet - dBetSize)



                If myReduceSizeBet.Status = ExecutionReportStatus.SUCCESS Then

                    'NOW INCREASE THE ODDS BACK TO WHAT WAS ORIGINALLY REQUESTED SO &lt;dPriceOdds&gt; @ 500 TO &lt;dBetSize&gt; @ &lt;dPriceOdds&gt;



                    'NOTE WE WILL NOW GET A NEW BET ID AS WE ARE CHANGING THE QUEUE POSITION

                    Dim myReplaceBet As ReplaceExecutionReport = THREAD_ReplaceBetfairOrderChangeOdds(sMarketID, myReduceSizeBet.InstructionReports(0).Instruction.BetId, Math.Round(dBetOdds, 2))

                    PlaceLowBetSizeBetfairOrder = myReplaceBet

                End If

            End If



        Catch ex As System.Exception

            Debug.Print("PlaceLowBetSizeBetfairOrder " &amp; ex.Message)

            THREAD_BF.InUse = False

        End Try

    End Function

---

## 2020-06-01 07:58:24 - random channel

**Lee**

i am, i got the all product pack but was a lot cheaper when i did it so i'm stuck on a lower pricing model (not as low as i first thought, was looking at organisation pricing)

---

## 2020-05-31 03:35:16 - general channel

**Steve**

I've been having a bit of an issue with latency and I'm trying to figure out what benchmark latency I should be striving for. What is the optimal time I could expect for a strategy to be able to register a change in the orderbook, process the change and have a new order posted back into the orderbook? So essentially, if I'm responding to change in the BF orderbook what latency should I expect between that change being made and my new order being placed in the orderbook?

---

## 2020-05-30 08:57:53 - strategies channel

**Stefan**

ML gives probability of prediction for some models, so you can narrow your betting for this values as well.

---

## 2020-05-29 17:26:31 - general channel

**jhaa**

I am getting an internal error because I had exposure moved to a new account. Not sure how relevant this is but maybe this should be caught or is of interest to anyone:



  File "/home/code/venv/lib/python3.6/site-packages/betfairlightweight/resources/bettingresources.py", line 505, in &lt;listcomp&gt;

    self.orders = [RunnerBookOrder(**i) for i in orders] if orders else []

TypeError: __init__() missing 1 required positional argument: 'placedDate'

---

## 2020-05-29 15:43:57 - strategies channel

**Lee**

yes, there was a screenshot showing how ML helped Sandy improve/optimize their strategy

---

## 2020-05-29 15:37:07 - issues channel

**Unknown**

Folks, re the certificates. As a beginner myself, I had the same issues..This question comes up a lot. I recently got this working. So if it helps someone in the future this is what isued to get it working.

Follow this link:



[http://www.betfairprotrader.co.uk/2015/08/creating-digital-certificate-for-betfair.html](http://www.betfairprotrader.co.uk/2015/08/creating-digital-certificate-for-betfair.html)



and then I continued with is link:



[https://helpcenter.gsx.com/hc/en-us/articles/115015887447-Extracting-Certificate-crt-and-PrivateKey-key-from-a-Certificate-pfx-File](https://helpcenter.gsx.com/hc/en-us/articles/115015887447-Extracting-Certificate-crt-and-PrivateKey-key-from-a-Certificate-pfx-File)



I had a single folder "certs" in the top level directory C:

This is what it looked like (see image), although I may have too many files in there now :grinning:



Your Python code should resemble something like this :-



trading = betfairlightweight.APIClient("UserName", "Password", app_key="YourAppKey", certs=r"C:\certs")

# login

trading.login()



Hope the helps

regards

Peter

---

## 2020-05-29 09:09:29 - issues channel

**JS**

Hi guys -  first time post from a newbie down under. I'm trying to setup betfairlightweight to bring through race fields and test on my model but have come across an issue in regards to the Certificates.  I followed this guide from Betfair in terms of certificate generation [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Certificate+Generation+With+XCA](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Certificate+Generation+With+XCA) which gives me a .crt and a .pem file. I realise though that it requires a .crt and a .key file as opposed to a .pem whihc this guide gives. I dont really understand the openssl side of things so thats why ive opted to use the XCA way. Any ideas on where to from here? any help would be much appreciated. Thanks!

---

## 2020-05-29 07:27:43 - strategies channel

**Zbanga**

Hardest part is edge. Similarly to sports betting edge is hard to come by. Definitely doable but like most people when it comes to betting they gamble. Financial data is also different and relatively hard to model. I used to work for a prop firm and the things they were doing isn’t ground breaking, but they had cheaper access to capital and way better technology and they had edge. 

---

## 2020-05-29 07:21:28 - general channel

**Mo**

The `marketCount` is the number of markets associated with that event and is correct. How are you getting those markets? Because they do not share that event ID. e.g.



```api_client.betting.list_market_catalogue(filter=betfairlightweight.filters.market_filter(market_ids=['1.160316133']), market_projection=['EVENT'], lightweight=True)

Out[10]: 

[{'marketId': '1.160316133',

  'marketName': 'Winner 2019/20',

  'totalMatched': 219.61,

  'event': {'id': '13932380',

   'name': 'Danish Superliga',

   'countryCode': 'DK',

   'timezone': 'Europe/London',

   'openDate': '2018-07-13T16:00:00.000Z'}}]```

---

## 2020-05-28 22:43:57 - strategies channel

**Sandy Caskie**

Yes, I can tell you a little but I feel a wee bit precious about how I implement it to my strategy. So it basically adapts my strategy based on data collected by myself. I really just wanted to show to what extent ML can be used to improve return. Has anyone else implemented a ML process and how effective have they found it? Please share...

---

## 2020-05-27 13:40:52 - strategies channel

**Remi**

Or one day they ~change~ upgrade their model.

---

## 2020-05-27 12:50:41 - strategies channel

**Mo**

What model are you referring to?

---

## 2020-05-27 12:50:39 - strategies channel

**JonJonJon**

Interesting. Do you know if anyone bets using Betfair's models as a signal? I'd be wary of using something that I did not understand, or which could easily disappear if they decided to stop it.

---

## 2020-05-27 12:47:31 - strategies channel

**Troy Edwards**

Hi guys just joined this channel and have read the entire thread.  I sometimes jump out on to Betfair forums ([https://forum.developer.betfair.com/](https://forum.developer.betfair.com/)).  Brizzie boy who trades gallops/trotts/dogs.  Have an ok bot i have developed with [http://VB.net|VB.net](http://VB.net|VB.net) and i guess like everyone still struggling to find a successful system.  I note betfair have racing models and their models (for instance the horse racing model) calculates a market price for the runner which can be compared against the current market to determine whether the bet is good value or poor value.  Does anyone know how this is calculated/determined?

---

## 2020-05-27 09:31:03 - general channel

**liam**

yeah that is the idea, I want to clean up the trade/strategy reset logic so its cleaner and easier to work out if you have live trades/pending orders etc. just haven't worked it out in my head yet hence why this hasn't been completed :slightly_smiling_face: I will look to put some warning logs going forward when something is being used which won't do anything

---

## 2020-05-27 09:22:36 - general channel

**liam**

both, not yet implemented but you could handle it in the strategy when processing orders. Typical use would be:



```trade = Trade(

    market_book.market_id, runner.selection_id, runner.handicap, self,

)

order = trade.create_order(

    side="LAY", order_type=LimitOrder(2, self.context["stake"]),

)

offset_order = trade.create_order(

    side="BACK", order_type=LimitOrder(10, self.context["stake"]),

)

trade.offset_orders.append(offset_order)

self.place_order(market, order)```



---

## 2020-05-26 11:01:17 - issues channel

**Julio**

I have exactly the same issue. But I am still no convince if it is because of 1) change in market 2) algos learning my strategy and beating it 3) survivorship biais (still running a loosing strat - among all losing strat some will still win at the beginning)

---

## 2020-05-25 19:45:08 - issues channel

**liam**

This is very strategy dependant, value backing / laying (handful of orders per race) then yeah I agree. Value taking preplay or inplay 100s/1000s of orders per race then you can drop your sample right down 

---

## 2020-05-25 19:43:11 - issues channel

**Mo**

This might not be as true in horse racing but also think about whether there is a bias to certain races at that time of the year, eg jumps vs flats that might mean a strategy trained on it doesn’t perform as well the rest of the year 

---

## 2020-05-25 19:27:21 - issues channel

**Mo**

Trading frequently doesn't help you if a lot of the outcomes are correlated

---

## 2020-05-25 17:52:57 - strategies channel

**Mo**

There’s also nothing forcing you to trade maiden races. A strategy doesn’t have to work on everything

---

## 2020-05-25 10:56:50 - strategies channel

**Dave**

Bit of a vague question, but curious about responses. Specifically RE racing markets, who here is trading based of their own predictive modelling of actual event outcomes, and who here is trading order flow? My approach for football has always been the former, but have been looking at expanding my strategies recently to racing and was curious what people's approaches were. For the former a clean, consistent data source is required (which I spent a lot of time building for football), considering doing the same for racing but obviously requires a fair bit of time investment. Given how volatile racing markets are (compared to the standard exponential decay you see in footy), maybe it lends itself better to order flow trading. I know Liam has already mentioned people having success with timeform data for the predictive modelling approach.

---

## 2020-05-25 07:11:42 - general channel

**liam**

I think I only have one strategy that actually takes, 90% of my orders are ‘passive’ before being taken or cancelled  

---

## 2020-05-24 19:19:15 - strategies channel

**VT**

Guys, I'm a Betfair worker, almost all day (before the virus) I was trading on Betfair, my favorite markets are match odds, correct score and goals after 80 minutes, I like to lay at low odds (&lt;1 , 09) in some situations. In the last 3 years there are an average of 8 hours of football a day. Working in the main leagues in Europe and Brazil, I don't have much preference, I think that German football is difficult for match odds but it is easy for goals, and so each league usually has its own characteristics and our work method needs to be adjusted. I have also been looking for value in Asian leagues, I had a good ROI in Vietnam before the stop, but games cannot happen at the same time as the major leagues. The capital is mine, personal, built with years of work.



I like computers, mathematics in general, so with the stop I went back to focusing on bots, machine learning etc ... I have some bets on goals recorded on my old blogabet [https://somatipsbr.blogabet.com/](https://somatipsbr.blogabet.com/) and my initial studies on this forum [https://forum.apostaganha.com/index.php/topic,110507.0.html](https://forum.apostaganha.com/index.php/topic,110507.0.html)

---

## 2020-05-24 13:32:13 - general channel

**Sandy Caskie**

[@UFPEU7URG](@UFPEU7URG) ye I was thinking along these lines. In terms of data collection have you used the Betfair timeform data. I had a quick look and it appears to have good data for predictive modeling. Here’s a link to it [https://developer.betfair.com/en/get-started/#timeform-api|https://developer.betfair.com/en/get-started/#timeform-api](https://developer.betfair.com/en/get-started/#timeform-api|https://developer.betfair.com/en/get-started/#timeform-api). Though the associated documentation is not available and it is also £500 per month.

---

## 2020-05-24 11:27:03 - general channel

**Sandy Caskie**

Has anyone used the following python packages to collect horse racing data: [https://pypi.org/user/justjasongreen/](https://pypi.org/user/justjasongreen/)? Is it useful? If you look at the racing data package it seems to contain some really useful information for creating predictive models. It uses something called MongoDB, I have no experience of this, does anyone else? I have been trying to get it working this morning without any luck.

---

## 2020-05-24 09:50:26 - strategies channel

**SrFabio**

[@U013ZS16QJZ](@U013ZS16QJZ) It's never a waste of time, the more experience you have (even by implementing strategies that end up not being profitable) the better you will become at tweaking your strategies. I firmly believe it's possible, there are so many things to try it's a matter figuring out up the best information (historical stats, ingame stats, etc etc) for the particular games you run your strategy on

---

## 2020-05-23 18:35:00 - strategies channel

**liam**

Depends on what the strategy is doing / odds taken but I would want that line a bit straighter, is this backing and laying? Preplay? 

---

## 2020-05-23 18:23:42 - strategies channel

**Unknown**

thanks for the tips yesterday, now positive on UK racing (the screenshot) and also US over the course of 18k races from the same strategy

---

## 2020-05-23 14:00:27 - general channel

**liam**

So I have my settings for a strategy which I use for production, I run those exact settings over a set market and assert profit == x on every run 

---

## 2020-05-22 19:48:34 - random channel

**Mo**

Some thoughts (spoilers ahead):



1) I found the story about taking advantage of the rogue trader very interesting from two angles: 1) considering whether there are malfunctioning algos on Betfair to exploit and 2) the idea that being lucky to be presented with an easy money making opportunity provided him with a bankroll that he could use to bootstrap his success. I wonder how differently things may have turned out if he hadn’t been in the right place at the right time to take advantage

2) As I said, I don’t think he deserves prison time in the US for what he did but I feel even worse for the developer being charged. I think that is a very dangerous precedent that if you write software that could be misused then you’re liable

3) I’m pretty sure I did some work on the Iconic Worldwide Gaming platform. I had no idea of the connection until the product was described - betting on financial price movements using a casino style interface

4) I loled at the description of him drinking coffee with a tea spoon

---

## 2020-05-22 15:13:29 - strategies channel

**SrFabio**

I was in the process of purchasing a house so I cashed out for the deposit and couldn't afford to invest for a few months (mortgage + all expenses on me), the stock price of the companies I trade was not good enough for me to open positions and I also didn't have enough spare cash (apart from the balance...need an emergency fund for the trading account lol) to trade confidently, during the pandemic the brokers reduced the leverage even more so right now is not a good time for me, no job not much help from gov and the way I trade CFDs is risky and stressful. I currently only have a few small positions on FX but it's money I'm not counting on

---

## 2020-05-22 13:59:31 - strategies channel

**brightcake**

I heard of a guy who made some NLP model that scanned trumps tweets and traded based on that

---

## 2020-05-22 11:36:09 - strategies channel

**mandelbot**

[@U013Z24LD0U](@U013Z24LD0U) How did you arrive at your strategy? via backtesting or via developing trading skills?

---

## 2020-05-22 11:34:31 - strategies channel

**SrFabio**

There's probably other routes for automated financial trading without having to delve into Level 2 and other high cost services. I've done quite well trading CFDs manually and quite frankly would have scaled massively if I had taken the time to automate the strategy

---

## 2020-05-22 11:07:21 - strategies channel

**Jonjonjon**

I did many years ago. But don't bother now as it'll cause problems with my day job (I'm an IT contractor at a bank). Also, it costs a lot more to do algo trading in financials. You need thousands of pounds in margin if you want to just trade single futures contracts. Plus expensive data feeds. It might costs upwards of £2k a month in connectivity and data fees. And one flash crash can wipe out a year or more of profits.



With Betfair, you can realistically start with under £100. You can rent a server to run your bot for under £10 a month. (In my experience) it's easier to find an edge. You get better diversification benefits, due to the hundreds of uncorrelated markets that trade every day. A flash crash wont' wipe out a years worth of profits.



A negative point of doing Betfair vs Financials is that Betfair is probably (in general) less scalable than financials. But that isn't to say that you can't make more than enough to feed your family using Betfair.

---

## 2020-05-22 09:47:25 - issues channel

**Newbie99**

I've never tried a 'FILL_AND_KILL' order before, so was just playing around, but I keep getting an error, suggesting the param's are wrong (FILL_OR_KILL works fine).



Params: {'marketId': '1.170485933', 'instructions': [{'orderType': 'LIMIT', 'selectionId': 28385567, 'side': 'BACK', 'limitOrder': {'price': 1000, 'persistenceType': 'LAPSE', 'size': 5, 'timeInForce': 'FILL_AND_KILL', 'minFillSize': 3}, 'customerOrderRef': '1.170485933_28385567_1'}], 'customerStrategyRef': 'manual_orders'}

Exception: None

Error: {'code': -32602, 'message': 'DSC-0018'}

Full Response: {'jsonrpc': '2.0', 'error': {'code': -32602, 'message': 'DSC-0018'}, 'id': 1}



Presumably FILL_AND_KILL is not the correct value to pass here, does anyone know what the correct one would be?

---

## 2020-05-21 21:53:16 - general channel

**Andrey Yunoshev**

Hi, guys. Nice framework, a great foundation for the future.



I'm just trying to analyze all the greyhound races in one day (and in the future I need a month).

The code is as simple as two pennies - but I never waited for it to finish.

Python eats up 29 gigabytes of memory and everything freezes :)



Is this expected at the moment or am I doing something wrong?



```class PastStrategy(BaseStrategy):

    def start(self) -&gt; None:

        None

    def check_market_book(self, market: Market, market_book: MarketBook) -&gt; bool:

        if market_book.status not in ["CLOSED", "SUSPENDED"]:

            town = market_book.market_definition.venue

            run_time = market.market_start_datetime.isoformat()

            key = "{0} at {1}".format(town, run_time)

            if town and key not in bf_runs_list:

                bf_runs_list.append(key)

                print("start processing new BF run: {0}, total {1} runs".format(key, len(bf_runs_list)))

            return True

        return False



    def process_market_book(self, market: Market, market_book: MarketBook) -&gt; None:

        None

    def process_orders(self, market: Market, orders: list) -&gt; None:

        None



markets = sorted(list_files_in_folder("./data/bf_uncompress/PRO/2020/May/1", "*.*"))



strategy = PastStrategy(

    market_filter={ "markets": markets},

    max_order_exposure=50,

    max_selection_exposure=10,



)



client = clients.BacktestClient()



framework = FlumineBacktest(

    client=client,

)



framework.add_strategy(strategy)

framework.run()```

---

## 2020-05-21 12:37:23 - general channel

**fjt1973**

Morning all... today is a school day and looking at Flumine. QQ. 1 I've been using the PriceRecorder for a specific inplay market. Once I've run the command "framework.run()" how would you end that session gracefully once the market was closed. QQ.2 Once you have a subscription / stream running can you add additional strategies with framework.add_strategy? Just a note I'm running this in Jupyter Lab and the framework.run() cell is still processing until I interrupt / terminate the kernel.

---

## 2020-05-21 12:36:56 - random channel

**Newbie99**

I have a couple of questions on SP bets (by which I mean bets with a persistence of 'MARKET_ON_CLOSE'), around how Betfair view the £10 minimum liability:



1. If have a lay bet that is partially matched, so say £9.90 gets matched initially (i.e. in live pre-market trading, before the SP is reconciled), is the expected behaviour that this additional 10p gets matched or cancelled?

---

## 2020-05-20 07:20:50 - strategies channel

**PeterLe**

It will be interesting to see just what effect lockdown has had on the markets and how it may change after lockdown. Ive found the US inplay markets particularly good using one strategy (last night was excellent).  The same strategy doesnt work as well on the Aus in-play unfortunately

---

## 2020-05-19 19:37:56 - strategies channel

**mandelbot**

[@U4H19D1D2](@U4H19D1D2) cant say for certain but the strategies that I employ on AUS don't work on UK/IRE, and AUS is feeling a lot more like UK/IRE since the lockdowns. Same with greyounds, previously very profitable strategy now in the red.

---

## 2020-05-19 14:11:53 - strategies channel

**SrFabio**

[@U010GM77S4W](@U010GM77S4W) Thanks :slightly_smiling_face: it's a huge joy especially during this time but it's incredibly hard to work decently. I really want to get into trading automation (even have an idea to try on the exchange games ahah) but I also like manual trading on a ladder too despite having mixed results (mainly bad xD) due to my incompetence on bankroll management (that's where my app is going to "help")

---

## 2020-05-19 12:44:59 - strategies channel

**brightcake**

Machine learning doesn't really seem to add that much of an edge at the moment (mostly speaking from the finance side but I assume it's pretty much the same in sports betting, if not even more so). You'd probably be able to get most information you need just using simple linear regressions.



If you really want to learn some ML, I would suggest taking one of those intro courses on Udemy (when there's a sale on ofc). They can give you a decent introduction to a topic in relatively small amounts of time, at least in my experience.

---

## 2020-05-19 12:19:48 - strategies channel

**SrFabio**

[@U4H19D1D2](@U4H19D1D2) I've been building a mobile app for the past couple of years using betfair API (part part part time xD) and it's nothing to do with trading automation, just a fancy cashout plus some other bits. Once I finish that (soon, I hope) I'll dive into more advanced stuff. So far it's given me a good understanding of the API-NG at least

---

## 2020-05-19 12:09:51 - strategies channel

**Mo**

Yes, fractional Kelly is a very good starting point

---

## 2020-05-19 12:09:18 - strategies channel

**liam**

I use a variation of it, full kelly just doesn’t work due to market capacity limits 

---

## 2020-05-19 12:08:40 - strategies channel

**SrFabio**

Have you guys tried the Kelly Criterion staking by any chance?

---

## 2020-05-19 12:03:54 - strategies channel

**SrFabio**

Would you not be interested to see if different staking would considerably alter the profitability of your strategy? From what this book has shown (despite being a simple Montecarlo simulation) using a "better" staking approach allowed for a much sustainable bankroll growth rate  vs traditional flat stake of fixed percent stakes

---

## 2020-05-19 11:59:19 - strategies channel

**MacrcoPolo**

Money management only matters if your strategy will work with a flat stake

---

## 2020-05-19 11:58:42 - strategies channel

**SrFabio**

I still feel a bit confused as to when exactly we should factor in the staking approach on a strategy, do we define the strategy and use montecarlo simulations to try the money management approaches or should that be integral part of the strategy itself?

---

## 2020-05-19 11:57:14 - strategies channel

**SrFabio**

Do you guys normally try different money management approaches when testing the strategies? Seeing the results based on a percentage staking vs kelly criterion approach. I recently finished reading a book that simulated this and the results were very interesting/surprising

---

## 2020-05-19 11:45:41 - strategies channel

**James T**

Backtesting does have its caveats though, as much as I advocate it. You can’t account for market impact or how the market will react to your bets. And that can be enough to kill a live strategy compared to its backtest. 



eg. If you offer, you can’t know if someone will undercut you. If you take, you don’t know how the book will react (potentially further down the line). 



I know [@U4H19D1D2](@U4H19D1D2) had some great ideas on measuring market impact. I’m hoping he’ll include a page on that too when he has time!

---

## 2020-05-19 11:39:38 - strategies channel

**James T**

In terms of strategy sensitivity to latency it really depends on the strategy. I would expect something fundamental based to be less sensitive to arbitrage for example. I would class what I do as statistical arbitrage, and I’m sensitive to around 100ms when betting pre-race. ie. I can notice lower returns with an extra delay of 100ms. 1ms not. 

---

## 2020-05-19 11:09:10 - strategies channel

**James T**

Horses and dogs are good because there’s a lot of them and a lot of liquidity every single day of the year so a good basis for building a staple. At least that’s why I initially chose it. 



It also has mostly smooth continuous movement in odds rather than being governed by discrete events like goals or sets which helps to make strategy returns less volatile. There’s obviously a lot more pre-event movement than in the other sports too. 



But in terms of how much you can win, I expect it’s of the same magnitude as any of the other big sports. 

---

## 2020-05-18 23:09:18 - strategies channel

**SrFabio**

Thanks! I'd like to ask a question as I'm a bit confused: when building a trading model do you guys mostly seek statistical arbitrage opportunities based on historical data or is there something better to look for?

---

## 2020-05-18 21:35:16 - random channel

**PeterLe**

Evening Folks,

I mentioned on this channel a few weeks ago that a new book was due out called Flash Crash by Liam Vaughan. It tells the story of Navinder Singh Sarao, a UK based day trader who traded the stock market from a standing start (from his bedroom) to amass a fortune of ~£70m!..and then supposedly loose it...

Enjoyed reading it, although a large proportion of the book is centred on the regulatory side of things.

Some soundbites I took: 



- Nav was sell taught

- His strategy was a simple scalping technique, by placing orders out of the money (on what we class as the back side), to skew the weight of money to give the appearance that sellers were in the market. Ie to push the price down. Tactics that are used on Betfair every day (probably by a few of us on here :-)

- He ended up using a standard platform “Trading Technologies” (TT) and had some additional features programmed in by a software engineer at TT. He subsequently had a guy from Edge Technologies to further enhance those features and add a couple more (to take on the HFT’s)

- He wasn’t 100% on auto. Rather, he traded manually with these extra “weapons” as he describes it

- He didn’t write any of his own code

- At his peak he was making upto £900K/Day

- He never spent anything! (Think he treated himself to a new bike and the odd McDonalds:-)

- He attributed his success to his pattern recognition and fast reactions, the numbers dont lie, so can you doubt it?



If anything I think the book tried to paint a picture of his character, that I didn’t quite like. A bit of a dis service to him IMO. He is obviously a clever guy and its not always possible to determine intelligence or judge someone on how they come across that is perhaps different to the norm.

I dont think this will lend itself to a film/movie (Unlike The Big Short), However, it does make a good story and especially to us on here as a glimpse of the art of the possible!!

---

## 2020-05-18 08:21:22 - strategies channel

**liam**

You guys mind if I take some of the above and put it in an area of the docs? Probably flumine rather than bflw, 'strategy development'

---

## 2020-05-18 07:53:41 - general channel

**Mo**

This is the official documentation: [https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-MarketBook](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-MarketBook)



Probably best just to look at the betfairlightweight source and/or click around the objects in Spyder.



[@U4H19D1D2](@U4H19D1D2) - any examples that show getting the best prices for each runner from a market book?

---

## 2020-05-17 19:50:22 - strategies channel

**Lee**

I can’t get this out of my head. Are people really doing this amount from a single strategy? Are some of them in this group?

---

## 2020-05-17 16:27:02 - strategies channel

**James T**

From what I’ve read, flumine isn’t quite ready yet? Or just about ready for testing? That’s basically what you want to use if you don’t have a backtesting system of your own. Then you just need the data to backtest with. And hope the backtest is a good representation of live betting. Which it mostly is at low stakes and when taking volume. 

---

## 2020-05-17 16:24:04 - strategies channel

**James T**

Well without knowing what the strategy edge is supposed to be (and I guess it might not always be that clear anyway), yes, I’d include everything. 



Are you backtesting or betting live? I would personally backtest so I can try lots of variations in a short space of time, not risk money, etc... But keep a set of out-of-sample data which I can verify the strategy on afterwards. 

---

## 2020-05-17 16:14:07 - strategies channel

**James T**

Yeah, definitely sounds like overfitting by choosing historically profitable venues without good reason. In fact if it doesn’t work for some venues then you need to question why - or it could just be your sample is too small. 



I supposed volume could be an issue if that’s somehow related to your strategy. 

---

## 2020-05-17 16:10:47 - strategies channel

**Lee**

Not yet, i'm just starting with simple strategies by venue and then try to tweak and improve them by looking for certain signals. I just tested by venue to begin with as I thought it's easy way to decide on a subset of the data which had volume.

Thats another reason why my sample size is low. I can add in more races but then i'd be choosing venues which show a profit with the strategy, which also makes me think i'm "forcing" a result rather than getting the "true" result.

---

## 2020-05-17 15:49:19 - strategies channel

**Mo**

This was a good talk at MathSport 2019 "Establishing a performance edge in P2P betting": [https://rstudio-pubs-static.s3.amazonaws.com/509874_7a4aef970d924450bb246cc4b5128d52.html](https://rstudio-pubs-static.s3.amazonaws.com/509874_7a4aef970d924450bb246cc4b5128d52.html)

---

## 2020-05-17 15:44:17 - strategies channel

**Mo**

Of course, a strategy could also be considered very successful if it produces consistent low volatility returns

---

## 2020-05-17 15:20:48 - strategies channel

**Lee**

I don't think it's relying on long shot bets coming in. I'm just thinking i might have just tweaked my strategy to work with a small dataset instead of what the real market will return. Can't wait for more data quick enough :slightly_smiling_face:

---

## 2020-05-17 15:18:40 - strategies channel

**Mo**

What are the average odds you're betting at? i.e. is the profitability of the strategy dependent on a few long shot bets coming in? Then periods of sustained losses and big jumps in profit are to be expected

---

## 2020-05-17 15:09:57 - strategies channel

**Unknown**

I don't currently have more data to backtest more but would this be considered a good strategy or are the days with large losses a concern? (ignore the currency)

---

## 2020-05-15 08:58:13 - general channel

**Jonjonjon**

This is my hacked up version of your PriceRecorder:



```from collections import defaultdict



from flumine import BaseStrategy

from flumine.utils import get_price



EPS=1e-6



def diff(a: dict, b: dict):

    """

    Return a minus b



    :param a:

    :param b:

    :return:

    """



    result = {}

    for k, v in a.items():

        difference = v - b.get(k, 0.0)

        if abs(difference)&gt;EPS:

            result[k] = difference



    return result





class PriceRecorder(BaseStrategy):

    """

    Example strategy for recording prices

    from historical or live data.

    """



    def __init__(self, *args, **kwargs):

        BaseStrategy.__init__(self, *args, **kwargs)

        self.market_data = defaultdict(list)

        self.runner_data = defaultdict(lambda: defaultdict(list))

        self.runner_names = defaultdict(dict)

        self._prior_traded_volume = defaultdict(dict)

        self._prior_publish_time = {}

        self.traded_volumes = defaultdict(lambda: defaultdict(list))



    def check_market_book(self, live_market, market_book):

        return market_book.inplay==False



    def process_market_book(self, live_market, market_book):



        market_data = self.market_data[market_book.market_id]

        prior_publish_time = self._prior_publish_time.get(market_book.market_id)

        self._prior_publish_time[market_book.market_id] = market_book.publish_time



        if not market_book.market_id in self.runner_names:

            runners = market_book.market_definition.runners

            d = {runner.selection_id:runner.name for runner in runners}

            self.runner_names = d



        is_currency_update = False



        for runner in market_book.runners:

            runner_data = self.runner_data[market_book.market_id][runner.selection_id]



            k = (market_book.market_id, runner.selection_id)

            prior_traded_volume = self._prior_traded_volume[k]

            traded_volume = {ps['price']:ps['size'] for ps in runner.ex.traded_volume}

            traded_volume_diff = diff(traded_volume, prior_traded_volume)

            self._prior_traded_volume[k] = traded_volume

            if traded_volume_diff:

                min_price = min(traded_volume_diff)

                max_price = max(traded_volume_diff)

                volume = sum(traded_volume_diff.values())



                if prior_publish_time.hour!=market_book.publish_time.hour:

                    if len(traded_volume_diff)&gt;1:

                        is_currency_update = True

                        print('Skipping ', market_book.publish_time)



                if min(traded_volume_diff.values())&lt;0.0:

                    is_currency_update = True



                # if market_book.publish_time&gt;=datetime.datetime(2020, 1, 1):

                #     if max_price==4:

                #         print('stpo')

            else:

                min_price = None

                max_price = None

                volume = 0



            is_currency_update=False



            if not is_currency_update:

                atb = get_price(runner.ex.available_to_back, 0)

                atl = get_price(runner.ex.available_to_lay, 0)



                if max_price and (max_price&gt;atl):

                    print('depth was hit')



                runner_data.append(

                    [

                        market_book.publish_time,

                        runner.last_price_traded,

                        atb,

                        atl,

                        max_price,

                        min_price,

                        volume

                        ]

                )



        market_data.append([

            market_book.market_id,

            market_book.publish_time,

            market_book.status,

            market_book.inplay,

        ])```

---

## 2020-05-14 18:35:31 - issues channel

**brightcake**

seem to be getting this error 'errorCode': 'INVALID_SESSION_INFORMATION' when trying to initiate an instance of 'trading.betting.list_event_types'. It seems to work fine outside of an object but as soon as I encase it within a class it gives me this strange behaviour. Does anyone know what this could be?

---

## 2020-05-14 12:45:08 - general channel

**liam**

[@U01093Z1KF0](@U01093Z1KF0) are you looking at the latest version? Moved to a strategy framework rather than market listeners 

---

## 2020-05-13 22:15:39 - general channel

**Jonjonjon**

Suppose I want to chart the best available to back/lay and traded prices for 1.166902450 (Warrenpoint v Crusaders, MATCH_ODDS). I have the free ADVANCED data from Betfair.



Is there an existing way to do this using bflw/flumine? Or would I need to subclass BaseStrategy, and make something similar to MarketRecorder, but that gives me what I want?

---

## 2020-05-13 15:34:24 - random channel

**Unknown**

I think it can depend on what the strategy is doing and it works both ways, here is something I haven't touched since I created it (very simple)

---

## 2020-05-13 15:20:22 - random channel

**Lee**

So a profitable strategy eventually loses it's edge over time and needs optimizations

---

## 2020-05-12 20:44:26 - general channel

**Jonjonjon**

I can't see a loop. I just want to run the Liam's sample code over a whole folder like this example. but I guess I can just create a new "LowestLayer" for each market inside a separate process:



```folder = '/home/jon/bet_data/ADVANCED/2020/Jan/4/29638355'

markets = os.listdir(folder)

markets = [x for x in markets if x.endswith('.bz2')]

markets = [os.path.join(folder, x) for x in markets]



strategy = LowestLayer(

    market_filter={"markets": markets},

    max_order_exposure=1000,

    max_selection_exposure=10,

    context={"stake": 2},

)

framework.add_strategy(strategy)```



---

## 2020-05-12 13:31:57 - general channel

**deactivateduser**

one more question what's the difference between exchange api and vendor api. if i want to make my own website my own betting system. what should i go for ?

---

## 2020-05-12 13:21:38 - general channel

**deactivateduser**

Hey guys I am solo in making a betting website. and i am not experienced like you guys. can someone tell me if is there any way to make python backend using betfair api without writing codes your self ? and if possible front end also. where i can just put my information app key username site name and all and rest is already done ?

---

## 2020-05-12 09:10:57 - general channel

**liam**

for me, if I have a strategy that is profitable over a day or two I chuck it straight in and see what happens, leave it for a week or two and then look at the profit vs any variables it used

---

## 2020-05-12 09:05:30 - general channel

**Lee**

Is there a general rule of thumb how much backtesting I should do before testing a strategy on live markets?

---

## 2020-05-12 08:54:59 - general channel

**Jonjonjon**

Is that from the example inplay strategy?

---

## 2020-05-11 17:09:28 - general channel

**liam**

FYI flumine dev branch can now handle place/cancel simulated execution, added an example strategy, lots likely to change / beware of bugs

---

## 2020-05-11 17:02:50 - general channel

**James T**

Yeah, any strategy which has to close before the off to be profitable is always going to run the risk of exchange crashes. Presumably profit from when it’s working has to outweigh the risk that’s taken. 

---

## 2020-05-11 16:55:08 - general channel

**Oliver Varney**

I think it mainly comes down to strategy bank size as youve said. just wondered as some of the strategies are not designed to be exposed at racetime

---

## 2020-05-11 10:00:19 - issues channel

**Schwaino**

```def bet(marketid, runnerid, odds):

    bank = 300

    stake = round(bank/20/odds,2)

    limit_order_filter = betfairlightweight.filters.limit_order(

    size= stake, 

    price=10,

    persistence_type='MARKET_ON_CLOSE')

    

    instructions_filter = betfairlightweight.filters.place_instruction(

    selection_id=str(runnerid),

    order_type="LIMIT",

    side="BACK",

    limit_order=limit_order_filter)

    

    order = trading.betting.place_orders(

    market_id=str(marketid), # The market id we obtained from before

    customer_strategy_ref='back_the_fav',

    instructions=[instructions_filter]) # This must be a list)

    return order```

---

## 2020-05-08 16:01:08 - random channel

**Mo**

I think for a lot of newbies it is secret sauce. Most people seem to want to start by either building a machine learning model to predict horses and end using features everyone else is already incorporating or some kind of generic time series analysis model to predict price movements as if that’s not driven by fundamental factors. 

---

## 2020-05-08 15:55:02 - random channel

**MacrcoPolo**

It's not secret sauce - it's a well known approach to markets. The secret sauce would be in the implementation, as it's a fairly obvious idea for a strategy. Doing well at xmarket arb requires a lot of attention on the details. Essentially you have an execution problem - how do I get the positions I want?

---

## 2020-05-07 15:16:26 - strategies channel

**Mo**

Did some modelling for it in the past but not trading it now

---

## 2020-05-06 11:25:04 - general channel

**liam**

```trading.betting.place_orders(.. async_=True)```

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L483](https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L483)

---

## 2020-05-06 07:07:22 - general channel

**liam**

Welcome, many (including myself) came from BA or gruss but moved after wanting to do more. For me it was the challenge (can I write this strategy in my own code) as well as the ability to collect my own data and complete flexibility that coding gives you.



However it’s worth noting that it’s a steep learning curve if you are new to programming or don’t have something already ‘working’ using off the shelf software.

---

## 2020-05-03 08:53:05 - random channel

**liam**

With flumine the target is making a simple framework which is going to come at a cost of performance. 

However eventually we can add the ability to use lightweight mode and handle the raw json, this will rapidly speed up backtesting, not worth it for the 99% when live trading unless speed is a priority or you are processing lots of markets. 



Very keen on benchmarking, with my own framework it’s about a minute for each racing market or sub 10s when using lightweight mode. I use a variation of threads, processes and AWS lambda for overnight backtesting. 

---

## 2020-05-01 22:42:37 - general channel

**Ruben**

```# Create stream

stream = trading.streaming.create_stream(listener=listener)

market_filter = bflw.filters.streaming_market_filter(event_type_ids=["1"], market_types=["MATCH_ODDS"])

market_data_filter = bflw.filters.streaming_market_data_filter(fields=["EX_BEST_OFFERS"], ladder_levels=3)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



t = threading.Thread(target=stream.start, daemon=True)

t.start()



# check for updates in output queue

while True:

    market_books = output_queue.get()



    for market_book in market_books:

        print(

            market_book,

            market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

            market_book.streaming_update,  # json update received

            market_book.market_definition,  # streaming definition, similar to catalogue request

            market_book.publish_time,  # betfair publish time of update

        )```

Hi guys, I'm following the streaming tutorial and I am trying to adapt the example code to retrieve the best available lay/back prices, for all soccer games. I would expect this to work, however, market_books seems to be always empty

---

## 2020-04-30 11:52:17 - issues channel

**Julio**

I thought about this, but then i'll still have the issue, with the place_order(). I think i'll have to rewrite my code, to put the strategy and the marketdata/orders into different threads.

---

## 2020-04-30 10:16:40 - strategies channel

**AP**

This may not relate at all but I did an internship at an options market making firm and I found that they barely used ML models at all, most of their systems and strategies were designed from good old fashioned empirical research and trial and error

---

## 2020-04-30 09:43:46 - strategies channel

**Paul**

"The application of recurrent layers in this approach is investigated. The experiments were performed on real anonymized data. The best architecture demonstrated a trading strategy for the RTS Index futures (MOEX:RTSI) with a profitability of 66% per annum accounting for commission." :eyes:

---

## 2020-04-29 09:33:35 - random channel

**Mo**

I think of it like this: if you remove the overround by dividing by the booksum then you are assuming that bookmakers (or aggregate exchange participant behaviour) applies the overround for each selection proportionally to the odds. An alternative assumption is that Shin's theoretical framework is true and the odds arise from how bookmakers would set the odds to protect themselves from insider trading. Neither of these assumptions is going to be a perfect model of reality but you can judge them on their output - how accurate the inferred probabilities are.

---

## 2020-04-28 18:31:47 - random channel

**Mo**

I think Shin's paper is immediately useful to almost every betting strategy. Here's my implementation: [https://github.com/mberk/shin](https://github.com/mberk/shin)

---

## 2020-04-28 10:15:23 - random channel

**Mo**

Might take me a while, the Kelly criterion book is 850 pages...

---

## 2020-04-28 09:13:35 - random channel

**Jonjonjon**

Random question, but does anyone use Tensorflow for sports betting purposes?

---

## 2020-04-27 12:01:47 - random channel

**James T**

Hi DC, by coincidence I got an agent email looking for a C++ developer with low latency and or trading platform experience. Contract job, potentially long term though. DM me your email and I’ll forward to you. 

---

## 2020-04-27 11:18:33 - random channel

**D C**

Morning all. Sorry to have to ask such a question irrelevant to botting/betting but desperate times call for desperate measures! Does anyone know anywhere currently recruiting C++ developers in the London or Cambridge areas????? Or at a push (former) mathematicians?

---

## 2020-04-25 11:52:07 - issues channel

**liam**

Ah I might have a look, my stolen stackoverflow function may creates issues but it’s only to deal with the length restriction betfair put on the reference. I looked at using the startegyRef in conjunction but thy would mean using a separate package per execution per strategy which just over complicates things 

---

## 2020-04-24 17:05:42 - issues channel

**Dave**

Precisely yep - basically added a dict in Markets class to hold orders by market ID on startup, and when a new market is added it checks if there are any orders in that dict and adds as a list called "recovered_orders" to the market object so it's accessible thereafter. Ideally I'd convert those bflw order objects into the Flumine Order/Trades objects so their lifecycles are automatically habdled but don't wanna invest time in making that yet hah, I will just check market.orders and market.recovered_orders together when looking at my open orders. My strategy is pretty simple so this works for me as a quick hack to get going but is an ugly solution

---

## 2020-04-24 15:48:23 - issues channel

**liam**

it currently uses the strategyRef more as an instanceRef as the hostname is used rather than the strategy name, maybe this needs to be changed to {hostname}-{strategy_name} but I am very wary of making things complicated

---

## 2020-04-24 15:26:55 - issues channel

**Newbie99**

Would using the customer_strategy_ref be an option to do a sweep on startup/restart and have flumine look for only those refs that had a match with a current strategy?

---

## 2020-04-24 14:39:45 - issues channel

**Dave**

ahh I see, fair enough. Just thinking about recovery after a disconnect/restart - I guess you'd just have to use the http client to get current orders with the same strategy ref and manually create order objects and load em into the blotter yourself I suppose (provided you want to manage them at strategy-ref level and nothing more fine-grained)

---

## 2020-04-24 14:36:02 - issues channel

**liam**

No, not currently, was thinking about this today, the issue is that currently it will only pick up orders that have been created by itself, if its changed to pull in all orders what do we do about the trade/strategy that its linked to. I guess they would be orphaned orders, my preference would be not to go down this route at all

---

## 2020-04-24 08:10:09 - random channel

**Newbie99**

Just going back to the high latency warnings, I got some strange ones last night (which might just be a limitation of my machine, in which case so be it, but wanted to get the opinion of others):



`CRITICAL:streaming_errors:MarketStreaming run error`

`MemoryError`



`During handling of the above exception, another exception occurred:`



`Traceback (most recent call last):`

  `File "D:\Python37\lib\site-packages\betfairlightweight\resources\bettingresources.py", line 504, in __init__`

    `self.ex = RunnerBookEX(**ex) if ex else None`

  `File "D:\Python37\lib\site-packages\betfairlightweight\resources\bettingresources.py", line 377, in __init__`

    `self.available_to_lay = [PriceSize(**i) for i in availableToLay]`

`MemoryError`



`During handling of the above exception, another exception occurred:`



`Traceback (most recent call last):`

  `File "D:\Python37\webpages\streaming_errors.py", line 46, in run`

    `self.stream.start()`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 59, in start`

    `self._read_loop()`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 209, in _read_loop`

    `self._data(received_data)`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 248, in _data`

    `if self.listener.on_data(received_data) is False:`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\listener.py", line 127, in on_data`

    `self._on_change_message(data, unique_id)`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\listener.py", line 167, in _on_change_message`

    `self.stream.on_update(data)`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\stream.py", line 59, in on_update`

    `self._process(data[self._lookup], publish_time)`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\stream.py", line 153, in _process`

    `self.unique_id, market_book, self._lightweight`

  `File "D:\Python37\lib\site-packages\betfairlightweight\streaming\cache.py", line 229, in create_resource`

  `File "D:\Python37\lib\site-packages\betfairlightweight\resources\bettingresources.py", line 585, in __init__`

    `self.runners = [RunnerBook(**i) for i in kwargs.get("runners")]`

`MemoryError`

---

## 2020-04-22 20:17:08 - general channel

**Chris**

I'm testing my model on US since GB/IRE isnt available

---

## 2020-04-21 16:51:08 - general channel

**liam**

bflw is a wrapper to the api, flumine is a trading framework (that uses bflw)

---

## 2020-04-19 21:51:00 - random channel

**Dave**

[https://www.google.com/amp/s/www.bloomberg.com/amp/news/articles/2020-04-17/renaissance-says-quant-models-misfired-during-march-mayhem](https://www.google.com/amp/s/www.bloomberg.com/amp/news/articles/2020-04-17/renaissance-says-quant-models-misfired-during-march-mayhem)

---

## 2020-04-19 17:51:14 - random channel

**Lee**

There was me wondering when you actually feel comfortable leaving an automated strategy. I’m only using small stakes and have a small amount in my account so not a big deal losing it.

I’ll think differently if i had a bigger account.

---

## 2020-04-18 18:19:46 - general channel

**Lee**

Hi Liam, i was just looking through the dev branch for flumine and was curious what would be some examples of the trading_controls

---

## 2020-04-17 12:03:11 - issues channel

**Josh**

Hi all, having trouble reading .bz2 files. Have passed in full path to code and unzipped files

```# create historical stream, update directory to file location

stream = trading.streaming.create_historical_stream(

    directory="C:/1.166899581",

    listener=listener,

)```

Seems to work but no output other than headers



```INFO:betfairlightweight.streaming.listener:Register: marketSubscription 0

INFO:betfairlightweight.streaming.stream:[Stream: 0]: "HistoricalStream" created```

Thanks for any help in advance

---

## 2020-04-16 14:34:59 - issues channel

**Newbie99**

```import account_info as ai

import logging

import betfairlightweight as bf



logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = bf.APIClient(ai.accname, ai.accpass, ai.acckey, certs=ai.path)

trading.login()



filters = bf.filters





market_catalogues = trading.betting.list_market_catalogue(

    filter=filters.market_filter(event_type_ids=[7],

                                 market_countries=["AU"],

                                 market_type_codes=["WIN"]

                                 ),

    market_projection=[

        "MARKET_START_TIME",

        "MARKET_DESCRIPTION",

        "EVENT"

    ],  # runner description required

    sort="FIRST_TO_START",

    max_results=800,

)



def check_rules(rules, search_string):

    check_rules = True if search_string in str(rules) else False

    return check_rules



for market_catalogue in market_catalogues:

    print(market_catalogue.market_name, ' ', market_catalogue.event.venue, ' ', check_rules(market_catalogue.description.rules, 'This is a Racing NSW Turnover Charge market'))```

This is a back of an envelope way to check market catalogue, looking at Aussie Racing markets and seeing if that text string is included in the rules.

---

## 2020-04-15 19:46:46 - general channel

**Lee**

I’m just looking for the races with volume and put my strategy against them purely for testing. Figured i can backtest all I like but that doesn’t validate my actual order part of the code

---

## 2020-04-15 09:06:08 - general channel

**liam**

using strategy.runner_context, all of which can be overridden or adapted if you want the ability to handle it yourself

---

## 2020-04-15 09:05:31 - general channel

**liam**

place_order will call validate_order first which will check that the market/runner/strategy is not already 'live'

---

## 2020-04-15 08:52:45 - general channel

**Unknown**

yeah it is at the moment due to it being in constant development, this is an example strategy of how it would work

---

## 2020-04-15 08:50:56 - general channel

**mandelbot**

i'm more interested in the mechanics of the library and how to use the different methods and classes etc. I'm a novice when it comes to code and find it helps me learn much quicker to work with and try to alter example code. So lets say you get a signal from your prediction model, and you want to place a bet x ticks above best back price when available volume is &gt; 100, odds &lt; 10 and time left till the off is &gt; 3 mins. Just as an example.

---

## 2020-04-15 07:09:03 - general channel

**Mo**

I'm up for this in principle but it would take me a while to put something together.



But if you're not interested in the secret sauce - let's say that's the prediction model and, to a lesser extent, the staking strategy - then what about it are you looking for insight into?

---

## 2020-04-14 20:48:29 - general channel

**mandelbot**

Would someone care to share an example of an implementation of a strategy? Can take the secret sauce out or something that isn't profitable. A non basic example would be really useful for me.

---

## 2020-04-14 20:10:59 - general channel

**Lee**

Just ran my first strategy placing real bets :slightly_smiling_face:

---

## 2020-04-14 17:08:12 - random channel

**brightcake**

If any of you are looking for financial trading strategies this paper might be of help - [https://journals.sagepub.com/doi/pdf/10.1057/s41265-016-0034-2](https://journals.sagepub.com/doi/pdf/10.1057/s41265-016-0034-2)

---

## 2020-04-13 20:06:45 - random channel

**James T**

I’ve been using Keras/Tensorflow in Python and saving models in .h5 format which can be converted to onnx models and loaded into [http://ML.Net|ML.Net](http://ML.Net|ML.Net) libraries to run predictions within C#, so actually no refactoring required. I haven’t looked into the Azure specific services though. 

---

## 2020-04-13 20:01:55 - random channel

**Silver Drifter**

James, I'm looking at the Azure stuff now for ML &amp; AI - I like your approach of using existing Python models and refactoring into c#, etc

---

## 2020-04-13 20:00:29 - random channel

**James T**

I’ve always started from the Betfair C# samples and gone from there. Never had any issues with the language. Even for ML work I’ve been doing recently I’ll do the R&amp;D in Python and then serialise the model and load it into C# for production use. 

---

## 2020-04-13 18:44:33 - strategies channel

**Jonjonjon**

Probably dependent on person and strategy. I don't need more than 5 figures in my account. I could probably manage just as well on 4 figures as I place lots of wide orders that rarely get filled. If I stopped that I could manage on low 4 figures.

---

## 2020-04-13 10:03:43 - general channel

**liam**

open to any other methods though as I don't do much hedging, for me it tends to be: place order -&gt; order matched -&gt; place offset -&gt; cancel offset | wait for offset to be matched -&gt; reset strategy

---

## 2020-04-12 20:33:56 - general channel

**Ruben**

Yeah makes sense; despite that, letting everyone access the platform and limiting yourself to collecting a % of the profits does not sound like a bad business model either. But as you say, their current approach is probably more profitable for them

---

## 2020-04-12 13:42:49 - strategies channel

**Jonjonjon**

If bflw stops working for you, it is like getting fired

And searching for the next strategy is just like a continuous job interview process.

---

## 2020-04-12 11:48:50 - random channel

**Mo**

Ed Thorpe is my role model

---

## 2020-04-11 19:05:41 - issues channel

**Lee**

```(.venv) ➜ git:(master) ✗ python [http://example.py|example.py](http://example.py|example.py) &amp;&amp; date

{"asctime": "2020-04-11 18:03:44,005", "levelname": "INFO", "message": "Creating new &lt;class 'flumine.streams.historicalstream.HistoricalStream'&gt; (1000) for strategy Ex"}

{"asctime": "2020-04-11 18:03:44,006", "levelname": "INFO", "message": "Creating new &lt;class 'flumine.streams.historicalstream.HistoricalStream'&gt; (2000) for strategy Ex"}

{"asctime": "2020-04-11 18:03:44,006", "levelname": "INFO", "message": "Starting flumine"}

{"asctime": "2020-04-11 18:03:44,006", "levelname": "INFO", "message": "Register: marketSubscription 0"}

{"asctime": "2020-04-11 18:03:44,006", "levelname": "INFO", "message": "[Stream: 0]: \"MarketStream\" created"}

{"asctime": "2020-04-11 18:03:44,006", "levelname": "INFO", "message": "Starting historical market 'marketdata/1.169499207'"}

{"asctime": "2020-04-11 18:03:44,009", "levelname": "INFO", "message": "[MarketStream: 0] 1.169499207 added, 1 markets in cache"}

{"asctime": "2020-04-11 18:03:44,012", "levelname": "INFO", "message": "Adding: 1.169499207 to live markets and blotter"}

{"asctime": "2020-04-11 18:04:11,383", "levelname": "INFO", "message": "Completed historical market 'marketdata/1.169499207'"}

{"asctime": "2020-04-11 18:04:11,384", "levelname": "INFO", "message": "Register: marketSubscription 0"}

{"asctime": "2020-04-11 18:04:11,384", "levelname": "INFO", "message": "[Stream: 0]: \"MarketStream\" created"}

{"asctime": "2020-04-11 18:04:11,384", "levelname": "INFO", "message": "Starting historical market 'marketdata/1.169499212'"}

{"asctime": "2020-04-11 18:04:11,387", "levelname": "INFO", "message": "[MarketStream: 0] 1.169499212 added, 1 markets in cache"}

{"asctime": "2020-04-11 18:04:11,389", "levelname": "INFO", "message": "Adding: 1.169499212 to live markets and blotter"}

{"asctime": "2020-04-11 18:04:36,102", "levelname": "INFO", "message": "Completed historical market 'marketdata/1.169499212'"}

{"asctime": "2020-04-11 18:04:36,102", "levelname": "INFO", "message": "Backtesting complete"}

{"asctime": "2020-04-11 18:04:36,102", "levelname": "INFO", "message": "Exiting flumine"}

Sat Apr 11 19:04:45 BST 2020```



---

## 2020-04-11 16:48:57 - issues channel

**Lee**

When using flumine to backtest with multiple files I get a delay from when I get the log message `Exiting flumine` to when it actually exits which increases with more files ranging from 10-20 seconds per a file. When I had 6 files I had to wait for 120 seconds. I’m adding multiple files like below:

```strategy = Ex(

    market_filter={

        "markets": [

            "marketdata/1.169499207",

            "marketdata/1.169499212",

            .......

        ]

    }

)```



---

## 2020-04-09 06:41:30 - issues channel

**JK**

Hey guys, ive got some historic stream data in bz2 files, 1 per market, but im having trouble reading it. Im using the example script at [https://github.com/liampauling/betfair/blob/master/examples/examplestreaminghistorical.py](https://github.com/liampauling/betfair/blob/master/examples/examplestreaminghistorical.py)



My main code looks like this



```# create listener

listener = HistoricalListener(max_latency=None)



# create historical stream, update directory to file location

stream = trading.streaming.create_historical_stream(

    directory='../data/Jan/1/29636351',

    listener=listener,

)



# start stream

stream.start()```

But I am getting the error `[Errno 13] Permission denied: '../data/Jan/1/29636351` , anyone else had this issue? Have googled to no avail. Is this the correct way to write the data to txt?

---

## 2020-04-08 18:27:03 - issues channel

**Christian Tox**

Yea that's what I expected too. If I



`print(trading.session_token)`



it returns the correct token. But trading.login_interactive still gives same error

---

## 2020-04-08 18:22:09 - issues channel

**Christian Tox**

Hmm I go:

`session_token = "token string"`

`trading = betfairlightweight.APIClient(username= "username", password="password", app_key="app key")`

`trading.set_session_token(session_token=session_token)`

`trading.login_interactive()`



And get it again:

`betfairlightweight.exceptions.LoginError: API login: DANISH_AUTHORIZATION_REQUIRED`

---

## 2020-04-08 14:46:59 - issues channel

**Christian Tox**

Hi, to be clear, I did this upon receiving the error:



`trading = betfairlightweight.APIClient(username="", password="", app_key="")` 

`trading.login_interactive()`



then got error



`betfairlightweight.exceptions.LoginError: API login: DANISH_AUTHORIZATION_REQUIRED`



thank you.

---

## 2020-04-05 12:41:03 - issues channel

**Mo**

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py|https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py|https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py)

---

## 2020-04-04 23:59:31 - issues channel

**Max**

Hi all, could anyone help me debug this error? I'm running the historical examples from [https://github.com/liampauling/betfair/blob/master/examples/examplehistoricdata.py](https://github.com/liampauling/betfair/blob/master/examples/examplehistoricdata.py). Everything works until `get_file_list`: [https://github.com/liampauling/betfair/blob/master/examples/examplehistoricdata.py#L38-L52](https://github.com/liampauling/betfair/blob/master/examples/examplehistoricdata.py#L38-L52)



It fails with this error; any ideas?



```---------------------------------------------------------------------------

JSONDecodeError                           Traceback (most recent call last)

/usr/local/lib/python3.7/site-packages/betfairlightweight/endpoints/historic.py in request(self, method, params, session)

    164         try:

--&gt; 165             response_data = response.json()

    166         except ValueError:



/usr/local/lib/python3.7/site-packages/requests/models.py in json(self, **kwargs)

    896                     pass

--&gt; 897         return complexjson.loads(self.text, **kwargs)

    898 



/usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/__init__.py in loads(s, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)

    347             parse_constant is None and object_pairs_hook is None and not kw):

--&gt; 348         return _default_decoder.decode(s)

    349     if cls is None:



/usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/decoder.py in decode(self, s, _w)

    336         """

--&gt; 337         obj, end = self.raw_decode(s, idx=_w(s, 0).end())

    338         end = _w(s, end).end()



/usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/decoder.py in raw_decode(self, s, idx)

    354         except StopIteration as err:

--&gt; 355             raise JSONDecodeError("Expecting value", s, err.value) from None

    356         return obj, end



JSONDecodeError: Expecting value: line 4 column 1 (char 6)



During handling of the above exception, another exception occurred:



InvalidResponse                           Traceback (most recent call last)

&lt;ipython-input-40-107c6aa3e9f7&gt; in &lt;module&gt;

     11     market_types_collection=["WIN", "PLACE"],

     12     countries_collection=["GB", "IE"],

---&gt; 13     file_type_collection=["M"],

     14 )

     15 print(file_list)



/usr/local/lib/python3.7/site-packages/betfairlightweight/endpoints/historic.py in get_file_list(self, sport, plan, from_day, from_month, from_year, to_day, to_month, to_year, event_id, event_name, market_types_collection, countries_collection, file_type_collection, session)

    114         params = clean_locals(locals())

    115         method = 'DownloadListOfFiles'

--&gt; 116         (response, elapsed_time) = self.request(method, params, session)

    117         return response

    118 



/usr/local/lib/python3.7/site-packages/betfairlightweight/endpoints/historic.py in request(self, method, params, session)

    165             response_data = response.json()

    166         except ValueError:

--&gt; 167             raise InvalidResponse(response.text)

    168 

    169         return response_data, elapsed_time



InvalidResponse: Invalid response received: 





[!DOCTYPE html](!DOCTYPE html)



&lt;html&gt;

&lt;head&gt;

    &lt;meta name="viewport" content="width=device-width" /&gt;

    &lt;title&gt;ngErrorRedirect&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;

    &lt;div&gt; 

        Error

    &lt;/div&gt;

&lt;/body&gt;

&lt;/html&gt;```

---

## 2020-04-02 10:44:14 - general channel

**Jeff**

I like manual trading and this project will give me something to do and learn about but unfortunately I don't know what to do first. I have Betfair historic horse racing data and Python installed with PyQt but I've hit a brick wall. I don't know where to start first?

---

## 2020-04-02 10:44:10 - general channel

**Mo**

Setting aside the idea of using the tool to place fictional bets, the ability to replay and visualise markets is useful for strategy development even if that strategy is going to be fully automated

---

## 2020-03-31 10:17:08 - issues channel

**mandelbot**

```Doh! Thanks, that was dumb. Although now I'm getting these: Traceback (most recent call last):

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\Lib\site-packages\flumine\examples\marketrecorder.py", line 46, in &lt;module&gt;

    framework.add_strategy(strategy)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\flumine\baseflumine.py", line 66, in add_strategy

    self.strategies(strategy)  # store in strategies

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\flumine\strategy\strategy.py", line 26, in _call_

    strategy.add()

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\Lib\site-packages\flumine\examples\strategies\marketrecorder.py", line 155, in add

    self.s3.head_bucket(Bucket=self._bucket)  # validate bucket/access

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\client.py", line 316, in _api_call

    return self._make_api_call(operation_name, kwargs)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\client.py", line 612, in _make_api_call

    http, parsed_response = self._make_request(

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\client.py", line 632, in _make_request

    return self._endpoint.make_request(operation_model, request_dict)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\endpoint.py", line 102, in make_request

    return self._send_request(request_dict, operation_model)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\endpoint.py", line 132, in _send_request

    request = self.create_request(request_dict, operation_model)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\endpoint.py", line 115, in create_request

    self._event_emitter.emit(event_name, request=request,

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\hooks.py", line 356, in emit

    return self._emitter.emit(aliased_event_name, **kwargs)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\hooks.py", line 228, in emit

    return self._emit(event_name, kwargs)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\hooks.py", line 211, in _emit

    response = handler(**kwargs)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\signers.py", line 90, in handler

    return self.sign(operation_name, request)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\signers.py", line 160, in sign

    auth.add_auth(request)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\botocore\auth.py", line 357, in add_auth

    raise NoCredentialsError

botocore.exceptions.NoCredentialsError: Unable to locate credentials```

---

## 2020-03-31 09:53:24 - issues channel

**mandelbot**

So im trying to run the example marketrecorder.py but I get the following error:

Traceback (most recent call last):

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\Lib\site-packages\flumine\examples\marketrecorder.py", line 46, in &lt;module&gt;

    framework.add_strategy(strategy)

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\flumine\baseflumine.py", line 66, in add_strategy

    self.strategies(strategy)  # store in strategies

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\lib\site-packages\flumine\strategy\strategy.py", line 26, in _call_

    strategy.add()

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\Lib\site-packages\flumine\examples\strategies\marketrecorder.py", line 154, in add

    super().add()

  File "C:\Users\Administrator\AppData\Local\Programs\Python\Python38\Lib\site-packages\flumine\examples\strategies\marketrecorder.py", line 37, in add

    raise OSError("File dir %s does not exist" % self.local_dir)

OSError: File dir /tmp does not exist



I tried to create the dir in question but get the same. What am I missing? Appologies for the dumb question, I'm new to python and coding and am still trying to understand how this library works.

---

## 2020-03-30 13:02:45 - general channel

**liam**

```    def _get_cleared_orders(self, event, client):

        from_record = 0

        while True:

            try:

                cleared_orders = client.betting_client.betting.list_cleared_orders(

                    bet_status="SETTLED",

                    from_record=from_record,

                    market_ids=[event.market_id],

                    customer_strategy_refs=[config.hostname],

                )

            except BetfairError as e:

                logger.error(

                    "_get_cleared_orders error",

                    extra={"trading_function": "list_cleared_orders", "response": e},

                    exc_info=True,

                )

                time.sleep(10)

                self.equine.account_queue.put(event)

                return



            [http://logger.info|logger.info](http://logger.info|logger.info)(

                "{0} cleared orders found, more available: {1}".format(

                    len(cleared_orders.orders), cleared_orders.more_available

                )

            )



            self.equine.log_control(ClearedOrdersEvent(event.market_id, cleared_orders))

            self.equine.handler_queue.put(

                ClearedOrdersEvent(event.market_id, cleared_orders)

            )



            from_record += 1000

            if not cleared_orders.more_available:

                break

        return len(cleared_orders.orders)```

---

## 2020-03-28 15:11:07 - strategies channel

**brightcake**

If you're able to trade rates products in any way I've heard there is some value in using the same models as central banks to forecast interest rates - might be something to look into. If you're interested, you should check out [https://www.sas.upenn.edu/~fdiebold/papers/paper49/Diebold-Li.pdf|Forecasting the term structure of government bond yields](https://www.sas.upenn.edu/~fdiebold/papers/paper49/Diebold-Li.pdf|Forecasting the term structure of government bond yields), central banks use a modified version of this model (I believe its the nelson siegal svensson model or something)

---

## 2020-03-28 14:08:04 - strategies channel

**brightcake**

What area in particular are you interested in? Unlikely that there will be anything interesting for trading strategy wise as most academics tend not to focus on this too much.

---

## 2020-03-26 20:16:35 - issues channel

**brightcake**

```logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))

trading = betfairlightweight.APIClient(username,

                                       password,

                                       app_key=app_key,

                                       certs=certs,

                                       cert_files=cert_files)



trading.login()

# trading.historic.read_timeout = 64

file_list = trading.historic.get_file_list(

    "Soccer",

    "Basic Plan",

    from_day=1,

    from_month=3,

    from_year=2017,

    to_day=31,

    to_month=3,

    to_year=2019

)

print(file_list)```

Code looks like this. I'm quite sure i've purchased all of the available football data, not sure what's going wrong here.

---

## 2020-03-26 17:10:19 - general channel

**Lee**

Look at the examples in the repo. Recording a market is implemented as a strategy

---

## 2020-03-24 17:21:34 - strategies channel

**Peter**

[@U01093Z1KF0](@U01093Z1KF0) There's a ton of papers out there findable by a simple Google search but no easy answers, though there are some clues as to where value might lie in some of the more fundamental papers, i.e. those that seek to understand the markets rather than simple build a model that's better than them. Tip: learn to spot and avoid the plethera of masters dissertations in this area - almost all a waste of time.

---

## 2020-03-24 16:49:12 - strategies channel

**Unknown**

Here is something recent that typifies the problem with academic research into betting applications: academics are quite naive about how the betting industry works. This paper advertises a profitable betting strategy but it's only profitable when you bet at the best odds available across a range of bookmakers and substantially unprofitable betting at the average odds.



Most likely, the model is utterly pointless and you could have shown you'd have been profitable taking the average odds as true and betting at the maximum odds.

---

## 2020-03-24 15:01:20 - strategies channel

**D C**

Specific to sports exchanges? You mean from a time series market type perspective or from a outcome prediction type approach with statistical models ?

---

## 2020-03-24 05:29:59 - general channel

**liam**

[@UU6AE43V0](@UU6AE43V0) many purchase historic data but you can record your own using [https://github.com/liampauling/flumine|flumine](https://github.com/liampauling/flumine|flumine) which is now being developed into a trading framework as well. I store the data in aws s3 and have an API/database which allows me to browse / search markets

---

## 2020-03-22 22:14:41 - general channel

**Rory**

just catching up on recent messages ... lots of good questions/discussion around ML ... we've been using it heavily in soccer for the last 2 years .. there is absolutely no doubt that machines are better at spotting patterns in large data sets than humans ... that's just proven beyond doubt by now with most of the publicly available models out there (think AWS image recognition, Google Translate, etc)



but sport by nature is pretty random, so it's a long slog to find the right combination of models to use and the right data to feed them ... we're definitely getting there but it takes a lot of dedication

---

## 2020-03-22 21:25:42 - issues channel

**Newbie99**

I'm getting the following:



  `File "D:\Python37\lib\site-packages\betfairlightweight\endpoints\betting.py", line 157, in list_market_catalogue`

    `(response, elapsed_time) = self.request(method, params, session)`

  `File "D:\Python37\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 51, in request`

    `check_status_code(response)`

  `File "D:\Python37\lib\site-packages\betfairlightweight\utils.py", line 17, in check_status_code`

    `raise StatusCodeError(response.status_code)`

`betfairlightweight.exceptions.StatusCodeError: Status code error: 400`



Which I'm guessing, is possibly due to to large a single listMarketCatalogue call on startup to get runner names (I can't see the error code in the docs, but that would make sense).



I was trying to keep the calls down to a minimum, but what is the best way to avoid this, is it just a case of call once per market on startup (once started is fine as then I only need to call on any runner changes)?

---

## 2020-03-21 13:49:17 - general channel

**kense**

Hi everyone. I have no experience whatsoever of Betfair trading. A friend of mine uses BetAngel with a variety of Excel spreadsheets, and asked if I would help him out in automating some of his processes. I found this project within a few minutes of Googling, though, and it seems like it makes more sense to skip BetAngel and Excel altogether and replicate the combined functionality with Flumine / Betfair API. Just wanted to introduce myself and apologise in advance for my SFQs!

---

## 2020-03-19 11:05:27 - issues channel

**brightcake**

feel like I might be missing something very obvious here but when I use the trading.historic.get_file_list() method I seem to be getting a timeout error: Exception: HTTPSConnectionPool(host='[http://historicdata.betfair.com|historicdata.betfair.com](http://historicdata.betfair.com|historicdata.betfair.com)', port=443): Read timed out. (read timeout=16)

---

## 2020-03-19 08:59:01 - general channel

**Jonjonjon**

It's definitely interesting. There are some excellent tutorials on deep reinforcement learning from Deepmind on Youtube. However, I  have not managed to used any ML successfully for betting. All my models are based on eyeballed observations.

---

## 2020-03-17 12:36:42 - general channel

**D C**

[@UUCD6P13J](@UUCD6P13J) Probably but through isolation boredom more than anything. Problem is that you have another potential unknown to factor in: global financial implosion. Fact is that the betting markets on the other side of this may not be anything like what they were prior to it. Will bookies/exchanges even survive? I am sure they will but really hard to see how life will change after this. May sound like hyperbole but that is how I am looking at it.

---

## 2020-03-15 06:16:49 - strategies channel

**Peter**

[@UUCD6P13J](@UUCD6P13J), I suspect you’re not getting much of a response because the question is way bigger than it looks. But I’ll bite … though I’m not sure you’ll find the answer very helpful!



I can only answer for myself, but I doubt I’m unusual, in saying that it’s both of the above and with way more nuance.



Pre-match predictions, basic or otherwise, aka fundamental analysis, can be useful for spotting where the market is getting it wrong. Most markets will start off a bit away from “fair odds” and work their way towards them as the market comes together - though as Liam has pointed out elsewhere, even then they’re not perfect then and money can still be made at starting prices.



Oftentimes the aim is not to use fundamental analysis to guess the event’s outcome, but simply to anticipate how the market is likely to move and then exit before the event starts, e.g. can you spot a set of circumstances where the favourite is habitually overbet.



Other strategies may ignore the fundamentals and simply look at what’s happening in the market, aka technical analysis or charting. So for example from the history of matched prices I might look for upper and lower bounds, aka resistance and support prices and trade pre-event between these extremes.



Yet another class of strategies uses the prices in one market, often WIN or MATCH_ODDS, to make inferences about related markets and trade on inconsistencies.



Other strategies will use fundamental and technical analysis, for example in-play soccer strategies will take note of how the market is moving with time decay and balance that against the probability of certain events (primarily goals) occurring based on information from matches with similar features.



So overall, it’s a big it depends and is one of the factors that makes this goal so interesting and creates so much space for wildly different approaches.



Given that, in the search for your first profitable strategy, I’d recommend that you dig where you feel most comfortable. Whichever of those two high level approaches calls loudest to you, there’s a profitable strategy waiting for you to discover it.

---

## 2020-03-14 10:38:25 - general channel

**Oliver Varney**

your going to struggle to find anyone willing to give there model away pal, not unless they want to shoot themself in the foot

---

## 2020-03-10 23:03:17 - general channel

**Jack Kaminski**

But I know from traditional quant models that the higher the IQ of the model the lower the return

---

## 2020-03-10 21:42:02 - general channel

**Chris**

Splitting the markets into smaller segments and rewarding the actions in each segment might be a step forward, but then you would need some criteria that decides what reward to give the model at each time step

---

## 2020-03-10 21:34:37 - general channel

**Chris**

You need a lot of data for one, and also you need to give the model rewards for its actions as soon as possible.. If it makes lots of decisions in a game but you only see the reward at the end, then the model has no way of knowing which decisons contributed to the end result

---

## 2020-03-10 21:27:51 - general channel

**Chris**

I could see simple models being used to aid strategies (predicting time until a race ends for example) but imo building something that would decide what bets to place and when would be extremely difficult, especially for a single person

---

## 2020-03-10 21:25:15 - general channel

**Chris**

Interesting to see a lot of conversation on ML here, does anyone else work in data science? or making ML models as a day job. Most people seem like software devs on here

---

## 2020-03-09 15:41:34 - issues channel

**jb**

Hey guys.  I normally use a VPN (at least from the laptop I tinker on), routing either thru Sweden or UK.  I sometimes get `LoginError: API login: BETTING_RESTRICTED_LOCATION` when logging in from either location - which goes away when I switch to the other one.  My account is registered to GB.



Anyone know what's going on - and also if betfair have any sensitivity about using VPNs etc?  Cheers.

---

## 2020-03-09 13:36:35 - general channel

**Jack Kaminski**

I won't bother him until I have a clear understanding of sports modelling

---

## 2020-03-09 13:25:40 - general channel

**Jack Kaminski**

I'm unfamiliar with sports modelling techniques, and how this materialises into cash

---

## 2020-03-09 13:24:22 - general channel

**D C**

What sports in particular? If you are on twitter and want soccer models you could contact Mercurius - they are quite helpful and sent me some papers a while back

---

## 2020-03-09 13:21:46 - general channel

**Jack Kaminski**

Does anyone have any suggestions for academic articles on sports modelling techniques

---

## 2020-03-09 13:13:02 - general channel

**hugo**

It's a lisp, so similar to other lisps like Scheme and Common Lisp. It runs on the JVM so has complete access to the Java ecosystem (without this I don't think it's a viable language). Immutable data-structures. You don't have the problem of having thousands of tiny classes because the Clojure of modelling data is essentially "use hashmaps". Macros, although that goes back to it being a lisp. It's functional.

---

## 2020-03-09 08:51:18 - general channel

**liam**

But you will be managing it / logging in etc. That's different to you selling a strategy

---

## 2020-03-08 11:48:19 - strategies channel

**Jack Kaminski**

Building a book that's over or under 100% is much better than a pure TA indicator based strategy right

---

## 2020-03-07 21:59:25 - general channel

**Jonjonjon**

I hope you find something useful to you. I have quite a jaded view, as all the truly effective strategies that I have seen, are the result of human intuition/skills/observation. Not AI/ML models. If you look at the public returns of hedge funds that claim a  heavy use of AI/ML, the real returns don't match the bluster of the promotional material.

---

## 2020-03-07 21:39:06 - general channel

**Silver Drifter**

I've just taken early, semi-retirement, which basically means I will continue to do odd-jobs here and there.  Having 40 years software development experience means I'm no spring chicken but I do "get" how to develop software for the finance industry in the manner to which they subscribe (long story).  So now, I finally have the time to get stuck into my BF trading bots and I'm "quietly confident" (yes, I understand the irony of being "quiet" whilst announcing my plans").  Anyway, as I've stated in my profile, in theory, I'm happy to consider various collaborations if anyone has a decent idea or maybe something else.  The only potential sticking point is that I am a 100% Microsoft "stack" developer.  Although, I'm seeing Python associated with so many articles to do with modelling, AI and ML, etc., that I MAY be tempted to have a look into the language soon!

---

## 2020-03-06 13:52:29 - issues channel

**AP**

You can also use the resources here: [https://www.betfair.com.au/hub/models/|https://www.betfair.com.au/hub/models/](https://www.betfair.com.au/hub/models/|https://www.betfair.com.au/hub/models/)



They all have a corresponding endpoint, I have built some useful strategies around them. 

---

## 2020-03-04 09:42:18 - strategies channel

**Unknown**

I posted this on BA forum a while ago but it is basically showing the profit of a strategy based on the time of order placement where -100 is BSP. As you can see there is more value at BSP then there is at 0 (scheduled start time) 

---

## 2020-03-04 09:17:24 - strategies channel

**D C**

It is usally the crowd that have a big hard on for Pinnacle that promote this narrative. I have asked many times that if their analysts are the best and if analytics have improved over the years we should see an improvement in the efficiency of opening prices over the last X years but this seems to never be addressed. Also always seem to just cover US sports and football all of which are much easier to build a statistical model for than horse racing. I really think pre-off horse racing is an a tier of its own in that regard, as well as price action before the start.

---

## 2020-03-04 08:22:04 - strategies channel

**liam**

The strategy was initially to try and reduce PC but eventually morphed into something profitable 

---

## 2020-03-03 21:40:21 - strategies channel

**D C**

If you had a half decent pricing model for the horses, asssuming that final BFSP is indeed efficient you could make a killing value betting alone. The price fluctuations would give you a decent window of opportunity if you had something moderately accurate. I tried myself years ago scraping RP website to get a database going with the view to doing a multinomial logistic regression on it but I found too many errors in the data. Might be easier these days with something like proform but I suspect that it would still be very very hard as there is a lot of "inside" info which probably has far more impact than the publicly available data.

---

## 2020-03-03 21:18:45 - strategies channel

**D C**

Yes there are some insane moves on the pre-off horses for no apparent reason at all. Really not unusual to see a runner start at 3.0 drift out to 5.0 then back again in the 10 mins prior to off. Of course sometimes there are things that make it move like a runner playing up when handlers are trying to get it in the stalls etc but a lot of the time there is no obvious reason for moves. [@UKD8R5P9N](@UKD8R5P9N) when you say probability based tick movement what kind of scale are you talking about? You looking to model probability of price moving +/- X ticks from current based on prior time series?

---

## 2020-03-03 16:58:56 - strategies channel

**Lee**

Makes me think you guys must have some very clever / complex strategy's. Most of mine tend to be reasonably straight forward.

---

## 2020-03-03 16:41:46 - strategies channel

**Mo**

Only considering pre-event:



I don't really know much about horse racing markets but from what I've heard people say, there is often a lot of price action with nothing fundamental behind it. Under these circumstances, it makes sense that you could take some kind of typical financial modelling approach of treating the price evolution as a random walk and trading a mean reversion strategy by continually backing above and laying below a central price.



It feels like other sports are much more fundamental driven - e.g. a star player is injured in training or an updated weather forecast comes in that produces a step change in the price. I would imagine you'd get killed when this happens as you'd be completely taken out at the wrong price, wiping out any profits that you'd pick up from the mean reversion.

---

## 2020-03-02 21:55:37 - general channel

**Newbie99**

Does anyone know if Betfair get annoyed if you place too many small stake bets below min size (in the docs it says you can place bets under GBP 2.00 if the total return &gt;= GBP 10.00). I wanted to test a new strategy with low stakes and some of them would be very small but at long odds, but obviously I don't want to annoy anyone by placing too many small orders (just for testing I mean, not the long term plan of course)!

---

## 2020-03-02 16:05:58 - general channel

**Lee**

I was just wondering about flumine, it seems like it creates a separate stream for each strategy, is it possible to use the same stream across multiple strategies?

---

## 2020-03-02 07:04:35 - strategies channel

**Mo**

e.g. there is £10 available to back at 2.0 which you take. If you let your strategy bet again without restriction and it places the same bet without someone else having posted more at that price then you have double counted the available liquidity leading to an incorrect view of how much volume your strategy can get down and its profitability.

---

## 2020-02-29 17:21:04 - strategies channel

**Lee**

I’ve been testing my first (simple) strategy on live data and seem to be able to make ~5pence per a back+lay trade from £2 stakes.

I know I can potentially optimise the strategy and increase these stakes but is ~1% profit on my stake (£2 x 2 trades) a reasonable strategy? I know I should aim for as much as possible but just trying to understand whats realistic vs risk and reward.

---

## 2020-02-29 17:00:29 - issues channel

**agberk**

You know you've created a StrategyOne object and assigned it to the variable strategy_two rather than a StrategyTwo object?

---

## 2020-02-29 17:00:29 - issues channel

**liam**

You’ve used strategy one twice 

---

## 2020-02-29 16:56:26 - issues channel

**Lee**

Think i’ve spotted an issue with flumine on release 1.0.0.

```class StrategyOne(BaseStrategy):

    def start(self):

        print("StrategyOne")





class StrategyTwo(BaseStrategy):

    def start(self):

        print("StrategyTwo")



strategy_one = StrategyOne(

    market_filter=streaming_market_filter(

        event_type_ids=["1"], country_codes=["GB"], market_types=["OVER_UNDER_25"]

    )

)



strategy_two = StrategyOne(

    market_filter=streaming_market_filter(

        event_type_ids=["1"], country_codes=["GB"], market_types=["OVER_UNDER_25"]

    )

)



framework.add_strategy(strategy_one)

framework.add_strategy(strategy_two)

framework.run()```

Will print out

```✗ python backtest.py

StrategyOne

StrategyOne```

---

## 2020-02-26 13:51:24 - issues channel

**Remi**

```best_prices_depth=9,

rollup_limit=1,

rollup_liability_threshold=0.01,

rollup_liability_factor=1```

I tried these with all the different rollupmodels, but I only ever get the same three quotes.

---

## 2020-02-26 13:27:07 - issues channel

**Remi**

With `ex_best_offers_overrides=filters.ex_best_offers_overrides(best_prices_depth=99, rollup_model=None)` I get the same response

---

## 2020-02-26 13:25:15 - issues channel

**Mo**

Try setting ex_best_offers_overrides argument rollup_model to NONE

---

## 2020-02-26 13:08:13 - issues channel

**Remi**

Could someone tell me how to get a detailed view of orders that are near the spread? I am using betting.list_runner_book and looking at the ‘ex’ bets. But the bets that come back are aggregated too much. How do I get a more detailed view?

---

## 2020-02-26 12:07:26 - strategies channel

**Lee**

also there was a small typo in the readme `flumine.add_strategy(strategy)` should be `framework.add_strategy(strategy)`

---

## 2020-02-26 11:29:05 - strategies channel

**Lee**

I guess i need some real trading data to help

---

## 2020-02-26 11:27:21 - strategies channel

**Mo**

• You could back test with the assumption everything will get fully filled which is obviously unrealistic but should help you compare strategies

• You could entirely randomise the amount matched

• You could model the amount matched, for example by taking account the size of your edge and real trading data (e.g. when your edge is high then your probability of getting matched is low because you've got a lot of competition for the price)

You also need to worry about double counting liquidity if you're testing something where you might bet on the same market multiple times

---

## 2020-02-22 12:25:37 - issues channel

**Lee**

Hi, for the historical data, I have all the files and wrote a little script to extract and merge into one file then call this:

```stream = trading.streaming.create_historical_stream(

    directory='data/merged.txt',

    listener=listener,

)```

Is this the correct way of doing it or is there a better way? Looks like doing it this way i'll need to sort by `publish_time`

---

## 2020-02-22 08:00:59 - issues channel

**liam**

[@UPMUFSGCR](@UPMUFSGCR) just use bflw :slightly_smiling_face:



```from requests import session



session = requests.Session()

s.proxies = {

  "http": http_proxy,

  "https": https_proxy,

}



trading = betfairlightweight.APIClient(

    "username", 

    "password", 

    app_key="app_key", 

    session=session,

)```

although that error looks like something is wrong with the proxy/settings

---

## 2020-02-21 09:20:52 - general channel

**Peter**

Although I’ve been using streaming for set and forget type trades, I’ve been using polling for more active trading. I’m now trying to wean myself off this approach and use streaming for all types. However, polling has the advantage that I can get the start of a market and my trades in that market with a single API call, whereas I would need to combine data from a stream with market data and an order stream.



I’m wondering how other people architect their applications to do this. Do you read both streams in a single loop? Or do you run each in its own process and share snapshots via a common cache? Do you initiate market streams for a single event, or leave them running all day choose within your application when you access the data? Do you use messaging to push data from the streams into a trading app, or pull data from a cache or other data store when needed?



Not expecting answers to all those questions … just hoping to get some insight in architectures that work in practice from those a little ahead of me in this area.

---

## 2020-02-17 11:18:27 - strategies channel

**Mo**

Yeah, TXODDS (and similar) price is a very high hurdle to overcome for a strategy, especially as you can't offset it against PC

---

## 2020-02-17 10:48:04 - strategies channel

**Unknown**

It's not an amazing strategy, so I'm willing to share results here:

---

## 2020-02-16 17:31:56 - strategies channel

**Mo**

Something like tennis or football you can model the scoring process - much easier to get at the fundamentals

---

## 2020-02-15 22:12:31 - general channel

**Jonjonjon**

This is bit embarrasing, but I only have permissions to run scripts on that machine. I don't have UI access or shell access.:expressionless:



I'm now paying the price for using an exceptionally cheap way to get started on my betting career.

---

## 2020-02-11 18:16:24 - general channel

**Alex F**

```import logging



import betfairlightweight

from betfairlightweight import StreamListener

from betfairlightweight.streaming.stream import MarketStream



"""

Data needs to be downloaded from:

    [https://historicdata.betfair.com](https://historicdata.betfair.com)

"""



# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



# create trading instance (no need to put in correct details)

trading = betfairlightweight.APIClient([mailto:'alexander@gmail.com|'alexander@gmail.com](mailto:'alexander@gmail.com|'alexander@gmail.com)','xxxxxx', app_key='xxxxxx', certs='C:/OpenSSL-Win64/bin')

trading.login()



class HistoricalStream(MarketStream):

    # create custom listener and stream



    def __init__(self, listener):

        super(HistoricalStream, self).__init__(listener)

        with open('output.txt', 'w') as output:

            output.write('Time,MarketId,Status,Inplay,SelectionId,LastPriceTraded\n')



    def on_process(self, market_books):

        with open('output.txt', 'a') as output:

            for market_book in market_books:

                for runner in market_book.runners:



                    # how to get runner details from the market definition

                    market_def = market_book.market_definition

                    runners_dict = {(runner.selection_id, runner.handicap): runner for runner in market_def.runners}

                    runner_def = runners_dict.get(

                        (runner.selection_id, runner.handicap)

                    )



                    output.write('%s,%s,%s,%s,%s,%s\n' % (

                        market_book.publish_time, market_book.market_id, market_book.status, market_book.inplay,

                        runner.selection_id, runner.last_price_traded or ''

                    ))





class HistoricalListener(StreamListener):

    def _add_stream(self, unique_id, stream_type):

        if stream_type == 'marketSubscription':

            return HistoricalStream(self)





# create listener

listener = HistoricalListener(

    max_latency=1e100

)



# create historical stream, update directory to file location

stream = trading.streaming.create_historical_generator_stream(

    directory='C:/Users/alexa/Desktop/repos/bet/betfair/examples/29637259',

    listener=listener

)



# start stream

#stream.start(async_=False)



g = stream.get_generator()



for i in g:

    print(i)

    ```

---

## 2020-02-11 18:06:20 - general channel

**Alex F**

stream = trading.streaming.create_historical_stream, yea

---

## 2020-02-10 19:20:36 - general channel

**Mo**

Scraping yourself obviously saves you $$$ but that only helps you going forward and they'll probably come down hard on you if you're not trading enough to justify it

---

## 2020-02-08 12:31:17 - general channel

**Mo**

Which would primarily depend on how powerful an instance type you need to run your strategy

---

## 2020-02-08 12:21:03 - general channel

**Mo**

One important "gotcha" regarding order streaming is that when you first subscribe you only receive data on *unmatched* orders, not matched ones. You would have to use the listCurrentOrders API call if you were interested in these or just make sure that the order stream is running before you place any bets. It doesn't sound like this would be a big problem for your strategy as it sounds like your orders are short lived but it's a surprising limitation of the order stream.

---

## 2020-01-21 11:28:31 - general channel

**ash**

Morning, I have been trying out streaming using how it is set up in the new examplestreamingerrhandling.py and I keep getting this error.

everything works fine but if I get a connection issue, for example, I am getting this:

```    raise SocketError('[Connect: %s]: Connection closed by server' % (self._unique_id,))

betfairlightweight.exceptions.SocketError: [Connect: 1002]: Connection closed by server

21/01/2020 11:00,581 GB __main__ INFO Starting MarketStreaming

21/01/2020 11:00,713 GB betfairlightweight.streaming.listener INFO [Connect: 1002]: connection_id: 202-210120110000-541

21/01/2020 11:00,756 GB betfairlightweight.streaming.listener ERROR [Subscription: 1003] INVALID_SESSION_INFORMATION: UnrecognisedCredentials

21/01/2020 11:00,756 GB __main__ ERROR MarketStreaming run error

Traceback (most recent call last):

  File "/Volumes/2/GitHub/OddsTrading/versionTWO.py", line 115, in run

    self.stream.start()

  File "/Users/ash/anaconda3/lib/python3.7/site-packages/betfairlightweight/streaming/betfairstream.py", line 60, in start

    self._read_loop()

  File "/Users/ash/anaconda3/lib/python3.7/site-packages/betfairlightweight/streaming/betfairstream.py", line 198, in _read_loop

    self._data(received_data)

  File "/Users/ash/anaconda3/lib/python3.7/site-packages/betfairlightweight/streaming/betfairstream.py", line 239, in _data

    raise ListenerError(self.listener.connection_id, received_data)

betfairlightweight.exceptions.ListenerError: connection_id: 202-210120110000-541, data: {"op":"status","id":1003,"statusCode":"FAILURE","errorCode":"INVALID_SESSION_INFORMATION","errorMessage":"UnrecognisedCredentials","connectionClosed":true,"connectionId":"202-210120110000-541"}

21/01/2020 11:00,759 GB __main__ INFO Starting MarketStreaming```

This is then stuck in the `@retry` loop raising the same error each time.

---

## 2020-01-19 07:34:59 - general channel

**Ian**

Hi all - just wondered what general methods are utilised to identify strategies. At the moment, my manual trading and time watching the markets (3 years - tiny compared to some, I know) has led to me identifying patterns visually and developing code against that. Now that I have collected months of data (flumine  thank you!) I am begging to explore that. I've built a tool that will let me recreate markets and see flow of money and so on, but clearly that will not work at scale, so will be using scikit - what do you do/use?

---

## 2020-01-13 00:23:33 - general channel

**Mo**

Then you case use listEvents [https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L70-L85](https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L70-L85) with a market filter [https://github.com/liampauling/betfair/blob/master/betfairlightweight/filters.py#L71-L97](https://github.com/liampauling/betfair/blob/master/betfairlightweight/filters.py#L71-L97) that has competition IDs set

---

## 2020-01-11 16:58:30 - general channel

**AP**

```def process_betfair_historical_file(file_path):

    print("Processing: " + file_path)

    

    class HistoricalStream(MarketStream):

    # create custom listener and stream



        def __init__(self, listener):

            super(HistoricalStream, self).__init__(listener)

            self.file_path = file_path.split("/")[-1]

            self.output = open(self.file_path + '.txt', 'w')

            self.output.write('Time,MarketStartTime,MarketType,MarketId,Status,Inplay,SelectionId,VWAP,BestLayPrice,LastPriceTraded,\n')



        def on_process(self, market_books):

            for market_book in market_books:

                for runner in market_book.runners:



                    # how to get runner details from the market definition

                    market_def = market_book.market_definition

                    runners_dict = {(runner.selection_id, runner.handicap): runner for runner in market_def.runners}

                    runner_def = runners_dict.get(

                        (runner.selection_id, runner.handicap)

                    )



                    # calculate lay wap

                    price = 0

                    vol = 0

                    for trade in runner.ex.traded_volume:

                        price += (trade.price * trade.size)

                        vol += trade.size

                    try:    

                        wap = price / vol

                    except:

                        wap = np.nan



                    # get best lay price

                    try:

                        best_lay = runner.ex.available_to_lay[0].price

                    except:

                        best_lay = np.nan



                    self.output.write('%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n' % (

                        market_book.publish_time, market_def.market_time, market_def.market_type, market_book.market_id, market_book.status, market_book.inplay,

                        runner.selection_id, wap or '', best_lay or '', runner.last_price_traded or ''

                    ))



    class HistoricalListener(StreamListener):

        def _add_stream(self, unique_id, stream_type):

            if stream_type == 'marketSubscription':

                return HistoricalStream(self)



    # create listener

    listener = HistoricalListener(

        max_latency=1e100

    )



    # create historical stream, update directory to file location

    stream = trading.streaming.create_historical_stream(

        directory=file_path,

        listener=listener

    )



    # start stream

    stream.start(async_=False)

    

    return "Processed" + file_path```

---

## 2020-01-10 14:36:45 - issues channel

**Mo**

The runners is a list of RunnerCatalogue objects. Look the definition of that object up here: [https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py|https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py|https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py) and see what fields you want

---

## 2020-01-10 14:23:57 - issues channel

**oliver**

Hi Mo. I fancy that is the route I just can't get it right! The code I tried (along with other slight tweaks) was:     `def finding_the_amount_of_money_match_on_each_market2():`

    `global betfair_win_race_id`

    `datetime_in_a_week = (datetime.datetime.utcnow() + datetime.timedelta(minutes=1100)).strftime("%Y-%m-%dT%TZ")`

    `market_catalogue_filter = betfairlightweight.filters.market_filter(market_ids=[1.167181875], market_start_time={'to': datetime_in_a_week})`

    `market_catalogues = trading.betting.list_market_catalogue(filter=market_catalogue_filter,`

        `market_projection=["RUNNER_DESCRIPTION","EVENT_TYPE","EVENT","COMPETITION","RUNNER_METADATA","MARKET_START_TIME"],`

        `max_results='100',`

        `sort='FIRST_TO_START')`

    `market_types_mooney_valley = pd.DataFrame({`

        `'name': [market_cat_object.runners for market_cat_object in market_catalogues],})`

    `print(market_types_mooney_valley)`      but the ouput was just the selection_ids for the horses

---

## 2020-01-10 13:44:17 - issues channel

**oliver**

Hi.

I am using a slightly different structure to the examples on the site ([https://github.com/liampauling/betfair](https://github.com/liampauling/betfair)) as I have been following the guide ([https://betfair-datascientists.github.io/api/apiPythontutorial/](https://betfair-datascientists.github.io/api/apiPythontutorial/)).

I am looking for the horses names. I don't mind how I get the names (either when I list the runners in a race, or just finding the specific name that matches with a specific selection_id using a separate bit of code).

I find the list of the runners in a race via the following code:

```def process_runner_books(runner_books):

    best_back_prices = [runner_book.ex.available_to_back[0].price

                        if runner_book.ex.available_to_back

                        else 100

                        for runner_book

                        in runner_books]

    best_lay_prices = [runner_book.ex.available_to_lay[0].price

                       if runner_book.ex.available_to_lay

                       else 1000.0

                       for runner_book

                       in runner_books]

    selection_ids = [runner_book.selection_id for runner_book in runner_books]

    last_prices_traded = [runner_book.last_price_traded for runner_book in runner_books]

    df = pd.DataFrame({

        'Last Price Traded': last_prices_traded,

        'Best Back Price': best_back_prices,

        'Selection ID': selection_ids,

        'Best Lay Price': best_lay_prices,

    }).set_index('Last Price Traded').sort_index()

    return df



def getting_market_info_for_all_the_horses_in_a_race():

    global runners_df

    price_filter = betfairlightweight.filters.price_projection(price_data=['EX_BEST_OFFERS'])

    market_books = trading.betting.list_market_book(market_ids=[betfair_win_race_id],price_projection=price_filter,)

    market_book = market_books[0]

    runners_df = process_runner_books(market_book.runners)```

If anyone could help me get the horses names I would be most grateful.

Cheers

---

## 2020-01-08 17:14:44 - general channel

**AP**

Ok so for trading live the historical data is stored in memory for the most part 

---

## 2020-01-08 16:58:31 - general channel

**AP**

I’ve just been going through all the code and documentation as well as this chat, if you need to store prices when trading (eg what the price was 30 seconds ago for a particular selection), is the idea to use flumine to do this?

---

## 2020-01-07 21:12:38 - issues channel

**Newbie99**

```Traceback (most recent call last):

  File "D:/Python37/webpages/new_betfair.py", line 37, in &lt;module&gt;

    trading.login()

  File "D:\Python37\lib\site-packages\betfairlightweight\endpoints\login.py", line 30, in __call__

    (response, elapsed_time) = self.request(self.url, session=session)

  File "D:\Python37\lib\site-packages\betfairlightweight\endpoints\login.py", line 52, in request

    self._error_handler(response_data)

  File "D:\Python37\lib\site-packages\betfairlightweight\endpoints\login.py", line 57, in _error_handler

    raise self._error(response)

betfairlightweight.exceptions.LoginError: API login: ACCOUNT_PENDING_PASSWORD_CHANGE```

I just received this error...my password hasn't changed and I can log into the Betfair GUI without any issues, so I'm a bit confused, any ideas?

---

## 2020-01-06 20:22:44 - issues channel

**DonJ80**

```  @liam Do you mean something like this?  

try:

       # start stream

       stream.start(async_=True)

except:

        stream.stop()

        # create stream listener

            listener = betfairlightweight.StreamListener(

                output_queue=output_queue,

            )



            # create stream

            stream = trading.streaming.create_stream(

                listener=listener,

            )



            # create filters 

            market_filter = streaming_market_filter(

                event_type_ids=['7'],

                event_ids=hr_thoroughbred_events_next_12hours['Event ID'],

                market_types=['WIN'],

            )

            market_data_filter = streaming_market_data_filter(

                fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF' ],

                ladder_levels=5,

            )



            # subscribe

            streaming_unique_id = stream.subscribe_to_markets(

                market_filter=market_filter,

                market_data_filter=market_data_filter,

                conflate_ms=1000,  # send update every 1000ms

            )



            # start stream

            stream.start(async_=True)

    # check for updates in output queue



    while datetime.datetime.now() &lt; t:

        

            market_books = output_queue.get()

            print(market_books)



            for market_book in market_books:

                print(

                    market_book.streaming_update, 

                    market_book.publish_time,  

                )

       

    t = t + datetime.timedelta(hours=12)```



---

## 2020-01-05 17:00:05 - issues channel

**Unknown**

Hi guys. i keep  getting the same error. how can i deal with this error attached

my code:

```import os

import logging

import queue

from betfairlightweight import filters

import datetime

import betfairlightweight

from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter,

)



import pandas as pd

# create trading instance

trading = betfairlightweight.APIClient('username',

                                       'password',

                                       app_key='appkey',

                                       certs='C:\\Users\\')



# login

trading.login()



# make event type request to find horse racing event type

horse_racing_event_type_id = trading.betting.list_event_types(

    filter=filters.market_filter(

        text_query='Horse Racing'

    )

)

# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# create trading instance (app key must be activated for streaming)

trading.login()



t = datetime.datetime.now()+datetime.timedelta(hours=12)



while datetime.datetime.now() &lt; t:

    h_i1 =datetime.datetime.now()

    h_i2 = h_i1 + datetime.timedelta(hours=12)

    # Define a market filter

    thoroughbreds_event_filter = betfairlightweight.filters.market_filter(

        event_type_ids=['7'],

        market_start_time={

            'from': h_i1.strftime("%Y-%m-%dT%TZ"),

            'to': h_i2.strftime("%Y-%m-%dT%TZ")

        }

    )



    # Print the filter

    # thoroughbreds_event_filter



    # Get a list of all thoroughbred events as objects

    thoroughbred_events = trading.betting.list_events(

        filter=thoroughbreds_event_filter

    )



    # Get a list of all thoroughbred events as objects

    hr_thoroughbred_events = trading.betting.list_events(

        filter=thoroughbreds_event_filter

    )



    # Create a DataFrame with all the events by iterating over each event object

    hr_thoroughbred_events_next_12hours = pd.DataFrame({

        'Event Name': [event_object.event.name for event_object in hr_thoroughbred_events],

        'Event ID': [event_object.event.id for event_object in hr_thoroughbred_events],

        'Event Venue': [event_object.event.venue for event_object in hr_thoroughbred_events],

        'Country Code': [event_object.event.country_code for event_object in

                         hr_thoroughbred_events],

        'Time Zone': [event_object.event.time_zone for event_object in hr_thoroughbred_events],

        'Open Date': [event_object.event.open_date for event_object in hr_thoroughbred_events],

        'Market Count': [event_object.market_count for event_object in hr_thoroughbred_events]

    })

    # create queue

    output_queue = queue.Queue()



    # create stream listener

    listener = betfairlightweight.StreamListener(

        output_queue=output_queue,

    )



    # create stream

    stream = trading.streaming.create_stream(

        listener=listener,

    )



    # create filters (GB WIN racing)

    market_filter = streaming_market_filter(

        event_type_ids=['7'],

        event_ids=hr_thoroughbred_events_next_12hours['Event ID'],

        market_types=['WIN'],

    )

    market_data_filter = streaming_market_data_filter(

        fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF'],

        ladder_levels=5,

    )



    # subscribe

    streaming_unique_id = stream.subscribe_to_markets(

        market_filter=market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=1000,  # send update every 1000ms

    )



    # start stream

    stream.start(async_=True)



    # check for updates in output queue



    while datetime.datetime.now() &lt; t:

        try:

            market_books = output_queue.get()

            print(market_books)



            for market_book in market_books:

                print(

                    market_book.streaming_update, 

                    market_book.publish_time,  

                )

        except:

            output_queue = queue.Queue()



            # create stream listener

            listener = betfairlightweight.StreamListener(

                output_queue=output_queue,

            )



            # create stream

            stream = trading.streaming.create_stream(

                listener=listener,

            )



            # create filters 

            market_filter = streaming_market_filter(

                event_type_ids=['7'],

                event_ids=hr_thoroughbred_events_next_12hours['Event ID'],

                market_types=['WIN'],

            )

            market_data_filter = streaming_market_data_filter(

                fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF' ],

                ladder_levels=5,

            )



            # subscribe

            streaming_unique_id = stream.subscribe_to_markets(

                market_filter=market_filter,

                market_data_filter=market_data_filter,

                conflate_ms=1000,  # send update every 1000ms

            )



            # start stream

            stream.start(async_=True)

    t = t + datetime.timedelta(hours=12)```

 but i doesn't  help. i thought if i put a while loop, then when error occurs it will sleep for 1 second and then subscribe to markets as you suggested and then  start the stream again. but still the code enter a state where the message below is displayed and nothing happens. this happens everyday once .  as you can see in Pycharm, the Run tab is still green, also the stop button(red square) is still active, it seems that my code does not capture the error , but the betfairlightweight source code capture it, then something happens and it stays there.why does my try and except  statements can't capture this error? I have to push  the stop button on the top left  and then rerun the code.  have you seen this issue before, any idea how can this be fixed.

---

## 2019-12-31 10:15:36 - general channel

**fjt1973**

[@U4H19D1D2](@U4H19D1D2) when you says its from the website which website do you mean? What i'm trying to understand is how you come up with statements like "horse_racing_event_type_id = trading.betting.list_event_types(    filter=filters.market_filter(        text_query='Horse Racing'    )). i.e Is there any documentation on how to use trading.betting.list_event_types and its variables for example.

---

## 2019-12-30 21:31:55 - general channel

**fjt1973**

Hello... is there any documentation around the Endpoints... for example all the options for trading.betting.&lt;option&gt; where option could be "list_competitions", "list_current_orders" or "list_event_types". The links here [https://github.com/liampauling/betfair/blob/master/README.md](https://github.com/liampauling/betfair/blob/master/README.md) do not appear to work

---

## 2019-12-23 20:47:09 - general channel

**Alex A**

So this slack is in general about automated betting on betting exchanges, or specifically about Liam Payne’s betfairlightweight

---

## 2019-12-23 13:07:10 - general channel

**Chris**

People simulating their strategies - are you modelling cross-matching in your simulator?

---

## 2019-12-18 13:05:46 - general channel

**Newbie99**

Yeah, that I feel would be useful, as I can then play around with the Redis data and analyse a bit more (to refine my models over time).



I don't need super speed, my hardware isn't good enough currently to make that worth worrying about, so not fussed about nano-seconds, but MySQL is just not usable for this kind of a thing, if you have more than a handful of runners the whole thing just grinds to a halt if you're inserting and select querying regularly!

---

## 2019-12-04 19:07:39 - general channel

**PeterLe**

Quick question please. Is the non certs option too risky to use (ie Trading.Login_Interactive) I have two step on the account too. Just having some issues with certs which I’ll resolve soon but wondered if it’s ok to use the non certs approach for the time being. Thanks

---

## 2019-12-03 17:59:24 - general channel

**Chris**

```db = database.cursor()

market_id = db.execute("SELECT match_id FROM bfex_match_ids")

values_list = db.fetchall()



def grabber(market_id):

  market_catalogues = trading.betting.list_market_catalogue(

    filter=filters.market_filter(

      market_ids=[market_id],

  #    in_play_only='false',

    ),

    market_projection=['MARKET_START_TIME', 'RUNNER_DESCRIPTION', 'RUNNER_METADATA'],  # runner description required

    max_results=1

  )



  for market_catalogue in market_catalogues:

    market_books = trading.betting.list_market_book(

      market_ids=[market_catalogue.market_id],

      price_projection=filters.price_projection(

      price_data=filters.price_data(

        ex_best_offers=True

        )

      )

    )



  db = database.cursor()

  sql_insert_query = """UPDATE bfex_match_odds SET selection_odds=%s, selection_back_odds=%s WHERE unique_id=%s"""



  for market_book in market_books:

    for runner in market_book.runners:

      try:

        available_to_back = runner.ex.available_to_back[0].price

        available_to_lay = runner.ex.available_to_lay[0].price

        unique_id = str(runner.selection_id) + market_id

        print(unique_id)

        db.execute(sql_insert_query, (available_to_lay, available_to_back, unique_id))

        print(available_to_lay, available_to_back, unique_id)

      except Exception:

        traceback.print_exc()

        unique_id = str(runner.selection_id) + market_id

        print(unique_id)

        db.execute(sql_insert_query, ("10000.0", "10000.0", unique_id))

        # print("uh-oh")

    database.commit()



def updater(values_list):

  for bfid in values_list:

    try:

      grabber(bfid[0])

    except:

      print("Could not update:")

      print(bfid[0])

      pass



updater(values_list)```

---

## 2019-12-02 19:33:09 - general channel

**JonJonJon**

Do you know what "turning over a lot" means? I use customer strategy ref, but an actual sub account with a separate balance would be a lot safer, as a bad software bug could empty the account in seconds.

---

## 2019-12-02 19:20:40 - general channel

**Mo**

My suggestion is to try to get an account manager and use them to get a master/subaccount setup. But I think they don’t really give them out any more. I think their intention is for people to separate strategies using the customerStrategyRef functionality instead. I could be wrong though. [@U4H19D1D2](@U4H19D1D2) do you have any more insight?

---

## 2019-12-02 10:52:13 - random channel

**Tom Poole**

Liam has given me permission to post an exciting new DevOps Lead Engineer opportunity in a high traffic data and streaming platform sports company, based in Central London.



As Lead DevOps Engineer you will report to the VP of Technology and will be tasked with shaping and executing the cloud and DevOps strategy. Given the seniority of the role, you should have a strong analytical mindset, be a natural problem-solver and enjoy working closely with Software Engineering teams to create a best in breed infrastructure ecosystem. You'll be responsible for shaping, building and monitoring a scalable cloud-based infrastructure (hybrid AWS / GCP… you decide!) and live operations environment. Given this is a new greenfield team you’ll have the opportunity to do this speed, scalability and security in mind. You’ll be given the autonomy to choose the best technologies and processes that will allows Engineers to consumer services effortlessly. The company has a great culture with lots of autonomy and empowerment to do things the right way.



As Lead DevOps Engineer you will need the following:

•	DevOps Engineer

•	Cloud experience AWS and/or GCP

•	Containerisation

•	CI / CD Pipelines

•	Strategy and execution

•	Docker and Kubernetes

•	Excellent communication skills

•	Advocate Agile working

•	Sports enthusiast



In return you will receive a generous salary package ranging from £90,000 - £110,000 plus bonus as well as some great benefits including free gym memberships, private medical/dental insurance and a competitive annual holiday plan.



If you are interested in learning more about the role, then please let me know when you’re next available, so I can update my diary. I look forward to hearing from you

---

## 2019-11-15 11:10:19 - general channel

**PeterLe**

Morning All, Just wanted to quickly introduce myself. Ive been trading on betfair since 2007 and I run my own programs (C#) which I had commissioned. I have very limited experience in programming, but very keen and enthusiastic to learn Python. So whilst I cant offer much at this stage, hopefully in the future i will be able to contribute more :slightly_smiling_face:

---

## 2019-11-14 22:00:50 - general channel

**bogdan**

Kyneton_filter = betfairlightweight.filters.market_filter(market_type_codes=['WIN'], venues=['Kyneton'])



market_catalogues = trading.betting.list_market_catalogue(

    filter=Kyneton_filter,

    max_results='100',

    sort='FIRST_TO_START'

)

print([market_cat_object.json() for market_cat_object in market_catalogues])

---

## 2019-11-14 21:53:40 - general channel

**bogdan**

Kyneton_filter = betfairlightweight.filters.market_filter(market_type_codes=['WIN'], venues=['Kyneton'])



Kyneton_venue = trading.betting.list_venues(

    filter=Kyneton_filter

)

#print(Kyneton_venue)

print([v_object.json() for v_object in Kyneton_venue])

---

## 2019-11-14 21:13:15 - general channel

**bogdan**

market_catalogue_filter = `betfairlightweight`.filters.market_filter(event_ids=['28971066'])



market_catalogues = trading.betting.list_market_catalogue(

    filter=market_catalogue_filter,

    max_results='100',

    sort='FIRST_TO_START'

)



# Create a DataFrame for each market catalogue

market_types_mooney_valley = pd.DataFrame({

    'Market Name': [market_cat_object.market_name for market_cat_object in market_catalogues],

    'Market ID': [market_cat_object.market_id for market_cat_object in market_catalogues],

    'Total Matched': [market_cat_object.total_matched for market_cat_object in market_catalogues],

})



market_types_mooney_valley

---

## 2019-11-12 22:38:46 - general channel

**Leon**

I've been trying to set flumine up for the last couple of nights but have got stuck on what is probably a basic error on my part, but I haven't been able to figure it out. The error I get is -

Traceback (most recent call last):

  File "C:/Users/leonf/PycharmProjects/flumine-master/flumine_test.py", line 17, in &lt;module&gt;

    "certificate_login": False,

  File "C:\Users\leonf\PycharmProjects\flumine-master\flumine\flumine.py", line 21, in __init__

    self.trading = self._create_client(settings)

  File "C:\Users\leonf\PycharmProjects\flumine-master\flumine\flumine.py", line 75, in _create_client

    return APIClient(**settings.get("betfairlightweight"))

TypeError: type object argument after ** must be a mapping, not NoneType



I'm presuming the error is being caused by the "certificate_login": False line (I didn't understand why certs were not required, but based it on the sample github code). An extract of where settings are defined is -

flumine = Flumine(

    recorder=MarketRecorder(

        storage_engine=storage_engine,

        market_filter=market_filter,

    ),

    settings={  # passed to betfairlightweight

        "username": "test",

        "password": "test",

        "app_key": "test",

        "certificate_login": False,

    }

)

with test being replaced by my credentials (obviously!).



Any suggestions would be greatly appreciated please.

(My credentials, app_key, etc work fine connecting in other betfairlightweight scripts)

---

## 2019-10-28 09:24:29 - issues channel

**Rory**

getting an InvalidResponse error from _trading.account.get_account_statement_ and it's because legacyData has a _handicap_ field, as below

---

## 2019-10-04 12:08:31 - general channel

**Unknown**

so for that problem i have a strategy runner_context which stores the current state, ie. if an order is live, this would stop an order being placed if in a pending state

---

## 2019-09-25 18:36:34 - general channel

**Mo**

I think it’s been and continues to be invaluable to debate the different approaches people have to building platforms on here. 



I’m not convinced that a UI is the best way to implement any of the functionality discussed so far, seems like it’s a better use of time to focus on developing a winning strategy when there are off the shelf ways to monitor/interact. But I’m very interested to see what you’re doing with Dash and getting a fresh perspective. 

---

## 2019-09-24 23:33:52 - general channel

**JonJonJon**

I started to knock together something very basic with Dash... It can monitor orders by customer strategy ref at the moment. It won't be too hard to add a "delete all orders"button. When it is tidier I can share it if people are interested. Due to Dash limitations I think it can only be very basic, but it should handle my use case.

---

## 2019-09-21 12:38:58 - issues channel

**Justin Fisher**

```

trading.historic.get_my_data()



{'sport': 'Greyhound Racing', 'plan': 'Basic Plan', 'forDate': '2018-05-01T00:00:00', 'purchaseItemId': 32386}

{'sport': 'Greyhound Racing', 'plan': 'Basic Plan', 'forDate': '2018-06-01T00:00:00', 'purchaseItemId': 32386}

{'sport': 'Horse Racing', 'plan': 'Basic Plan', 'forDate': '2018-05-01T00:00:00', 'purchaseItemId': 32379}

{'sport': 'Horse Racing', 'plan': 'Basic Plan', 'forDate': '2018-06-01T00:00:00', 'purchaseItemId': 32379}

{'sport': 'Horse Racing', 'plan': 'Basic Plan', 'forDate': '2018-11-01T00:00:00', 'purchaseItemId': 22726}

{'sport': 'Horse Racing', 'plan': 'Basic Plan', 'forDate': '2018-12-01T00:00:00', 'purchaseItemId': 22726}



trading.historic.get_collection_options:

 {'marketTypesCollection': [{'name': '', 'count': 1233}, {'name': 'ANTEPOST_WIN', 'count': 46}, {'name': 'DAILY_WIN_DIST', 'count': 1}, {'name': 'EACH_WAY', 'count': 1113}, {'name': 'FORECAST', 'count': 211}, {'name': 'MATCH_BET', 'count': 1165}, {'name': 'OTHER_PLACE', 'count': 6012}, {'name': 'PLACE', 'count': 4157}, {'name': 'RACE_WIN_DIST', 'count': 188}, {'name': 'REV_FORECAST', 'count': 574}, {'name': 'WIN', 'count': 6909}, {'name': 'WITHOUT_FAV', 'count': 222}], 'countriesCollection': [{'name': 'AR', 'count': 17}, {'name': 'AU', 'count': 4671}, {'name': 'BR', 'count': 10}, {'name': 'CL', 'count': 120}, {'name': 'FR', 'count': 591}, {'name': 'GB', 'count': 6612}, {'name': 'IE', 'count': 1608}, {'name': 'IN', 'count': 128}, {'name': 'NZ', 'count': 744}, {'name': 'PE', 'count': 9}, {'name': 'SE', 'count': 185}, {'name': 'SG', 'count': 138}, {'name': 'US', 'count': 6444}, {'name': 'UY', 'count': 12}, {'name': 'ZA', 'count': 542}], 'fileTypeCollection': [{'name': 'E', 'count': 1233}, {'name': 'M', 'count': 20598}]}



trading.historic.get_data_size:

 {'totalSizeMB': 63, 'fileCount': 23680}



trading.historic.get_file_list:



Traceback (most recent call last):

  File "/Users/justinfisher/anaconda3/lib/python3.6/site-packages/betfairlightweight/endpoints/historic.py", line 166, in request

    response_data = response.json()

  File "/Users/justinfisher/anaconda3/lib/python3.6/site-packages/requests/models.py", line 897, in json

    return complexjson.loads(self.text, **kwargs)

  File "/Users/justinfisher/anaconda3/lib/python3.6/json/__init__.py", line 354, in loads

    return _default_decoder.decode(s)

  File "/Users/justinfisher/anaconda3/lib/python3.6/json/decoder.py", line 339, in decode

    obj, end = self.raw_decode(s, idx=_w(s, 0).end())

  File "/Users/justinfisher/anaconda3/lib/python3.6/json/decoder.py", line 357, in raw_decode

    raise JSONDecodeError("Expecting value", s, err.value) from None

json.decoder.JSONDecodeError: Expecting value: line 4 column 1 (char 6)



During handling of the above exception, another exception occurred:



Traceback (most recent call last):

  File "download_data.py", line 48, in &lt;module&gt;

    market_types_collection=['WIN'],

  File "/Users/justinfisher/anaconda3/lib/python3.6/site-packages/betfairlightweight/endpoints/historic.py", line 116, in get_file_list

    (response, elapsed_time) = self.request(method, params, session)

  File "/Users/justinfisher/anaconda3/lib/python3.6/site-packages/betfairlightweight/endpoints/historic.py", line 168, in request

    raise InvalidResponse(response.text)

betfairlightweight.exceptions.InvalidResponse: Invalid response received:





&lt;!DOCTYPE html&gt;



&lt;html&gt;

&lt;head&gt;

    &lt;meta name="viewport" content="width=device-width" /&gt;

    &lt;title&gt;ngErrorRedirect&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;

    &lt;div&gt;

        Error

    &lt;/div&gt;

&lt;/body&gt;

&lt;/html&gt;

```

---

## 2019-09-16 07:31:46 - general channel

**Newbie99**

yep, I had just stripped out the market bits, the full code is:



```import threading

import logging

from datetime import datetime

import mysql.connector

import queue

from new_functions import calc_live_order_risk, view_runners, view_orders, database_run_sp, getprofitandloss, check_queue, \

    set_initial_market_book, inital_position, create_initial_market_book, calc_initial_risk, check_positions, live_positions, create_initial_risk, combine_stream_results

import auto_hedge

import betfairlightweight

from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter,

    streaming_order_filter,

    market_filter,

    price_data,

    price_projection,

    ex_best_offers_overrides

)

from account_info import accname, accpass, acckey, path, db_host, db_user, db_passwd, db_database

from betfairlightweight.resources.bettingresources import MarketBook, CurrentOrders

from betfairlightweight.endpoints.account import Account

from betfairlightweight.endpoints.betting import Betting

from place_orders import place_order



logging.basicConfig(level=logging.DEBUG)  # change to DEBUG to see log all updates



filters = betfairlightweight.filters



mysql = mysql.connector



logging.basicConfig(level=[http://logging.info|logging.info](http://logging.info|logging.info))



trading = betfairlightweight.APIClient(accname, accpass, acckey, certs=path)

trading.login()



order_queue = queue.Queue()

order_listener = betfairlightweight.StreamListener(output_queue=order_queue)

order_stream = trading.streaming.create_stream(listener=order_listener)

order_filter = streaming_order_filter(

    include_overall_position=True

    # customer_strategy_refs=[""]

    #    partition_matched_by_strategy_ref=None

)

order_stream.subscribe_to_orders(

    order_filter=order_filter)

order_stream.start(async_=True)



market_ids=['1.148222764','1.132099836','1.130856098']



market_queue = queue.Queue()

market_listener = betfairlightweight.StreamListener(output_queue=market_queue)

market_stream = trading.streaming.create_stream(listener=market_listener)

market_filter = streaming_market_filter(

market_ids=market_ids)



market_data_filter = streaming_market_data_filter(

    fields=['EX_ALL_OFFERS', 'EX_MARKET_DEF', 'EX_TRADED', 'EX_LTP'])



market_stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter)



market_stream.start(async_=True)



mb =[]



initial_risk_list = create_initial_risk(trading, filters, market_ids)



def consumer(queue, initial_risk_list):

    while True:

        message = queue.get()

        output = check_queue(message,'market_list', 'order_list', update_time, initial_risk_list)

        live_data = combine_stream_results(output, mb, queue, update_time)





if __name__ == "__main__":

    format = "%(asctime)s: %(message)s"

    logging.basicConfig(format=format, level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO), datefmt="%H:%M:%S")

    pipeline = queue.Queue(maxsize=50)

    c = threading.Thread(target=consumer, args=(pipeline,initial_risk_list))

    c.start()



while True:

    update_time = datetime.now().strftime("%m/%d/%Y, %H:%M:%S")

    order_books = order_queue.get()

    for order_book in order_books:

        print(order_book.streaming_update)

    order_list = {'order_list': view_orders(order_books)}

    pipeline.put(order_list)

    market_books = market_queue.get()

    for market_book in market_books:

        print(market_book.streaming_update)

    runner_list, mb = view_runners(mb, market_books, mysql, db_host, db_user, db_passwd, db_database)

    runner_list = {'runner_list': runner_list}

    pipeline.put(runner_list)

    market_list = {'market_list': mb}

    pipeline.put(market_list)```

---

## 2019-09-15 10:07:02 - general channel

**Newbie99**

I managed to replicate the issue again, this time, with EX_ALL_OFFERS, just to see.



My code, is stripped back, completely to basics here, so it should be obvious if something is wrong, but it looks okay to me, I can't see what would be withholding messages (and is there any possibility they aren't being sent somehow?)



```filters = betfairlightweight.filters



logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = betfairlightweight.APIClient(accname, accpass, acckey, certs=path)

trading.login()



market_ids=['1.148222764','1.132099836','1.130856098']



market_queue = queue.Queue()

market_listener = betfairlightweight.StreamListener(output_queue=market_queue)

market_stream = trading.streaming.create_stream(listener=market_listener)

market_filter = streaming_market_filter(

market_ids=market_ids)



market_data_filter = streaming_market_data_filter(

    fields=['EX_ALL_OFFERS', 'EX_MARKET_DEF', 'EX_TRADED', 'EX_LTP'])



market_stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter)



market_stream.start(async_=True)



while True:

    market_books = market_queue.get()

    for market_book in market_books:

        print(market_book.streaming_update)```

---

## 2019-09-13 13:55:06 - general channel

**Mo**

Has anyone else observed streaming price updates coming in some time after a market has been closed?



e.g

```

{"op": "mcm", "id": 1, "clk": "AK31jAUA9uWeBQCxp9IE", "pt": 1566406561261, "mc": {"id": "1.161522056", "marketDefinition": {"bspMarket": false, "turnInPlayEnabled": true, "persistenceEnabled": true, "marketBaseRate": 5, "eventId": "29425833", "eventTypeId": "1", "numberOfWinners": 1, "bettingType": "ODDS", "marketType": "OVER_UNDER_35", "marketTime": "2019-08-21T15:01:11.000Z", "suspendTime": "2019-08-21T15:01:11.000Z", "bspReconciled": false, "complete": true, "inPlay": true, "crossMatching": false, "runnersVoidable": false, "numberOfActiveRunners": 0, "betDelay": 5, "status": "CLOSED", "settledTime": "2019-08-21T16:55:57.000Z", "runners": [{"status": "WINNER", "sortPriority": 1, "id": 1222344}, {"status": "LOSER", "sortPriority": 2, "id": 1222345}], "regulators": ["MR_INT"], "countryCode": "PL", "discountAllowed": true, "timezone": "GMT", "openDate": "2019-08-21T15:01:11.000Z", "version": 2904477007, "priceLadderDefinition": {"type": "CLASSIC"}}}}

{"op": "mcm", "id": 1, "clk": "AMSpkgUA5rCkBQDMvdcE", "pt": 1566407145831, "mc": {"id": "1.161522056", "rc": [{"trd": [[1.05, 16.47], [1.02, 16.47], [1.11, 54.93]], "id": 1222344}]}}

```

---

## 2019-09-10 09:56:22 - issues channel

**Rob (NZ)**

days_ago = (datetime.datetime.utcnow() - datetime.timedelta(days=1)).strftime("%Y-%m-%dT%TZ")

acct_statement_date_filter = betfairlightweight.filters.time_range(from_=days_ago)



more_available = True

from_record = 0

data = []

while more_available:

    account_statement_result = trading.account.get_account_statement(item_date_range=acct_statement_date_filter, from_record=from_record)

    more_available = account_statement_result.more_available

    from_record += len(account_statement_result.account_statement)

    data.extend(account_statement_result._data['accountStatement'])



recent_transactions = pd.DataFrame(data)

recent_transactions



class_df = pd.DataFrame(json.loads(i['unknownStatementItem']) for i in recent_transactions.itemClassData)

class_df

---

## 2019-09-09 21:57:30 - general channel

**Newbie99**

Actually one other way, that seems to be better is using list_market_books, using orders instead of matches and filtering on EXECUTION_COMPLETE, that approach gets most of the key info on each bet, although I can't see a way to filter on strategy...

---

## 2019-09-06 11:02:42 - issues channel

**Newbie99**

it is most likely my misunderstanding of how it works! Here is the rest:



```

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = betfairlightweight.APIClient(accname, accpass, acckey, certs=path)

trading.login()



order_queue = queue.Queue()

order_listener = betfairlightweight.StreamListener(output_queue=order_queue)

order_stream = trading.streaming.create_stream(listener=order_listener)

order_filter = streaming_order_filter(

    include_overall_position=True

)

order_stream.subscribe_to_orders(

    order_filter=order_filter)

order_stream.start(async_=True)



market_queue = queue.Queue()

market_listener = betfairlightweight.StreamListener(output_queue=market_queue)

market_stream = trading.streaming.create_stream(listener=market_listener)

market_filter = streaming_market_filter(

market_ids=['1.130856098','1.132099836'])



market_data_filter = streaming_market_data_filter(

    fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF', 'EX_TRADED', 'EX_LTP'],

    ladder_levels=3)



market_stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter)



market_stream.start(async_=True)

```

---

## 2019-08-30 17:21:12 - issues channel

**Mo**

```

import argparse

import betfairlightweight

import time



market_ids = ['1.161554359', '1.161515961', '1.161776871', '1.161557163', '1.161658694', '1.161554616', '1.161524492', '1.161659060', '1.161516211', '1.161516095', '1.161516559', '1.161516443', '1.161516327', '1.161658810', '1.161524800', '1.161658944', '1.161524184', '1.161657639', '1.161524338', '1.161657890', '1.161525108', '1.161658158', '1.161658024', '1.161658426', '1.161658292', '1.161523876', '1.161658560', '1.161657756', '1.161524030', '1.161554766', '1.161557279', '1.161776286', '1.161524954', '1.161516675', '1.161555048', '1.161554916', '1.161557529', '1.161557663', '1.161557395', '1.161557779', '1.161776201', '1.161555180', '1.161558243', '1.161558002', '1.161524646', '1.161516793', '1.161558484', '1.161555312', '1.161523722', '1.161516909', '1.161776413', '1.161555693', '1.161555444', '1.161776987', '1.161776668', '1.161777339', '1.161777222', '1.161776540', '1.161777104', '1.161555981', '1.161558707']





if __name__ == '__main__':

    parser = argparse.ArgumentParser()

    parser.add_argument('--username')

    parser.add_argument('--password')

    parser.add_argument('--app_key')

    parser.add_argument('--certs')

    args = parser.parse_args()

    api = betfairlightweight.APIClient(

        username=args.username,

        password=args.password,

        app_key=args.app_key,

        certs=args.certs,

        lightweight=True

    )



    api.login()



    for iteration in range(10):

        market_books = api.betting.list_market_book(

            market_ids=market_ids[:40],

            price_projection=betfairlightweight.filters.price_projection(

                price_data=betfairlightweight.filters.price_data(

                    ex_best_offers=True

                )

            )

        ) + api.betting.list_market_book(

            market_ids=market_ids[40:],

            price_projection=betfairlightweight.filters.price_projection(

                price_data=betfairlightweight.filters.price_data(

                    ex_best_offers=True

                )

            )

        )

        received_market_ids = [m['marketId'] for m in market_books]

        print('Requested {} market_ids'.format(len(market_ids)))

        print('Received {} market_ids'.format(len(received_market_ids)))

        print('set(market_ids) - set(received_market_ids) = {}'.format(set(market_ids) - set(received_market_ids)))

        time.sleep(1)



    api.logout()

```

---

## 2019-08-29 09:17:57 - issues channel

**liam**

one order stream per account is fine, why per strategy? You can add customerRef and customerStrategyRef to separate orders easily enough

---

## 2019-08-29 09:16:24 - issues channel

**LK**

which is why I switched to using a separate orderstream per strategy, but that is running into connection limits now.

---

## 2019-08-28 20:12:19 - general channel

**liam**

Is your strategy still profitable if you do that?

---

## 2019-08-23 09:40:03 - general channel

**liam**

Thanks to [@UDCDFJ0NS](@UDCDFJ0NS) I created a PR which fixes a pretty major bug with the streaming order cache when betting on handicap markets. I am surprised this hasn't been found before, is there anyone out there using order streaming with handicap markets? [@U4H3EEV45](@U4H3EEV45) [@UBS7QANF3](@UBS7QANF3) [@U5D4ZBEAG](@U5D4ZBEAG)?

---

## 2019-08-15 13:05:55 - general channel

**Mo**

Redis is an in memory database but it has lots of functionality built upon that (you can use it for pubsub messaging for example). MySQL, Postgres etc would be RDBMSs. From your brief description, I suspect Redis might be a better fit for what you’re using MySQL for. Very generally speaking, I think Redis is better suited for live trading and a RDBMS for all of your “offline” data needs like backtesting, bet reconciliation etc

---

## 2019-08-15 12:07:42 - general channel

**Rob (NZ)**

Any advice for taking the leap from running code locally to putting it in AWS or GCP etc . I currently have a database with selections and some code that checks that every 30secs to look for bets to place .. if a bet meets the criteria then it places the bet ..  i use Jupyter notebooks so have an initial step that does the connection to the api so that seems to be persistent when I run other cells like the betting code etc.   Just wondering what type of structure others are using and if anyone knows of any good blogs on it etc. Happy to change my structure to something better but just not sure what that is..   wondering if a virtual machine is the way to go or possibly just use lambdas on AWS etc

---

## 2019-08-09 10:31:05 - issues channel

**Rob (NZ)**

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

C:\anaconda\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py in process_response(self, response_json, resource, elapsed_time, lightweight)

    106             try:

--&gt; 107                 return [resource(elapsed_time=elapsed_time, **x) for x in result]

    108             except TypeError:



C:\anaconda\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py in &lt;listcomp&gt;(.0)

    106             try:

--&gt; 107                 return [resource(elapsed_time=elapsed_time, **x) for x in result]

    108             except TypeError:



C:\anaconda\lib\site-packages\betfairlightweight\resources\bettingresources.py in __init__(self, **kwargs)

    256         self.description = MarketCatalogueDescription(**kwargs.get('description')) if \

--&gt; 257             kwargs.get('description') else None

    258         self.runners = [RunnerCatalogue(**i) for i in kwargs.get('runners', [])]



TypeError: __init__() missing 7 required positional arguments: 'discountAllowed', 'marketBaseRate', 'persistenceEnabled', 'regulator', 'rules', 'rulesHasDate', and 'wallet'



During handling of the above exception, another exception occurred:



InvalidResponse                           Traceback (most recent call last)

&lt;ipython-input-29-d9f9200f7a2b&gt; in &lt;module&gt;

      9     max_results='100',

     10     market_projection = ['MARKET_DESCRIPTION','RUNNER_METADATA','MARKET_START_TIME'],

---&gt; 11     sort='FIRST_TO_START'

     12 )

     13



C:\anaconda\lib\site-packages\betfairlightweight\endpoints\betting.py in list_market_catalogue(self, filter, market_projection, sort, max_results, locale, session, lightweight)

    156         method = '%s%s' % (self.URI, 'listMarketCatalogue')

    157         (response, elapsed_time) = self.request(method, params, session)

--&gt; 158         return self.process_response(response, resources.MarketCatalogue, elapsed_time, lightweight)

    159

    160     def list_market_book(self, market_ids, price_projection=None, order_projection=None,



C:\anaconda\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py in process_response(self, response_json, resource, elapsed_time, lightweight)

    107                 return [resource(elapsed_time=elapsed_time, **x) for x in result]

    108             except TypeError:

--&gt; 109                 raise InvalidResponse(response=result)

    110         else:

    111             try:



InvalidResponse: Invalid response received: [{'marketId': '1.161129845', 'marketName': 'R3 2200m Trot S', 'marketStartTime': '2019-08-09T09:00:00.000Z', 'description': {'persistenceEnabled': True, 'bspMarket': True, 'marketTime': '2019-08-09T09:00:00.000Z', 'suspendTime': '2019-08-09T09:00:00.000Z', 'bettingType': 'ODDS', 'turnInPlayEnabled': True, 'marketType': 'WIN', 'regulator': 'MALTA LOTTERIES AND GAMBLING AU

---

## 2019-07-28 17:17:56 - general channel

**liam**

Not sure what you mean, you only get an update if there is an update, there is a variable which holds the update called streaming_update which you can use [https://github.com/liampauling/betfair/blob/285d694b096daefe80b53eded7b5712d3cbaa4c7/betfairlightweight/resources/bettingresources.py#L477](https://github.com/liampauling/betfair/blob/285d694b096daefe80b53eded7b5712d3cbaa4c7/betfairlightweight/resources/bettingresources.py#L477)

---

## 2019-07-23 12:10:13 - general channel

**William**

How do you do trading.login_interactive() in flumine without certs?

---

## 2019-07-22 12:10:07 - general channel

**Oliver Varney**

Morning all, hope everyone had a nice weekend! Liam just looking through the flumine code now and was wondering if you separate out your market recording via flumine from your trading programs or can the two be easily used in conjugation without hacking code or performance issues?

---

## 2019-07-16 16:08:55 - general channel

**magiclevinho**

Dear All! My problem is that maybe i m not making valid request for traded volumes in match odds e.g.

I can see properly all things in market_book_CS[0] list only the HOME/AWAY/DRAW traded volumes.

My code is the following, which works for total traded volume only:

                    market_book_CS = trading.betting.list_market_book(

                        market_ids=[active_market_list[i+3]],

                        price_projection=filters.price_projection(

                            price_data=filters.price_data(

                                ex_all_offers=True

                            )

                        )

                    )

market_book_CS[0].total_matched

---

## 2019-07-14 22:52:11 - general channel

**Filippo Bovo**

Hello, everyone. When I log out of Betfair through the APIs after these steps, I get a `ConnectionError`:

1. The day before a match, I set up a scheduler that waits until 30 minutes before the start of a match to begin streaming a market.

2. 30 minutes before the start of the match, the scrip logs in again to Betfair if `trading.session_expired` is true and launches the market stream.

3. As soon as the match turns in-play the stream stops and the scrips logs out of Betfair as `trading.logout()` — at that point I've got the error.



Note that I run the above script in an AWS compute instance and that normally, I don't get errors when I log out.



Does anyone have a hint at why I get the error? Thanks.

---

## 2019-07-12 21:02:39 - general channel

**Newbie99**

possibly a very basic question....I keep getting orders randomly disappearing from my calcs and I can't see where in my code this is happening, so I think (perhaps incorrectly), its something really basic to do with how I'm capturing them from the queue.



Ignoring the functions, is there anything glaringly stupid here, that I have done, that could possibly result in missing items from queues (I've only noticed the order queue, but its not impossible I'm missing things from the market queue too and simply haven't spotted that):



```

while True:

    try:

        order_books = order_queue.get(block=True, timeout=0.5)

        market_books = market_queue.get(block=True, timeout=0.5)

    except Empty:

        try:

            market_books = market_queue.get(block=True, timeout=0.5)

        except Empty:

            update_all(order_books, market_books, mkt_runners, profitloss, trading, eo, mb, market_catalogues, start_time)

        finally:

            update_all(order_books, market_books, mkt_runners, profitloss, trading, eo, mb, market_catalogues, start_time)

    finally:

        update_all(order_books, market_books, mkt_runners, profitloss, trading, eo, mb, market_catalogues, start_time)

```

---

## 2019-07-07 21:45:14 - general channel

**Newbie99**

In the Betfair front end, I can see this bet has lapsed, however for some reason it shows as follows for me, via the API:



```

{'bet_id': '170304700688', 'average_price_matched': 0.0, 'bsp_liability': None, 'handicap': 0, 'matched_date': None, 'order_type': 'LIMIT', 'persistence_type': 'LAPSE', 'placed_date': '07/06/2019, 14:51:06', 'regulator_code': 'REG_GGC', 'side': 'LAY', 'price': 330, 'size': 4, 'size_cancelled': 0, 'size_lapsed': 0, 'size_matched': 0, 'size_remaining': 4, 'size_voided': 0, 'status': 'EXECUTABLE', 'customer_strategy_ref': '', 'customer_order_ref': ''}

```



Should I not expect size_lapsed = 4 in this instance, or is there some other way I should be checking for this?

---

## 2019-07-07 19:38:30 - general channel

**Mo**

[https://support.developer.betfair.com/hc/en-us/articles/115003887111-Why-am-I-receiving-the-error-BETTING-RESTRICTED-LOCATION-](https://support.developer.betfair.com/hc/en-us/articles/115003887111-Why-am-I-receiving-the-error-BETTING-RESTRICTED-LOCATION-)

---

## 2019-07-07 19:23:09 - general channel

**Filippo Bovo**

Has anyone used a Google Cloud instance to log in to the Betfair APIs? I am using a Google Cloud instance based in London (I also double checked that the IP address is based in London and it is). I get the following error when I try to log in `BETTING_RESTRICTED_LOCATION`. Has anyone had a similar experience with Google Cloud? Thanks.

---

## 2019-07-07 11:24:56 - random channel

**OT**

I've written for 3 betting APIs and it's the worst one. It's the second time I've written for matchbook api though, the first time the strategy was not so sensitive to this

---

## 2019-06-28 17:33:21 - general channel

**liam**

I have at most 1 or 2 market streams, using some logic to cast the net as wide as possible. A strategy then subscribed to a market and my handler then makes sure the strategy gets any updates for it. I can have 50ish strategies all on the same markets so would be pointless and expensive to be duplicating the markets in multiple streams 

---

## 2019-06-28 15:42:46 - general channel

**OT**

[@U4H19D1D2](@U4H19D1D2), in this case I am creating different threads for each sport/market so that betting strategy only runs within that thread, and then just passing the betfair_api object around. I'm doing it, but just looking to tidy it up a bit.

---

## 2019-06-28 15:39:25 - general channel

**liam**

[@U7QLCB7HA](@U7QLCB7HA) why multiple classes? For me I just use the api class for streaming order / market data and my execution class which handles place/cancel/replace, I then have a few threads for keep alive and catalogue requests when required. All handed the trading class at initialisation and then forgotten about 

---

## 2019-06-20 22:05:23 - general channel

**Dan**

trading = betfairlightweight.APIClient('deleted','deleted',app_key='deleted',certs='C:/users/danmi/PycharmProjects/bflight/venv/Lib/site-packages/betfairlightweight/certs')

---

## 2019-06-20 11:57:02 - general channel

**Mo**

```

days_ago = (datetime.datetime.utcnow() - datetime.timedelta(days=14)).strftime("%Y-%m-%dT%TZ")

acct_statement_date_filter = betfairlightweight.filters.time_range(from_=days_ago)



more_available = True

from_record = 0

data = []

while more_available:

    account_statement_result = trading.account.get_account_statement(item_date_range=acct_statement_date_filter, from_record=from_record)

    more_available = account_statement_result.more_available

    from_record += len(account_statement_result.account_statement)

    data.extend(account_statement_result._data['accountStatement'])



recent_transactions = pd.DataFrame(data)

recent_transactions

```

---

## 2019-06-13 13:33:10 - issues channel

**stefan**

Hi all, quick question regarding authentication. I am having trouble to establish a connection using `APIClient`. I am using the sample code `examplestreaming.py` from the repo with my details:



`trading = betfairlightweight.APIClient('xxx', 'xxx', app_key='xxx', cert_files=('./certs/client-2048.crt', './certs/client-2048.key'))`



When connecting I am getting the following error:```INFO:betfairlightweight.streaming.stream:[Stream: 1]: "MarketStream" created

INFO:betfairlightweight.streaming.listener:[Connect: 1]: connection_id: xxx

ERROR:betfairlightweight.streaming.listener:[Subscription: 2] UNEXPECTED_ERROR: Unknown error authenticating

Exception in thread BetfairSocket:

Traceback (most recent call last):

  File "C:\ProgramData\Anaconda3\lib\threading.py", line 917, in _bootstrap_inner

    self.run()

  File "C:\ProgramData\Anaconda3\lib\threading.py", line 865, in run

    self._target(*self._args, **self._kwargs)

  File "C:\ProgramData\Anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 198, in _read_loop

    self._data(received_data)

  File "C:\ProgramData\Anaconda3\lib\site-packages\betfairlightweight\streaming\betfairstream.py", line 239, in _data

    raise ListenerError(self.listener.connection_id, received_data)

betfairlightweight.exceptions.ListenerError: connection_id: xxx, data: {"op":"status","id":2,"statusCode":"FAILURE","errorCode":"UNEXPECTED_ERROR","errorMessage":"Unknown error authenticating","connectionClosed":true,"connectionId":"xxx"}

```



I was able to establish a connection using the sample code from betfair: `[https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Non-Interactive+%28bot%29+login#Non-Interactive(bot)login-SamplePythoncode](https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni/Non-Interactive+%28bot%29+login#Non-Interactive(bot)login-SamplePythoncode)`

Also the curl command with the same certificates and credentials is working fine to establish a connection.



Any suggestions/help would be very welcome. Thanks.

---

## 2019-06-10 09:46:37 - general channel

**liam**

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L252](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L252)

---

## 2019-05-26 10:16:34 - general channel

**Rob (NZ)**

cheers Liam,   I have been using the example code from the betfair website ...   would i just remove the event_id as I imagine thats filtering to just that single event and then put the code you provided down under the list_market_catalogue section?



market_catalogue_filter = `betfairlightweight`.filters.market_filter(event_ids=['28971066'])



market_catalogues = trading.betting.list_market_catalogue(

    filter=market_catalogue_filter,

    max_results='100',

    sort='FIRST_TO_START'

)



# Create a DataFrame for each market catalogue

market_types_mooney_valley = pd.DataFrame({

    'Market Name': [market_cat_object.market_name for market_cat_object in market_catalogues],

    'Market ID': [market_cat_object.market_id for market_cat_object in market_catalogues],

    'Total Matched': [market_cat_object.total_matched for market_cat_object in market_catalogues],

})



market_types_mooney_valley

---

## 2019-05-24 17:45:11 - issues channel

**Newbie99**

I keep randomly getting the following error (but not every time, seems to happen 3/5 times for a period then not again for ages, very odd):



```

betfairlightweight.exceptions.InvalidResponse: Invalid response received:

```



Sort of tricky to decipher exactly where its comeing from, possibly from:



```

        market_catalogues = trading.betting.list_market_catalogue(

        market_projection=["RUNNER_DESCRIPTION", "RUNNER_METADATA", "COMPETITION", "EVENT", "EVENT_TYPE",

                           "MARKET_DESCRIPTION", "MARKET_START_TIME"],

        filter=betfairlightweight.filters.market_filter(

        with_orders=["EXECUTION_COMPLETE", "EXECUTABLE"]),

        max_results=800)

```



Also, I think this has only occurred since the last update. Could it be related to the issue in the conversation above by chance, or is that a totally separate issue?

---

## 2019-05-22 02:03:24 - issues channel

**T**

``` OverflowError                             Traceback (most recent call last)

&lt;ipython-input-56-134ce2a3b2dc&gt; in &lt;module&gt;()

     26     place_orders = trading.betting.place_orders(

     27         market_id=market_id,

---&gt; 28         instructions=[instruction])

     29 

     30     break



C:\Users\user\Anaconda3\lib\site-packages\betfairlightweight\endpoints\betting.py in place_orders(self, market_id, instructions, customer_ref, market_version, customer_strategy_ref, async_, session, lightweight)

    331         params = clean_locals(locals())

    332         method = '%s%s' % (self.URI, 'placeOrders')

--&gt; 333         (response, elapsed_time) = self.request(method, params, session)

    334         return self.process_response(response, resources.PlaceOrders, elapsed_time, lightweight)

    335 



C:\Users\user\Anaconda3\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py in request(self, method, params, session)

     34         """

     35         session = session or self.client.session

---&gt; 36         request = self.create_req(method, params)

     37         date_time_sent = datetime.datetime.utcnow()

     38         try:



C:\Users\user\Anaconda3\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py in create_req(method, params)

     71                 'method': method,

     72                 'params': params,

---&gt; 73                 'id': 1

     74             }

     75         )



OverflowError: Maximum recursion level reached````

---

## 2019-05-22 02:01:45 - issues channel

**T**

Hi guys. I am pretty new to betfairlightweight so please bear with!



I am trying to place an order onto the exchange using the following code:



```limit_order = filters.limit_order(

            size=stake,

            price=price,

            persistence_type='LAPSE')



    instruction = filters.place_instruction(

        order_type='LIMIT',

        selection_id=selection_id,

        side='BACK',

        limit_order=limit_order)



    place_orders = trading.betting.place_orders(

        market_id=market_id,

        instructions=[instruction])```

---

## 2019-04-24 11:52:58 - general channel

**OT**

I often wonder if these people that write the APIs have ever been a user and programmed a strategy for one. although betfair's is definitely the best I've used.

---

## 2019-04-12 10:21:19 - general channel

**Dado**

price_filter = betfairlightweight.filters.price_projection(

		price_data=['EX_BEST_OFFERS']

	)



	market_books = trading.betting.list_market_book(

		market_ids=array_market_type_ids,

		price_projection=price_filter

	)

---

## 2019-04-12 10:06:48 - general channel

**Dado**

price_filter = betfairlightweight.filters.price_projection(

		price_data=['EX_BEST_OFFERS']

	)



	market_books = trading.betting.list_market_book(

		market_ids=array_market_type_ids,

		price_projection=price_filter

	)

---

## 2019-04-12 10:06:28 - general channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(event_ids=upcoming_events_id,market_type_codes=['MATCH_ODDS','TO_SCORE','FIRST_GOAL_SCORER'])

	market_catalogues = trading.betting.list_market_catalogue(

		filter=market_catalogue_filter,

		max_results='1000'

	)

---

## 2019-04-12 10:05:46 - general channel

**Dado**

thoroughbreds_event_filter = betfairlightweight.filters.market_filter(

		event_type_ids=[sport_id],

		in_play_only='false',

		market_start_time={

			'to': (datetime.datetime.utcnow() + datetime.timedelta(days=2)).strftime("%Y-%m-%dT%TZ")

		}

	)



	aus_thoroughbred_events = trading.betting.list_events(

		filter=thoroughbreds_event_filter

	)

---

## 2019-04-12 09:59:05 - general channel

**Dado**

def getUpcomingEvents(sport_id):

	thoroughbreds_event_filter = betfairlightweight.filters.market_filter(

		event_type_ids=[sport_id],

		in_play_only='false',

		market_start_time={

			'to': (datetime.datetime.utcnow() + datetime.timedelta(days=2)).strftime("%Y-%m-%dT%TZ")

		}

	)



	aus_thoroughbred_events = trading.betting.list_events(

		filter=thoroughbreds_event_filter

	)

---

## 2019-04-12 09:42:26 - general channel

**phil**

UK horses. There's a guy I know who gave me a strategy I want to test. I expect to find it doesn't work but I want to know for sure. Do people (like you guys,...) make a living with this stuff&gt;

---

## 2019-04-11 15:52:55 - issues channel

**Dado**

thoroughbreds_event_filter = betfairlightweight.filters.market_filter(

		event_type_ids=[sport_id],

		in_play_only='false',

		market_start_time={

			'to': (datetime.datetime.utcnow() + datetime.timedelta(days=2)).strftime("%Y-%m-%dT%TZ")

		}

	)



	aus_thoroughbred_events = trading.betting.list_events(

		filter=thoroughbreds_event_filter

	)

---

## 2019-04-11 10:18:00 - general channel

**liam**

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L193](https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L193)

---

## 2019-04-09 13:01:28 - general channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(

		market_ids=['1.156230909']

	)

	market_catalogues = trading.betting.list_market_catalogue(

		filter=market_catalogue_filter,

		max_results=1000,

		market_projection=["RUNNER_DESCRIPTION","MARKET_START_TIME", "COMPETITION"]

	)

	print(len(market_catalogues))

---

## 2019-04-09 12:57:44 - general channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(

		market_ids=[1.156230909],

		market_type_codes=["MATCH_ODDS","CORRECT_SCORE"]

	)

	market_catalogues = trading.betting.list_market_catalogue(

		filter=market_catalogue_filter,

		max_results=1000,

		market_projection=["RUNNER_DESCRIPTION","MARKET_START_TIME", "COMPETITION"]

	)

	print(len(market_catalogues))

---

## 2019-04-09 12:56:43 - general channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(

		market_ids=[14843951],

		market_type_codes=["MATCH_ODDS","CORRECT_SCORE"]

	)

	market_catalogues = trading.betting.list_market_catalogue(

		filter=market_catalogue_filter,

		max_results=1000,

		market_projection=["RUNNER_DESCRIPTION","MARKET_START_TIME", "COMPETITION"]

	)

	print(len(market_catalogues))

---

## 2019-04-09 12:50:24 - issues channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(

        event_ids=[14843951],

        market_type_codes=["MATCH_ODDS","CORRECT_SCORE"]

    )

    market_catalogues = trading.betting.list_market_catalogue(

        filter=market_catalogue_filter,

        max_results=1000,

        market_projection=["RUNNER_DESCRIPTION","MARKET_START_TIME", "COMPETITION"]

    )

    print(len(market_catalogues))

---

## 2019-04-09 12:44:38 - general channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(

		event_ids=[14843951],

		market_type_codes=["MATCH_ODDS","CORRECT_SCORE"]

	)

	market_catalogues = trading.betting.list_market_catalogue(

		filter=market_catalogue_filter,

		max_results=1000,

		market_projection=["RUNNER_DESCRIPTION","MARKET_START_TIME", "COMPETITION"]

	)

	print(len(market_catalogues))

---

## 2019-04-09 12:39:38 - general channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(

		event_ids=[14843951],

		market_type_codes=["MATCH_ODDS","CORRECT_SCORE"]

	)

	market_catalogues = trading.betting.list_market_catalogue(

		filter=market_catalogue_filter,

		max_results='1000',

		market_projection=["RUNNER_DESCRIPTION","MARKET_START_TIME", "COMPETITION"]

	)

	print(len(market_catalogues))

---

## 2019-04-09 12:35:17 - general channel

**Dado**

market_catalogue_filter = betfairlightweight.filters.market_filter(

		event_ids=['14843951'],

		market_type_codes=["MATCH_ODDS","CORRECT_SCORE"]

	)

	market_catalogues = trading.betting.list_market_book(

		filter=market_catalogue_filter,

		max_results='1000',

		market_projection=["RUNNER_DESCRIPTION"]

	)

---

## 2019-04-03 08:34:19 - general channel

**LK**

why would one use AWS instead of VPS like this one? [https://www.tradingservers.co.uk/?language=english](https://www.tradingservers.co.uk/?language=english)

---

## 2019-03-28 10:39:51 - general channel

**Ajay kumar**

i just have a dumb question.... can i use this betfairlightweight to create my own betting site ?

---

## 2019-03-25 19:18:59 - issues channel

**Paw**

Following up on the data question -&gt; do we have a secondary historical data market on here :wink: I'm looking for a month of premiership initially to start building my ingestion framework and ML models..

---

## 2019-03-15 22:13:29 - general channel

**seaders**

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L215](https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L215)

---

## 2019-03-15 22:10:03 - general channel

**seaders**

`.list_current_orders` returns a _single_ CurrentOrders object - [https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L556](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L556)

---

## 2019-03-15 22:01:03 - general channel

**Newbie99**

I think, this a 2 second question for someone (not streaming related).



```

current_order_list = trading.betting.list_current_orders(

    order_by="BY_MATCH_TIME",

    sort_dir="LATEST_TO_EARLIEST",

    record_count="20",

    lightweight=False)





print(current_order_list._data)

```



That works fine, except I can't seem to work out the correct way to iterate through Bet_id, I assumed I could just do something like:



```

for a in current_order_list:

    for b in a.currentOrders:

        print(b)

```



But that returns:



```

TypeError: 'CurrentOrders' object is not iterable

```



testing a[0] doesn't work either, so clearly I'm missing the correct way to iterate through this, as I've tried various alternatives and I can't figure it out....although I'm sure its a blindingly obvious answer! Would anyone care to put me out of my misery on this one?

---

## 2019-03-03 22:48:33 - issues channel

**seaders**

Do _something like_,

```

market_catalogues = trading.betting.list_market_catalogue(

            market_projection=["RUNNER_DESCRIPTION", "RUNNER_METADATA", "COMPETITION", "EVENT", "EVENT_TYPE", "MARKET_DESCRIPTION", "MARKET_START_TIME"],

            filter=betfairlightweight.filters.market_filter(

                market_ids=[mb.market_id for mb in market_books],

            ),

            max_results=100)

for market_book in market_books:

       for runner in market_book.runners:

        ```

---

## 2019-03-03 22:47:36 - issues channel

**seaders**

```for market_book in market_books:

       for runner in market_book.runners:



        market_catalogues = trading.betting.list_market_catalogue(

            market_projection=["RUNNER_DESCRIPTION", "RUNNER_METADATA", "COMPETITION", "EVENT", "EVENT_TYPE", "MARKET_DESCRIPTION", "MARKET_START_TIME"],

            filter=betfairlightweight.filters.market_filter(

                market_ids=[market_book.market_id],

            ),

            max_results=100)```

Also don't do ^^^ - if you've 1000 market_books, that'll be 1000 calls to list_market_catalogue

---

## 2019-03-03 21:25:06 - issues channel

**Newbie99**

I have another frustratingly dumb question...all I'm trying to do, is append runner name into market_book, based on selectionId. Logically this shouldn't be difficult, but I keep getting various errors, regardless of which method I use.



All I'm doing is, using the code posted the other day (or very similar):



```

    for market_book in market_books:

       for runner in market_book.runners:



        market_catalogues = trading.betting.list_market_catalogue(

            market_projection=["RUNNER_DESCRIPTION", "RUNNER_METADATA", "COMPETITION", "EVENT", "EVENT_TYPE", "MARKET_DESCRIPTION", "MARKET_START_TIME"],

            filter=betfairlightweight.filters.market_filter(

                market_ids=[market_book.market_id],

            ),

            max_results=100)



        data = []

        for market_catalogue in market_catalogues:

            for runner in market_catalogue.runners:

                data.append(

                    (runner.selection_id, runner.runner_name)

                )

```



That all works fine, but I then want to add runner name into market_book, based on selection_id = selectionId and I can't seem to do it.



Is this just a stupid idea (i.e. am I missing the obvious and market_book(s) is actually immutable?), should I simply be creating a new list and appending that with what I need from market_book(s) and the above 2 column data list, or is it a sensible approach and I'm just don't know how to do it correctly?

---

## 2019-02-24 18:34:50 - general channel

**liam**

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L774](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L774)

---

## 2019-02-23 19:58:55 - issues channel

**Newbie99**

All I wanted to do (and maybe I'm misunderstanding what Snap is for), is to get the full market state at every update.



So for example, for market x, I get the initial market on connection, e.g.



```

1 {'id': '1.130856098', 'marketDefinition': {'bspMarket': False, 'turnInPlayEnabled': False, 'persistenceEnabled': False, 'marketBaseRate': 5, 'eventId': '28180290', 'eventTypeId': '2378961', 'numberOfWinners': 1, 'bettingType': .....

```



Then every update an update e.g.



```

1 {'id': '1.130856098', 'rc': [{'batl': [[2, 2.8, 163.58], [1, 2.78, 2.61]], 'id': 12832765}, {'batb': [[2, 38, 4.36], [1, 42, 5.23], [0, 44, 25.58]], 'id': 12832769}, {'batb': [[1, 34, 4], [0, 36, 1]], 'id': 12832768}], 'con': True} 

```



That all works fine of course....however what I thought Snap would help is return an updated version of:



```

1 {'id': '1.130856098', 'marketDefinition': {'bspMarket': False, 'turnInPlayEnabled': False, 'persistenceEnabled': False, 'marketBaseRate': 5, 'eventId': '28180290', 'eventTypeId': '2378961', 'numberOfWinners': 1, 'bettingType': ...

```



On every update, but maybe I'm misunderstanding what the correct use of Snap is?

---

## 2019-02-23 19:39:15 - issues channel

**Newbie99**

Actually, having run a few attempts, the former doesn't seem to work either.



Running:



```

stream.start(_async=True)

time.sleep(2)

market_books = listener.snap(market_ids=['1.130856098'])



while True:

    market_books = output_queue.get()

    for market_book in market_books:

      print(

            market_book.streaming_unique_id,  

            market_book.streaming_update,  

            market_book.market_definition,  

            market_book.publish_time)  

```



Returns:



```

1 {'id': '1.130856098', 'marketDefinition': {'bspMarket': False, 'turnInPlayEnabled': False, 'persistenceEnabled': False, 'marketBaseRate': 5, 'eventId': '28180290', 'eventTypeId': '2378961', 'numberOfWinners': 1, 'bettingType': 'ODDS', 'marketType': 'NONSPORT', 'marketTime': '2019-03-29T00:00:00.000Z', 'suspendTime': '2019-03-29T00:00:00.000Z', 'bspReconciled': False, 'complete': True, 'inPlay': False, 'crossMatching': False, 'runnersVoidable': False, 'numberOfActiveRunners': 8, 'betDelay': 0, 'status': 'OPEN', 'runners': [{'status': 'ACTIVE', 'sortPriority': 1, 'id': 10064909}, {'status': 'ACTIVE', 'sortPriority': 2, 'id': 12832765}, {'status': 'ACTIVE', 'sortPriority': 3, 'id': 12832766}, {'status': 'ACTIVE', 'sortPriority': 4, 'id': 12832767}, {'status': 'ACTIVE', 'sortPriority': 5, 'id': 12832768}, {'status': 'ACTIVE', 'sortPriority': 6, 'id': 12832770}, {'status': 'ACTIVE', 'sortPriority': 7, 'id': 12832769}, {'status': 'ACTIVE', 'sortPriority': 8, 'id': 12832771}, {'status': 'LOSER', 'sortPriority': 9, 'id': 10317013}, {'status': 'LOSER', 'sortPriority': 10, 'id': 10317010}], 'regulators': ['MR_INT'], 'countryCode': 'GB', 'discountAllowed': True, 'timezone': 'Europe/London', 'openDate': '2019-03-29T00:00:00.000Z', 'version': 2576584033, 'priceLadderDefinition': {'type': 'CLASSIC'}}, 'rc': [{'batb': [[0, 2.66, 6.06], [1, 2.64, 20.7], [2, 2.58, 24.4]], 'batl': [[0, 2.68, 1], [1, 2.8, 163.58], [2, 2.94, 140.19]], 'id': 12832765}, {'batb': [[0, 18.5, 4], [1, 18, 3], [2, 17.5, 2]], 'batl': [[0, 19.5, 2], [1, 20, 7.88], [2, 21, 6.89]], 'id': 12832767}, {'batb': [[0, 8.2, 2], [1, 8, 6], [2, 7.8, 143.63]], 'batl': [[0, 9, 19.87], [1, 9.2, 2], [2, 9.4, 6.37]], 'id': 12832766}, {'batb': [[0, 42, 5.3], [1, 38, 4.36], [2, 36, 13.27]], 'batl': [[0, 55, 4], [1, 60, 2], [2, 70, 2]], 'id': 12832769}, {'batb': [[0, 36, 3], [1, 34, 2], [2, 30, 4]], 'batl': [[0, 46, 5.01], [1, 48, 1.91], [2, 50, 4.38]], 'id': 12832768}, {'batb': [[0, 6, 73.77], [1, 5.9, 14.65], [2, 5.8, 58]], 'batl': [[0, 6.2, 71.22], [1, 6.4, 96.21], [2, 6.6, 109.08]], 'id': 12832771}, {'batb': [[0, 40, 7.47], [1, 38, 2], [2, 36, 4.36]], 'batl': [[0, 48, 2], [1, 50, 2.36], [2, 55, 8.09]], 'id': 12832770}, {'batb': [[0, 4.1, 20], [1, 4, 31], [2, 3.95, 5.38]], 'batl': [[0, 4.5, 5], [1, 4.7, 61.8], [2, 5.5, 3.14]], 'id': 10064909}], 'img': True} &lt;betfairlightweight.resources.streamingresources.MarketDefinition object at 0x0000028F6EB9F4E0&gt; 2019-02-23 19:33:02.838000

1 {'id': '1.130856098', 'rc': [{'batl': [[2, 2.8, 163.58], [1, 2.78, 2.61]], 'id': 12832765}, {'batb': [[2, 38, 4.36], [1, 42, 5.23], [0, 44, 25.58]], 'id': 12832769}, {'batb': [[1, 34, 4], [0, 36, 1]], 'id': 12832768}], 'con': True} &lt;betfairlightweight.resources.streamingresources.MarketDefinition object at 0x0000028F6EB1EB70&gt; 2019-02-23 19:36:02.838000



```



i.e. the updates come through exactly the same as if I wasn't using the snap

---

## 2019-02-23 17:23:26 - issues channel

**Newbie99**

```

import logging

import time

import queue

from queue import Empty

from flask import Flask, render_template

from flask_socketio import SocketIO, emit

import betfairlightweight

from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter,

)

from account_info import accname, accpass, acckey, path



logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))



trading = betfairlightweight.APIClient(accname, accpass, acckey, certs=path)

trading.login()



output_queue = queue.Queue()

listener = betfairlightweight.StreamListener(output_queue=output_queue)

stream = trading.streaming.create_stream(listener=listener)



# create filters (US WIN horse racing)

market_filter = streaming_market_filter(

#    event_type_ids=['7'],

#    country_codes=['US'],

#    market_types=['WIN'])

     market_ids=['1.130856098'])

market_data_filter = streaming_market_data_filter(

    fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF'],

    ladder_levels=3)



stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000)



stream.start(_async=True)



market_books = listener.snap(market_ids=['1.130856098'])

```

---

## 2019-02-23 17:20:01 - issues channel

**Newbie99**

well that much I'd guessed :wink:



But my stream appears to be working correctly (i.e. I see market updates such as):



```

1 {'id': '1.130856098', 'marketDefinition': {'bspMarket': False, 'turnInPlayEnabled': False, 'persistenceEnabled': False, 'marketBaseRate': 5, 'eventId': '28180290', 'eventTypeId': '2378961', 'numberOfWinners': 1, 'bettingType': 'ODDS', 'marketType': 'NONSPORT', 'marketTime': '2019-03-29T00:00:00.000Z', 'suspendTime': '2019-03-29T00:00:00.000Z', 'bspReconciled': False, 'complete': True, 'inPlay': False, 'crossMatching': False, 'runnersVoidable': False, 'numberOfActiveRunners': 8, 'betDelay': 0, 'status': 'OPEN', 'runners': [{'status': 'ACTIVE', 'sortPriority': 1, 'id': 10064909}, {'status': 'ACTIVE', 'sortPriority': 2, 'id': 12832765}, {'status': 'ACTIVE', 'sortPriority': 3, 'id': 12832766}, {'status': 'ACTIVE', 'sortPriority': 4, 'id': 12832767}, {'status': 'ACTIVE', 'sortPriority': 5, 'id': 12832768}, {'status': 'ACTIVE', 'sortPriority': 6, 'id': 12832770}, {'status': 'ACTIVE', 'sortPriority': 7, 'id': 12832769}, {'status': 'ACTIVE', 'sortPriority': 8, 'id': 12832771}, {'status': 'LOSER', 'sortPriority': 9, 'id': 10317013}, {'status': 'LOSER', 'sortPriority': 10, 'id': 10317010}], 'regulators': ['MR_INT'], 'countryCode': 'GB', 'discountAllowed': True, 'timezone': 'Europe/London', 'openDate': '2019-03-29T00:00:00.000Z', 'version': 2576584033, 'priceLadderDefinition': {'type': 'CLASSIC'}}, 'rc': [{'batb': [[0, 2.66, 9.96], [1, 2.64, 20.7], [2, 2.58, 24.4]], 'batl': [[0, 2.8, 163.58], [1, 2.94, 140.19], [2, 2.96, 11]], 'id': 12832765}, {'batb': [[0, 18.5, 4], [1, 18, 3], [2, 17.5, 2]], 'batl': [[0, 19.5, 2], [1, 20, 7.88], [2, 21, 6.89]], 'id': 12832767}, {'batb': [[0, 8.2, 2], [1, 8, 6], [2, 7.8, 143.63]], 'batl': [[0, 9, 19.87], [1, 9.2, 2], [2, 9.4, 6.37]], 'id': 12832766}, {'batb': [[0, 44, 25.58], [1, 42, 5.23], [2, 38, 4.36]], 'batl': [[0, 55, 4], [1, 60, 2], [2, 70, 2]], 'id': 12832769}, {'batb': [[0, 36, 1], [1, 34, 2], [2, 30, 4]], 'batl': [[0, 40, 3.8], [1, 42, 8.2], [2, 44, 2.01]], 'id': 12832768}, {'batb': [[0, 6, 73.77], [1, 5.9, 14.65], [2, 5.8, 58]], 'batl': [[0, 6.2, 71.22], [1, 6.4, 96.21], [2, 6.6, 109.08]], 'id': 12832771}, {'batb': [[0, 40, 7.47], [1, 38, 2], [2, 36, 4.36]], 'batl': [[0, 44, 1.72], [1, 46, 1], [2, 48, 2]], 'id': 12832770}, {'batb': [[0, 4.1, 2], [1, 4, 31], [2, 3.95, 5.38]], 'batl': [[0, 4.5, 5], [1, 4.7, 61.8], [2, 5.5, 3.14]], 'id': 10064909}], 'img': True} &lt;betfairlightweight.resources.streamingresources.MarketDefinition object at 0x000002720FE564E0&gt; 2019-02-23 17:19:24.141000

```



If I remove that 1 line.

---

## 2019-02-23 17:02:18 - issues channel

**Newbie99**

I was simply calling:



```

stream = trading.streaming.create_stream(listener=listener.snap(market_ids=['1.130856098']))

```

---

## 2019-02-18 19:36:35 - issues channel

**Newbie99**

Hmm, I tried a couple of different browsers, with the same result, however I'm 99% sure your diagnosis is correct here, from playing around with sleep in Python and setInterval on the browser side.



Server:



```

@socketio.on('ping')

def handle_message(*_args, **_kwargs):

    emit('my_response2', 'text')

    socketio.sleep(1)

    stream_send()



def stream_send(*_args, **_kwargs):

    market_books = output_queue.get()

    for market_book in market_books:

       emit('my_response',{'message':market_book.streaming_update})

    socketio.sleep(1)

    emit('my_response2', 'text')

```



In the server logs this pauses here:



```

INFO:engineio.server:3fd83d077e694382a70dc6d73429cc51: Sending packet MESSAGE data 2["my_response",{"message":{"id":"1.155109947","marketDefinition":{"bspMarket":true,"turnInPlayEnabled":false,"persistenceEnabled":false,"marketBaseRate":5,"eventId":"29138495","eventTypeId":"7","numberOfWinners":1,"bettingType":"ODDS","marketType":"WIN","marketTime":"2019-02-19T01:10:00.000Z","suspendTime":"2019-02-19T01:10:00.000Z","bspReconciled":false,"complete":true,"inPlay":false,"crossMatching":false,"runnersVoidable":false,"numberOfActiveRunners":9,"betDelay":0,"status":"OPEN","runners":[{"status":"ACTIVE","sortPriority":1,"id":22937351},{"status":"ACTIVE","sortPriority":2,"id":22937352},{"status":"ACTIVE","sortPriority":3,"id":22937353},{"status":"ACTIVE","sortPriority":4,"id":22937354},{"status":"ACTIVE","sortPriority":5,"id":22937355},{"status":"ACTIVE","sortPriority":6,"id":22937356},{"status":"ACTIVE","sortPriority":7,"id":22937361},{"status":"ACTIVE","sortPriority":8,"id":22937362},{"status":"ACTIVE","sortPriority":9,"id":11502826}],"regulators":["MR_NJ","MR_INT"],"venue":"Dover Downs","countryCode":"US","discountAllowed":true,"timezone":"US/Eastern","openDate":"2019-02-18T21:30:00.000Z","version":2645887285,"priceLadderDefinition":{"type":"CLASSIC"}},"rc":[{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.67]],"id":22937361},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.63]],"id":22937356},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.65]],"id":22937354},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.69]],"id":11502826},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.73]],"id":22937355},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.69]],"id":22937352},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.69]],"id":22937353},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.73]],"id":22937351},{"batb":[[0,1.01,17.52]],"batl":[[0,1000,1.7]],"id":22937362}],"img":true}}]

INFO:socketio.server:emitting event "my_response2" to 3fd83d077e694382a70dc6d73429cc51 [/]

INFO:engineio.server:3fd83d077e694382a70dc6d73429cc51: Sending packet MESSAGE data 2["my_response2","text"]

127.0.0.1 - - [18/Feb/2019 19:28:27] "POST /socket.io/?EIO=3&amp;transport=polling&amp;t=1550518105709-1&amp;sid=3fd83d077e694382a70dc6d73429cc51 HTTP/1.1" 200 219 2.080826

INFO:engineio.server:3fd83d077e694382a70dc6d73429cc51: Upgrade to websocket successful

INFO:engineio.server:3fd83d077e694382a70dc6d73429cc51: Received packet MESSAGE data 2["ping"]

INFO:socketio.server:received event "ping" from 3fd83d077e694382a70dc6d73429cc51 [/]

INFO:socketio.server:emitting event "my_response2" to 3fd83d077e694382a70dc6d73429cc51 [/]

INFO:engineio.server:3fd83d077e694382a70dc6d73429cc51: Sending packet MESSAGE data 2["my_response2","text"]

```



From the client side it appears to ping pong twice successfully on connection, then sends the market book, then (seemingly) it ping pongs twice before stopping (the above is with no delay on emitting a ping on the browser side, if I delay then the behaviour actually seems counter intuitive in that it appears 2 pings arrive before the last pong).



So as you can see, it does appear your diagnosis is correct, but somewhere along the line maybe the messages go out of sync, thus breaking the socket?

---

## 2019-02-17 13:48:17 - general channel

**Marcel**

Hello, nice there is a Phyton Betfair API community! I am new to Python and the Betfair API. Currently I use a vendor application in combination with Excel VBA.



To improve speed and flexibility I would like to build a bot in Python for betting on Match Odds soccer. Does someone has a script which generates a coupon of matches for the day with betting functionality which I can use as a starting point to add my criteria to place bets on those markets? That would be great!

---

## 2019-02-16 17:39:52 - issues channel

**Newbie99**

```

import os

import logging

import queue

from threading import Thread

from flask import Flask, render_template

from flask_socketio import SocketIO, emit

import betfairlightweight

from betfairlightweight.filters import (

            streaming_market_filter,

            streaming_market_data_filter,

        )



# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# create trading instance (app key must be activated for streaming)

username = os.environ.get('username')

trading = betfairlightweight.APIClient(user_name, password, appkey, certs=cert_path)

trading.login()



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(

    output_queue=output_queue,

)



# create stream

stream = trading.streaming.create_stream(

    listener=listener,

)



# create filters (GB WIN racing)

market_filter = streaming_market_filter(

        event_type_ids=['7'],

        country_codes=['US'],

        market_types=['WIN'],

)

market_data_filter = streaming_market_data_filter(

    fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF'],

    ladder_levels=3,

)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



# start stream

stream.start(_async=True)



# Create a flask app

app = Flask(__name__)

app.config['SECRET_KEY'] = 'secret!'

# Use the flask app to create a socketio decorator

socketio = SocketIO(app)

thread = None



@app.route('/')

def index():

    global thread

    if thread is None:

        thread = Thread(target=handle_message)

        thread.start()

        socketio.sleep(2)

        return render_template('index.html')



@socketio.on('connect', namespace='/test')

def test_connect():

        global thread

        socketio.sleep(1)

        market_books = output_queue.get()

        print(market_books)

        for market_book in market_books:

             print(

             market_book,

             market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

             market_book.streaming_update,  # json update received

             market_book.market_definition,  # streaming definition, similar to catalogue request

             market_book.publish_time  # betfair publish time of update

        )



        for market_book in market_books:

             emit('my_response', {'data': 'connect', 'mb': market_book.streaming_update, 'namespace': '/test'})

        socketio.sleep(1)

@socketio.on('ping', namespace='/test')

def handle_message(*_args, **_kwargs):

    global thread

    while True:

        socketio.sleep(2)

        emit('my_response', {'data': 'pong', 'mb': 'pong', 'namespace': '/test'})

        socketio.sleep(2)

        market_books = output_queue.get()

        print(market_books)



        for market_book in market_books:

            print(

                market_book,

                market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

                market_book.streaming_update,  # json update received

                market_book.market_definition,  # streaming definition, similar to catalogue request

                market_book.publish_time  # betfair publish time of update

            )



        for market_book in market_books:

            emit('my_response', {'data': 'update', 'mb': market_book.streaming_update, 'namespace': '/test'})

        socketio.sleep(1)



if __name__ == '__main__':

    socketio.run(app, debug=True, host='127.0.0.1', port=5000)

stream.stop()

```

---

## 2019-02-09 17:22:40 - issues channel

**Newbie99**

Okay, sorry I'm back again and really confused!



This appears to connect, but doesn't seem to emit any messages:



```

import os

import logging

import queue



from flask import Flask, render_template

from flask_socketio import SocketIO



import betfairlightweight

from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter,

)



app = Flask(__name__)

app.config['SECRET_KEY'] = secretkey

socketio = SocketIO(app)



@app.route('/')

def sessions():

    return render_template('index.html')



# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# create trading instance (app key must be activated for streaming)

username = os.environ.get('username')

trading = betfairlightweight.APIClient(user_name,password,appkey,certs=cert_path)

trading.login()



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(

    output_queue=output_queue,

)



# create stream

stream = trading.streaming.create_stream(

    listener=listener,

)



# create filters (GB WIN racing)

market_filter = streaming_market_filter(

#    event_type_ids=['7'],

#    country_codes=['GB'],

#    market_types=['WIN'],

    market_ids=['1.130856098'],

)

market_data_filter = streaming_market_data_filter(

    fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF'],

    ladder_levels=3,

)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



#start stream

stream.start(_async=True)





"""while True:

    market_books = output_queue.get()

    print(market_books)



    for market_book in market_books:

        print(

            market_book,

            market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

            market_book.streaming_update,  # json update received

            market_book.market_definition,  # streaming definition, similar to catalogue request

            market_book.publish_time  # betfair publish time of update

        )"""



@socketio.on('ping')

def handle_message(_message):

    market_books = output_queue.get()

    print(market_books)



    for market_book in market_books:

        emit(

            'market_book',

            f'{market_book} '

            f'{market_book.streaming_unique_id} '

            f'{market_book.streaming_update}, '

            f'{market_book.market_definition}, '

            f'{market_book.publish_time} '

        )



if __name__ == '__main__':

    socketio.run(app, debug=True)

```

---

## 2019-02-07 18:38:51 - issues channel

**Newbie99**

thank you for your code snippet seaders, however maybe I'm being really dense, but it doesn't appear to be working. The client code says io isn't defined, so I tried with the sample code from the Flask page, which doesn't return an error, but still nothing happens. I feel that the problem is probably still with my server code, which is currently as follows. Python is very new to me, so this attempt at editing the streaming example, might be a bit poor, but as I don't get any errors, its a bit tricky to see where the problem is!



[code]

import os

import logging

import queue



import betfairlightweight

from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter,

)



from flask import Flask, render_template

from flask_socketio import SocketIO



# setup logging

logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))  # change to DEBUG to see log all updates



# create trading instance (app key must be activated for streaming)

username = os.environ.get('username')





# create trading instance

trading = betfairlightweight.APIClient(user_name,password,appkey,certs=cert_path)



trading.login()



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(

    output_queue=output_queue,

)



# create stream

stream = trading.streaming.create_stream(

    listener=listener,

)



# create filters (GB WIN racing)

market_filter = streaming_market_filter(

    event_type_ids=['7'],

    country_codes=['GB'],

    market_types=['WIN'],

)

market_data_filter = streaming_market_data_filter(

    fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF'],

    ladder_levels=3,

)



# subscribe

streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=1000,  # send update every 1000ms

)



# start stream

stream.start(_async=True)



"""

Data can also be accessed by using the snap function in the listener, e.g:

    market_books = listener.snap(

        market_ids=[1.12345323]

    )

Errors need to be caught at stream.start, resubscribe can then be used to

prevent full image being sent, e.g:

    streaming_unique_id = stream.subscribe_to_markets(

        market_filter=market_filter,

        market_data_filter=market_data_filter,

        conflate_ms=1000,  # send update every 1000ms

        initial_clk=listener.initial_clk,

        clk=listener.clk,

    )

The streaming unique id is returned in the market book which allows multiple

streams to be differentiated if multiple streams feed into the same queue.

"""



# check for updates in output queue

while True:

    market_books = output_queue.get()

    print(market_books)





    for market_book in market_books:

        print(

            market_book,

            market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

            market_book.streaming_update,  # json update received

            market_book.market_definition,  # streaming definition, similar to catalogue request

            market_book.publish_time  # betfair publish time of update

        )



app = Flask(__name__)

app.config['SECRET_KEY'] = 'secret!'

socketio = SocketIO(app)



if __name__ == '__main__':

    socketio.run(app)



stream = None

queue = None





def get_queue():

    global queue, stream



    if not queue:

        stream, queue =  trading.streaming.create_stream(

    listener=listener,

)

    return queue



@socketio.on('ping')

def handle_message(_message):

    market_books = get_queue().get()

    print(market_books)



    for market_book in market_books:

        emit(

            'market_book',

            f'{market_book} '

            f'{market_book.streaming_unique_id} '

            f'{market_book.streaming_update}, '

            f'{market_book.market_definition}, '

            f'{market_book.publish_time} '

        )





if __name__ == '__main__':

    socketio.run(app)

    stream.stop()



[/code]

---

## 2019-02-02 09:56:27 - general channel

**wsdlwizard**

I am trying to simulate betting and need to instantiate an object of type CurrentOrder. My import is "from betfairlightweight.resources.bettingresources import PriceSize,CurrentOrder"  and my code is "test = CurrentOrder(5.5,'1234567',4.5,'1','2',1.0,'654987',datetime.datetime(2019,1,1,12,0,0),'PERSIST',datetime.datetime(2019,1,1,12,0,0),{'price':2.0,'size':20.0},'3',123456,'BACK',0.0,0.0,0.0,0.0,0.0,'SUCCESS')

" I get the error "TypeError: type object argument after ** must be a mapping, not float " any ideas? Many thanks.

---

## 2019-01-30 06:49:08 - issues channel

**liam**

[@UFTBRB3F1](@UFTBRB3F1) in regards to your question on the forum



certs_dir = r’C:/windows/sucks/python/certs’



trading = APIClient(’username’, ’password’, ’appKey’, certs=certs_dir)

---

## 2019-01-29 19:41:00 - issues channel

**Newbie99**

Hi,



I'm having real trouble with certs at the moment and having read about a thousand Github pages and various others I'm no closer.



I created certs using XCA and have a .pem and a .crt file. I have uploaded the .crt file to Betfair and enabled it for Bot trading...however thats where it all falls down.



I've tried both the Betfair and Betfairlightweight Python wrappers, but both keep coming up with various error messages, relating to the certs.



For Betfairlightweight, I have no idea where it expects them to be, as there's no certs folder and even if I attempt to change the path, it still doesn't work.



For the Betfair python wrapper, it just produces a similar error, although at least that seems to have a certs folder.



I've tried the following Curl request:



curl -q -k --cert CERT.pem [https://identitysso-cert.betfair.com/api/certlogin](https://identitysso-cert.betfair.com/api/certlogin) -d "username='USERNAME'&amp;password='PASSWORD'" -H "'APPKEY': curlCommandLineTest"

---

## 2019-01-21 23:36:14 - general channel

**Rob**

print(type(market_books[0].runners[0])) gives me &lt;class 'betfairlightweight.resources.bettingresources.RunnerBook'&gt;

---

## 2019-01-21 23:35:33 - general channel

**Rob**

print(type(market_books[0])) gives me &lt;class 'betfairlightweight.resources.bettingresources.MarketBook'&gt;

---

## 2019-01-21 21:46:01 - general channel

**Rob**

import os

import logging

import queue

import betfairlightweight

from betfairlightweight.filters import (

    streaming_market_filter,

    streaming_market_data_filter

)



#logging.basicConfig(level=[http://logging.INFO|logging.INFO](http://logging.INFO|logging.INFO))

# OR TO GET MORE INFORMATIOJN logging.basicConfig(level=logging.DEBUG)





trading = betfairlightweight.APIClient('my [mailto:email@mail.com|email@mail.com](mailto:email@mail.com|email@mail.com)', 'my pass', app_key='my app key')

trading.login()

trading.session_token

print(trading.session_token)



# create queue

output_queue = queue.Queue()



# create stream listener

listener = betfairlightweight.StreamListener(

    output_queue=output_queue,

)





 #create filters (GB WIN racing)

market_filter = streaming_market_filter(

    market_ids=["1.153765710"]

)



market_data_filter = streaming_market_data_filter(

    fields=["EX_MARKET_DEF","EX_BEST_OFFERS","EX_LTP"],

    ladder_levels=3,

)



streaming_unique_id = stream.subscribe_to_markets(

    market_filter=market_filter,

    market_data_filter=market_data_filter,

    conflate_ms=0,  # send update every 1000ms

)



# start stream

stream.start(_async=True)





# check for updates in output queue

while True:

    market_books = output_queue.get()

    #print(market_books)



    for market_book in market_books:

        print(market_book.streaming_update

            #market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)

            #market_book.streaming_update,  # json update received

            #market_book.market_definition,  # streaming definition, similar to catalogue request

            #market_book.publish_time  # betfair publish time of update

        )

---

## 2019-01-13 20:14:43 - general channel

**Rob**

Hello all, can someone help me here (Python Newbie)? when i run "runner.ex.traded_volume" i get this &lt;betfairlightweight.resources.bettingresources.PriceSize object at 0x000002797A1AD828&gt;

---

## 2018-12-12 16:01:33 - general channel

**JMaster**

[@U5D4ZBEAG](@U5D4ZBEAG) my visualiser gets the same 12 events. with respect to the bettingresources.py, excuse the simple question, but do I run this within my script?

---

## 2018-12-12 13:40:16 - general channel

**seaders**

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L94](https://github.com/liampauling/betfair/blob/master/betfairlightweight/resources/bettingresources.py#L94)

---

## 2018-12-12 13:38:13 - general channel

**JMaster**

[@U4H19D1D2](@U4H19D1D2) [@U5D4ZBEAG](@U5D4ZBEAG) trying to list markets:





# make event request to find listed events

special_bet_events = trading.betting.list_events(

filter=filters.market_filter(

text_query='Special Bets'

)

)



# returns result

print(special_bet_events)



however, I get returned 12 &lt;EventResult&gt; instead of the 12 different event names. Please can you help.

---

## 2018-12-03 20:01:10 - general channel

**JMaster**

trading.logininteractive()

Traceback (most recent call last):

  File "&lt;input&gt;", line 1, in &lt;module&gt;

AttributeError: 'APIClient' object has no attribute 'logininteractive'

---

## 2018-12-03 19:58:33 - general channel

**liam**

Do you get the same error with trading.logininteractive()

---

## 2018-12-03 19:57:12 - general channel

**JMaster**

could it be something to do with the directories, in the error it shows venv/lib/.... where as when I did print(trading.cert) the path does not show the same (venv/lib/...)

---

## 2018-12-03 19:47:56 - general channel

**JMaster**

trading = betfairlightweight.APIClient('myusername', password='mypassword', app_key=('myappkey'), certs='C:/Users/mrmax/Desktop/MRHP/betfair-master/betfairlightweight/certs/')

---

## 2018-12-03 19:23:33 - general channel

**JMaster**

adding certs='...' went through, but still got same error when running trading.login()

---

## 2018-12-03 19:08:14 - general channel

**JMaster**

[@U4H19D1D2](@U4H19D1D2) I am getting the below - sorry but have no idea how to resolve? Thanks in advance.

trading.login()

Traceback (most recent call last):

  File "&lt;input&gt;", line 1, in &lt;module&gt;

  File "C:\Users\mrmax\Desktop\MRHP\venv\lib\site-packages\betfairlightweight\endpoints\login.py", line 30, in __call__

    (response, elapsed_time) = self.request(self.url, session=session)

  File "C:\Users\mrmax\Desktop\MRHP\venv\lib\site-packages\betfairlightweight\endpoints\login.py", line 52, in request

    self._error_handler(response_data)

  File "C:\Users\mrmax\Desktop\MRHP\venv\lib\site-packages\betfairlightweight\endpoints\login.py", line 57, in _error_handler

    raise self._error(response)

betfairlightweight.exceptions.LoginError: API login: CERT_AUTH_REQUIRED

---

## 2018-12-03 02:11:03 - general channel

**JMaster**

however when I run trading.login()   --&gt;  betfairlightweight.exceptions.LoginError: API login: CERT_AUTH_REQUIRED

---

## 2018-12-02 12:05:02 - general channel

**Donkey**

final code for me and it works:

```# grep betfairlightweight.APIClient exampleone.py

trading = betfairlightweight.APIClient(username=os.environ.get('_USERNAME'), password=os.environ.get('_PASSWORD'), app_key=os.environ.get('_APIKEY'))```



and in ~/.bash_profile   (fake stuff below…) but use your real ones.

export _APIKEY=“12345”

export _USERNAME=“123ABCD”

export _PASSWORD=“67890”

---

## 2018-12-02 11:48:14 - general channel

**Donkey**

I guess I need to modify the line then, but for what please?

```# create trading instance

trading = betfairlightweight.APIClient('username', 'password', app_key='appKey')```

---

## 2018-12-02 11:14:57 - general channel

**Donkey**

if I change in the code:

`trading = betfairlightweight.APIClient('username', 'password', app_key='appKey')`

for my actual username etc…   then the code works fine

---

## 2018-12-02 10:55:18 - general channel

**Donkey**

I’m looking for some help please with the .bash_profile content.

Currently set with (fake username/api/pass this is just an example, I use the real ones on my server):

```export username="johnsmith"

export appKey="1234567890"

export password="abcdef"```



In the exampleone.py I have:

```# create trading instance

trading = betfairlightweight.APIClient('username', 'password', app_key='appKey')```



On execution I get however the following error:

```# python exampleone.py

Traceback (most recent call last):

  File "exampleone.py", line 10, in &lt;module&gt;

    trading.login()

  File "/usr/lib/python3.6/site-packages/betfairlightweight/endpoints/login.py", line 30, in __call__

    (response, elapsed_time) = self.request(self.url, session=session)

  File "/usr/lib/python3.6/site-packages/betfairlightweight/endpoints/login.py", line 52, in request

    self._error_handler(response_data)

  File "/usr/lib/python3.6/site-packages/betfairlightweight/endpoints/login.py", line 57, in _error_handler

    raise self._error(response)

betfairlightweight.exceptions.LoginError: API login: ACCOUNT_PENDING_PASSWORD_CHANGE```



But my actual password logs me in betfair account without any issues.



Thanks for the help.

---

## 2018-11-12 11:26:01 - general channel

**seaders**

in another part of the code, that order is placed, and that strategy is placed on hold until it receives an order update

---

## 2018-11-12 11:25:33 - general channel

**seaders**

in my strat, my code places any strategy in a "ORDER_PLACED" status, when the strategy decides to place an order

---

## 2018-11-11 18:47:12 - general channel

**stephencornelius**

Hi All, does anyone know whether theres an issue using the streaming api to just gather data without placing any bets?



I recall betfair said that on the previous api they would cut you off after a period of time if you werent placing bets and just wondered if this was true of the streaming api as well?



My reason being that I want to build up some price data first which i will use to test the betting functionality. Its a pretty normal use case but can understand betfair being against it since they sell it themselves now

---

## 2018-11-07 13:12:49 - general channel

**George**

The problem with using a non-Fill or Kill order is that I would want any unmatched portion to be cancelled and not rest on the book. I think it's a valid and not uncommon strategy to say I'd rather not be the only guy offering liquidity at the top level of the book.

---

## 2018-11-07 12:50:13 - general channel

**seaders**

hmmm, BF do *a lot* of dumb things, but I'm not 100% sure what your problem is with this strategy is [@UCQB6S222](@UCQB6S222)?

---

## 2018-10-18 16:51:32 - general channel

**LK**

ok. Allthough that is present in the 'advanced' data I see. But I was assuming that just meant best back/lay (like a BBO in stock-trading). That could still mean that virtual / implied prices are not in the advanced historical data.

---

## 2018-08-30 11:06:45 - general channel

**seaders**

And kinda the same with your strategy, figuring out exactly what you want from the market, and how you'd want it to look for your "action 1", or "action 2" will serve you better

---

## 2018-08-30 11:04:36 - general channel

**seaders**

Again, you should be deciding things like this for your own strategy

---

## 2018-08-28 13:01:54 - general channel

**favetelinguis**

Since its not the same horses in both markets but it is likely the same market partitioners you want to model the behavior of the partitioners

---

## 2018-08-27 12:50:58 - issues channel

**liam**

Helpful for the website / trading apps, it will be updated during the day but I believe it is static from about 10mins out

---

## 2018-08-16 20:37:23 - general channel

**Tom**

Hi, I'm trying to modify this code to use lightweight in order to gather tennis data from betfair api on a cronjob and save to a model. I'm having an isssue with getting competition names from list.market.catalogue, I'm getting the following error AttributeError: 'tuple' object has no attribute 'competition' Can anyone help? Code and stacktrace posted below. Thanks

---

## 2018-08-03 13:29:38 - general channel

**Matt P**

With regards to my employer, only a couple of years ago it actually used to be gross misconduct to bet at work. Fortunately now though they're much more relaxed and betting from the office isn't a problem

---

## 2018-07-30 14:11:56 - general channel

**Ian**

(casbi) ian@KYOFBU C:\code\casbi\casbi

$ python casbi.py

Traceback (most recent call last):

  File "casbi.py", line 5, in &lt;module&gt;

    import betfairlightweight

  File "C:\Users\ian\Envs\casbi\lib\site-packages\betfairlightweight\__init__.py", line 3, in &lt;module&gt;

    from .apiclient import APIClient

  File "C:\Users\ian\Envs\casbi\lib\site-packages\betfairlightweight\apiclient.py", line 2, in &lt;module&gt;

    from . import endpoints

  File "C:\Users\ian\Envs\casbi\lib\site-packages\betfairlightweight\endpoints\__init__.py", line 4, in &lt;module&gt;

    from .betting import Betting

  File "C:\Users\ian\Envs\casbi\lib\site-packages\betfairlightweight\endpoints\betting.py", line 277

    customer_strategy_ref=None, async=None, session=None, lightweight=None):

                                    ^

SyntaxError: invalid syntax



(casbi) ian@KYOFBU C:\code\casbi\casbi

$

---

## 2018-07-24 20:54:37 - general channel

**liam**

[https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L171](https://github.com/liampauling/betfair/blob/master/betfairlightweight/endpoints/betting.py#L171)

---

## 2018-06-18 13:16:36 - general channel

**mbk**

According to the documentation, this uses the default roll-up model STAKE, with roll-up of minimum stake:

[http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-ExBestOffersOverrides](http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-ExBestOffersOverrides)

---

## 2018-04-11 22:35:06 - issues channel

**OT**

python3.5/site-packages/betfairlightweight/resources/bettingresources.py", line 489, in __init__

    ) if kwargs.get('keyLineDescription') else None

TypeError: __init__() got an unexpected keyword argument 'kl'

---

## 2018-03-12 21:22:24 - general channel

**Tom**

On liams Github? Yes. I can login by passing my credentials to trading = betfairlightweight.APIClient(' ', ' ', ' ')  But I can't login using the .bash_profile method.

---

## 2018-02-26 07:11:27 - general channel

**liam**

Hi,

 

Following the recent developer survey we’d like to provide some feedback on some of the points raised by customers both generally and in terms of additional feature requests.

 

We’ve grouped these into distinct categories:

 

Market Data &amp; Feeds

 

We are constantly exploring ways of incorporating new data feeds into the API.    Unfortunately, there are restrictions relating to the onward supply of specific data via the API (specifically football related data) but we are investigating the incorporation of other data feeds at the moment, including improved feeds for horse racing.

 

The inclusion of raceType is on the current API roadmap and we are looking to integrate this data as soon as possible but don’t have a specific ETA.

 

We are working to make improvements to the consistency of market names &amp; abbreviations across the platform. 

 

We don’t have any plans to add specific results data into the API.  Customer who require results data following market settlement can use the historical data service (via [https://historicdata.betfair.com/#/home](https://historicdata.betfair.com/#/home)).  This data includes the result for each runner by name within the free BASIC data files.

 

We don’t have any plans to remove the time delay associated with in-play betting.  This is in place to protect customers when betting in-play and watching transmission described as “live” that may be actually delayed.

 

Stream API

 

We have an existing backlog item to add additional filters to the Stream API (including competitionId) but no plans to make any changes to the existing filter name.

 

We don’t have any plans to change the way we conflate data via the Stream API but historical data is available via [https://historicdata.betfair.com/#/home](https://historicdata.betfair.com/#/home) in the same format as provided via the Stream API if required for testing &amp; analysis purposes.

 

Pricing &amp; Charges

 

We don’t have any current plans to increase/reduce the £299 fee for Live Application Keys.

 

We received some requests to include an indicator within the API relation to transaction charging.   For transaction charging, we recommend that customers count unique the number of betId’s created in a single hour (0000-0059, 0100-0159, 0200-0259).  Any transaction fees are offset by the following (Commission + Implied Commission) ÷ 2

where Implied Commission = market losses x 3% which is calculated on a daily basis. Full details can be found via [http://www.betfair.com/aboutUs/Betfair.Charges/](http://www.betfair.com/aboutUs/Betfair.Charges/) &gt; Transaction Charges.

 

If there any specific questions/queries you’d like us to follow up with you directly please get in touch via Developer Support ([https://developer.betfair.com/support/](https://developer.betfair.com/support/))

 

Kind Regards

 

Neil

Betfair Developer Program

---

## 2018-02-08 20:17:22 - general channel

**swt**

hi, can you help me what is the syntax to filter today markets at market_start_time?            market_catalogues = trading.betting.list_market_catalogue(

                filter=filters.market_filter(

                    event_type_ids=[recorded_id], 

                    market_countries=[mc_id], 

                    market_type_codes=[mtc_id], 

                    turn_in_play_enabled=True,

                    market_start_time=date.today().strftime('%Y-%m-%d')

                ),

                market_projection=['MARKET_START_TIME', 'RUNNER_DESCRIPTION'], 

                max_results=1000

            )

---

## 2018-02-05 18:10:29 - general channel

**liam**

I use terraform for infra and the a mix of portainer (for monitoring, its great) and then my own deployment library using the docker python wrapper (also great) I have found that Sports trading programs don't really suit ECS / container services

---

## 2018-02-03 15:57:27 - general channel

**Jack**

so does your strategy look at the horses themselves or is it more so spotting patterns in how the market is moving ?

---

## 2018-01-25 09:50:03 - issues channel

**mbk**

Using the example in your repo, I get the following response when calling `trading.historic.get_file_list` which raises an exception

---

## 2018-01-12 15:40:57 - issues channel

**mikey155**

Thanks that's a good lead. What gets me about Python is that things change so quickly e.g. I'm using Python 3.6 in PyCharm and the word async gives a syntax error. I was able to get round that for the historical data but it might be an issue when I move on to stream API for trading.

---

## 2018-01-12 09:39:04 - general channel

**seaders**

in VSCode: `{'lightweight': None, 'session': None, 'locale': None, 'filter': {'textQuery': 'Horse Racing', 'args': {'with_orders': None, 'market_start_time': None, 'market_type_codes': None, 'market_countries': None, 'market_betting_types': None, 'in_play_only': None, 'turn_in_play_enabled': None, 'bsp_only': None, 'venues': None, 'market_ids': None, 'competition_ids': None, 'event_ids': None, 'event_type_ids': None, 'text_query': 'Horse Racing', 'args': {...}}}, 'self': &lt;betfairlightweight.endpoints.betting.Betting object at 0x10ac0f278&gt;}`

---

## 2018-01-12 09:35:28 - general channel

**seaders**

in PyCharm / regularly: `{'lightweight': None, 'session': None, 'locale': None, 'filter': {'textQuery': 'Horse Racing'}, 'self': &lt;betfairlightweight.endpoints.betting.Betting object at 0x10dc10048&gt;}`

---

## 2018-01-11 11:32:13 - issues channel

**mbk**

```

def create_stream(client):

    listener = betfairlightweight.StreamListener()

    stream = client.streaming.create_stream(listener=listener)

    market_filter = streaming_market_filter(

        event_type_ids=['7'],

        country_codes=['GB', 'IE'],

        market_types=['WIN', 'PLACE'],

        )

    market_data_filter = streaming_market_data_filter(

        fields=['EX_BEST_OFFERS', 'EX_MARKET_DEF'],

        ladder_levels=1,

        )

    stream.subscribe_to_markets(

        market_filter=market_filter,

        market_data_filter=market_data_filter,

        )

    return stream, listener



if __name__ == '__main__':

    trading = APIClient('username', 'password', 'certs')

    trading.login()

    stream, listener = api.create_stream(trading)



    stream.start(async=True)



    # starting up

    time.sleep(10)

    books = listener.snap()

    stream.stop()



    for b in books:

        md = b.market_definition

        print md.venue, md.market_time

        for runner in md.runners:

            print runner.name



```

---

## 2017-12-19 15:46:38 - general channel

**liam**

I use the strategy filter with place orders and the order stream 

---

## 2017-11-12 17:22:47 - general channel

**magiclevinho**

Hello Mates!

I m trying to get the live scores for a particular match, but I get connection error. What I use is:

trading.in_play_service.get_scores(event_ids=[event.event.id])

I can successfully get the events, but not the scores!

---

## 2017-10-18 09:55:47 - general channel

**liam**

Hmm I guess deploying the strategy then executing is the only option 

---

## 2017-10-18 09:24:09 - general channel

**will**

you cant pickle functions, either sending a config which can be parsed by your backtesting library into a strategy, OR, send a pointer to the strategy which already exists in your backtesting library works. You cannot pickle partial functions or lambdas.

---

## 2017-09-15 10:34:29 - general channel

**seaders**

like, per BF's documentation, [http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-RunnerCatalog](http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-RunnerCatalog) what you have should work, but they were obviously not sending one of selectionId, runnerName, handicap or sortPriority, but ew don't see that because the response is swallowed &amp; lost with the exception

---

## 2017-09-15 10:29:03 - general channel

**seaders**

```

   File "/home/ubuntu/Envs/bfstream/lib/python2.7/site-packages/betfairlightweight/endpoints/betting.py", line 158, in list_market_catalogue

    return self.process_response(response, resources.MarketCatalogue, elapsed_time, lightweight)

  File "/home/ubuntu/Envs/bfstream/lib/python2.7/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 100, in process_response

    return [resource(elapsed_time=elapsed_time, **x) for x in result]

  File "/home/ubuntu/Envs/bfstream/lib/python2.7/site-packages/betfairlightweight/resources/bettingresources.py", line 248, in __init__

    self.runners = [RunnerCatalogue(**i) for i in kwargs.get('runners', [])]

TypeError: __init__() takes at least 5 arguments (4 given)```

---

## 2017-09-11 02:35:59 - issues channel

**seaders**

[https://github.com/liampauling/betfair/blob/b4e85fdc595a74610f85599eb15792411e3e108c/betfairlightweight/resources/bettingresources.py#L407](https://github.com/liampauling/betfair/blob/b4e85fdc595a74610f85599eb15792411e3e108c/betfairlightweight/resources/bettingresources.py#L407)

---

## 2017-09-11 01:55:20 - issues channel

**seaders**

and that corresponds to BetFair's documentation, [http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-MarketBook](http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-MarketBook)

---

## 2017-09-11 01:54:52 - issues channel

**seaders**

and for what marketbook is,

[https://github.com/liampauling/betfair/blob/b4e85fdc595a74610f85599eb15792411e3e108c/betfairlightweight/resources/bettingresources.py#L430](https://github.com/liampauling/betfair/blob/b4e85fdc595a74610f85599eb15792411e3e108c/betfairlightweight/resources/bettingresources.py#L430)

---

## 2017-09-09 23:32:09 - issues channel

**gerg**

[@U4H19D1D2](@U4H19D1D2) Like you said I downloaded the file and gave the entire path to that file, 



# create historical stream, update directory to file location

stream = trading.historical.create_stream(

  directory='C:\\Users\Gerg\Downloads\data\Sites\bodw\api\8223dab0-db21-4435-af78-42d036c9ada0\BASIC-1.119219417',

  listener=listener

)



but I am getting following error. 





IOError                                   Traceback (most recent call last)

&lt;ipython-input-13-9b68443c839e&gt; in &lt;module&gt;()

35 

36 # start stream

---&gt; 37 stream.start(async=False)



C:\Users\Gerg\Anaconda2\lib\site-packages\betfairlightweight\endpoints\historical.pyc in start(self, async)

45             t.start()

46         else:

  ---&gt; 47             self._read_loop()

48 

49     def _read_loop(self):

  

  C:\Users\Gerg\Anaconda2\lib\site-packages\betfairlightweight\endpoints\historical.pyc in _read_loop(self)

48 

49     def _read_loop(self):

  ---&gt; 50         with open(self.directory, 'r') as f:

  51             for update in f:

  52                 self.listener.on_data(update)



IOError: [Errno 22] invalid mode ('r') or filename: 'C:\\Users\\Gerg\\Downloads\\data\\Sites\x08odw\x07pi\\8223dab0-db21-4435-af78-42d036c9ada0\\BASIC-1.119219417'

---

## 2017-09-09 21:42:45 - issues channel

**gerg**

I am getting IO error in windows machine. Its failing here in examplehistorical.py



#######################

# create historical stream, update directory to file location

stream = trading.historical.create_stream(

    directory='C:\\Users\Gerg\Desktop',

    listener=listener

)

########################

---------------------------------------------------------------------------

IOError                                   Traceback (most recent call last)

&lt;ipython-input-27-5894684e70b4&gt; in &lt;module&gt;()

     35 

     36 # start stream

---&gt; 37 stream.start(async=False)



C:\Users\Gerg\Anaconda2\lib\site-packages\betfairlightweight\endpoints\historical.pyc in start(self, async)

     45             t.start()

     46         else:

---&gt; 47             self._read_loop()

     48 

     49     def _read_loop(self):



C:\Users\Gerg\Anaconda2\lib\site-packages\betfairlightweight\endpoints\historical.pyc in _read_loop(self)

     48 

     49     def _read_loop(self):

---&gt; 50         with open(self.directory, 'r') as f:

     51             for update in f:

     52                 self.listener.on_data(update)



IOError: [Errno 2] No such file or directory: 'C:\\Users\\Gerg\\Desktop'

---

## 2017-08-27 16:36:31 - general channel

**magiclevinho**

Can somebody help me? How to get available fund to bet? I know there is th function "trading.account.get_account_funds()" but how to give it params? Is the wallet "Main Wallet"? and what is the session?

---

## 2017-08-19 14:50:49 - general channel

**jfo**

found it: [https://www.betfair.com/www/sports/exchange/readonly/v1/bymarket?currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.131810553&amp;rollupLimit=2&amp;rollupModel=STAKE&amp;types=MARKET_STATE,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_DESCRIPTION](https://www.betfair.com/www/sports/exchange/readonly/v1/bymarket?currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.131810553&amp;rollupLimit=2&amp;rollupModel=STAKE&amp;types=MARKET_STATE,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_DESCRIPTION)

---

## 2017-07-26 05:15:29 - general channel

**magiclevinho**

Until now my program worked, now I'm getting JSON error during login:

Traceback (most recent call last):

  File "D:/01_PhD/Fogadas/BETFAIR0,5/main.py", line 39, in &lt;module&gt;

    trading.login()

  File "C:\Python27\lib\site-packages\betfairlightweight\endpoints\login.py", line 26, in __call__

    (response, elapsed_time) = self.request(self.url, session=session)

  File "C:\Python27\lib\site-packages\betfairlightweight\endpoints\login.py", line 41, in request

    response_data = response.json()

  File "C:\Python27\lib\site-packages\requests\models.py", line 894, in json

    return complexjson.loads(self.text, **kwargs)

  File "C:\Python27\lib\json\__init__.py", line 339, in loads

    return _default_decoder.decode(s)

  File "C:\Python27\lib\json\decoder.py", line 364, in decode

    obj, end = self.raw_decode(s, idx=_w(s, 0).end())

  File "C:\Python27\lib\json\decoder.py", line 382, in raw_decode

    raise ValueError("No JSON object could be decoded")

ValueError: No JSON object could be decoded

---

## 2017-07-11 11:18:28 - general channel

**agberk**

If the strategy isn't speed dependent then spawning threads on demand is what I do

---

## 2017-07-03 21:01:18 - general channel

**liam**

This is for marketbook polling so the trigger is if a strategy is after a market e.g. Its inplay 

---

## 2017-07-03 19:03:56 - general channel

**liam**

Anyone finding that the 'customer_strategy_refs' is not filtering the order stream?

---

## 2017-06-28 12:46:16 - general channel

**Evaldas**

i get error:



place_order()

  File "/home/daan/Python/GreyHoundBot_streaming/bf_api_test.py", line 28, in place_order

    place_orders = trading.betting.place_orders(market_id=market_id, instructions=[instruction])  # list

  File "/home/daan/Python/GreyHoundBot_streaming/bfmaster/betfairlightweight/endpoints/betting.py", line 299, in place_orders

    return self.process_response(response, resources.PlaceOrders, elapsed_time, lightweight)

  File "/home/daan/Python/GreyHoundBot_streaming/bfmaster/betfairlightweight/endpoints/baseendpoint.py", line 102, in process_response



    return resource(elapsed_time=elapsed_time, **result)

  File "/home/daan/Python/GreyHoundBot_streaming/bfmaster/betfairlightweight/resources/bettingresources.py", line 679, in __init__



    PlaceOrderInstructionReports(**i) for i in kwargs.get('instructionReports')

  File "/home/daan/Python/GreyHoundBot_streaming/bfmaster/betfairlightweight/resources/bettingresources.py", line 679, in &lt;listcomp&gt;

    PlaceOrderInstructionReports(**i) for i in kwargs.get('instructionReports')

  File "/home/daan/Python/GreyHoundBot_streaming/bfmaster/betfairlightweight/resources/bettingresources.py", line 659, in __init__

    self.instruction = PlaceOrderInstruction(**instruction) if instruction else None

TypeError: __init__() got an unexpected keyword argument 'marketOnCloseOrder'

---

## 2017-06-28 12:33:24 - general channel

**Evaldas**

that was exception from betting.place_orders

---

## 2017-06-10 20:27:16 - general channel

**Evaldas**

oh gee, I understand now. get data from stream and put it into market/strategy object, took me a while, kinda new to this :slightly_smiling_face: thanks

---

## 2017-06-10 19:33:47 - general channel

**liam**

I use an event driven framework, numerous threads that are streams and then an event handler in main which processes the market books. I then use the unique id to determine which market book should be sent to which strategy. This prevents race conditions 

---

## 2017-06-09 17:03:01 - general channel

**magiclevinho**

Traceback (most recent call last):

  File "C:\Program Files\JetBrains\PyCharm Community Edition 2017.1.3\helpers\pydev\pydevd.py", line 1585, in &lt;module&gt;

    globals = debugger.run(setup['file'], None, None, is_module)

  File "C:\Program Files\JetBrains\PyCharm Community Edition 2017.1.3\helpers\pydev\pydevd.py", line 1015, in run

    pydev_imports.execfile(file, globals, locals)  # execute the script

  File "C:/Users/john/Documents/Pythonprojects/betfair_00/main.py", line 27, in &lt;module&gt;

    in_play_only=True,

  File "C:\Python27\lib\site-packages\betfairlightweight\endpoints\betting.py", line 84, in list_events

    (response, elapsed_time) = self.request(method, params, session)

  File "C:\Python27\lib\site-packages\betfairlightweight\endpoints\baseendpoint.py", line 43, in request

    raise APIError(None, method, params, 'ConnectionError')

betfairlightweight.exceptions.APIError: SportsAPING/v1.0/listEvents 

Params: {'filter': {'eventTypeIds': [u'1'], 'inPlayOnly': True}} 

Exception: ConnectionError

---

## 2017-06-05 13:54:26 - general channel

**agberk**

[@U4H19D1D2](@U4H19D1D2) - another error I've just run into with the latest version

```

Exception in thread Thread-1:

Traceback (most recent call last):

  File "/usr/lib/python2.7/threading.py", line 801, in __bootstrap_inner

    self.run()

  File "/usr/lib/python2.7/threading.py", line 754, in run

    self.__target(*self.__args, **self.__kwargs)

  File "/home/aaron/workspace/xxx/betfair_market_feed.py", line 42, in betfair_market_feed

    locale=config.get('markets', {}).get('locale')

  File "/home/aaron/tmp/venv/betfairlightweight/local/lib/python2.7/site-packages/betfairlightweight/endpoints/betting.py", line 158, in list_market_catalogue

    return self.process_response(response, resources.MarketCatalogue, elapsed_time, lightweight)

  File "/home/aaron/tmp/venv/betfairlightweight/local/lib/python2.7/site-packages/betfairlightweight/endpoints/baseendpoint.py", line 100, in process_response

    return [resource(elapsed_time=elapsed_time, **x) for x in result]

  File "/home/aaron/tmp/venv/betfairlightweight/local/lib/python2.7/site-packages/betfairlightweight/resources/bettingresources.py", line 229, in __init__

    self.runners = [RunnerCatalogue(**i) for i in kwargs.get('runners', [])]

TypeError: __init__() takes at least 5 arguments (4 given)

```

Now the docs do say there are 4 required attributes on a RunnerCatalogue: [http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-RunnerCatalog](http://docs.developer.betfair.com/docs/display/1smk3cen4v3lu3yomq5qye0ni/Betting+Type+Definitions#BettingTypeDefinitions-RunnerCatalog)

They've sent through a list of runners where one is missing the runnerName:

```

runners: [{u'handicap': 0.0, u'runnerName': u'Knowle/Zelenay', u'selectionId': 5717065, u'sortPriority': 1}, {u'handicap': 0.0, u'runnerName': u'Marrero/Paes.', u'selectionId': 8786145, u'sortPriority': 2}, {u'handicap': 0.0, u'sortPriority': 3, u'selectionId': 8781561}]

```

I know a lot has changed in terms of the resources - how come this sort of thing worked (or maybe silently failed is a better way of describing it? lol) before? Did the Beckett resource model just None anything that wasn't present?

---

## 2017-06-02 15:01:58 - general channel

**seaders**

your library is nearly at the stage that all the models follow nearly the exact same pattern,

---

## 2017-06-02 15:01:40 - general channel

**seaders**

I've poked them a few times about auto-generating models from that thing definition they have

---

## 2017-05-29 18:11:53 - general channel

**jfo**

Sorry. More daft questions but i’m seeing this error: `__init__() takes at least 3 arguments (5 given)` It says its coming from: 

```place_orders = self.client.betting.place_orders(

                            market_id=str(book.market_id),

                            instructions=[instruction]

                        )```

---

## 2017-05-25 17:13:56 - general channel

**seaders**

If you use it, definitely do with alembic on top, that handles your table/model migrations like a charm as well

---

## 2017-05-24 18:53:11 - general channel

**liam**

At least the free sample contains LTP, might use that for doing some basic football modelling

---

## 2017-05-22 19:42:11 - general channel

**liam**

[https://www.betfair.com/www/sports/exchange/readonly/v1/bymarket?currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.131810553&amp;rollupLimit=2&amp;rollupModel=STAKE&amp;types=MARKET_STATE,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_DESCRIPTION](https://www.betfair.com/www/sports/exchange/readonly/v1/bymarket?currencyCode=GBP&amp;locale=en_GB&amp;marketIds=1.131810553&amp;rollupLimit=2&amp;rollupModel=STAKE&amp;types=MARKET_STATE,RUNNER_STATE,RUNNER_EXCHANGE_PRICES_BEST,RUNNER_DESCRIPTION)

---

## 2017-05-22 16:16:09 - general channel

**richard**

Makes me weep that I used to have a dedicated server at nearly £200/month for my betting - this was when AWS was just in its infancy though.

---

## 2017-05-21 23:30:52 - general channel

**richard**

On trying the trading.login() line I now get:APIError: None

Params: None

Exception: [('system library', 'fopen', 'No such process'), ('BIO routines', 'FILE_CTRL', 'system lib'), ('SSL routines', 'SSL_CTX_use_certificate_file', 'system lib')]

---

## 2017-05-21 23:30:00 - general channel

**richard**

So I created the certificates and attached to my Betfair account. Now I'm back to trying part1 with trading=betfairlightweight.APIClient(...) passing in my username, password, app_key and cert_files folder.

---

## 2017-05-20 12:44:21 - general channel

**liam**

so the django app (called pinhole) is setup to record order/strategy data and some market level data. When it comes to recording market book data i zip that up and send it to s3, then have lambda process which includes parsing and loading to MySQL depending on market type or simply adding a record of what it is into pinhole which I can then query to get the bucket location for back testing or processing later. But yeh if you want to record/log something else you have to create a model/migrate/build the view/add to the api so its limited in that respect. But that is what elasticsearch is good for which i use for logging as it can pretty much take anything you chuck at it

---

## 2017-05-08 16:36:05 - general channel

**jfo**

still in the process of putting together my own order placing strategy so using betangel server with streaming to get up and running before coding it all. so not sure on latency, at what number does latency become bad? obviously the lower the better

---

## 2017-04-19 17:34:39 - general channel

**liam**

Want to be able to take advantage of serverless and run a strategy through a couple thousand markets in a few seconds 

---

## 2017-04-19 17:31:56 - general channel

**favetelinguis**

it is best for really complex unstructured data and deep models

---

## 2017-04-19 17:07:05 - general channel

**favetelinguis**

this has been my inspiration and the next step is to acually apply it and build a trading bot

---

