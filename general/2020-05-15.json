[
    {
        "text": "I'm plotting The Draw for 1.166709916.\n\nRed line is Best Available To Lay.\nGreen line is Best Avalable to Back.\n\nBlue dots are the lowest trade price. Orange dots are highest traded price.\n\nBy traded price, I am considering anything where the total traded volume has changed since the previous market book update.\n\nSo there are lots of orange (high) dots at 4.0. Which makes it look as though bets were being matched well above the best available to lay (red) price.\n\nSo to filter out those, I can remove anything where the change in volume negative. But where the traded volume is non-zero, filtering out these events is less trivial, as how do I know whether or not they are genuine?",
        "files": [
            {
                "id": "F0142KCV91P",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": true,
        "user": "UPMUFSGCR",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XCaBt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm plotting The Draw for 1.166709916.\n\nRed line is Best Available To Lay.\nGreen line is Best Avalable to Back.\n\nBlue dots are the lowest trade price. Orange dots are highest traded price.\n\nBy traded price, I am considering anything where the total traded volume has changed since the previous market book update.\n\nSo there are lots of orange (high) dots at 4.0. Which makes it look as though bets were being matched well above the best available to lay (red) price.\n\nSo to filter out those, I can remove anything where the change in volume negative. But where the traded volume is non-zero, filtering out these events is less trivial, as how do I know whether or not they are genuine?"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1589529209.333900",
        "client_msg_id": "6608c233-2f7e-400b-bccf-f59d485a6fe7",
        "thread_ts": "1588364934.006900",
        "parent_user_id": "UBS7QANF3"
    },
    {
        "user": "U4H19D1D2",
        "type": "message",
        "ts": "1589529292.334300",
        "client_msg_id": "f05b4259-dcbe-441c-8998-98a4bc631958",
        "text": "can you share your logic for traded volume? It is possible that xm is at play here as well",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "137c5a3ef323",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-03-15\/6819395173841_137c5a3ef323f1944a1a_72.png",
            "first_name": "liam",
            "real_name": "liam",
            "display_name": "liam",
            "team": "T4G9NBD2M",
            "name": "liam",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1588364934.006900",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3VLZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "can you share your logic for traded volume? It is possible that xm is at play here as well"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UPMUFSGCR",
        "type": "message",
        "ts": "1589529311.334500",
        "client_msg_id": "67511ff4-e0bc-45b6-b292-c39d05ec93a3",
        "text": "What is xm?",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "31c0bb5a442c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-28\/812386967189_31c0bb5a442c5b8d2c61_72.png",
            "first_name": "Jon",
            "real_name": "Jon Jon Jon Jon Jon Jon Jon Jon",
            "display_name": "Jonjonjon",
            "team": "T4G9NBD2M",
            "name": "fcmisc",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1588364934.006900",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aYou",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What is xm?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U4H19D1D2",
        "type": "message",
        "ts": "1589529323.334700",
        "client_msg_id": "c29e472d-6d0e-4169-8239-d293a2131f69",
        "text": "cross matching",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "137c5a3ef323",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-03-15\/6819395173841_137c5a3ef323f1944a1a_72.png",
            "first_name": "liam",
            "real_name": "liam",
            "display_name": "liam",
            "team": "T4G9NBD2M",
            "name": "liam",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1588364934.006900",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zdyrK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "cross matching"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UPMUFSGCR",
        "type": "message",
        "ts": "1589529493.334900",
        "edited": {
            "user": "UPMUFSGCR",
            "ts": "1589529556.000000"
        },
        "client_msg_id": "c8f5290e-e870-4d91-9a94-fd3c1e2c46e8",
        "text": "This is my hacked up version of your PriceRecorder:\n\n```from collections import defaultdict\n\nfrom flumine import BaseStrategy\nfrom flumine.utils import get_price\n\nEPS=1e-6\n\ndef diff(a: dict, b: dict):\n    \"\"\"\n    Return a minus b\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n\n    result = {}\n    for k, v in a.items():\n        difference = v - b.get(k, 0.0)\n        if abs(difference)&gt;EPS:\n            result[k] = difference\n\n    return result\n\n\nclass PriceRecorder(BaseStrategy):\n    \"\"\"\n    Example strategy for recording prices\n    from historical or live data.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        BaseStrategy.__init__(self, *args, **kwargs)\n        self.market_data = defaultdict(list)\n        self.runner_data = defaultdict(lambda: defaultdict(list))\n        self.runner_names = defaultdict(dict)\n        self._prior_traded_volume = defaultdict(dict)\n        self._prior_publish_time = {}\n        self.traded_volumes = defaultdict(lambda: defaultdict(list))\n\n    def check_market_book(self, live_market, market_book):\n        return market_book.inplay==False\n\n    def process_market_book(self, live_market, market_book):\n\n        market_data = self.market_data[market_book.market_id]\n        prior_publish_time = self._prior_publish_time.get(market_book.market_id)\n        self._prior_publish_time[market_book.market_id] = market_book.publish_time\n\n        if not market_book.market_id in self.runner_names:\n            runners = market_book.market_definition.runners\n            d = {runner.selection_id:runner.name for runner in runners}\n            self.runner_names = d\n\n        is_currency_update = False\n\n        for runner in market_book.runners:\n            runner_data = self.runner_data[market_book.market_id][runner.selection_id]\n\n            k = (market_book.market_id, runner.selection_id)\n            prior_traded_volume = self._prior_traded_volume[k]\n            traded_volume = {ps['price']:ps['size'] for ps in runner.ex.traded_volume}\n            traded_volume_diff = diff(traded_volume, prior_traded_volume)\n            self._prior_traded_volume[k] = traded_volume\n            if traded_volume_diff:\n                min_price = min(traded_volume_diff)\n                max_price = max(traded_volume_diff)\n                volume = sum(traded_volume_diff.values())\n\n                if prior_publish_time.hour!=market_book.publish_time.hour:\n                    if len(traded_volume_diff)&gt;1:\n                        is_currency_update = True\n                        print('Skipping ', market_book.publish_time)\n\n                if min(traded_volume_diff.values())&lt;0.0:\n                    is_currency_update = True\n\n                # if market_book.publish_time&gt;=datetime.datetime(2020, 1, 1):\n                #     if max_price==4:\n                #         print('stpo')\n            else:\n                min_price = None\n                max_price = None\n                volume = 0\n\n            is_currency_update=False\n\n            if not is_currency_update:\n                atb = get_price(runner.ex.available_to_back, 0)\n                atl = get_price(runner.ex.available_to_lay, 0)\n\n                if max_price and (max_price&gt;atl):\n                    print('depth was hit')\n\n                runner_data.append(\n                    [\n                        market_book.publish_time,\n                        runner.last_price_traded,\n                        atb,\n                        atl,\n                        max_price,\n                        min_price,\n                        volume\n                        ]\n                )\n\n        market_data.append([\n            market_book.market_id,\n            market_book.publish_time,\n            market_book.status,\n            market_book.inplay,\n        ])```",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "31c0bb5a442c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2019-10-28\/812386967189_31c0bb5a442c5b8d2c61_72.png",
            "first_name": "Jon",
            "real_name": "Jon Jon Jon Jon Jon Jon Jon Jon",
            "display_name": "Jonjonjon",
            "team": "T4G9NBD2M",
            "name": "fcmisc",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1588364934.006900",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "L+c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is my hacked up version of your PriceRecorder:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "from collections import defaultdict\n\nfrom flumine import BaseStrategy\nfrom flumine.utils import get_price\n\nEPS=1e-6\n\ndef diff(a: dict, b: dict):\n    \"\"\"\n    Return a minus b\n\n    :param a:\n    :param b:\n    :return:\n    \"\"\"\n\n    result = {}\n    for k, v in a.items():\n        difference = v - b.get(k, 0.0)\n        if abs(difference)>EPS:\n            result[k] = difference\n\n    return result\n\n\nclass PriceRecorder(BaseStrategy):\n    \"\"\"\n    Example strategy for recording prices\n    from historical or live data.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        BaseStrategy.__init__(self, *args, **kwargs)\n        self.market_data = defaultdict(list)\n        self.runner_data = defaultdict(lambda: defaultdict(list))\n        self.runner_names = defaultdict(dict)\n        self._prior_traded_volume = defaultdict(dict)\n        self._prior_publish_time = {}\n        self.traded_volumes = defaultdict(lambda: defaultdict(list))\n\n    def check_market_book(self, live_market, market_book):\n        return market_book.inplay==False\n\n    def process_market_book(self, live_market, market_book):\n\n        market_data = self.market_data[market_book.market_id]\n        prior_publish_time = self._prior_publish_time.get(market_book.market_id)\n        self._prior_publish_time[market_book.market_id] = market_book.publish_time\n\n        if not market_book.market_id in self.runner_names:\n            runners = market_book.market_definition.runners\n            d = {runner.selection_id:runner.name for runner in runners}\n            self.runner_names = d\n\n        is_currency_update = False\n\n        for runner in market_book.runners:\n            runner_data = self.runner_data[market_book.market_id][runner.selection_id]\n\n            k = (market_book.market_id, runner.selection_id)\n            prior_traded_volume = self._prior_traded_volume[k]\n            traded_volume = {ps['price']:ps['size'] for ps in runner.ex.traded_volume}\n            traded_volume_diff = diff(traded_volume, prior_traded_volume)\n            self._prior_traded_volume[k] = traded_volume\n            if traded_volume_diff:\n                min_price = min(traded_volume_diff)\n                max_price = max(traded_volume_diff)\n                volume = sum(traded_volume_diff.values())\n\n                if prior_publish_time.hour!=market_book.publish_time.hour:\n                    if len(traded_volume_diff)>1:\n                        is_currency_update = True\n                        print('Skipping ', market_book.publish_time)\n\n                if min(traded_volume_diff.values())<0.0:\n                    is_currency_update = True\n\n                # if market_book.publish_time>=datetime.datetime(2020, 1, 1):\n                #     if max_price==4:\n                #         print('stpo')\n            else:\n                min_price = None\n                max_price = None\n                volume = 0\n\n            is_currency_update=False\n\n            if not is_currency_update:\n                atb = get_price(runner.ex.available_to_back, 0)\n                atl = get_price(runner.ex.available_to_lay, 0)\n\n                if max_price and (max_price>atl):\n                    print('depth was hit')\n\n                runner_data.append(\n                    [\n                        market_book.publish_time,\n                        runner.last_price_traded,\n                        atb,\n                        atl,\n                        max_price,\n                        min_price,\n                        volume\n                        ]\n                )\n\n        market_data.append([\n            market_book.market_id,\n            market_book.publish_time,\n            market_book.status,\n            market_book.inplay,\n        ])"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBS7QANF3",
        "type": "message",
        "ts": "1589529640.335700",
        "client_msg_id": "6CE92E49-78E4-431A-AB39-8ECE6E61FD4A",
        "text": "What about cross referencing with changes in available back and lay prices?",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "gaaf844a4a90",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/eaaf844a4a905431d83430e563b077aa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "",
            "real_name": "Maurice Berk",
            "display_name": "Mo",
            "team": "T4G9NBD2M",
            "name": "maurice",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1588364934.006900",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tjn+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What about cross referencing with changes in available back and lay prices?"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UPMUFSGCR"
                ],
                "count": 1
            }
        ]
    },
    {
        "subtype": "channel_join",
        "user": "U013A4DBS9M",
        "text": "<@U013A4DBS9M> has joined the channel",
        "type": "message",
        "ts": "1589554787.336100"
    },
    {
        "text": "I started writing code to cross reference against changes in available to back and lay prices. But then realised that doing so would significantly add to CPU overhead.\n\nInstead, I tried a simple method of:\n• looking for traded volume differences under £2.\n• From these, filtering again for amount risked (i.e. (price-1)*size) under £10.0\n• And then finally excluding the updates if any of these low risk, small sized, trades have penetrated the best back\/lay prices.\nThe resulting chart looks a lot cleaner:",
        "files": [
            {
                "id": "F013RTNMZFD",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": true,
        "user": "UPMUFSGCR",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "17rU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I started writing code to cross reference against changes in available to back and lay prices. But then realised that doing so would significantly add to CPU overhead.\n\nInstead, I tried a simple method of:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "looking for traded volume differences under £2."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "From these, filtering again for amount risked (i.e. (price-1)*size) under £10.0"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "And then finally excluding the updates if any of these low risk, small sized, trades have penetrated the best back\/lay prices."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe resulting chart looks a lot cleaner:"
                            }
                        ]
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1589575559.336200",
        "edited": {
            "user": "UPMUFSGCR",
            "ts": "1589575619.000000"
        },
        "client_msg_id": "e101d5e6-2a27-40f8-8120-e133255f25fb",
        "thread_ts": "1588364934.006900",
        "parent_user_id": "UBS7QANF3"
    },
    {
        "subtype": "channel_join",
        "user": "U013KB5R3T8",
        "text": "<@U013KB5R3T8> has joined the channel",
        "type": "message",
        "ts": "1589601988.336800"
    }
]