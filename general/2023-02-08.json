[
    {
        "user": "U4H19D1D2",
        "type": "message",
        "ts": "1675843663.280869",
        "client_msg_id": "dbb9d246-0955-4c0a-b461-f657435d1f86",
        "text": "Can you share some code and the market? Not sure its possible to debug without",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "137c5a3ef323",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-03-15\/6819395173841_137c5a3ef323f1944a1a_72.png",
            "first_name": "liam",
            "real_name": "liam",
            "display_name": "liam",
            "team": "T4G9NBD2M",
            "name": "liam",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675805913.836409",
        "parent_user_id": "U03N4QBJ0TV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Cjc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Can you share some code and the market? Not sure its possible to debug without"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04M1BY1FRR",
        "type": "message",
        "ts": "1675857724.358749",
        "client_msg_id": "a79cb131-5986-4a16-b918-6a46e00ee388",
        "text": "Hi guys, does anyone know when using betfair lightweight, is it possible to subscribe to a new market in the stream while the stream is already running and listening to two other markets for example.",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "086a17ff0ee5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-01-29\/4712580647589_086a17ff0ee5f9664c27_72.png",
            "first_name": "Charaka",
            "real_name": "Charaka Abeywickrama",
            "display_name": "Charaka A",
            "team": "T4G9NBD2M",
            "name": "charaka.abeywickrama",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D1Sb1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi guys, does anyone know when using betfair lightweight, is it possible to subscribe to a new market in the stream while the stream is already running and listening to two other markets for example."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBS7QANF3",
        "type": "message",
        "ts": "1675857913.677769",
        "client_msg_id": "e3a806dd-f246-4200-9e93-04f22e2425c8",
        "text": "If the new market matches your filter you will automatically receive updates for it. If it doesn't match your filter then you need to reconsider your filter",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "gaaf844a4a90",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/eaaf844a4a905431d83430e563b077aa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "",
            "real_name": "Maurice Berk",
            "display_name": "Mo",
            "team": "T4G9NBD2M",
            "name": "maurice",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675857913.677769",
        "reply_count": 3,
        "reply_users_count": 2,
        "latest_reply": "1675859057.504249",
        "reply_users": [
            "U04M1BY1FRR",
            "UBS7QANF3"
        ],
        "replies": [
            {
                "user": "U04M1BY1FRR",
                "ts": "1675858247.148859"
            },
            {
                "user": "UBS7QANF3",
                "ts": "1675858404.252639"
            },
            {
                "user": "U04M1BY1FRR",
                "ts": "1675859057.504249"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RxOK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If the new market matches your filter you will automatically receive updates for it. If it doesn't match your filter then you need to reconsider your filter"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U4H19D1D2"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U04M1BY1FRR",
        "type": "message",
        "ts": "1675858247.148859",
        "client_msg_id": "e3b1c498-f639-42b7-a1d5-ee8835bb64aa",
        "text": "Thanks a lot Mo when I update the filter I do not need to stop the stream right",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "086a17ff0ee5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-01-29\/4712580647589_086a17ff0ee5f9664c27_72.png",
            "first_name": "Charaka",
            "real_name": "Charaka Abeywickrama",
            "display_name": "Charaka A",
            "team": "T4G9NBD2M",
            "name": "charaka.abeywickrama",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675857913.677769",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HIMYn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks a lot Mo when I update the filter I do not need to stop the stream right"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBS7QANF3",
        "type": "message",
        "ts": "1675858404.252639",
        "client_msg_id": "267dd223-23ca-40ef-90ed-94e953f063a4",
        "text": "You cannot change the filter once you have subscribed to the stream",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "gaaf844a4a90",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/eaaf844a4a905431d83430e563b077aa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "",
            "real_name": "Maurice Berk",
            "display_name": "Mo",
            "team": "T4G9NBD2M",
            "name": "maurice",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675857913.677769",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "\/2eC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You cannot change the filter once you have subscribed to the stream"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U04M1BY1FRR"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U04M1BY1FRR",
        "type": "message",
        "ts": "1675859057.504249",
        "client_msg_id": "2811730b-b92b-4d9e-a7a8-7186106ca6e4",
        "text": "Got it thanks :slightly_smiling_face:",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "086a17ff0ee5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-01-29\/4712580647589_086a17ff0ee5f9664c27_72.png",
            "first_name": "Charaka",
            "real_name": "Charaka Abeywickrama",
            "display_name": "Charaka A",
            "team": "T4G9NBD2M",
            "name": "charaka.abeywickrama",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675857913.677769",
        "parent_user_id": "UBS7QANF3",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TGi0r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Got it thanks "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "text": "```import math\nfrom collections import OrderedDict\nfrom flumine import BaseStrategy\nfrom flumine.order.trade import Trade\nfrom flumine.order.order import OrderStatus\nfrom flumine.order.ordertype import LimitOrder\nfrom flumine.utils import get_price\nimport numpy as np\n\n\nclass LowestLayer(BaseStrategy):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.max_order_exposure = 100\n\n    def check_market_book(self, market, market_book):\n        if market_book.status == \"OPEN\" and not market_book.inplay:\n            return True\n\n    def process_market_book(self, market, market_book):\n\n        # count market matched trades\n        market_matched_trades_count = sum(\n            [self.get_runner_context(market.market_id, r.selection_id, r.handicap).trade_count -\n             self.get_runner_context(market.market_id, r.selection_id, r.handicap).live_trade_count for r\n             in market_book.runners])\n\n        # get lowest\/highest priced runner (depends on sort settings)\n        prices = [\n            (r.selection_id, get_price(r.ex.available_to_back, 0))\n            for r in market_book.runners if r.status == \"ACTIVE\"\n\n        ]\n\n        if not prices:\n            return\n\n        if market.seconds_to_start &gt; 250:\n            return\n\n        prices.sort(key=lambda tup: tup[1], reverse=False)\n        selection_id = prices[0][0]\n\n        if prices[0][1] &gt; 12:\n            return\n\n        # calculate market under\/over round for later analysis\n        underround = _calculate_underround(market_book.runners)\n\n        for runner in market_book.runners:\n\n            runner_context = self.get_runner_context(\n                market.market_id, runner.selection_id, runner.handicap\n            )\n\n            if runner.selection_id == selection_id:\n\n                '''Place initial bet'''\n                if market_matched_trades_count == 0 and runner_context.live_trade_count == 0 and 250 &gt; market.seconds_to_start &gt; 0:\n                    self.create_trade_create_order(market, market_book, runner, underround, self.context['stake'],\n                                                   back_lay='LAY', market_depth=0)\n                    print('Entry Bet')\n\n                '''Code only here for investigations'''\n                if market.seconds_to_start in [104.043, 103.929]:\n                    print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;')\n                    print(f'SECONDS TO START = {market.seconds_to_start}')\n                    print(f'strategy_selection_orders{market.blotter.strategy_selection_orders(self, selection_id, runner.handicap)}')\n                    print(f'market.blotter.orders = {[o for o in market.blotter]}')\n                    print(f'market status = {market.status}')\n                    print(f'runner status = {runner.status}')\n                    print( f'selection exposure = {market.blotter.selection_exposure(strategy=self, lookup=(runner.handicap, runner.selection_id))}')\n                    print(f'stats = {market.blotter.get_exposures(strategy=self, lookup=(runner.handicap, runner.selection_id))}')\n                    print(f'number of active runners = {len([r for r in market_book.runners if runner.status == \"ACTIVE\"])}')\n\n                '''Try to green up on runner - limit order'''\n                if runner_context.trade_count == 1 and runner_context.live_trade_count == 0 \\\n                        and 30 &lt; market.seconds_to_start &lt;= 60:\n                    stake, price, backorlay = self.green_all(market, runner, market_depth=0)\n                    self.create_trade_create_order(market, market_book, runner, underround,\n                                                   stake=stake, back_lay=backorlay, set_price=price)\n\n                '''If green up was unsuccessful then cancel bets'''\n                if runner_context.trade_count &gt;= 1 and runner_context.live_trade_count &gt; 0 and market.seconds_to_start &lt; 30:\n                    executable_orders = [o for o in\n                                         market.blotter.strategy_selection_orders(\n                                             self, selection_id, runner.handicap) if o.status.value == 'Executable']\n\n                    if len(executable_orders) &gt; 0:\n                        for order in executable_orders:\n                            market.cancel_order(order)\n                            print(executable_orders)\n\n                '''Place green up at market price\n                Will do this only if matched profit if lose &gt; £1 difference that matched profit if win'''\n                if market.seconds_to_start &lt; 25:\n                    exposures = market.blotter.get_exposures(strategy=self,\n                                                             lookup=(runner.handicap, runner.selection_id))\n\n                    matched_profit_if_win = math.sqrt(exposures['matched_profit_if_win'] ** 2)\n                    matched_profit_if_lose = math.sqrt(exposures['matched_profit_if_lose'] ** 2)\n                    if math.sqrt((matched_profit_if_win - matched_profit_if_lose) ** 2) &gt; 1:\n                        stake, price, backorlay = self.green_all(market, runner, dump_position=True)\n                        self.create_trade_create_order(market, market_book, runner, underround,\n                                                       stake=stake, set_price=price, back_lay=backorlay)\n\n     \n\n    def process_orders(self, market, orders):\n        # kill order if unmatched in market for greater than X seconds\n        for order in orders:\n            if order.status == OrderStatus.EXECUTABLE:\n                if order.elapsed_seconds and order.elapsed_seconds &gt; 100:\n                    market.cancel_order(order)\n\n    def create_trade_create_order(self, market, market_book, runner, underround, stake,\n                                  back_lay: str, market_depth: int = 1, set_price: float = 0.0):\n\n        stake = float((np.round(stake, 2)))\n        '''If market_order = True then a higher market_depth results \n        in a worst price. If it is False the reverse is true'''\n\n        if set_price != 0.0:\n            bet_template = [back_lay, set_price]\n        elif back_lay == 'BACK':\n            bet_template = ['BACK', get_price(runner.ex.available_to_lay, market_depth)]\n        else:\n            bet_template = ['LAY', get_price(runner.ex.available_to_back, market_depth)]\n\n        # create trade\n        trade = Trade(\n            market_book.market_id,\n            runner.selection_id,\n            runner.handicap,\n            self,\n        )\n        # create order\n        order = trade.create_order(\n            side=bet_template[0],\n            order_type=LimitOrder(bet_template[1], np.round(stake, 2)),\n            notes=OrderedDict(underround=round(underround, 4)),\n        )\n        # place order for execution\n        market.place_order(order)\n\n    def green_all(self, market, runner, market_depth: int = 0, dump_position: bool = False):\n        facts = market.blotter.get_exposures(strategy=self, lookup=(runner.handicap, runner.selection_id))\n\n        selection_exposure = market.blotter.selection_exposure(strategy=self,\n                                                               lookup=(runner.handicap, runner.selection_id))\n        matched_profit_if_win = facts['matched_profit_if_win']\n        matched_profit_if_lose = facts['matched_profit_if_lose']\n        print('green all called')\n        print(matched_profit_if_win)\n        print(matched_profit_if_lose)\n\n        if matched_profit_if_win &gt; 0:\n            avg_odds = (matched_profit_if_win + selection_exposure) \/ selection_exposure\n            if dump_position is False:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_back, market_depth),\n                                       total_staked=selection_exposure) + ('LAY',)\n            else:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_lay, 0),\n                                       total_staked=selection_exposure) + ('LAY',)\n\n        if matched_profit_if_win &lt; 0:\n            avg_odds = (matched_profit_if_lose + selection_exposure) \/ matched_profit_if_lose\n            if dump_position is False:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_lay, market_depth),\n                                       total_staked=matched_profit_if_lose) + ('BACK',)\n            else:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_back, 0),\n                                       total_staked=matched_profit_if_lose) + ('BACK',)\n\n    def calc_green(self, avg_odds, current_price_of_runner, total_staked):\n        green_all_stake = avg_odds \/ current_price_of_runner * total_staked\n        return green_all_stake, current_price_of_runner\n\n\ndef _calculate_underround(runners: list) -&gt; float:\n    return sum(\n        [\n            1 \/ get_price(r.ex.available_to_lay, 0)\n            for r in runners\n            if r.ex.available_to_lay\n        ]\n    )```",
        "files": [
            {
                "id": "F04NAUSS223",
                "mode": "hidden_by_limit"
            }
        ],
        "upload": false,
        "user": "U03N4QBJ0TV",
        "display_as_bot": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5Z\/=i",
                "elements": [
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "import math\nfrom collections import OrderedDict\nfrom flumine import BaseStrategy\nfrom flumine.order.trade import Trade\nfrom flumine.order.order import OrderStatus\nfrom flumine.order.ordertype import LimitOrder\nfrom flumine.utils import get_price\nimport numpy as np\n\n\nclass LowestLayer(BaseStrategy):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.max_order_exposure = 100\n\n    def check_market_book(self, market, market_book):\n        if market_book.status == \"OPEN\" and not market_book.inplay:\n            return True\n\n    def process_market_book(self, market, market_book):\n\n        # count market matched trades\n        market_matched_trades_count = sum(\n            [self.get_runner_context(market.market_id, r.selection_id, r.handicap).trade_count -\n             self.get_runner_context(market.market_id, r.selection_id, r.handicap).live_trade_count for r\n             in market_book.runners])\n\n        # get lowest\/highest priced runner (depends on sort settings)\n        prices = [\n            (r.selection_id, get_price(r.ex.available_to_back, 0))\n            for r in market_book.runners if r.status == \"ACTIVE\"\n\n        ]\n\n        if not prices:\n            return\n\n        if market.seconds_to_start > 250:\n            return\n\n        prices.sort(key=lambda tup: tup[1], reverse=False)\n        selection_id = prices[0][0]\n\n        if prices[0][1] > 12:\n            return\n\n        # calculate market under\/over round for later analysis\n        underround = _calculate_underround(market_book.runners)\n\n        for runner in market_book.runners:\n\n            runner_context = self.get_runner_context(\n                market.market_id, runner.selection_id, runner.handicap\n            )\n\n            if runner.selection_id == selection_id:\n\n                '''Place initial bet'''\n                if market_matched_trades_count == 0 and runner_context.live_trade_count == 0 and 250 > market.seconds_to_start > 0:\n                    self.create_trade_create_order(market, market_book, runner, underround, self.context['stake'],\n                                                   back_lay='LAY', market_depth=0)\n                    print('Entry Bet')\n\n                '''Code only here for investigations'''\n                if market.seconds_to_start in [104.043, 103.929]:\n                    print('>>>>>>>>>>>>>>>>>')\n                    print(f'SECONDS TO START = {market.seconds_to_start}')\n                    print(f'strategy_selection_orders{market.blotter.strategy_selection_orders(self, selection_id, runner.handicap)}')\n                    print(f'market.blotter.orders = {[o for o in market.blotter]}')\n                    print(f'market status = {market.status}')\n                    print(f'runner status = {runner.status}')\n                    print( f'selection exposure = {market.blotter.selection_exposure(strategy=self, lookup=(runner.handicap, runner.selection_id))}')\n                    print(f'stats = {market.blotter.get_exposures(strategy=self, lookup=(runner.handicap, runner.selection_id))}')\n                    print(f'number of active runners = {len([r for r in market_book.runners if runner.status == \"ACTIVE\"])}')\n\n                '''Try to green up on runner - limit order'''\n                if runner_context.trade_count == 1 and runner_context.live_trade_count == 0 \\\n                        and 30 < market.seconds_to_start <= 60:\n                    stake, price, backorlay = self.green_all(market, runner, market_depth=0)\n                    self.create_trade_create_order(market, market_book, runner, underround,\n                                                   stake=stake, back_lay=backorlay, set_price=price)\n\n                '''If green up was unsuccessful then cancel bets'''\n                if runner_context.trade_count >= 1 and runner_context.live_trade_count > 0 and market.seconds_to_start < 30:\n                    executable_orders = [o for o in\n                                         market.blotter.strategy_selection_orders(\n                                             self, selection_id, runner.handicap) if o.status.value == 'Executable']\n\n                    if len(executable_orders) > 0:\n                        for order in executable_orders:\n                            market.cancel_order(order)\n                            print(executable_orders)\n\n                '''Place green up at market price\n                Will do this only if matched profit if lose > £1 difference that matched profit if win'''\n                if market.seconds_to_start < 25:\n                    exposures = market.blotter.get_exposures(strategy=self,\n                                                             lookup=(runner.handicap, runner.selection_id))\n\n                    matched_profit_if_win = math.sqrt(exposures['matched_profit_if_win'] ** 2)\n                    matched_profit_if_lose = math.sqrt(exposures['matched_profit_if_lose'] ** 2)\n                    if math.sqrt((matched_profit_if_win - matched_profit_if_lose) ** 2) > 1:\n                        stake, price, backorlay = self.green_all(market, runner, dump_position=True)\n                        self.create_trade_create_order(market, market_book, runner, underround,\n                                                       stake=stake, set_price=price, back_lay=backorlay)\n\n     \n\n    def process_orders(self, market, orders):\n        # kill order if unmatched in market for greater than X seconds\n        for order in orders:\n            if order.status == OrderStatus.EXECUTABLE:\n                if order.elapsed_seconds and order.elapsed_seconds > 100:\n                    market.cancel_order(order)\n\n    def create_trade_create_order(self, market, market_book, runner, underround, stake,\n                                  back_lay: str, market_depth: int = 1, set_price: float = 0.0):\n\n        stake = float((np.round(stake, 2)))\n        '''If market_order = True then a higher market_depth results \n        in a worst price. If it is False the reverse is true'''\n\n        if set_price != 0.0:\n            bet_template = [back_lay, set_price]\n        elif back_lay == 'BACK':\n            bet_template = ['BACK', get_price(runner.ex.available_to_lay, market_depth)]\n        else:\n            bet_template = ['LAY', get_price(runner.ex.available_to_back, market_depth)]\n\n        # create trade\n        trade = Trade(\n            market_book.market_id,\n            runner.selection_id,\n            runner.handicap,\n            self,\n        )\n        # create order\n        order = trade.create_order(\n            side=bet_template[0],\n            order_type=LimitOrder(bet_template[1], np.round(stake, 2)),\n            notes=OrderedDict(underround=round(underround, 4)),\n        )\n        # place order for execution\n        market.place_order(order)\n\n    def green_all(self, market, runner, market_depth: int = 0, dump_position: bool = False):\n        facts = market.blotter.get_exposures(strategy=self, lookup=(runner.handicap, runner.selection_id))\n\n        selection_exposure = market.blotter.selection_exposure(strategy=self,\n                                                               lookup=(runner.handicap, runner.selection_id))\n        matched_profit_if_win = facts['matched_profit_if_win']\n        matched_profit_if_lose = facts['matched_profit_if_lose']\n        print('green all called')\n        print(matched_profit_if_win)\n        print(matched_profit_if_lose)\n\n        if matched_profit_if_win > 0:\n            avg_odds = (matched_profit_if_win + selection_exposure) \/ selection_exposure\n            if dump_position is False:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_back, market_depth),\n                                       total_staked=selection_exposure) + ('LAY',)\n            else:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_lay, 0),\n                                       total_staked=selection_exposure) + ('LAY',)\n\n        if matched_profit_if_win < 0:\n            avg_odds = (matched_profit_if_lose + selection_exposure) \/ matched_profit_if_lose\n            if dump_position is False:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_lay, market_depth),\n                                       total_staked=matched_profit_if_lose) + ('BACK',)\n            else:\n                return self.calc_green(avg_odds,\n                                       current_price_of_runner=get_price(runner.ex.available_to_back, 0),\n                                       total_staked=matched_profit_if_lose) + ('BACK',)\n\n    def calc_green(self, avg_odds, current_price_of_runner, total_staked):\n        green_all_stake = avg_odds \/ current_price_of_runner * total_staked\n        return green_all_stake, current_price_of_runner\n\n\ndef _calculate_underround(runners: list) -> float:\n    return sum(\n        [\n            1 \/ get_price(r.ex.available_to_lay, 0)\n            for r in runners\n            if r.ex.available_to_lay\n        ]\n    )"
                            }
                        ],
                        "border": 0
                    }
                ]
            }
        ],
        "type": "message",
        "ts": "1675899143.371779",
        "client_msg_id": "25d3a971-0b68-40d9-adde-2d5d7c4d721e",
        "thread_ts": "1675805913.836409",
        "parent_user_id": "U03N4QBJ0TV"
    },
    {
        "user": "U03N4QBJ0TV",
        "type": "message",
        "ts": "1675899261.986869",
        "edited": {
            "user": "U03N4QBJ0TV",
            "ts": "1675899290.000000"
        },
        "client_msg_id": "69845d64-fb72-4679-a2e9-86db7475d37e",
        "text": "See above, its just a modified version of the Lay_Fav code that places a bet before market start then looks to green up at some time later also before market start. Also uploaded the market file.",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "g2c8538b47ad",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/2c8538b47ad4bed6facbb148134bb486.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0020-72.png",
            "first_name": "Trex44",
            "real_name": "Trex44",
            "display_name": "Trex44",
            "team": "T4G9NBD2M",
            "name": "c.s.mpharm",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1675805913.836409",
        "parent_user_id": "U03N4QBJ0TV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x=dTc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "See above, its just a modified version of the Lay_Fav code that places a bet before market start then looks to green up at some time later also before market start. Also uploaded the market file."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]