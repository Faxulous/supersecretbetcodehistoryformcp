[
    {
        "user": "U9JHLMZB4",
        "type": "message",
        "ts": "1679935070.682009",
        "client_msg_id": "328a4939-fec8-45ca-ac1d-42d695590c6f",
        "text": "Creating a middleware child class with a  `___call___()` method is exactly how I would do it. You can write the results to the market.context dictionary and they'll be available to every strategy that consumes that market.\n\nNot sure why you would want a timer-based callback in this context.",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "g951ddcb43e7",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3951ddcb43e788a387d6daf330dad5ca.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0018-72.png",
            "first_name": "",
            "real_name": "Peter Coles",
            "display_name": "Peter",
            "team": "T4G9NBD2M",
            "name": "peter",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679858003.936109",
        "parent_user_id": "U01AH6Q3GUV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KCpWV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Creating a middleware child class with a  "
                            },
                            {
                                "type": "text",
                                "text": "__",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "call__",
                                "style": {
                                    "italic": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " method is exactly how I would do it. You can write the results to the market.context dictionary and they'll be available to every strategy that consumes that market.\n\nNot sure why you would want a timer-based callback in this context."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AH6Q3GUV",
        "type": "message",
        "ts": "1679935528.084279",
        "client_msg_id": "acce8566-c4a2-4e52-b646-d6b4e77b476c",
        "text": "To compute time-based analytics?\nIf there are no market-book updates, the middleware won't get called and the analytics won't get updated and become stale.\nIf there are no market-book updates (and no strategy order), the strategy won't get evaluated either I believe, but that's another question.\nIs there a Flumine facility to have a timer-based callback?\nI am now leaning towards creating a separate BackgroundWorker for this. Any suggestion?",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "4c0ac0301b29",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-13\/1366509062548_4c0ac0301b291e04d139_72.png",
            "first_name": "",
            "real_name": "Thomas JAMET",
            "display_name": "Thomas JAMET",
            "team": "T4G9NBD2M",
            "name": "jamet.thomas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679858003.936109",
        "parent_user_id": "U01AH6Q3GUV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JSYb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To compute time-based analytics?\nIf there are no market-book updates, the middleware won't get called and the analytics won't get updated and become stale.\nIf there are no market-book updates (and no strategy order), the strategy won't get evaluated either I believe, but that's another question.\nIs there a Flumine facility to have a timer-based callback?\nI am now leaning towards creating a separate BackgroundWorker for this. Any suggestion?"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U9JHLMZB4",
        "type": "message",
        "ts": "1679935827.830129",
        "client_msg_id": "ea9d4d98-44a7-4fce-aefe-2d297cc5232f",
        "text": "When you setup a strategy to subscribe to a market, you can set the streaming_timeout (seconds) parameter. That will force the a snapshot to be taken and evaluated at that frequency if no market updates have been received. <https:\/\/betcode-org.github.io\/flumine\/strategies\/#parameters>",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "g951ddcb43e7",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/3951ddcb43e788a387d6daf330dad5ca.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0018-72.png",
            "first_name": "",
            "real_name": "Peter Coles",
            "display_name": "Peter",
            "team": "T4G9NBD2M",
            "name": "peter",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679858003.936109",
        "parent_user_id": "U01AH6Q3GUV",
        "attachments": [
            {
                "from_url": "https:\/\/betcode-org.github.io\/flumine\/strategies\/#parameters",
                "service_icon": "https:\/\/betcode-org.github.io\/flumine\/images\/logo.png",
                "id": 1,
                "original_url": "https:\/\/betcode-org.github.io\/flumine\/strategies\/#parameters",
                "fallback": "Strategies - flumine",
                "text": "Betting trading framework",
                "title": "Strategies - flumine",
                "title_link": "https:\/\/betcode-org.github.io\/flumine\/strategies\/#parameters",
                "service_name": "betcode-org.github.io"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9yWQj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When you setup a strategy to subscribe to a market, you can set the streaming_timeout (seconds) parameter. That will force the a snapshot to be taken and evaluated at that frequency if no market updates have been received. "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/betcode-org.github.io\/flumine\/strategies\/#parameters"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U01AH6Q3GUV",
        "type": "message",
        "ts": "1679936239.759769",
        "client_msg_id": "6ac75025-36a1-4fb3-8e01-ca29808b1254",
        "text": "Ok, I see, the timeout will get passed to the get of the event queue.\nThanks!",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "4c0ac0301b29",
            "image_72": "https:\/\/avatars.slack-edge.com\/2020-09-13\/1366509062548_4c0ac0301b291e04d139_72.png",
            "first_name": "",
            "real_name": "Thomas JAMET",
            "display_name": "Thomas JAMET",
            "team": "T4G9NBD2M",
            "name": "jamet.thomas",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679858003.936109",
        "parent_user_id": "U01AH6Q3GUV",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RAJRn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ok, I see, the timeout will get passed to the get of the event queue.\nThanks!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04M1BY1FRR",
        "type": "message",
        "ts": "1679959167.408039",
        "client_msg_id": "d7abfe78-beb4-4fb1-b789-f68f439497f3",
        "text": "Hi guys when using the betfair lightweight api is it possible to list the market catalogue of historical events?  Would the below work with an already completed event passed in to the market filter\n\n```trading.betting.list_market_catalogue(\n            filter=market_filter,\n            max_results='100',\n            sort='FIRST_TO_START',\n            market_projection=[\"MARKET_DESCRIPTION\", \"RUNNER_DESCRIPTION\", \"EVENT_TYPE\"],\n            lightweight=True\n        )```",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "086a17ff0ee5",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-01-29\/4712580647589_086a17ff0ee5f9664c27_72.png",
            "first_name": "Charaka",
            "real_name": "Charaka Abeywickrama",
            "display_name": "Charaka A",
            "team": "T4G9NBD2M",
            "name": "charaka.abeywickrama",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679959167.408039",
        "reply_count": 3,
        "reply_users_count": 2,
        "latest_reply": "1680040102.911399",
        "reply_users": [
            "UBS7QANF3",
            "U04M1BY1FRR"
        ],
        "replies": [
            {
                "user": "UBS7QANF3",
                "ts": "1679983304.848469"
            },
            {
                "user": "U04M1BY1FRR",
                "ts": "1680023049.528229"
            },
            {
                "user": "UBS7QANF3",
                "ts": "1680040102.911399"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xeMYj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi guys when using the betfair lightweight api is it possible to list the market catalogue of historical events?  Would the below work with an already completed event passed in to the market filter\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "trading.betting.list_market_catalogue(\n            filter=market_filter,\n            max_results='100',\n            sort='FIRST_TO_START',\n            market_projection=[\"MARKET_DESCRIPTION\", \"RUNNER_DESCRIPTION\", \"EVENT_TYPE\"],\n            lightweight=True\n        )"
                            }
                        ],
                        "border": 0
                    }
                ]
            }
        ]
    },
    {
        "user": "U028MHQKX6J",
        "type": "message",
        "ts": "1679959519.471829",
        "edited": {
            "user": "U028MHQKX6J",
            "ts": "1679964761.000000"
        },
        "client_msg_id": "2aa86d31-0df9-4fef-ac87-a5c8b3992a5f",
        "text": "Hi, I am only getting started and found some codes to get stream racing data using befairlightweight.\nIt sounds like Flumine could facilitate the process and run different market_ids streams in parallel\/concurrently and sequentially.\nCould someone assist and let me know what the Flumine codes would be to run and get\/save different streaming data in parallel (different venues) and also in sequence (same venue for different races once the previous race market closes) ?\nThanks!\n\n#===================================================\n# Sample section of codes for betfairlightweight version (only 1 stream worked for me, not sure how to adapt the codes or use existing Flumine functions to record multiple markets in  parallel or sequentially)\n\n# create queue\noutput_queue = queue.Queue()\n\n# create stream listener\nlistener = betfairlightweight.StreamListener(output_queue=output_queue)\n\n# create stream\nstream = trading.streaming.create_stream(listener=listener)\n\n# create filters (AU WIN racing)\n# market_filter = streaming_market_filter(\n#    event_type_ids=[\"7\"], country_codes=[\"AU\"], market_types=[\"WIN\"],\n# )\nmy_market_ids = [..., ...., ...]\nmarket_filter = filters.market_filter(market_ids=my_market_ids)\n\nmarket_data_filter = streaming_market_data_filter(\n    fields=[\"EX_MARKET_DEF\", \"EX_LTP\", \"EX_BEST_OFFERS\", \"EX_TRADED\", \"EX_TRADED_VOL\", \"SP_TRADED\", \"SP_PROJECTED\"], ladder_levels=3\n)\n\n# subscribe\nstreaming_unique_id = stream.subscribe_to_markets(\n    market_filter=market_filter,\n    market_data_filter=market_data_filter,\n    conflate_ms=1000,  # send update every 1000ms\n)\n\n# start stream in a new thread (in production would need err handling)\nt = threading.Thread(target=stream.start, daemon=True)\nt.start()\n\n# Open a file for the market stream data\nfilename = f\"{market_id}.txt\"\nfilepath = os.path.join(\"data\", filename)\nwith open(filepath, \"w\") as f:\n\n    # check for updates in output queue\n    while True:\n        market_books = output_queue.get()\n        print(market_books)\n\n        for market_book in market_books:\n            # print(\n            #     market_book,\n            #     market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)\n            #     market_book.streaming_update,  # json update received\n            #     market_book.market_definition,  # streaming definition, similar to catalogue request\n            #     market_book.publish_time,  # betfair publish time of update\n            # )\n\n            # write data to file\n            f.write(str(market_book.streaming_unique_id) + '\\n')\n            f.write(str(market_book.streaming_update) + '\\n')\n            f.write(str(market_book.market_definition) + '\\n')\n            f.write(str(market_book.publish_time) + '\\n')",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "g329582e96f9",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/329582e96f9f089a7df077376fdd735f.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0008-72.png",
            "first_name": "Richard",
            "real_name": "Richard Denis",
            "display_name": "RDr",
            "team": "T4G9NBD2M",
            "name": "richard854",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679959519.471829",
        "reply_count": 5,
        "reply_users_count": 2,
        "latest_reply": "1680075457.538309",
        "reply_users": [
            "U4H19D1D2",
            "U028MHQKX6J"
        ],
        "replies": [
            {
                "user": "U4H19D1D2",
                "ts": "1679986379.249899"
            },
            {
                "user": "U028MHQKX6J",
                "ts": "1679989057.751119"
            },
            {
                "user": "U4H19D1D2",
                "ts": "1679991042.092349"
            },
            {
                "user": "U028MHQKX6J",
                "ts": "1680004885.853179"
            },
            {
                "user": "U4H19D1D2",
                "ts": "1680075457.538309"
            }
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1680075457.538309",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "55X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi, I am only getting started and found some codes to get stream racing data using befairlightweight.\nIt sounds like Flumine could facilitate the process and run different market_ids streams in parallel\/concurrently and sequentially.\nCould someone assist and let me know what the Flumine codes would be to run and get\/save different streaming data in parallel (different venues) and also in sequence (same venue for different races once the previous race market closes) ?\nThanks!\n\n#===================================================\n# Sample section of codes for betfairlightweight version (only 1 stream worked for me, not sure how to adapt the codes or use existing Flumine functions to record multiple markets in  parallel or sequentially)\n\n# create queue\noutput_queue = queue.Queue()\n\n# create stream listener\nlistener = betfairlightweight.StreamListener(output_queue=output_queue)\n\n# create stream\nstream = trading.streaming.create_stream(listener=listener)\n\n# create filters (AU WIN racing)\n# market_filter = streaming_market_filter(\n#    event_type_ids=[\"7\"], country_codes=[\"AU\"], market_types=[\"WIN\"],\n# )\nmy_market_ids = [..., ...., ...]\nmarket_filter = filters.market_filter(market_ids=my_market_ids)\n\nmarket_data_filter = streaming_market_data_filter(\n    fields=[\"EX_MARKET_DEF\", \"EX_LTP\", \"EX_BEST_OFFERS\", \"EX_TRADED\", \"EX_TRADED_VOL\", \"SP_TRADED\", \"SP_PROJECTED\"], ladder_levels=3\n)\n\n# subscribe\nstreaming_unique_id = stream.subscribe_to_markets(\n    market_filter=market_filter,\n    market_data_filter=market_data_filter,\n    conflate_ms=1000,  # send update every 1000ms\n)\n\n# start stream in a new thread (in production would need err handling)\nt = threading.Thread(target=stream.start, daemon=True)\nt.start()\n\n# Open a file for the market stream data\nfilename = f\"{market_id}.txt\"\nfilepath = os.path.join(\"data\", filename)\nwith open(filepath, \"w\") as f:\n\n    # check for updates in output queue\n    while True:\n        market_books = output_queue.get()\n        print(market_books)\n\n        for market_book in market_books:\n            # print(\n            #     market_book,\n            #     market_book.streaming_unique_id,  # unique id of stream (returned from subscribe request)\n            #     market_book.streaming_update,  # json update received\n            #     market_book.market_definition,  # streaming definition, similar to catalogue request\n            #     market_book.publish_time,  # betfair publish time of update\n            # )\n\n            # write data to file\n            f.write(str(market_book.streaming_unique_id) + '\\n')\n            f.write(str(market_book.streaming_update) + '\\n')\n            f.write(str(market_book.market_definition) + '\\n')\n            f.write(str(market_book.publish_time) + '\\n')"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "UBS7QANF3",
        "type": "message",
        "ts": "1679983304.848469",
        "client_msg_id": "9CD6E7CA-2831-44A5-8FF6-18545D6F64CA",
        "text": "No, not possible ",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "gaaf844a4a90",
            "image_72": "https:\/\/secure.gravatar.com\/avatar\/eaaf844a4a905431d83430e563b077aa.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0011-72.png",
            "first_name": "",
            "real_name": "Maurice Berk",
            "display_name": "Mo",
            "team": "T4G9NBD2M",
            "name": "maurice",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679959167.408039",
        "parent_user_id": "U04M1BY1FRR",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "96\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No, not possible "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U4H19D1D2",
        "type": "message",
        "ts": "1679986379.249899",
        "client_msg_id": "1981481B-DBB7-4CD7-85F5-4272A8438612",
        "text": "Have you had a go at the examples \/ docs? Should do everything you want ",
        "team": "T4G9NBD2M",
        "user_team": "T4G9NBD2M",
        "source_team": "T4G9NBD2M",
        "user_profile": {
            "avatar_hash": "137c5a3ef323",
            "image_72": "https:\/\/avatars.slack-edge.com\/2024-03-15\/6819395173841_137c5a3ef323f1944a1a_72.png",
            "first_name": "liam",
            "real_name": "liam",
            "display_name": "liam",
            "team": "T4G9NBD2M",
            "name": "liam",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1679959519.471829",
        "parent_user_id": "U028MHQKX6J",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bQ5KS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Have you had a go at the examples \/ docs? "
                            },
                            {
                                "type": "text",
                                "text": "Should"
                            },
                            {
                                "type": "text",
                                "text": " do everything you want "
                            }
                        ]
                    }
                ]
            }
        ]
    }
]